{
  "name": "HumanEval_17_parse_music",
  "language": "go_test.go",
  "prompt": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n",
  "tests": "func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    var current_note_duration int\n    var current_note_duration_count int\n    var current_note_duration_count_max int\n    var current_note_duration_count_min int\n    var current_note_duration_count_max_min int\n    var current_note_duration_count_min_max int\n    var current_note_duration_count_min_max_max int\n    var current_note_duration_count_min_max_max_min int\n    var current_note_duration_count_min_max_max_min_max int\n    var current_note_duration_count_min_max_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max int\n    var current_note_duration_count_min_max_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptybuw04f_test.go:42:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_beat_count int\n    var note_beat_duration int\n    var note_beat_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note_count++\n            note_duration = 0\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else if music_string[i] == '|' {\n            note_count++\n            note_duration = 0\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else if music_string[i] == 'o' {\n            note_count++\n            note_duration = 4\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else if music_string[i] == 'o|' {\n            note_count++\n            note_duration = 2\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else if music_string[i] == '.' || music_string[i] == '|' || music_string[i] == 'o' || music_string[i] == 'o|' {\n            note_count++\n            note_duration = 1\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else {\n            note_count++\n            note_duration = 0\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        }\n    }\n    for i := 0; i < note_count; i++ {\n        result = append(result\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi341_218_test.go:47:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == '.'|'|' {\n            current_note = \".\"\n            current_duration = 1\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == 'o' || music_string[i] == 'o|' || music_string[i] == '.' || music_string[i] == '\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpm1zm4jmr_test.go:52:31: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpqff017v3_test.go:64: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpqff017v3_test.go:64: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqff017v3_test.go:64: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpqff017v3_test.go:64: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for _, c := range music_string {\n        if c == ' ' {\n            continue\n        }\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            continue\n        }\n        if c == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat += 1\n            continue\n        }\n        if c == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat += 1\n            continue\n        }\n        if c == '.' {\n            current_note = \".\"\n            current_duration = 1\n            current_beat += 1\n            continue\n        }\n        if c == '|' {\n            current_note = \"|\"\n            current_duration = 1\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat += 1\n            continue\n        }\n        if c == '.' {\n            current_note = \".\"\n            current_duration = 1\n            current_beat += 1\n            continue\n        }\n        if c == '|' {\n            current_note = \"|\"\n            current_duration = 1\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat += 1\n            continue\n        }\n        if c == '.' {\n            current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6emdc_xx_test.go:44:17: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_count int\n    var current_note_count_multiplier int\n    var current_note_count_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph_9u23eq_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + music_string[i]\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + music_string[i]\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + music_string[i]\n            count = count + 4\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            note = note + \" \"\n            count = 0\n        }\n        if count == 2 {\n            beats = append(beats, 2)\n            note = note + \" \"\n            count = 0\n        }\n        if count == 1 {\n            beats = append(beats, 1)\n            note = note + \" \"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvu5ah6s__test.go:23:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n/tmp/tmpvu5ah6s__test.go:26:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n/tmp/tmpvu5ah6s__test.go:29:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n/tmp/tmpvu5ah6s__test.go:32:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat int\n    var current_beat_count int\n    var current_beat_count_count int\n    var current_beat_count_count_count int\n    var current_beat_count_count_count_count int\n    var current_beat_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnyrjimm8_test.go:41:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 2\n        } else if music_string[i] == '.' {\n            current_note = \".\"\n            current_duration = 1\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == '|' {\n            current_note = \"|\"\n            current_duration = 1\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else {\n            panic(\"Unknown note\")\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration * current_duration_multiplier * current_duration_multiplier_multiplier)\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 0\n            current_duration_multiplier_multiplier = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpoc2n21mg_test.go:29:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if c == '|' {\n            current_note += c\n            current_duration += 1\n        } else if c == 'o' {\n            current_note += c\n            current_duration += 4\n        } else {\n            current_note += c\n            current_duration += 2\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration)\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwfay41kv_test.go:26:26: invalid operation: current_note += c (mismatched types string and rune)\n/tmp/tmpwfay41kv_test.go:29:26: invalid operation: current_note += c (mismatched types string and rune)\n/tmp/tmpwfay41kv_test.go:32:26: invalid operation: current_note += c (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_count int\n    var current_duration int\n    var current_beat int\n    for _, c := range music_string {\n        if c == 'o' || c == 'o|' || c == '.' || c == '|' {\n            if current_note != \"\" {\n                result = append(result, current_count)\n                current_note = \"\"\n                current_count = 0\n            }\n            if c == 'o' || c == 'o|' {\n                current_duration = 4\n            } else if c == '.' || c == '|' {\n                current_duration = 1\n            }\n            current_beat += 1\n        } else {\n            current_note += string(c)\n            current_count += current_duration\n        }\n    }\n    result = append(result, current_count)\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpah6t1u06_test.go:24:29: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = current_note + c\n            current_beat += 1\n        } else if c == '|' {\n            current_note = current_note + c\n            current_beat += 2\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_beat += 4\n        } else {\n            current_note = current_note + c\n            current_beat += 1\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            beats = append(beats, current_beat)\n            current_note = \"\"\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdt779fo_test.go:23:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmpfdt779fo_test.go:26:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmpfdt779fo_test.go:29:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmpfdt779fo_test.go:32:41: invalid operation: current_note + c (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_count_multiplier int\n    var current_note_count_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4a9mn6oo_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_beats int\n    var current_note_beat_count int\n    var current_note_beat_count_beats int\n    var current_note_beat_count_beats_count int\n    var current_note_beat_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0ht27ngb_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpssy33vj4_test.go:23:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    var current_note_beats_count int\n    var current_note_beats_count_count int\n    var current_note_beats_count_count_count int\n    var current_note_beats_count_count_count_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \".\"\n            current_note_length = 1\n            current_note_beats = 1\n            current_note_beats_count = 1\n            current_note_beats_count_count = 1\n            current_note_beats_count_count_count = 1\n            current_note_beats_count_count_count_count = 1\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note = \"|\"\n            current_note_length = 1\n            current_note_beats = 1\n            current_note_beats_count = 1\n            current_note_beats_count_count = 1\n            current_note_beats_count_count_count = 1\n            current_note_beats_count_count_count_count = 1\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_length = 4\n            current_note_beats = 1\n            current_note_beats_count = 1\n            current_note_beats_count_count = 1\n            current_note_beats_count_count_count = 1\n            current_note_beats_count_count_count_count = 1\n            continue\n        }\n        if music_string[i] == 'o|' {\n            current_note = \"o|\"\n            current_note_length = 2\n            current_note_beats = 1\n            current_note_beats_count = 1\n            current_note_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4o_oaz3y_test.go:60:31: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_count_multiplier int\n    var current_note_count_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4a9mn6oo_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note_count int\n    var note_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note_count = note_count + 1\n        } else if music_string[i] == '|' {\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            if note_count == 0 {\n                beats = append(beats, note_duration)\n                note_count = note_count + 1\n                note_duration = 0\n            } else {\n                beats = append(beats, note_duration)\n                note_count = note_count - 1\n                note_duration = 0\n            }\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpserk5dpu_test.go:58: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpserk5dpu_test.go:58: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpserk5dpu_test.go:58: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpserk5dpu_test.go:58: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=0) %!s(int=2) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwxaaygn1_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note string\n    var count int\n    for _, c := range music_string {\n        if c == 'o' {\n            note = \"o\"\n            count = 4\n        } else if c == 'o|' {\n            note = \"o\"\n            count = 2\n        } else if c == '.' {\n            note = \".\"\n            count = 1\n        } else {\n            note = \" \"\n            count = 0\n        }\n        result = append(result, count)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5sph_nqq_test.go:25:24: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_duration = 1\n        } else if music_string[i] == '|' {\n            current_duration = 2\n        } else if music_string[i] == 'o' {\n            current_duration = 4\n        } else if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n        } else if music_string[i] == 'o' {\n            current_note = \"half\"\n            current_duration = 2\n        } else if music_string[i] == 'o' {\n            current_note = \"quarter\"\n            current_duration = 1\n        }\n        if current_note != \"\" {\n            beats = append(beats, current_beat)\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        }\n        current_beat += current_duration\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0 (0.00s)\n        tmpyd7z2p_s_test.go:71: expected '[]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpyd7z2p_s_test.go:71: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpyd7z2p_s_test.go:71: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=12)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpyd7z2p_s_test.go:71: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=34)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpyd7z2p_s_test.go:71: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=38)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, note := range music_string {\n        if note == 'o' {\n            current_beat += 4\n        } else if note == 'o|' {\n            current_beat += 2\n        } else if note == '.' {\n            current_beat += 1\n        } else {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0zz06bci_test.go:23:27: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpdeknu_3r_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdeknu_3r_test.go:50: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdeknu_3r_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpdeknu_3r_test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \".\"\n            current_duration = 1\n        } else if music_string[i] == '|' {\n            current_note = \"|\"\n            current_duration = 2\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else {\n            panic(\"Invalid note\")\n        }\n        if current_note == \".\" {\n            current_beats = current_beats + current_duration\n        } else {\n            current_beats = current_beats + current_duration * 2\n        }\n        if current_note == \"o\" {\n            result = append(result, current_beats)\n        }\n        current_note = \"\"\n        current_duration = 0\n        current_beats = 0\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmps0mzrigg_test.go:70: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=8) %!s(int=8) %!s(int=8) %!s(int=8)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmps0mzrigg_test.go:70: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmps0mzrigg_test.go:70: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=8) %!s(int=8) %!s(int=8) %!s(int=8) %!s(int=8) %!s(int=8)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmps0mzrigg_test.go:70: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=8) %!s(int=8) %!s(int=8) %!s(int=8) %!s(int=8) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var notes []int\n    var note_count int\n    var note_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note_count = note_count + 1\n        } else if music_string[i] == '|' {\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 4\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 2\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9hfo0c1u_test.go:60:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_count_multiplier int\n    var current_note_count_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4a9mn6oo_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_note_count int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_note_count = 0\n        } else if c == '|' {\n            current_note += c\n            current_note_count++\n        } else if c == 'o' {\n            if current_note_count > 0 {\n                beats = append(beats, current_note_count)\n                current_note_count = 0\n            }\n            current_note += c\n        } else {\n            current_note += c\n            current_note_count++\n        }\n    }\n    if current_note_count > 0 {\n        beats = append(beats, current_note_count)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_975dwbu_test.go:26:26: invalid operation: current_note += c (mismatched types string and rune)\n/tmp/tmp_975dwbu_test.go:33:26: invalid operation: current_note += c (mismatched types string and rune)\n/tmp/tmp_975dwbu_test.go:35:26: invalid operation: current_note += c (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                current_beat += 4\n            case 'o|':\n                current_beat += 2\n            case '.':\n                current_beat += 1\n            default:\n                current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplg16ishx_test.go:24:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for _, c := range music_string {\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else if c == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n        } else if c == '.' {\n            current_note = \".\"\n            current_duration = 1\n        } else {\n            current_note = \"o\"\n            current_duration = 4\n        }\n        if current_note != \"o\" {\n            result = append(result, current_duration)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_d7a7g6h_test.go:25:24: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        switch music_string[i] {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp012mwc4c_test.go:23:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, char := range music_string {\n        switch char {\n            case 'o':\n                current_beat += 4\n            case 'o|':\n                current_beat += 2\n            case '.':\n                current_beat += 1\n            default:\n                beats = append(beats, current_beat)\n                current_beat = 0\n        }\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcfa1fkwi_test.go:24:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note string\n    var beats int\n    var i int\n    for i = 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = \"\"\n            beats = 0\n        } else if music_string[i] == '|' {\n            note = note + \"o\"\n            beats = beats + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o|\"\n            beats = beats + 2\n        } else if music_string[i] == 'o' {\n            note = note + \"o|\"\n            beats = beats + 2\n        } else {\n            note = note + music_string[i]\n            beats = beats + 1\n        }\n        if note == \"o o| o| o| o| o| o| o| o o\" {\n            result = append(result, beats)\n            note = \"\"\n            beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9iz46jsq_test.go:36:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_count int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_count = 0\n        } else if char == '|' {\n            if current_note == \"\" {\n                current_note = \"whole\"\n                current_duration = 4\n                current_duration_count = 1\n            } else {\n                current_note = current_note + \"half\"\n                current_duration = 2\n                current_duration_count = 1\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"whole\"\n                current_duration = 4\n                current_duration_count = 1\n            } else {\n                current_note = current_note + \"quarter\"\n                current_duration = 1\n                current_duration_count = 1\n            }\n        } else {\n            if current_note == \"\" {\n                current_note = \"whole\"\n                current_duration = 4\n                current_duration_count = 1\n            } else {\n                current_note = current_note + \"half\"\n                current_duration = 2\n                current_duration_count = 1\n            }\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration_count)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpocu7_vu8_test.go:20:9: current_duration declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    var current_duration int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_beat = 0\n            current_duration = 0\n        } else if c == '|' {\n            current_note = current_note + c\n            current_beat = current_beat + 1\n            current_duration = 0\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_beat = current_beat + 1\n            current_duration = 4\n        } else if c == 'o|' {\n            current_note = current_note + c\n            current_beat = current_beat + 1\n            current_duration = 2\n        }\n        if current_note != \"\" {\n            if current_note == \"o\" {\n                beats = append(beats, current_beat * current_duration)\n            } else if current_note == \"o|\" {\n                beats = append(beats, current_beat * current_duration)\n            } else if current_note == \".|\" {\n                beats = append(beats, current_beat * current_duration)\n            }\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvhj_ruav_test.go:35:24: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n        case 'o':\n            result = append(result, 4)\n        case 'o|':\n            result = append(result, 2)\n        case '.':\n            result = append(result, 1)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj7epbiob_test.go:23:14: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    var current_note_duration int\n    var current_note_duration_count int\n    var current_note_duration_count_max int\n    var current_note_duration_count_min int\n    var current_note_duration_count_sum int\n    var current_note_duration_count_sum_max int\n    var current_note_duration_count_sum_min int\n    var current_note_duration_count_sum_sum int\n    var current_note_duration_count_sum_sum_max int\n    var current_note_duration_count_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpowe07pwb_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_index int\n    var note_string string\n    var note_string_index int\n    var note_string_length int\n    var note_string_length_index int\n    var note_string_length_length int\n    var note_string_length_length_index int\n    var note_string_length_length_length int\n    var note_string_length_length_length_index int\n    var note_string_length_length_length_length int\n    var note_string_length_length_length_length_index int\n    var note_string_length_length_length_length_length int\n    var note_string_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpg7g99gce_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    var current_note_duration int\n    var current_note_duration_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_count = 0\n            current_note_duration_count = 0\n        } else if music_string[i] == '|' {\n            current_note_count = 0\n            current_note_duration_count = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_note_count = 4\n            current_note_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"half\"\n            current_note_count = 2\n            current_note_duration = 2\n        }\n        if current_note != \"\" {\n            if current_note_count == 0 {\n                current_note_count = 1\n            }\n            if current_note_duration_count == 0 {\n                current_note_duration_count = 1\n            }\n            if current_note_count > 0 {\n                result = append(result, current_note_count)\n            }\n            if current_note_duration_count > 0 {\n                result = append(result, current_note_duration_count)\n            }\n            current_note_count = 0\n            current_note_duration_count = 0\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgsjcegro_test.go:34:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_note_count = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_note_count = current_note_count + 4\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_note_count = current_note_count + 2\n        } else {\n            current_note = current_note + \".\" + music_string[i]\n            current_note_count = current_note_count + 1\n        }\n        if current_note_count > 0 {\n            result = append(result, current_note_count)\n            current_note_count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb3dko94m_test.go:32:47: invalid operation: (current_note + \".\") + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 4\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 4\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 4\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 2\n        } else if music_string[i] == '.' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 2\n        } else if music_string[i] == '.' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 2\n        } else if music_string[i\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp01k2s2xp_test.go:59:33: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_note_length = 0\n            current_note_beats = 0\n        } else if c == '|' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 4\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 2\n        } else if c == '|' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '.' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '|' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '.' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '|' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '.' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwwzfmmn2_test.go:71:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    for _, char := range music_string {\n        if char == 'o' {\n            current_note_duration = 4\n        } else if char == 'o|' {\n            current_note_duration = 2\n        } else if char == '.' {\n            current_note_duration = 1\n        } else {\n            current_note = \"\"\n        }\n        if current_note != \"\" {\n            current_note += char\n        } else {\n            if current_note_duration > 0 {\n                result = append(result, current_note_duration)\n                current_note_duration = 0\n            }\n            current_note = char\n        }\n    }\n    if current_note_duration > 0 {\n        result = append(result, current_note_duration)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2h8ahvb8_test.go:24:27: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if char == '|' {\n            current_note = current_note + char\n            current_duration++\n        } else if char == 'o' {\n            current_note = current_note + char\n            current_duration += 4\n        } else {\n            current_note = current_note + char\n            current_duration++\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration)\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp39e8_8x2_test.go:26:41: invalid operation: current_note + char (mismatched types string and rune)\n/tmp/tmp39e8_8x2_test.go:29:41: invalid operation: current_note + char (mismatched types string and rune)\n/tmp/tmp39e8_8x2_test.go:32:41: invalid operation: current_note + char (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpzzir1czl_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpzzir1czl_test.go:50: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpzzir1czl_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpzzir1czl_test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    var current_note_duration int\n    var current_note_duration_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_count = 0\n            current_note_duration_count = 0\n        } else if music_string[i] == '|' {\n            current_note_count = 0\n            current_note_duration_count = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_count = 1\n            current_note_duration_count = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"o|\"\n            current_note_count = 1\n            current_note_duration_count = 2\n        } else {\n            current_note = \".\"\n            current_note_count = 0\n            current_note_duration_count = 0\n        }\n        if current_note_count == 0 {\n            current_note_duration = current_note_duration + current_note_duration_count\n        } else {\n            current_note_duration = current_note_duration + current_note_duration_count\n            current_note_count = current_note_count + 1\n            result = append(result, current_note_duration)\n            current_note_duration = 0\n            current_note_duration_count = 0\n        }\n    }\n    if current_note_count > 0 {\n        result = append(result, current_note_duration)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdvtfkjzt_test.go:34:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=8) %!s(int=8) %!s(int=12) %!s(int=12) %!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=6) %!s(int=7) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=12)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=6) %!s(int=6) %!s(int=10) %!s(int=12) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=18) %!s(int=18) %!s(int=22) %!s(int=22) %!s(int=26) %!s(int=26) %!s(int=30) %!s(int=30) %!s(int=34)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=6) %!s(int=6) %!s(int=7) %!s(int=9) %!s(int=9) %!s(int=13) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=18) %!s(int=18) %!s(int=22) %!s(int=22) %!s(int=26) %!s(int=28) %!s(int=28) %!s(int=32) %!s(int=32) %!s(int=36) %!s(int=38)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwxaaygn1_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if char == '|' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3gq7kw4t_test.go:77:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_length_count int\n    var current_note_count_count int\n    for _, c := range music_string {\n        if c == 'o' {\n            current_note_length_count = 4\n        } else if c == 'o|' {\n            current_note_length_count = 2\n        } else if c == '.' {\n            current_note_length_count = 1\n        } else {\n            current_note_length_count = 0\n        }\n        current_note_count_count = 0\n        for _, c := range current_note {\n            if c == 'o' {\n                current_note_count_count = 4\n            } else if c == 'o|' {\n                current_note_count_count = 2\n            } else if c == '.' {\n                current_note_count_count = 1\n            } else {\n                current_note_count_count = 0\n            }\n            current_note_count += current_note_count_count\n            current_note_length += current_note_length_count\n            current_note_length_count = 0\n        }\n        current_note = \"\"\n        current_note_count = 0\n        current_note_length_count = 0\n        result = append(result, current_note_count)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp75n2q8qm_test.go:27:24: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_count = 0\n            current_note = \"\"\n            current_note_length = 0\n        } else if music_string[i] == '|' {\n            current_note_count = 0\n            current_note = \"\"\n            current_note_length = 0\n        } else if music_string[i] == 'o' {\n            current_note_count = 1\n            current_note = \"o\"\n            current_note_length = 4\n        } else if music_string[i] == 'o|' {\n            current_note_count = 2\n            current_note = \"o|\"\n            current_note_length = 2\n        }\n        if current_note_count > 0 {\n            current_note_count++\n            if current_note_length == 1 {\n                current_note_length = 4\n            } else if current_note_length == 2 {\n                current_note_length = 2\n            } else if current_note_length == 4 {\n                current_note_length = 1\n            }\n            result = append(result, current_note_count)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsd7xjfi9_test.go:35:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + music_string[i]\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + music_string[i]\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + music_string[i]\n            count = count + 4\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            note = note + \"|\"\n            count = 0\n        }\n        if count == 2 {\n            beats = append(beats, 2)\n            note = note + \"|\"\n            count = 0\n        }\n        if count == 1 {\n            beats = append(beats, 1)\n            note = note + \"|\"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpefu_yfyn_test.go:23:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n/tmp/tmpefu_yfyn_test.go:26:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n/tmp/tmpefu_yfyn_test.go:29:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n/tmp/tmpefu_yfyn_test.go:32:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_rest int\n    var note_rest_count int\n    var note_rest_duration int\n    var note_rest_beats int\n    var note_rest_rest int\n    var note_rest_rest_count int\n    var note_rest_rest_duration int\n    var note_rest_rest_beats int\n    var note_rest_rest_rest int\n    var note_rest_rest_rest_count int\n    var note_rest_rest_rest_duration int\n    var note_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_4xayhfp_test.go:53:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        if note == 'o' {\n            beats = append(beats, 4)\n        } else if note == 'o|' {\n            beats = append(beats, 2)\n        } else if note == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpn8yl_13o_test.go:22:27: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpssy33vj4_test.go:23:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    var current_note_length int\n    var current_note_length_multiplier int\n    var current_note_length_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprvh6fd5o_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_count int\n    var current_beat_duration_count_count int\n    var current_beat_duration_count_count_count int\n    var current_beat_duration_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n            current_beat_duration = 0\n            current_beat_duration_count = 0\n            current_beat_duration_count_count = 0\n            current_beat_duration_count_count_count = 0\n            current_beat_duration_count_count_count_count = 0\n            current_beat_duration_count_count_count_count_count = 0\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n            current_beat_duration = 0\n            current_beat_duration_count = 0\n            current_beat_duration_count_count = 0\n            current_beat_duration_count_count_count = 0\n            current_beat_duration_count_count_count_count = 0\n            current_beat_duration_count_count_count_count_count = 0\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beats = 0\n            current_beat_duration = 0\n            current_beat_duration_count = 0\n            current_beat_duration_count_count = 0\n            current_beat_duration_count_count_count = 0\n            current_beat_duration_count_count_count_count = 0\n            current_beat_duration_count_count_count_count_count = 0\n            continue\n        }\n        if music\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbzn4mseb_test.go:66:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_beats int\n    var current_note_beats_count int\n    var current_note_beats_count_count int\n    var current_note_beats_count_count_count int\n    var current_note_beats_count_count_count_count int\n    var current_note_beats_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfsd0ta79_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n            current_note_duration_multiplier_multiplier = 2\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n            current_note_duration_multiplier_multiplier = 2\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n            current_note_duration_multiplier_multiplier = 2\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz0fduypu_test.go:69:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            current_beat += 4\n        } else if music_string[i] == 'o|' {\n            current_beat += 2\n        } else if music_string[i] == '.' {\n            current_beat += 1\n        } else {\n            current_beat += 0\n        }\n        if current_beat > 0 {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfq5dx3oy_test.go:23:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpssy33vj4_test.go:23:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = current_note + char\n            current_duration = 4\n        } else if char == 'o' {\n            current_note = current_note + char\n            current_duration = 4\n        } else if char == '|' {\n            current_note = current_note + char\n            current_duration = 2\n        } else if char == 'o|' {\n            current_note = current_note + char\n            current_duration = 2\n        } else {\n            current_note = current_note + char\n            current_duration = 1\n        }\n        if current_note == \"o\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1iqhwh9m_test.go:32:27: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwxaaygn1_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_index int\n    var note_string string\n    var note_note string\n    var note_type string\n    var note_octave string\n    var note_rest bool\n    var note_rest_duration int\n    var note_rest_index int\n    var note_rest_string string\n    var note_rest_note string\n    var note_rest_type string\n    var note_rest_octave string\n    var note_rest_rest bool\n    var note_rest_rest_duration int\n    var note_rest_rest_index int\n    var note_rest_rest_string string\n    var note_rest_rest_note string\n    var note_rest_rest_type string\n    var note_rest_rest_octave string\n    var note_rest_rest_rest bool\n    var note_rest_rest_rest_duration int\n    var note_rest_rest_rest_index int\n    var note_rest_rest_rest_string string\n    var note_rest_rest_rest_note string\n    var note_rest_rest_rest_type string\n    var note_rest_rest_rest_octave string\n    var note_rest_rest_rest_rest bool\n    var note_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_index int\n    var note_rest_rest_rest_rest_string string\n    var note_rest_rest_rest_rest_note string\n    var note_rest_rest_rest_rest_type string\n    var note_rest_rest_rest_rest_octave string\n    var note_rest_rest_rest_rest_rest bool\n    var note_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_index int\n    var note_rest_rest_rest_rest_rest_string string\n    var note_rest_rest_rest_rest_rest_note string\n    var note_rest_rest_rest_rest_rest_type string\n    var note_rest_rest_rest_rest_rest_octave\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgom9_4cj_test.go:61:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_beat = 0\n        } else if c == '|' {\n            current_note += c\n            current_beat += 1\n        } else if c == 'o' {\n            current_note += c\n            current_beat += 4\n        } else {\n            current_note += c\n            current_beat += 1\n        }\n        if current_note != \"\" {\n            beats = append(beats, current_beat)\n            current_note = \"\"\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg78yuzb1_test.go:26:26: invalid operation: current_note += c (mismatched types string and rune)\n/tmp/tmpg78yuzb1_test.go:29:26: invalid operation: current_note += c (mismatched types string and rune)\n/tmp/tmpg78yuzb1_test.go:32:26: invalid operation: current_note += c (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_duration_count int\n    for _, char := range music_string {\n        if char == '.' {\n            current_duration_count++\n            if current_duration_count == 4 {\n                current_duration = 4\n            } else if current_duration_count == 2 {\n                current_duration = 2\n            } else if current_duration_count == 1 {\n                current_duration = 1\n            }\n        } else if char == '|' {\n            current_note = current_note + char\n            if current_note == \"o\" {\n                current_duration = 4\n            } else if current_note == \"o|\" {\n                current_duration = 2\n            } else if current_note == \".|\" {\n                current_duration = 1\n            }\n            current_note = \"\"\n        } else {\n            current_note = current_note + char\n        }\n    }\n    for i := 0; i < len(beats); i++ {\n        beats[i] = current_duration\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpekwzecw3_test.go:33:41: invalid operation: current_note + char (mismatched types string and rune)\n/tmp/tmpekwzecw3_test.go:43:41: invalid operation: current_note + char (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        if note == '.' {\n            beats = append(beats, 1)\n        } else if note == '|' {\n            beats = append(beats, 2)\n        } else if note == 'o' {\n            beats = append(beats, 4)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpdugp0c8o_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdugp0c8o_test.go:50: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdugp0c8o_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpdugp0c8o_test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpklh34k3s_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_beat++\n        } else if music_string[i] == 'o' {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpwut5qbpa_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpwut5qbpa_test.go:50: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpwut5qbpa_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpwut5qbpa_test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note string\n    var beats int\n    var i int\n    for i = 0; i < len(music_string); i++ {\n        note = music_string[i]\n        if note == 'o' {\n            beats = 4\n        } else if note == 'o|' {\n            beats = 2\n        } else if note == '.' {\n            beats = 1\n        } else {\n            beats = 0\n        }\n        result = append(result, beats)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1ijz5udt_test.go:26:27: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = current_note + c\n            current_beat += 1\n        } else if c == '|' {\n            current_note = current_note + c\n            current_beat += 2\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_beat += 4\n        } else {\n            current_note = current_note + c\n            current_beat += 1\n        }\n        if current_note == \".\" {\n            beats = append(beats, current_beat)\n            current_note = \"\"\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqti6ricr_test.go:23:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmpqti6ricr_test.go:26:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmpqti6ricr_test.go:29:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmpqti6ricr_test.go:32:41: invalid operation: current_note + c (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + music_string[i]\n            current_beat = current_beat + 1\n            if current_note == \"o\" {\n                beats = append(beats, 4)\n                current_note = \"\"\n            } else if current_note == \"o|\" {\n                beats = append(beats, 2)\n                current_note = \"\"\n            } else if current_note == \".|\" {\n                beats = append(beats, 1)\n                current_note = \"\"\n            }\n        } else if music_string[i] == 'o' {\n            current_note = current_note + music_string[i]\n            current_beat = current_beat + 1\n            if current_note == \"o\" {\n                beats = append(beats, 4)\n                current_note = \"\"\n            } else if current_note == \"o|\" {\n                beats = append(beats, 2)\n                current_note = \"\"\n            } else if current_note == \".|\" {\n                beats = append(beats, 1)\n                current_note = \"\"\n            }\n        } else {\n            current_note = current_note + music_string[i]\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7j13kc8a_test.go:23:41: invalid operation: current_note + music_string[i] (mismatched types string and byte)\n/tmp/tmp7j13kc8a_test.go:36:41: invalid operation: current_note + music_string[i] (mismatched types string and byte)\n/tmp/tmp7j13kc8a_test.go:49:41: invalid operation: current_note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwxaaygn1_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    var current_beat_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o|' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o|'|'o' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o|'|'o|'o' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o|'|'o|'o|'o' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpswmwiedf_test.go:39:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 1\n            current_beat = 0\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 2\n            current_beat = 0\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat = 0\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '|' {\n            current_note = \"o|\"\n            current_duration = 2\n            current_beat = 0\n            i++\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '.' {\n            current_note = \"o.\"\n            current_duration = 1\n            current_beat = 0\n            i++\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '|' && music_string[i+2] == '.' {\n            current_note = \"o|.\"\n            current_duration = 1\n            current_beat = 0\n            i += 2\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '|' && music_string[i+2] == '|' {\n            current_note = \"o|o\"\n            current_duration = 1\n            current_beat = 0\n            i += 2\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '.' && music_string[i+2] == '|' {\n            current_note = \"o.|\"\n            current_duration\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpl2f9ki0w_test.go:75:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                beats = append(beats, 4)\n            case 'o|':\n                beats = append(beats, 2)\n            case '.':\n                beats = append(beats, 1)\n            default:\n                beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_hed9g2t_test.go:23:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_beats int\n    var current_note_beat_duration int\n    var current_note_beat_duration_counter int\n    var current_note_beat_duration_counter_counter int\n    var current_note_beat_duration_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxwrursxf_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for _, char := range music_string {\n        if char == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beats = 1\n        } else if char == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beats = 1\n        } else if char == '.' {\n            current_note = \".\"\n            current_duration = 1\n            current_beats = 1\n        } else if char == '|' {\n            current_note = \".\"\n            current_duration = 1\n            current_beats = 2\n        } else {\n            current_note = \".\"\n            current_duration = 1\n            current_beats = 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 1\n            current_beats = 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpta9x_7j5_test.go:27:27: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        if note == 'o' {\n            result = append(result, 4)\n        } else if note == 'o|' {\n            result = append(result, 2)\n        } else if note == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplleum3xr_test.go:22:27: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_count = 0\n            current_note = \"\"\n            current_note_length = 0\n        } else if music_string[i] == '|' {\n            current_note_count = 0\n            current_note = \"\"\n            current_note_length = 0\n        } else if music_string[i] == 'o' {\n            current_note_count = 1\n            current_note = \"o\"\n            current_note_length = 4\n        } else if music_string[i] == 'o|' {\n            current_note_count = 2\n            current_note = \"o|\"\n            current_note_length = 2\n        }\n        if current_note != \"\" {\n            current_note_count += 1\n        }\n        if current_note_length > 0 {\n            current_note_length -= 1\n        }\n        if current_note_length == 0 {\n            result = append(result, current_note_count)\n            current_note = \"\"\n            current_note_length = 0\n            current_note_count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprn3t22n7_test.go:35:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_duration = 1\n        } else if music_string[i] == '|' {\n            current_note_duration = 2\n        } else if music_string[i] == 'o' {\n            current_note_duration = 4\n        } else {\n            current_note = \"\"\n        }\n        if current_note != \"\" {\n            current_note += music_string[i]\n        } else {\n            if current_note_duration > 0 {\n                current_note_duration -= 1\n            }\n            if current_note_duration == 0 {\n                result = append(result, 1)\n            }\n            if current_note_duration == 1 {\n                result = append(result, 2)\n            }\n            if current_note_duration == 2 {\n                result = append(result, 1)\n            }\n            if current_note_duration == 3 {\n                result = append(result, 1)\n            }\n            if current_note_duration == 4 {\n                result = append(result, 1)\n            }\n            current_note = \"\"\n            current_note_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyvryms0p_test.go:32:26: invalid operation: current_note += music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpklh34k3s_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    var current_note_rest int\n    var current_note_rest_length int\n    var current_note_rest_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_length = 4\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_note_length = 2\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == '.' {\n            current_note = \".\"\n            current_note_length = 1\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = \".\"\n            current_note_length = 1\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_length = 4\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_note_length = 2\n            current_note_beats = 1\n            current_note_rest = 0\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0olmysid_test.go:33:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat += 1\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat += 1\n        } else {\n            current_note = music_string[i]\n            current_duration += 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beat * current_duration)\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjhvyxhjw_test.go:35:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                current_beat += 4\n            case 'o|':\n                current_beat += 2\n            case '.':\n                current_beat += 1\n            default:\n                current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplg16ishx_test.go:24:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpxmehq6tm_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    var current_beat_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat = 0\n            current_beat_duration = 0\n        } else {\n            current_note = music_string[i]\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        }\n        if current_note != \"\" {\n            if current_beat == 0 {\n                beats = append(beats, current_beat_duration)\n            }\n            current_beat_duration += current_duration\n            current_beat += 1\n            if current_beat == 4 {\n                beats = append(beats, current_beat_duration)\n                current_beat = 0\n                current_beat_duration = 0\n            }\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwt8l69m0_test.go:39:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp16qb65is_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_count int\n    var current_beat_duration_count_count int\n    var current_beat_duration_count_count_count int\n    var current_beat_duration_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpydkwe3bf_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var note_count int\n    for _, char := range music_string {\n        if char == '.' {\n            note_count = 0\n        } else if char == '|' {\n            note_count++\n        } else if char == 'o' {\n            note = note + \"o\"\n            note_count++\n        } else if note != \"\" {\n            note = note + char\n            note_count++\n        }\n        if note_count == 4 {\n            beats = append(beats, note_count)\n            note = \"\"\n            note_count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppzksg7a8_test.go:30:25: invalid operation: note + char (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \"quarter\"\n            current_duration = 1\n        } else if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"half\"\n            current_duration = 2\n        }\n        if current_note != \"\" {\n            current_beats = current_duration\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdz5ras47_test.go:32:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note_duration = 1\n        } else if c == '|' {\n            current_note_duration = 2\n        } else if c == 'o' {\n            current_note_duration = 4\n        } else {\n            current_note = string(c)\n            current_note_duration = 4\n        }\n        if current_note != \"\" {\n            result = append(result, current_note_duration)\n            current_note = \"\"\n            current_note_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmp6zid13lt_test.go:58: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp6zid13lt_test.go:58: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp6zid13lt_test.go:58: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp6zid13lt_test.go:58: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_count int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = current_note + c\n            current_count = 0\n        } else if c == '|' {\n            current_note = current_note + c\n            current_count = current_count + 1\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_count = current_count + 4\n        } else {\n            current_note = current_note + c\n            current_count = current_count + 1\n        }\n        if current_count == 4 {\n            result = append(result, 4)\n            current_note = \"\"\n            current_count = 0\n        }\n    }\n    if current_note != \"\" {\n        result = append(result, current_count)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6hhth6r4_test.go:23:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmp6hhth6r4_test.go:26:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmp6hhth6r4_test.go:29:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmp6hhth6r4_test.go:32:41: invalid operation: current_note + c (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for _, c := range music_string {\n        if c == '.' {\n            note = \"\"\n            count = 0\n        } else if c == '|' {\n            note += \"o\"\n            count += 1\n        } else {\n            note += c\n            count += 1\n        }\n        if count == 4 {\n            beats = append(beats, note)\n            note = \"\"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5besxa1p_test.go:29:18: invalid operation: note += c (mismatched types string and rune)\n/tmp/tmp5besxa1p_test.go:33:27: cannot use note (type string) as type int in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=8) %!s(int=8) %!s(int=12) %!s(int=12) %!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=6) %!s(int=7) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=12)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=6) %!s(int=6) %!s(int=10) %!s(int=12) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=18) %!s(int=18) %!s(int=22) %!s(int=22) %!s(int=26) %!s(int=26) %!s(int=30) %!s(int=30) %!s(int=34)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=6) %!s(int=6) %!s(int=7) %!s(int=9) %!s(int=9) %!s(int=13) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=18) %!s(int=18) %!s(int=22) %!s(int=22) %!s(int=26) %!s(int=28) %!s(int=28) %!s(int=32) %!s(int=32) %!s(int=36) %!s(int=38)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwxaaygn1_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=8) %!s(int=8) %!s(int=12) %!s(int=12) %!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=6) %!s(int=7) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=12)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=6) %!s(int=6) %!s(int=10) %!s(int=12) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=18) %!s(int=18) %!s(int=22) %!s(int=22) %!s(int=26) %!s(int=26) %!s(int=30) %!s(int=30) %!s(int=34)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmprdxxlajr_test.go:52: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=6) %!s(int=6) %!s(int=7) %!s(int=9) %!s(int=9) %!s(int=13) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=18) %!s(int=18) %!s(int=22) %!s(int=22) %!s(int=26) %!s(int=28) %!s(int=28) %!s(int=32) %!s(int=32) %!s(int=36) %!s(int=38)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphi7agdem_test.go:37:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 1)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxyozu2p8_test.go:23:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_note += \"o\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp35ordhg9_test.go:66:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n        } else {\n            note = note + music_string[i]\n        }\n        if note == \"o.\" {\n            beats = append(beats, count)\n            count = 0\n            note = \"\"\n        } else {\n            count++\n        }\n    }\n    beats = append(beats, count)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph9un0ikj_test.go:29:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = \"\"\n            count = 0\n        } else if music_string[i] == '|' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            result = append(result, 4)\n            count = 0\n        }\n        if count == 2 {\n            result = append(result, 2)\n            count = 0\n        }\n        if count == 1 {\n            result = append(result, 1)\n            count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp44_ltz1q_test.go:29:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_beat_count int\n    var note_beat_duration int\n    var note_beat_beats int\n    var note_beat_beat_count int\n    var note_beat_beat_duration int\n    var note_beat_beat_beats int\n    var note_beat_beat_beat_count int\n    var note_beat_beat_beat_duration int\n    var note_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpn0tbmnoi_test.go:49:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for _, c := range music_string {\n        if c == '.' {\n            note = \"\"\n            count = 0\n        } else if c == '|' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c ==\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv9l_6600_test.go:95:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_beats int\n    var current_note_beats_count int\n    var current_note_beats_count_count int\n    var current_note_beats_count_count_count int\n    var current_note_beats_count_count_count_count int\n    var current_note_beats_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfsd0ta79_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n        } else if c == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 2\n        } else if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_duration_multiplier = 1\n        } else if c == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_duration_multiplier = 2\n        } else {\n            current_note = c\n            current_duration = 1\n            current_duration_multiplier = 1\n        }\n        if current_note != \"\" {\n            if current_note == \"o\" {\n                current_beat += current_duration * current_duration_multiplier\n            } else {\n                current_beat += current_duration * current_duration_multiplier\n            }\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsjdozxpx_test.go:36:24: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwxaaygn1_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5vz6cwmx_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_duration += 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphakket_7_test.go:31:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_note_duration = 0\n            current_note_duration_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier_multiplier = 1\n        } else if music_string[i] == '|' {\n            current_note_duration_multiplier_multiplier_multiplier = 2\n        } else if music_string[i] == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_note_duration = current_note_duration + current_note_duration_multiplier_multiplier_multiplier * current_note_duration_multiplier_multiplier\n        }\n        if current_note_duration > 0 {\n            result = append(result, current_note_duration)\n            current_note_duration = 0\n            current_note_duration_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier_multiplier = 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdtg0jk9s_test.go:21:9: current_note_duration_multiplier declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_count = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_count = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_duration_count = 1\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_duration_count = 1\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_duration = current_duration + 1\n            current_duration_count = current_duration_count + 1\n        }\n        if current_note != \"\" {\n            if current_duration_count == 4 {\n                result = append(result, current_duration)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7byhpibq_test.go:35:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0 (0.00s)\n        tmpt8dzaubm_test.go:55: expected '[]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpt8dzaubm_test.go:55: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpt8dzaubm_test.go:55: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=6) %!s(int=6) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpt8dzaubm_test.go:55: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=6) %!s(int=3) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=4) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var notes []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_rest int\n    var note_rest_count int\n    var note_rest_duration int\n    var note_rest_beats int\n    var note_rest_rest int\n    var note_rest_rest_count int\n    var note_rest_rest_duration int\n    var note_rest_rest_beats int\n    var note_rest_rest_rest_count int\n    var note_rest_rest_rest_duration int\n    var note_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_rest_beats int\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpl361lrg1_test.go:52:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n        } else if c == '|' {\n            if current_note != \"\" {\n                current_beat += parse_note(current_note)\n                current_note = \"\"\n            }\n        } else if c == 'o' {\n            current_note = \"o\"\n        } else if c == 'o|' {\n            current_note = \"o|\"\n        }\n        if current_note != \"\" {\n            current_beat += parse_note(current_note)\n            current_note = \"\"\n        }\n        if current_beat > 0 {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcjf_wed2_test.go:31:24: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 0\n        }\n        if current_beat > 0 {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmplagif843_test.go:55: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmplagif843_test.go:55: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmplagif843_test.go:55: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpqff017v3_test.go:64: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpqff017v3_test.go:64: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqff017v3_test.go:64: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpqff017v3_test.go:64: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_beats int\n    for _, c := range music_string {\n        if c == ' ' {\n            continue\n        }\n        if c == '.' {\n            current_note_duration = 1\n        } else if c == '|' {\n            current_note_duration = 2\n        } else if c == 'o' {\n            current_note_duration = 4\n        } else {\n            panic(fmt.Sprintf(\"Unknown note: %c\", c))\n        }\n        if current_note != \"\" {\n            current_note_beats += current_note_duration\n            result = append(result, current_note_beats)\n            current_note = \"\"\n        }\n        current_note = string(c)\n    }\n    if current_note != \"\" {\n        current_note_beats += current_note_duration\n        result = append(result, current_note_beats)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmp4paixlm0_test.go:66: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=8) %!s(int=12) %!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp4paixlm0_test.go:66: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=11) %!s(int=13)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp4paixlm0_test.go:66: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=11) %!s(int=12) %!s(int=14) %!s(int=18) %!s(int=22) %!s(int=26) %!s(int=30) %!s(int=34)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp4paixlm0_test.go:66: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=9) %!s(int=11) %!s(int=12) %!s(int=14) %!s(int=18) %!s(int=22) %!s(int=24) %!s(int=28) %!s(int=32) %!s(int=34) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                beats = append(beats, 4)\n            case 'o|':\n                beats = append(beats, 2)\n            case '.':\n                beats = append(beats, 1)\n            default:\n                beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_hed9g2t_test.go:23:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_length_multiplier int\n    var current_note_length_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1dycr67s_test.go:37:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_duration = 1\n        } else if music_string[i] == '|' {\n            current_note_duration = 2\n        } else if music_string[i] == 'o' {\n            current_note_duration = 4\n        } else {\n            current_note_duration = 0\n        }\n        if current_note_duration > 0 {\n            current_note = music_string[i:i+current_note_duration]\n            current_note_count = 1\n            for j := i + current_note_duration; j < len(music_string); j++ {\n                if music_string[j] == current_note[current_note_count-1] {\n                    current_note_count++\n                } else {\n                    break\n                }\n            }\n            if current_note_count > 1 {\n                result = append(result, current_note_count)\n            }\n            i = j - 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3h4pi16h_test.go:45:17: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwxaaygn1_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpwywj4yjd_test.go:67: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpwywj4yjd_test.go:67: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpwywj4yjd_test.go:67: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpwywj4yjd_test.go:67: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else if music_string[i] == 'o' && music_string[i+1] == '|' {\n            current_note = \"o|\"\n            current_duration = 2\n        } else if music_string[i] == '.' && music_string[i+1] == '|' {\n            current_note = \".|\"\n            current_duration = 1\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_duration = current_duration + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration)\n            current_note = \"\"\n            current_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpaoajca11_test.go:67: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpaoajca11_test.go:67: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpaoajca11_test.go:67: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpaoajca11_test.go:67: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, note := range music_string {\n        if note == '.' {\n            current_beat += 1\n        } else if note == '|' {\n            current_beat += 2\n        } else if note == 'o' {\n            current_beat += 4\n        } else {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0 (0.00s)\n        tmpw2470eo1_test.go:53: expected '[]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpw2470eo1_test.go:53: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpw2470eo1_test.go:53: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=6) %!s(int=6) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpw2470eo1_test.go:53: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=6) %!s(int=3) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=4) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp16qb65is_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    var beats []int\n    var current_beat int\n    var current_note string\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_note_count = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_note_count = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_count = 4\n        } else if music_string[i] == 'o' && music_string[i+1] == '|' {\n            current_note = \"o|\"\n            current_note_count = 2\n        } else if music_string[i] == '.' && music_string[i+1] == '|' {\n            current_note = \".|\"\n            current_note_count = 1\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_note_count++\n        }\n        if current_note_count == 4 {\n            current_beat += 4\n        } else if current_note_count == 2 {\n            current_beat += 2\n        } else if current_note_count == 1 {\n            current_beat += 1\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmp2e3tzs06_test.go:72: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=8) %!s(int=8) %!s(int=12) %!s(int=12) %!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp2e3tzs06_test.go:72: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp2e3tzs06_test.go:72: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=5) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=10) %!s(int=10) %!s(int=11) %!s(int=11) %!s(int=11) %!s(int=12) %!s(int=16) %!s(int=16) %!s(int=20) %!s(int=20) %!s(int=24) %!s(int=24) %!s(int=28)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp2e3tzs06_test.go:72: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=4) %!s(int=5) %!s(int=5) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=10) %!s(int=11) %!s(int=11) %!s(int=11) %!s(int=12) %!s(int=16) %!s(int=16) %!s(int=20) %!s(int=20) %!s(int=21) %!s(int=25) %!s(int=25) %!s(int=29) %!s(int=29)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_count_int int\n    var current_note_count_int_int int\n    var current_note_count_int_int_int int\n    var current_note_count_int_int_int_int int\n    var current_note_count_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpf7gvix29_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beats)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3vg_npe5_test.go:35:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                beats = append(beats, 4)\n            case 'o|':\n                beats = append(beats, 2)\n            case '.':\n                beats = append(beats, 1)\n            default:\n                beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_hed9g2t_test.go:23:18: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp81ljlxu_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_length int\n    var note_beats int\n    var note_index int\n    var note_string string\n    var note_note string\n    var note_rest string\n    var note_rest_length int\n    var note_rest_beats int\n    var note_rest_index int\n    var note_rest_string string\n    var note_rest_note string\n    var note_rest_rest string\n    var note_rest_rest_length int\n    var note_rest_rest_beats int\n    var note_rest_rest_index int\n    var note_rest_rest_string string\n    var note_rest_rest_note string\n    var note_rest_rest_rest string\n    var note_rest_rest_rest_length int\n    var note_rest_rest_rest_beats int\n    var note_rest_rest_rest_index int\n    var note_rest_rest_rest_string string\n    var note_rest_rest_rest_note string\n    var note_rest_rest_rest_rest string\n    var note_rest_rest_rest_rest_length int\n    var note_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_index int\n    var note_rest_rest_rest_rest_string string\n    var note_rest_rest_rest_rest_note string\n    var note_rest_rest_rest_rest_rest string\n    var note_rest_rest_rest_rest_rest_length int\n    var note_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_index int\n    var note_rest_rest_rest_rest_rest_string string\n    var note_rest_rest_rest_rest_rest_note string\n    var note_rest_rest_rest_rest_rest_rest string\n    var note_rest_rest_rest_rest_rest_rest_length int\n    var note_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_index int\n    var note\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6onyzcyx_test.go:59:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if c == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 2\n        } else if c == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if c == 'o|' {\n            current_note = \"half\"\n            current_duration = 2\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 2\n        }\n        if current_note != \"\" {\n            beats = append(beats, current_duration * current_duration_multiplier * current_duration_multiplier_multiplier)\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv087c2ed_test.go:39:24: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpwywj4yjd_test.go:67: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpwywj4yjd_test.go:67: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpwywj4yjd_test.go:67: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpwywj4yjd_test.go:67: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374812,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpyiutlr6p_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfzmak6fg_test.go:32:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            count = 0\n        }\n        if count == 2 {\n            beats = append(beats, 2)\n            count = 0\n        }\n        if count == 1 {\n            beats = append(beats, 1)\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqivk57t4_test.go:32:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat int\n    var current_beat_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat_duration = 1\n        } else if music_string[i] == '|' {\n            current_beat_duration = 2\n        } else if music_string[i] == 'o' {\n            current_beat_duration = 4\n        } else {\n            current_beat_duration = 0\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"o|\"\n            current_duration = 2\n        } else if music_string[i] == '.' {\n            current_note = \".\"\n            current_duration = 1\n        }\n        if current_note != \"\" {\n            current_beats = current_duration / current_beat_duration\n            current_beat = current_beats\n            beats = append(beats, current_beat)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2vskol77_test.go:37:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyy3boewi_test.go:37:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beat = current_beat + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beat = current_beat + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beat = current_beat + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beat)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpn5b8svjw_test.go:64: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpn5b8svjw_test.go:64: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpn5b8svjw_test.go:64: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpn5b8svjw_test.go:64: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    var current_note_index int\n    var current_note_index_prev int\n    var current_note_index_next int\n    var current_note_index_next_prev int\n    var current_note_index_next_next int\n    var current_note_index_next_next_prev int\n    var current_note_index_next_next_next int\n    var current_note_index_next_next_next_prev int\n    var current_note_index_next_next_next_next int\n    var current_note_index_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next_next_next_next_next int\n    var current_note_index_next\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpudg8p8it_test.go:45:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_count int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_count = 0\n        } else if char == '|' {\n            current_note = current_note + char\n            current_duration = current_duration + 1\n            current_count = current_count + 1\n        } else if char == 'o' {\n            current_note = current_note + char\n            current_duration = current_duration + 4\n            current_count = current_count + 1\n        } else {\n            current_note = current_note + char\n            current_duration = current_duration + 2\n            current_count = current_count + 1\n        }\n        if current_count == 4 {\n            result = append(result, current_duration)\n            current_note = \"\"\n            current_duration = 0\n            current_count = 0\n        }\n    }\n    if current_count > 0 {\n        result = append(result, current_duration)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnrnpba0a_test.go:28:41: invalid operation: current_note + char (mismatched types string and rune)\n/tmp/tmpnrnpba0a_test.go:32:41: invalid operation: current_note + char (mismatched types string and rune)\n/tmp/tmpnrnpba0a_test.go:36:41: invalid operation: current_note + char (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp16qb65is_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var notes []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_index int\n    var note_string string\n    var note_string_length int\n    var note_string_index int\n    var note_string_length_index int\n    var note_string_length_count int\n    var note_string_length_count_index int\n    var note_string_length_count_count int\n    var note_string_length_count_count_index int\n    var note_string_length_count_count_count int\n    var note_string_length_count_count_count_index int\n    var note_string_length_count_count_count_count int\n    var note_string_length_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpn6ohda3q_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beat = current_beat + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 2\n            current_beat = current_beat + 1\n        } else if music_string[i] == 'o|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beat = current_beat + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beat)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplqrmljdq_test.go:35:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        if note == '.' {\n            result = append(result, 1)\n        } else if note == '|' {\n            result = append(result, 2)\n        } else if note == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp9pys_vd__test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp9pys_vd__test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp9pys_vd__test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if char == '|' {\n            current_note = current_note + char\n            current_duration = current_duration + 1\n            current_beat = 0\n        } else if char == 'o' {\n            current_note = current_note + char\n            current_duration = current_duration + 4\n            current_beat = current_beat + 1\n        } else if char == 'o|' {\n            current_note = current_note + char\n            current_duration = current_duration + 2\n            current_beat = current_beat + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beat)\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpf79djwds_test.go:35:27: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if char == '|' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note +\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjdlg13m6_test.go:79:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration += 1\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration += 2\n            current_beat += 1\n        } else {\n            current_note = current_note + music_string[i]\n            current_duration += 1\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beat)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3_tpgbhj_test.go:36:41: invalid operation: current_note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if c == '|' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == '.' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == '|' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration +=\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2gkf78w1_test.go:85:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_vqq6k88_test.go:35:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_counter int\n    var current_beat_duration_counter_counter int\n    var current_beat_duration_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkwfa3xv__test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_counter int\n    var current_beat_duration_counter_counter int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_beat_duration_counter_counter++\n            if current_beat_duration_counter_counter == 4 {\n                current_beat_duration_counter = 0\n                current_beat_duration_counter_counter = 0\n                current_beat_duration++\n            }\n            continue\n        }\n        if music_string[i] == '|' {\n            current_beat_duration_counter_counter++\n            if current_beat_duration_counter_counter == 2 {\n                current_beat_duration_counter = 0\n                current_beat_duration_counter_counter = 0\n                current_beat_duration++\n            }\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n            current_beats = 4\n            current_beat_duration = 1\n            current_beat_duration_counter = 0\n            current_beat_duration_counter_counter = 0\n            continue\n        }\n        if music_string[i] == 'o|' {\n            current_note = \"half\"\n            current_duration = 2\n            current_beats = 2\n            current_beat_duration = 1\n            current_beat_duration_counter = 0\n            current_beat_duration_counter_counter = 0\n            continue\n        }\n        if music_string[i] == '.'|'|' {\n            current_note = \"quarter\"\n            current_duration = 1\n            current_beats = 1\n            current_beat_duration = 1\n            current_beat_duration_counter = 0\n            current_beat_duration_counter_counter = 0\n            continue\n        }\n        if music_string[i] == 'o' {\n            \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbou4v2au_test.go:56:31: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_note_length int\n    var current_note_length_multiplier int\n    var current_note_length_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \".\"\n            current_note_length = 1\n            current_note_length_multiplier = 1\n            current_note_length_multiplier_multiplier = 1\n            current_note_length_multiplier_multiplier_multiplier = 1\n        } else if music_string[i] == '|' {\n            current_note = \"|\"\n            current_note_length = 2\n            current_note_length_multiplier = 1\n            current_note_length_multiplier_multiplier = 1\n            current_note_length_multiplier_multiplier_multiplier = 1\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_length = 4\n            current_note_length_multiplier = 1\n            current_note_length_multiplier_multiplier = 1\n            current_note_length_multiplier_multiplier_multiplier = 1\n        } else {\n            fmt.Printf(\"%c is not a valid note\", music_string[i])\n            return beats\n        }\n        if current_note_length_multiplier_multiplier_multiplier == 4 {\n            beats = append(beats, current_note_length_multiplier_multiplier_multiplier)\n            current_note_length_multiplier_multiplier_multiplier = 1\n        } else {\n            beats = append(beats, current_note_length_multiplier_multiplier_multiplier)\n            current_note_length_multiplier_multiplier_multiplier = current_note_length_multiplier_multiplier\n        }\n        current_note_length_multiplier_multiplier = current_note_length_multiplier\n        current_note_length_multiplier = current_note_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpc_183kql_test.go:56:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n        } else {\n            current_note = current_note + music_string[i]\n        }\n        if current_note == \"o.\" {\n            current_beat = 4\n        } else if current_note == \"o|\" {\n            current_beat = 2\n        } else if current_note == \"o\" {\n            current_beat = 1\n        } else {\n            current_beat = 0\n        }\n        beats = append(beats, current_beat)\n        current_note = \"\"\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxienco9j_test.go:29:41: invalid operation: current_note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpdeknu_3r_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdeknu_3r_test.go:50: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdeknu_3r_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpdeknu_3r_test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 2\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == 'o|' {\n            current_note = \"half\"\n            current_duration = 2\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 2\n        } else {\n            current_note = music_string[i]\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        }\n        if current_note != \"\" {\n            if current_note == \"whole\" {\n                current_duration *= 4\n            } else if current_note == \"half\" {\n                current_duration *= 2\n            }\n            current_beat += current_duration * current_duration_multiplier * current_duration_multiplier_multiplier\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk9xsc2au_test.go:40:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_beat = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_beat = 4\n        } else if music_string[i] == 'o' && music_string[i+1] == '|' {\n            current_note = \"o|\"\n            current_beat = 2\n        } else if music_string[i] == '.' && music_string[i+1] == '|' {\n            current_note = \".|\"\n            current_beat = 1\n        } else {\n            current_note = music_string[i]\n            current_beat = 1\n        }\n        if current_note != \"\" {\n            beats = append(beats, current_beat)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprkyb60y5_test.go:38:26: cannot use music_string[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwxaaygn1_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note_count int\n    var note_duration int\n    var note_type string\n    var note_string string\n    var note_index int\n    var note_index_prev int\n    var note_index_next int\n    var note_index_next_prev int\n    var note_index_next_next int\n    var note_index_next_next_prev int\n    var note_index_next_next_next int\n    var note_index_next_next_next_prev int\n    var note_index_next_next_next_next int\n    var note_index_next_next_next_next_prev int\n    var note_index_next_next_next_next_next int\n    var note_index_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzdbkvxcg_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if c == '|' {\n            current_note = current_note + c\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_duration = current_duration + 1\n            current_beats = current_beats + 4\n        } else {\n            current_note = current_note + c\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp08r51h_2_test.go:28:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmp08r51h_2_test.go:32:41: invalid operation: current_note + c (mismatched types string and rune)\n/tmp/tmp08r51h_2_test.go:36:41: invalid operation: current_note + c (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_beat += 1\n        } else if char == '|' {\n            current_note += char\n            if current_note == \"o\" {\n                beats = append(beats, 4)\n            } else if current_note == \"o|\" {\n                beats = append(beats, 2)\n            } else if current_note == \".|\" {\n                beats = append(beats, 1)\n            }\n            current_note = \"\"\n            current_beat += 1\n        } else {\n            current_note += char\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpllgh6pvl_test.go:26:26: invalid operation: current_note += char (mismatched types string and rune)\n/tmp/tmpllgh6pvl_test.go:37:26: invalid operation: current_note += char (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var i int\n    for i = 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + music_string[i]\n        } else if music_string[i] == '|' {\n            note = note + music_string[i]\n            if note == \"o|\" {\n                beats = append(beats, 4)\n                note = \"\"\n            } else if note == \"o.\" {\n                beats = append(beats, 2)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note ==\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpg625or1c_test.go:72:6: expected '(', found TestParse_Music\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    var current_note_beats_count int\n    var current_note_beats_count_count int\n    var current_note_beats_count_count_count int\n    var current_note_beats_count_count_count_count int\n    var current_note_beats_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4keqf2gx_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpklh34k3s_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = current_note + \"o|\"\n            current_duration = 2\n        }\n        if current_note != \"\" {\n            current_beat = current_beat + 1\n            if current_beat == current_duration {\n                current_beat = 0\n                result = append(result, current_beat)\n            }\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwniqqdn2_test.go:30:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqwb4qs81_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for _, c := range music_string {\n        if c == '.' {\n            note = \"\"\n            count = 0\n        } else if c == '|' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else {\n            note += c\n            count++\n        }\n        if count == 4 {\n            beats = append(beats, note)\n            note = \"\"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0bh622v9_test.go:26:18: invalid operation: note += c (mismatched types string and rune)\n/tmp/tmp0bh622v9_test.go:29:18: invalid operation: note += c (mismatched types string and rune)\n/tmp/tmp0bh622v9_test.go:32:18: invalid operation: note += c (mismatched types string and rune)\n/tmp/tmp0bh622v9_test.go:35:18: invalid operation: note += c (mismatched types string and rune)\n/tmp/tmp0bh622v9_test.go:39:27: cannot use note (type string) as type int in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_count int\n    var current_beat_duration_count_count int\n    var current_beat_duration_count_count_count int\n    var current_beat_duration_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpydkwe3bf_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq69_lpz_test.go:22:38: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n        } else {\n            current_note = current_note + music_string[i]\n            current_duration = current_duration + 1\n        }\n        if current_duration == 4 {\n            current_beats = current_beats + 1\n            current_note = current_note + \" \"\n            current_duration = 0\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vy0dxeg_test.go:33:41: invalid operation: current_note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    for _, c := range music_string {\n        if c == ' ' {\n            continue\n        }\n        if c == '.' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == '|' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n            current_note_duration_multiplier_multiplier = 2\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == 'o|' {\n            current_note_duration_multiplier_multiplier_multiplier = 2\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == '.'|'|' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == 'o' || c == 'o|' || c == '.' || c == '.'|'|' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi2vb2_b8_test.go:49:17: illegal rune literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, note)\n            note = \"\"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdqeomu2f_test.go:32:25: invalid operation: note + music_string[i] (mismatched types string and byte)\n/tmp/tmpdqeomu2f_test.go:36:27: cannot use note (type string) as type int in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n            current_duration = current_duration + 2\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n        } else {\n            current_note = current_note + music_string[i]\n            current_duration = current_duration + 1\n        }\n        if current_note == \"o\" {\n            result = append(result, current_duration)\n            current_note = \"\"\n            current_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkt2oqnh9_test.go:32:41: invalid operation: current_note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_count int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note_count = 0\n            current_note = \"\"\n        } else if char == '|' {\n            current_note_count = 1\n            current_note = \"\"\n        } else if char == 'o' {\n            current_note_count = 2\n            current_note = \"\"\n        } else if char == 'o' {\n            current_note_count = 4\n            current_note = \"\"\n        } else {\n            current_note = current_note + string(char)\n        }\n        if current_note_count > 0 {\n            current_note_duration = current_note_duration + current_note_count\n            result = append(result, current_note_duration)\n            current_note_count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmp3escql3k_test.go:64: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=4) %!s(int=6) %!s(int=8)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp3escql3k_test.go:64: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp3escql3k_test.go:64: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=10) %!s(int=12) %!s(int=14) %!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp3escql3k_test.go:64: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=10) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=17) %!s(int=18)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n        } else {\n            current_note = current_note + music_string[i]\n            current_duration = current_duration + 1\n        }\n        if current_duration == 4 {\n            current_beat = current_beat + 1\n            current_duration = 0\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beat)\n            current_beat = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7gp18h1y_test.go:33:41: invalid operation: current_note + music_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 1\n        }\n        if current_beat > 4 {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmp_51og4kw_test.go:55: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=5) %!s(int=5) %!s(int=5)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp_51og4kw_test.go:55: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=5) %!s(int=6)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp_51og4kw_test.go:55: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=6) %!s(int=5) %!s(int=6) %!s(int=5) %!s(int=5) %!s(int=5) %!s(int=5)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp_51og4kw_test.go:55: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=6) %!s(int=5) %!s(int=6) %!s(int=5) %!s(int=5) %!s(int=6) %!s(int=5) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}