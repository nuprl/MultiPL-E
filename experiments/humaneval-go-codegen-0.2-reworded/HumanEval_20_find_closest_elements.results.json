{
  "name": "HumanEval_20_find_closest_elements",
  "language": "go_test.go",
  "prompt": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n",
  "tests": "func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var minIndex int\n    var maxIndex int\n    var minValue float64\n    var maxValue float64\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min = numbers[i]\n            max = numbers[i]\n            minIndex = i\n            maxIndex = i\n            minValue = numbers[i]\n            maxValue = numbers[i]\n        } else {\n            if numbers[i] < min {\n                min = numbers[i]\n                minIndex = i\n                minValue = numbers[i]\n            }\n            if numbers[i] > max {\n                max = numbers[i]\n                maxIndex = i\n                maxValue = numbers[i]\n            }\n        }\n    }\n    result = append(result, minValue)\n    result = append(result, maxValue)\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpayr3qg71_test.go:18:9: minIndex declared but not used\n/tmp/tmpayr3qg71_test.go:19:9: maxIndex declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min = numbers[i]\n            max = numbers[i]\n            min_index = i\n            max_index = i\n        } else {\n            if numbers[i] < min {\n                min = numbers[i]\n                min_index = i\n            }\n            if numbers[i] > max {\n                max = numbers[i]\n                max_index = i\n            }\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[max_index])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var min_diff float64\n    var max_diff float64\n    \n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min_number = numbers[i]\n            max_number = numbers[i]\n            min_index = i\n            max_index = i\n            min_diff = numbers[i] - numbers[i]\n            max_diff = numbers[i] - numbers[i]\n        } else {\n            if numbers[i] < min_number {\n                min_number = numbers[i]\n                min_index = i\n                min_diff = numbers[i] - numbers[i]\n            }\n            if numbers[i] > max_number {\n                max_number = numbers[i]\n                max_index = i\n                max_diff = numbers[i] - numbers[i]\n            }\n        }\n    }\n    \n    closest_numbers = []interface{}{min_number, max_number}\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9jgai5fc_test.go:18:9: min_index declared but not used\n/tmp/tmp9jgai5fc_test.go:19:9: max_index declared but not used\n/tmp/tmp9jgai5fc_test.go:20:9: min_diff declared but not used\n/tmp/tmp9jgai5fc_test.go:21:9: max_diff declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i, number := range numbers {\n        if i == 0 {\n            min = number\n            max = number\n            min_index = i\n            max_index = i\n        } else {\n            if number < min {\n                min = number\n                min_index = i\n            }\n            if number > max {\n                max = number\n                max_index = i\n            }\n        }\n    }\n    closest = append(closest, numbers[min_index])\n    closest = append(closest, numbers[max_index])\n    return closest\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpk1bcm3as_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpk1bcm3as_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpk1bcm3as_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpk1bcm3as_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpk1bcm3as_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_pair = append(closest_pair, numbers[i])\n                closest_pair = append(closest_pair, numbers[j])\n            } else {\n                closest_pair = append(closest_pair, numbers[j])\n                closest_pair = append(closest_pair, numbers[i])\n            }\n        }\n    }\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpsn1f4oj5_test.go:47: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=3.9) %!s(float64=5) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpsn1f4oj5_test.go:47: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=5.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=2) %!s(float64=5.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=4) %!s(float64=5.9) %!s(float64=5) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpsn1f4oj5_test.go:47: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=3) %!s(float64=5) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpsn1f4oj5_test.go:47: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(fl",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_value float64\n    var max_value float64\n    var min_index int\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min_value = numbers[i]\n            min_index = i\n        } else {\n            if numbers[i] < min_value {\n                min_value = numbers[i]\n                min_index = i\n            }\n        }\n        if i == len(numbers) - 1 {\n            max_value = numbers[i]\n            max_index = i\n        } else {\n            if numbers[i] > max_value {\n                max_value = numbers[i]\n                max_index = i\n            }\n        }\n    }\n    closest_numbers = []interface{}{min_value, max_value}\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqica9e4r_test.go:18:9: min_index declared but not used\n/tmp/tmpqica9e4r_test.go:19:9: max_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var minIndex int\n    var maxIndex int\n    \n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            minIndex = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            maxIndex = i\n        }\n    }\n    \n    if minIndex == maxIndex {\n        result = append(result, numbers[minIndex])\n        result = append(result, numbers[maxIndex])\n    } else {\n        result = append(result, numbers[minIndex])\n        result = append(result, numbers[maxIndex])\n    }\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpqnspt1ge_test.go:60: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpqnspt1ge_test.go:60: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpqnspt1ge_test.go:60: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpqnspt1ge_test.go:60: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpqnspt1ge_test.go:60: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.015s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64 = numbers[0]\n    var max_number float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min_number {\n            closest_numbers = append(closest_numbers, number)\n        }\n        if number == max_number {\n            closest_numbers = append(closest_numbers, number)\n        }\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpvdx9gthg_test.go:60: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpvdx9gthg_test.go:60: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpvdx9gthg_test.go:60: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpvdx9gthg_test.go:60: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpvdx9gthg_test.go:60: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_distance := numbers[0] - numbers[1]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        distance := numbers[i] - numbers[i-1]\n        if distance < min_distance {\n            min_distance = distance\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index+1)%len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpa6j0m2ot_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpa6j0m2ot_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpa6j0m2ot_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpa6j0m2ot_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpa6j0m2ot_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var closest_distance float64\n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i == j {\n                continue\n            }\n            distance := numbers[i] - numbers[j]\n            if closest_distance == 0.0 || distance < closest_distance {\n                closest_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpid_d8vph_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpid_d8vph_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpid_d8vph_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpid_d8vph_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpid_d8vph_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n\n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmprqbpp61i_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmprqbpp61i_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmprqbpp61i_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmprqbpp61i_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index + 1) % len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv779st7m_test.go:21:5: min_value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var result []interface{} = []interface{}{}\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    \n    if len(numbers) < 2 {\n        return closest_pair\n    }\n    \n    min_distance := math.MaxFloat64\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := math.Abs(numbers[i] - numbers[j])\n            if distance < min_distance {\n                min_distance = distance\n                closest_pair = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    \n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnp3fozu4_test.go:21:21: undefined: math\n/tmp/tmpnp3fozu4_test.go:25:25: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if distance < 0 {\n                distance *= -1\n            }\n            if min_distance == 0 || distance < min_distance {\n                min_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpac4xkhht_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=5.9) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpac4xkhht_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=3) %!s(float64=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_number := numbers[0]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n            min_index = i\n        }\n    }\n    \n    max_number := numbers[0]\n    max_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n    \n    return []interface{}{min_number, max_number}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdah5uj5k_test.go:20:5: min_index declared but not used\n/tmp/tmpdah5uj5k_test.go:30:5: max_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var min_index int = 0\n    var max_index int = 0\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min_number float64\n    var min_index int\n    var max_number float64\n    var max_index int\n    var result []interface{}\n    for i, number := range numbers {\n        if i == 0 {\n            min_number = number\n            min_index = i\n            max_number = number\n            max_index = i\n        } else {\n            if number < min_number {\n                min_number = number\n                min_index = i\n            }\n            if number > max_number {\n                max_number = number\n                max_index = i\n            }\n        }\n    }\n    if min_index == max_index {\n        result = append(result, numbers[min_index])\n        result = append(result, numbers[max_index])\n    } else {\n        result = append(result, numbers[min_index])\n        result = append(result, numbers[max_index])\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp64u1tnij_test.go:64: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp64u1tnij_test.go:64: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp64u1tnij_test.go:64: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp64u1tnij_test.go:64: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp64u1tnij_test.go:64: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var minIndex int\n    var maxIndex int\n    var minValue float64\n    var maxValue float64\n    var minValueIndex int\n    var maxValueIndex int\n    \n    if len(numbers) < 2 {\n        return result\n    }\n    \n    min = numbers[0]\n    max = numbers[0]\n    minIndex = 0\n    maxIndex = 0\n    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            minIndex = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            maxIndex = i\n        }\n    }\n    \n    minValue = numbers[minIndex]\n    maxValue = numbers[maxIndex]\n    minValueIndex = minIndex\n    maxValueIndex = maxIndex\n    \n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] == minValue {\n            if i == minValueIndex {\n                continue\n            }\n            minValueIndex = i\n            minValue = numbers[i]\n        }\n        if numbers[i] == maxValue {\n            if i == maxValueIndex {\n                continue\n            }\n            maxValueIndex = i\n            maxValue = numbers[i]\n        }\n    }\n    \n    result = []interface{}{minValue, maxValue}\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmphe2hng6q_test.go:88: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmphe2hng6q_test.go:88: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphe2hng6q_test.go:88: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphe2hng6q_test.go:88: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphe2hng6q_test.go:88: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_diff float64\n    var min_index int\n    var max_index int\n    var max_diff float64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff || min_index == -1 {\n                min_diff = diff\n                min_index = i\n                max_index = j\n            }\n        }\n    }\n    closest_pair = []interface{}{numbers[min_index], numbers[max_index]}\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5locozx6_test.go:19:9: max_diff declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_number := numbers[0]\n    max_number := numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min_number {\n            result = append(result, min_number)\n        }\n        if number == max_number {\n            result = append(result, max_number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpal8lgfj7_test.go:17:6: expected '(', found TestFind_Closest_Elements\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var closest_distance float64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if closest_distance == 0.0 || distance < closest_distance {\n                closest_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] > numbers[j] {\n                result = append(result, numbers[i])\n                result = append(result, numbers[j])\n                return result\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=3.9) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=5.9) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=3) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=3) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    var min_value float64\n    var max_value float64\n    for i, number := range numbers {\n        if i == 0 {\n            min = number\n            max = number\n            min_index = 0\n            max_index = 0\n        } else {\n            if number < min {\n                min = number\n                min_index = i\n            }\n            if number > max {\n                max = number\n                max_index = i\n            }\n        }\n    }\n    if min_index == 0 {\n        result = append(result, min)\n        result = append(result, max)\n    } else {\n        result = append(result, max)\n        result = append(result, min)\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9n3_zmub_test.go:19:9: max_index declared but not used\n/tmp/tmp9n3_zmub_test.go:20:9: min_value declared but not used\n/tmp/tmp9n3_zmub_test.go:21:9: max_value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_numbers = append(closest_numbers, numbers[i])\n                closest_numbers = append(closest_numbers, numbers[j])\n                break\n            } else if numbers[i] > numbers[j] {\n                closest_numbers = append(closest_numbers, numbers[j])\n                closest_numbers = append(closest_numbers, numbers[i])\n                break\n            }\n        }\n    }\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3.9) %!s(float64=3.9) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=5.9) %!s(float64=4) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2) %!s(float64=2.2) %!s(float64=3.1) %!s(float64=3.1) %!s(float64=4.1) %!s(float64=4.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_diff float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i != j {\n                diff := numbers[i] - numbers[j]\n                if diff < 0 {\n                    diff = -diff\n                }\n                if diff < min_diff {\n                    min_diff = diff\n                    closest_numbers = []interface{}{numbers[i], numbers[j]}\n                }\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpza79c52w_test.go:16:28: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := math.Abs(numbers[i] - numbers[j])\n            if distance < min_distance {\n                min_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpervx_ylv_test.go:16:32: undefined: math\n/tmp/tmpervx_ylv_test.go:19:25: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    var min_diff float64 = math.MaxFloat64\n    var min_index int = 0\n    var min_value float64 = math.MaxFloat64\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            \n            if diff < min_diff {\n                min_diff = diff\n                min_index = i\n                min_value = numbers[i]\n            }\n        }\n    }\n    \n    return []interface{}{numbers[min_index], min_value}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiqw7ojwo_test.go:19:28: undefined: math\n/tmp/tmpiqw7ojwo_test.go:21:29: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min = numbers[i]\n            max = numbers[i]\n            min_index = i\n            max_index = i\n        } else {\n            if numbers[i] < min {\n                min = numbers[i]\n                min_index = i\n            }\n            if numbers[i] > max {\n                max = numbers[i]\n                max_index = i\n            }\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[max_index])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var closest_distance float64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if distance < closest_distance {\n                closest_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpfwrkjc05_test.go:46: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpfwrkjc05_test.go:46: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpfwrkjc05_test.go:46: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpfwrkjc05_test.go:46: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpfwrkjc05_test.go:46: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"find_closest_elements: list too short\")\n    }\n    \n    min_diff := math.MaxFloat64\n    min_diff_index := 0\n    min_diff_number := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[0]\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            min_diff_index = i\n            min_diff_number = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_diff_number, numbers[min_diff_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8bzydgre_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var closest_distance float64\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if distance < closest_distance {\n                closest_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp49lgx84n_test.go:48: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp49lgx84n_test.go:48: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp49lgx84n_test.go:48: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp49lgx84n_test.go:48: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp49lgx84n_test.go:48: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var min_diff float64\n    var max_diff float64\n    var diff float64\n    \n    for i := 0; i < len(numbers); i++ {\n        diff = numbers[i] - numbers[0]\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            min_number = numbers[i]\n            min_index = i\n        }\n        diff = numbers[i] - numbers[len(numbers) - 1]\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < max_diff {\n            max_diff = diff\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n    \n    closest_numbers = []interface{}{min_number, max_number}\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwizafoou_test.go:18:9: min_index declared but not used\n/tmp/tmpwizafoou_test.go:19:9: max_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_value float64\n    var max_value float64\n    var min_index int\n    var max_index int\n    var min_value_index int\n    var max_value_index int\n    \n    if len(numbers) < 2 {\n        return closest_pair\n    }\n    \n    min_value = numbers[0]\n    max_value = numbers[0]\n    min_index = 0\n    max_index = 0\n    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n    \n    min_value_index = min_index\n    max_value_index = max_index\n    \n    for i := 0; i < len(numbers); i++ {\n        if i == min_index || i == max_index {\n            continue\n        }\n        \n        if numbers[i] < min_value {\n            min_value = numbers[i]\n            min_value_index = i\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_value_index = i\n        }\n    }\n    \n    closest_pair = []interface{}{numbers[min_value_index], numbers[max_value_index]}\n    \n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp7mr82cbp_test.go:83: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp7mr82cbp_test.go:83: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp7mr82cbp_test.go:83: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp7mr82cbp_test.go:83: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp7mr82cbp_test.go:83: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var result []interface{} = []interface{}{}\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, min)\n        }\n        if number == max {\n            result = append(result, max)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpatwu2md5_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpatwu2md5_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpatwu2md5_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpatwu2md5_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpatwu2md5_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var min_diff float64\n    var max_diff float64\n    \n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min_number = numbers[i]\n            max_number = numbers[i]\n            min_index = i\n            max_index = i\n            min_diff = numbers[i] - numbers[i]\n            max_diff = numbers[i] - numbers[i]\n        } else {\n            if numbers[i] < min_number {\n                min_number = numbers[i]\n                min_index = i\n                min_diff = numbers[i] - numbers[i]\n            } else if numbers[i] > max_number {\n                max_number = numbers[i]\n                max_index = i\n                max_diff = numbers[i] - numbers[i]\n            }\n        }\n    }\n    \n    closest_numbers = []interface{}{min_number, max_number}\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_ykr1t4k_test.go:18:9: min_index declared but not used\n/tmp/tmp_ykr1t4k_test.go:19:9: max_index declared but not used\n/tmp/tmp_ykr1t4k_test.go:20:9: min_diff declared but not used\n/tmp/tmp_ykr1t4k_test.go:21:9: max_diff declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var min_diff float64\n    var max_diff float64\n    \n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min_number = numbers[i]\n            max_number = numbers[i]\n            min_index = i\n            max_index = i\n            min_diff = numbers[i] - numbers[i]\n            max_diff = numbers[i] - numbers[i]\n        } else {\n            if numbers[i] < min_number {\n                min_number = numbers[i]\n                min_index = i\n                min_diff = numbers[i] - numbers[i]\n            }\n            if numbers[i] > max_number {\n                max_number = numbers[i]\n                max_index = i\n                max_diff = numbers[i] - numbers[i]\n            }\n        }\n    }\n    \n    closest_numbers = []interface{}{min_number, max_number}\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9jgai5fc_test.go:18:9: min_index declared but not used\n/tmp/tmp9jgai5fc_test.go:19:9: max_index declared but not used\n/tmp/tmp9jgai5fc_test.go:20:9: min_diff declared but not used\n/tmp/tmp9jgai5fc_test.go:21:9: max_diff declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"Not enough numbers\")\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpmh4m6515_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpmh4m6515_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpmh4m6515_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpmh4m6515_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    var min_value float64\n    var max_value float64\n    \n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min = numbers[0]\n    max = numbers[0]\n    min_index = 0\n    max_index = 0\n    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n    \n    min_value = numbers[min_index]\n    max_value = numbers[max_index]\n    \n    if min_value == max_value {\n        return []interface{}{min_value, max_value}\n    }\n    \n    if min_value < max_value {\n        return []interface{}{min_value, max_value}\n    }\n    \n    return []interface{}{max_value, min_value}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp_gnpfxn7_test.go:73: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp_gnpfxn7_test.go:73: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp_gnpfxn7_test.go:73: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp_gnpfxn7_test.go:73: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp_gnpfxn7_test.go:73: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_diff float64 = 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqqzgf1za_test.go:17:6: expected '(', found TestFind_Closest_Elements\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    result = append(result, numbers[0])\n    result = append(result, numbers[1])\n    \n    for i := 2; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            result[0], result[1] = numbers[i-1], numbers[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=5) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=5.9) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=5) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=5) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i, number := range numbers {\n        if i == 0 {\n            min = number\n            max = number\n            min_index = 0\n            max_index = 0\n        } else {\n            if number < min {\n                min = number\n                min_index = i\n            }\n            if number > max {\n                max = number\n                max_index = i\n            }\n        }\n    }\n    if min_index == 0 {\n        result = append(result, numbers[max_index])\n        result = append(result, numbers[min_index])\n    } else {\n        result = append(result, numbers[min_index])\n        result = append(result, numbers[max_index])\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp_w_1y51p_test.go:64: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=5) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp_w_1y51p_test.go:64: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=5.9) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp_w_1y51p_test.go:64: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=5) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp_w_1y51p_test.go:64: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=5) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp_w_1y51p_test.go:64: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=5.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] > numbers[j] {\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n            }\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                result = append(result, numbers[i])\n                result = append(result, numbers[j])\n                return result\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmphnj_5tfj_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmphnj_5tfj_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphnj_5tfj_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphnj_5tfj_test.go:52: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphnj_5tfj_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_number := numbers[0]\n    max_number := numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min_number {\n            result = append(result, number)\n        }\n        if number == max_number {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpr_3dsr7e_test.go:57: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpr_3dsr7e_test.go:57: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpr_3dsr7e_test.go:57: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpr_3dsr7e_test.go:57: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpr_3dsr7e_test.go:57: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i == j {\n                continue\n            }\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptd3c14bw_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index + 1) % len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp9z52xatt_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp9z52xatt_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp9z52xatt_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp9z52xatt_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp9z52xatt_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var i int\n    for i = 0; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n    closest_numbers = append(closest_numbers, numbers[min_index])\n    closest_numbers = append(closest_numbers, numbers[max_index])\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpoi2xag1k_test.go:53: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpoi2xag1k_test.go:53: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpoi2xag1k_test.go:53: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpoi2xag1k_test.go:53: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpoi2xag1k_test.go:53: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_diff float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                closest_pair = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprepa_t38_test.go:16:28: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var min_index int = 0\n    var max_index int = 0\n\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp7plv7k8p_test.go:56: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp7plv7k8p_test.go:56: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp7plv7k8p_test.go:56: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp7plv7k8p_test.go:56: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp7plv7k8p_test.go:56: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            result = append(result, number)\n        } else if number > max {\n            result = append(result, number)\n        } else {\n            result = append(result, min)\n            result = append(result, max)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpftogz7nq_test.go:57: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpftogz7nq_test.go:57: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpftogz7nq_test.go:57: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpftogz7nq_test.go:57: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpftogz7nq_test.go:57: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    min_number := numbers[0]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n            min_index = i\n        }\n    }\n\n    max_number := numbers[0]\n    max_index := 0\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp91wgf9k5_test.go:57: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp91wgf9k5_test.go:57: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp91wgf9k5_test.go:57: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp91wgf9k5_test.go:57: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp91wgf9k5_test.go:57: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvko6jsbs_test.go:107:6: expected '(', found TestFind_Closest_Elements\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"Not enough numbers\")\n    }\n\n    min_number := numbers[0]\n    max_number := numbers[0]\n\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n\n        if number > max_number {\n            max_number = number\n        }\n    }\n\n    min_index := 0\n    max_index := 0\n\n    for i, number := range numbers {\n        if number == min_number {\n            min_index = i\n        }\n\n        if number == max_number {\n            max_index = i\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpfld0b4qu_test.go:65: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpfld0b4qu_test.go:65: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpfld0b4qu_test.go:65: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpfld0b4qu_test.go:65: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpfld0b4qu_test.go:65: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min_diff float64 = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwb2lv73a_test.go:16:6: expected '(', found TestFind_Closest_Elements\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var min_diff float64\n    var max_diff float64\n    for i, number := range numbers {\n        if i == 0 {\n            min_number = number\n            max_number = number\n            min_index = i\n            max_index = i\n            min_diff = number - min_number\n            max_diff = number - max_number\n        } else {\n            if number < min_number {\n                min_number = number\n                min_index = i\n                min_diff = number - min_number\n            } else if number > max_number {\n                max_number = number\n                max_index = i\n                max_diff = number - max_number\n            }\n        }\n    }\n    closest_numbers = []interface{}{min_number, max_number}\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdj8_o6p_test.go:18:9: min_index declared but not used\n/tmp/tmpfdj8_o6p_test.go:19:9: max_index declared but not used\n/tmp/tmpfdj8_o6p_test.go:20:9: min_diff declared but not used\n/tmp/tmpfdj8_o6p_test.go:21:9: max_diff declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] > numbers[j] {\n                closest_numbers = append(closest_numbers, numbers[j])\n                closest_numbers = append(closest_numbers, numbers[i])\n            } else {\n                closest_numbers = append(closest_numbers, numbers[i])\n                closest_numbers = append(closest_numbers, numbers[j])\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpgy75wnvw_test.go:47: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=3.9) %!s(float64=5) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpgy75wnvw_test.go:47: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=5.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=2) %!s(float64=5.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=4) %!s(float64=5.9) %!s(float64=5) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpgy75wnvw_test.go:47: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=3) %!s(float64=5) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpgy75wnvw_test.go:47: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(fl",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    var min_value float64\n    var max_value float64\n    var result []interface{}\n    \n    if len(numbers) < 2 {\n        return result\n    }\n    \n    min = numbers[0]\n    max = numbers[0]\n    min_index = 0\n    max_index = 0\n    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n    \n    min_value = numbers[min_index]\n    max_value = numbers[max_index]\n    \n    if min_value == max_value {\n        result = []interface{}{min_value, max_value}\n    } else {\n        result = []interface{}{min_value, max_value}\n    }\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpvwemflbt_test.go:72: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpvwemflbt_test.go:72: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpvwemflbt_test.go:72: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpvwemflbt_test.go:72: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpvwemflbt_test.go:72: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := math.Abs(numbers[i] - numbers[j])\n            if distance < min_distance {\n                min_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpervx_ylv_test.go:16:32: undefined: math\n/tmp/tmpervx_ylv_test.go:19:25: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_diff float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < min_diff {\n                min_diff = diff\n                closest_pair = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7co9alku_test.go:16:28: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    return []interface{}{numbers[min_index], numbers[(min_index + 1) % len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp0j5jv2sk_test.go:47: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp0j5jv2sk_test.go:47: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp0j5jv2sk_test.go:47: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp0j5jv2sk_test.go:47: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp0j5jv2sk_test.go:47: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_value float64\n    var max_value float64\n    var min_index int\n    var max_index int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gntkkf_test.go:115:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_pair = append(closest_pair, numbers[i])\n                closest_pair = append(closest_pair, numbers[j])\n            } else {\n                closest_pair = append(closest_pair, numbers[j])\n                closest_pair = append(closest_pair, numbers[i])\n            }\n        }\n    }\n    \n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpbbdvaky6_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=3.9) %!s(float64=5) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpbbdvaky6_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=5.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=2) %!s(float64=5.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=4) %!s(float64=5.9) %!s(float64=5) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpbbdvaky6_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=3) %!s(float64=5) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpbbdvaky6_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(fl",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_diff float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                closest_pair = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprepa_t38_test.go:16:28: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_pair = append(closest_pair, numbers[i])\n                closest_pair = append(closest_pair, numbers[j])\n            } else {\n                closest_pair = append(closest_pair, numbers[j])\n                closest_pair = append(closest_pair, numbers[i])\n            }\n        }\n    }\n    \n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpbbdvaky6_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=3.9) %!s(float64=5) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpbbdvaky6_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=5.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=2) %!s(float64=5.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=4) %!s(float64=5.9) %!s(float64=5) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpbbdvaky6_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=3) %!s(float64=5) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpbbdvaky6_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(fl",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    var min_number float64\n    var min_index int\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n            min_index = i\n        }\n    }\n\n    var max_number float64\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n\n    if min_index == max_index {\n        return []interface{}{numbers[min_index], numbers[max_index]}\n    }\n\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpeetukgne_test.go:61: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpeetukgne_test.go:61: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpeetukgne_test.go:61: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpeetukgne_test.go:61: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpeetukgne_test.go:61: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64\n    var min_index int\n    for i, number := range numbers {\n        for j, other_number := range numbers {\n            if i == j {\n                continue\n            }\n            distance := math.Abs(number - other_number)\n            if distance < min_distance || min_distance == 0.0 {\n                min_distance = distance\n                min_index = j\n            }\n        }\n        closest_numbers = append(closest_numbers, numbers[min_index])\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpih7xkkb__test.go:23:25: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_difference := numbers[0] - numbers[1]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        difference := numbers[i] - numbers[i-1]\n        if difference < min_difference {\n            min_difference = difference\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index + 1) % len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp8crn_n27_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp8crn_n27_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp8crn_n27_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp8crn_n27_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp8crn_n27_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4iozjwy8_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    \n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        \n        if number > max {\n            max = number\n        }\n    }\n    \n    var result []interface{}\n    \n    for _, number := range numbers {\n        if number < min {\n            result = append(result, number)\n        }\n        \n        if number > max {\n            result = append(result, number)\n        }\n    }\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpkiitlk12_test.go:64: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpkiitlk12_test.go:64: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpkiitlk12_test.go:64: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpkiitlk12_test.go:64: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpkiitlk12_test.go:64: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i == j {\n                continue\n            }\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptd3c14bw_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpok97rrte_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpok97rrte_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpok97rrte_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpok97rrte_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    \n    min := numbers[0]\n    max := numbers[0]\n    \n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    \n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    \n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpernsfuti_test.go:70: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpernsfuti_test.go:70: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpernsfuti_test.go:70: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpernsfuti_test.go:70: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpernsfuti_test.go:70: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index + 1) % len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv779st7m_test.go:21:5: min_value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if distance < min_distance {\n                min_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsw58o92h_test.go:16:32: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_diff float64\n    var min_index int\n    var max_index int\n    var max_diff float64\n    for i, number := range numbers {\n        for j, number2 := range numbers {\n            if i == j {\n                continue\n            }\n            diff := number - number2\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff || min_index == -1 {\n                min_diff = diff\n                min_index = i\n            }\n            if diff > max_diff || max_index == -1 {\n                max_diff = diff\n                max_index = j\n            }\n        }\n    }\n    if min_index == -1 || max_index == -1 {\n        return closest_numbers\n    }\n    closest_numbers = append(closest_numbers, numbers[min_index])\n    closest_numbers = append(closest_numbers, numbers[max_index])\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpmny_g2k2_test.go:64: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpmny_g2k2_test.go:64: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpmny_g2k2_test.go:64: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpmny_g2k2_test.go:64: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpmny_g2k2_test.go:64: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4iozjwy8_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var min_index int = 0\n    var max_index int = 0\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    var min_diff float64 = math.MaxFloat64\n    var min_index int = 0\n    var min_value float64 = numbers[0]\n    var max_diff float64 = math.MaxFloat64\n    var max_index int = 0\n    var max_value float64 = numbers[0]\n    \n    for i := 0; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[0]\n        if diff < 0 {\n            diff = -diff\n        }\n        \n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n        \n        if diff > max_diff {\n            max_diff = diff\n            max_index = i\n            max_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, max_value}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplna9fxi0_test.go:19:28: undefined: math\n/tmp/tmplna9fxi0_test.go:22:28: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    \n    if len(numbers) < 2 {\n        return closest_numbers\n    }\n    \n    min_number := numbers[0]\n    max_number := numbers[0]\n    \n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    \n    for _, number := range numbers {\n        if number == min_number {\n            closest_numbers = append(closest_numbers, number)\n        }\n        if number == max_number {\n            closest_numbers = append(closest_numbers, number)\n        }\n    }\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpzw32gd6r_test.go:62: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpzw32gd6r_test.go:62: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpzw32gd6r_test.go:62: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpzw32gd6r_test.go:62: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpzw32gd6r_test.go:62: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                min_number = numbers[i]\n                min_index = i\n            } else {\n                min_number = numbers[j]\n                min_index = j\n            }\n            if numbers[i] > numbers[j] {\n                max_number = numbers[i]\n                max_index = i\n            } else {\n                max_number = numbers[j]\n                max_index = j\n            }\n            if min_number - max_number < 0.00001 {\n                closest_pair = append(closest_pair, numbers[min_index])\n                closest_pair = append(closest_pair, numbers[max_index])\n                break\n            }\n        }\n    }\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp9bgc6o8c_test.go:64: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3.9) %!s(float64=3.9) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp9bgc6o8c_test.go:64: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=5.9) %!s(float64=4) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp9bgc6o8c_test.go:64: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp9bgc6o8c_test.go:64: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp9bgc6o8c_test.go:64: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2) %!s(float64=2.2) %!s(float64=3.1) %!s(float64=3.1) %!s(float64=4.1) %!s(float64=4.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < 0 {\n            diff = -diff\n        }\n        \n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[min_index+1]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfpbs923m_test.go:21:5: min_value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                result = append(result, numbers[i])\n                result = append(result, numbers[j])\n                return result\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := math.MaxFloat64\n    min_diff_index := 0\n    min_diff_number := numbers[0]\n    \n    for i := 0; i < len(numbers); i++ {\n        diff := math.Abs(numbers[i] - min_diff_number)\n        if diff < min_diff {\n            min_diff = diff\n            min_diff_index = i\n        }\n    }\n    \n    min_diff_number = numbers[min_diff_index]\n    \n    for i := 0; i < len(numbers); i++ {\n        diff := math.Abs(numbers[i] - min_diff_number)\n        if diff == min_diff {\n            return []interface{}{min_diff_number, numbers[i]}\n        }\n    }\n    \n    return []interface{}{min_diff_number, min_diff_number}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg6k0ifgj_test.go:19:17: undefined: math\n/tmp/tmpg6k0ifgj_test.go:24:17: undefined: math\n/tmp/tmpg6k0ifgj_test.go:34:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"Not enough numbers\")\n    }\n\n    min_diff := math.MaxFloat64\n    min_index := 0\n    max_index := 0\n\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                min_index = i\n                max_index = j\n            }\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7e90fddk_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64\n    var max float64\n    var minIndex int\n    var maxIndex int\n    var minValue float64\n    var maxValue float64\n    var result []interface{}\n    \n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min || min == 0 {\n            min = numbers[i]\n            minIndex = i\n        }\n        if numbers[i] > max || max == 0 {\n            max = numbers[i]\n            maxIndex = i\n        }\n    }\n    \n    minValue = numbers[minIndex]\n    maxValue = numbers[maxIndex]\n    \n    if minValue == maxValue {\n        result = []interface{}{minValue, maxValue}\n    } else {\n        result = []interface{}{minValue, maxValue}\n    }\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp7a1mvm9b_test.go:63: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp7a1mvm9b_test.go:63: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp7a1mvm9b_test.go:63: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp7a1mvm9b_test.go:63: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp7a1mvm9b_test.go:63: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    \n    if len(numbers) < 2 {\n        return closest_pair\n    }\n    \n    min_number = numbers[0]\n    max_number = numbers[0]\n    min_index = 0\n    max_index = 0\n    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n            min_index = i\n        }\n        \n        if numbers[i] > max_number {\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n    \n    closest_pair = []interface{}{numbers[min_index], numbers[max_index]}\n    \n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpb29l_swa_test.go:64: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpb29l_swa_test.go:64: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpb29l_swa_test.go:64: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpb29l_swa_test.go:64: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpb29l_swa_test.go:64: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var closest float64 = numbers[0]\n    var closest_index int = 0\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            closest = numbers[i]\n            closest_index = i\n        } else if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    return []interface{}{closest, closest_index}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp6c32miw0_test.go:48: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(int=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp6c32miw0_test.go:48: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(int=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp6c32miw0_test.go:48: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(int=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp6c32miw0_test.go:48: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(int=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp6c32miw0_test.go:48: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var closest float64 = numbers[0]\n    var closest_index int = 0\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            closest = numbers[i]\n            closest_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    return []interface{}{closest, closest_index}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmput5mn1v4_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(int=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmput5mn1v4_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(int=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmput5mn1v4_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(int=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmput5mn1v4_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(int=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmput5mn1v4_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_numbers = append(closest_numbers, numbers[i])\n                closest_numbers = append(closest_numbers, numbers[j])\n                break\n            } else if numbers[i] > numbers[j] {\n                closest_numbers = append(closest_numbers, numbers[j])\n                closest_numbers = append(closest_numbers, numbers[i])\n                break\n            }\n        }\n    }\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3.9) %!s(float64=3.9) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=5.9) %!s(float64=4) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2) %!s(float64=2.2) %!s(float64=3.1) %!s(float64=3.1) %!s(float64=4.1) %!s(float64=4.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_number := numbers[0]\n    max_number := numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min_number {\n            result = append(result, min_number)\n        }\n        if number == max_number {\n            result = append(result, max_number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpnagu5a0o_test.go:57: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min_diff float64 = math.MaxFloat64\n    var min_index int = -1\n    var min_number float64 = math.MaxFloat64\n    var max_diff float64 = math.MaxFloat64\n    var max_index int = -1\n    var max_number float64 = math.MaxFloat64\n    for i, number := range numbers {\n        diff := number - min_number\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n        diff = number - max_number\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < max_diff {\n            max_diff = diff\n            max_index = i\n        }\n    }\n    if min_index == max_index {\n        return []interface{}{numbers[min_index], numbers[max_index]}\n    }\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdt36c0ks_test.go:15:28: undefined: math\n/tmp/tmpdt36c0ks_test.go:17:30: undefined: math\n/tmp/tmpdt36c0ks_test.go:18:28: undefined: math\n/tmp/tmpdt36c0ks_test.go:20:30: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    var min_value float64\n    var max_value float64\n    var i int\n    var j int\n    var k int\n    for i = 0; i < len(numbers); i++ {\n        for j = i + 1; j < len(numbers); j++ {\n            if numbers[i] > numbers[j] {\n                min = numbers[i]\n                max = numbers[j]\n                min_index = i\n                max_index = j\n            } else {\n                min = numbers[j]\n                max = numbers[i]\n                min_index = j\n                max_index = i\n            }\n            for k = 0; k < len(numbers); k++ {\n                if numbers[k] > min && numbers[k] < max {\n                    min_value = numbers[k]\n                    break\n                }\n            }\n            for k = 0; k < len(numbers); k++ {\n                if numbers[k] > max && numbers[k] < min {\n                    max_value = numbers[k]\n                    break\n                }\n            }\n            if min_value != max_value {\n                result = append(result, min_value)\n                result = append(result, max_value)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpensfg0rr_test.go:18:9: min_index declared but not used\n/tmp/tmpensfg0rr_test.go:19:9: max_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_numbers = append(closest_numbers, numbers[i])\n                closest_numbers = append(closest_numbers, numbers[j])\n                break\n            } else if numbers[i] > numbers[j] {\n                closest_numbers = append(closest_numbers, numbers[j])\n                closest_numbers = append(closest_numbers, numbers[i])\n                break\n            }\n        }\n    }\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3.9) %!s(float64=3.9) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=5.9) %!s(float64=4) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpv6i5icac_test.go:51: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2) %!s(float64=2.2) %!s(float64=3.1) %!s(float64=3.1) %!s(float64=4.1) %!s(float64=4.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    \n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_vjgtu38_test.go:20:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var result []interface{} = []interface{}{}\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"Need at least two numbers\")\n    }\n    \n    var min_number float64\n    var min_index int\n    \n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n            min_index = i\n        }\n    }\n    \n    var max_number float64\n    var max_index int\n    \n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n    \n    var closest_number float64\n    var closest_index int\n    \n    if numbers[min_index] < numbers[max_index] {\n        closest_number = numbers[min_index]\n        closest_index = min_index\n    } else {\n        closest_number = numbers[max_index]\n        closest_index = max_index\n    }\n    \n    return []interface{}{closest_number, numbers[closest_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp3pnw0b40_test.go:70: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp3pnw0b40_test.go:70: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp3pnw0b40_test.go:70: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp3pnw0b40_test.go:70: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp3pnw0b40_test.go:70: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    min_number := numbers[0]\n    max_number := numbers[0]\n\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n\n    for _, number := range numbers {\n        if number == min_number {\n            continue\n        }\n        if number == max_number {\n            continue\n        }\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n\n    return []interface{}{min_number, max_number}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmph8q3id3p_test.go:66: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmph8q3id3p_test.go:66: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmph8q3id3p_test.go:66: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmph8q3id3p_test.go:66: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmph8q3id3p_test.go:66: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    max_index := 1\n\n    for i := 2; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        } else if diff > min_diff {\n            max_index = i\n            break\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpbwiai543_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=3.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpbwiai543_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpbwiai543_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=3)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpbwiai543_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=3)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpbwiai543_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=3.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i, number := range numbers {\n        if i == 0 {\n            min = number\n            max = number\n            min_index = 0\n            max_index = 0\n        } else {\n            if number < min {\n                min = number\n                min_index = i\n            }\n            if number > max {\n                max = number\n                max_index = i\n            }\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[max_index])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp1kj3__3l_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp1kj3__3l_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp1kj3__3l_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp1kj3__3l_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp1kj3__3l_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var result []interface{} = []interface{}{}\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"The list must contain at least two numbers\")\n    }\n\n    min_diff := math.MaxFloat64\n    min_index := 0\n    min_value := numbers[0]\n    max_index := 0\n    max_value := numbers[0]\n\n    for i := 0; i < len(numbers); i++ {\n        diff := math.Abs(numbers[i] - numbers[min_index])\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n\n        diff = math.Abs(numbers[i] - numbers[max_index])\n        if diff < min_diff {\n            min_diff = diff\n            max_index = i\n            max_value = numbers[i]\n        }\n    }\n\n    return []interface{}{min_value, max_value}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1rwdvvye_test.go:19:17: undefined: math\n/tmp/tmp1rwdvvye_test.go:26:17: undefined: math\n/tmp/tmp1rwdvvye_test.go:33:16: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min_distance float64 = math.MaxFloat64\n    var min_index int = 0\n    var min_value float64 = math.MaxFloat64\n    var max_index int = 0\n    var max_value float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if distance < min_distance {\n                min_distance = distance\n                min_index = i\n                min_value = numbers[i]\n            }\n            if distance > max_distance {\n                max_distance = distance\n                max_index = i\n                max_value = numbers[i]\n            }\n        }\n    }\n    return []interface{}{min_value, max_value}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy8zdpva3_test.go:15:32: undefined: math\n/tmp/tmpy8zdpva3_test.go:17:29: undefined: math\n/tmp/tmpy8zdpva3_test.go:19:29: undefined: math\n/tmp/tmpy8zdpva3_test.go:28:27: undefined: max_distance\n/tmp/tmpy8zdpva3_test.go:29:17: undefined: max_distance\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpal8lgfj7_test.go:17:6: expected '(', found TestFind_Closest_Elements\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i == j {\n                continue\n            }\n            distance := math.Abs(numbers[i] - numbers[j])\n            if distance < min_distance {\n                min_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpknq4nt03_test.go:16:32: undefined: math\n/tmp/tmpknq4nt03_test.go:22:25: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpwquaac1n_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var closest_distance float64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if closest_distance == 0.0 || distance < closest_distance {\n                closest_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpy83eszaa_test.go:46: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_diff float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i == j {\n                continue\n            }\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj0id1wq6_test.go:16:28: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    result = append(result, numbers[0])\n    result = append(result, numbers[1])\n    \n    for i := 2; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            result[0], result[1] = numbers[i-1], numbers[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=5) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=5.9) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=5) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=5) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp5v02ayeu_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index+1)%len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpdd5kqiun_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpdd5kqiun_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpdd5kqiun_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpdd5kqiun_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpdd5kqiun_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := math.MaxFloat64\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 0; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[0]\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv9g0bj5f_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min = numbers[i]\n            max = numbers[i]\n            min_index = i\n            max_index = i\n        } else {\n            if numbers[i] < min {\n                min = numbers[i]\n                min_index = i\n            }\n            if numbers[i] > max {\n                max = numbers[i]\n                max_index = i\n            }\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[max_index])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var minIndex int\n    var maxIndex int\n    var minValue float64\n    var maxValue float64\n    \n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min = numbers[i]\n            max = numbers[i]\n            minIndex = i\n            maxIndex = i\n            minValue = numbers[i]\n            maxValue = numbers[i]\n        } else {\n            if numbers[i] < min {\n                min = numbers[i]\n                minIndex = i\n                minValue = numbers[i]\n            }\n            if numbers[i] > max {\n                max = numbers[i]\n                maxIndex = i\n                maxValue = numbers[i]\n            }\n        }\n    }\n    \n    result = append(result, minValue)\n    result = append(result, maxValue)\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0np90iut_test.go:18:9: minIndex declared but not used\n/tmp/tmp0np90iut_test.go:19:9: maxIndex declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_difference := math.MaxFloat64\n    min_index := 0\n    min_value := numbers[0]\n    max_index := 0\n    max_value := numbers[0]\n    \n    for i := 0; i < len(numbers); i++ {\n        difference := numbers[i] - numbers[0]\n        if difference < 0 {\n            difference = -difference\n        }\n        if difference < min_difference {\n            min_difference = difference\n            min_index = i\n            min_value = numbers[i]\n        }\n        if difference > 0 {\n            difference = -difference\n        }\n        if difference > max_difference {\n            max_difference = difference\n            max_index = i\n            max_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, max_value}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0fn8dckg_test.go:19:23: undefined: math\n/tmp/tmp0fn8dckg_test.go:38:25: undefined: max_difference\n/tmp/tmp0fn8dckg_test.go:39:13: undefined: max_difference\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_difference := math.MaxFloat64\n    min_index := 0\n    max_index := 0\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            difference := numbers[i] - numbers[j]\n            if difference < 0 {\n                difference = -difference\n            }\n            \n            if difference < min_difference {\n                min_difference = difference\n                min_index = i\n                max_index = j\n            }\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsnw3jtnd_test.go:19:23: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var minIndex int\n    var maxIndex int\n    var minValue float64\n    var maxValue float64\n    var minValueIndex int\n    var maxValueIndex int\n    \n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min = numbers[i]\n            max = numbers[i]\n            minIndex = i\n            maxIndex = i\n            minValue = numbers[i]\n            maxValue = numbers[i]\n            minValueIndex = i\n            maxValueIndex = i\n        } else {\n            if numbers[i] < min {\n                min = numbers[i]\n                minIndex = i\n                minValue = numbers[i]\n                minValueIndex = i\n            }\n            if numbers[i] > max {\n                max = numbers[i]\n                maxIndex = i\n                maxValue = numbers[i]\n                maxValueIndex = i\n            }\n        }\n    }\n    \n    result = append(result, minValue)\n    result = append(result, maxValue)\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcuuf9gb0_test.go:18:9: minIndex declared but not used\n/tmp/tmpcuuf9gb0_test.go:19:9: maxIndex declared but not used\n/tmp/tmpcuuf9gb0_test.go:22:9: minValueIndex declared but not used\n/tmp/tmpcuuf9gb0_test.go:23:9: maxValueIndex declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return []interface{}{}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpyhi43epb_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpyhi43epb_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpyhi43epb_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpyhi43epb_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpyhi43epb_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[min_index+1])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\npanic: runtime error: index out of range [6] with length 6 [recovered]\n\tpanic: runtime error: index out of range [6] with length 6\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.find_closest_elements(0xc0000b8df0, 0x6, 0x6, 0x4cd164, 0x0, 0x58a65f)\n\t/tmp/tmpgh7b40j7_test.go:29 +0x256\ncommand-line-arguments_test.TestFind_Closest_Elements(0xc000001380)\n\t/tmp/tmpgh7b40j7_test.go:40 +0xe2\ntesting.tRunner(0xc000001380, 0x54f210)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i != j {\n                distance := math.Abs(numbers[i] - numbers[j])\n                if distance < min_distance {\n                    min_distance = distance\n                    closest_numbers = []interface{}{numbers[i], numbers[j]}\n                }\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6k224uy2_test.go:16:32: undefined: math\n/tmp/tmp6k224uy2_test.go:20:29: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    var min_number float64\n    var min_index int\n    for i, number := range numbers {\n        if i == 0 {\n            min_number = number\n            min_index = i\n            continue\n        }\n\n        if number < min_number {\n            min_number = number\n            min_index = i\n        }\n    }\n\n    var max_number float64\n    var max_index int\n    for i, number := range numbers {\n        if i == len(numbers) - 1 {\n            max_number = number\n            max_index = i\n            continue\n        }\n\n        if number > max_number {\n            max_number = number\n            max_index = i\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpixw94oka_test.go:69: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpixw94oka_test.go:69: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpixw94oka_test.go:69: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpixw94oka_test.go:69: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpixw94oka_test.go:69: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index+1)%len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_distance := numbers[0] - numbers[1]\n    min_index := 0\n    min_index_2 := 1\n    \n    for i := 1; i < len(numbers); i++ {\n        distance := numbers[i] - numbers[i-1]\n        if distance < min_distance {\n            min_distance = distance\n            min_index = i\n            min_index_2 = i - 1\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[min_index_2]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp63qzy7bs_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp63qzy7bs_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp63qzy7bs_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp63qzy7bs_test.go:52: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp63qzy7bs_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index+1)%len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff *= -1\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcvmt4bh0_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var min_index int = 0\n    var max_index int = 0\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp02a_6nc5_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var min_diff float64\n    var max_diff float64\n    var i int\n    var j int\n    var diff float64\n    \n    if len(numbers) < 2 {\n        return closest_numbers\n    }\n    \n    min_number = numbers[0]\n    max_number = numbers[0]\n    min_index = 0\n    max_index = 0\n    \n    for i = 1; i < len(numbers); i++ {\n        diff = numbers[i] - min_number\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n        diff = numbers[i] - max_number\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff > max_diff {\n            max_diff = diff\n            max_index = i\n        }\n    }\n    \n    closest_numbers = []interface{}{numbers[min_index], numbers[max_index]}\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpztb5ry53_test.go:23:9: j declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff *= -1\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcvmt4bh0_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_distance := math.MaxFloat64\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if distance < 0 {\n                distance = -distance\n            }\n            \n            if distance < min_distance {\n                min_distance = distance\n            }\n        }\n    }\n    \n    return []interface{}{numbers[0], numbers[1]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7htm2rp7_test.go:19:21: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_distance := math.MaxFloat64\n    min_index := 0\n    max_index := 0\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i == j {\n                continue\n            }\n            \n            distance := math.Abs(numbers[i] - numbers[j])\n            if distance < min_distance {\n                min_distance = distance\n                min_index = i\n                max_index = j\n            }\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvbiarve__test.go:19:21: undefined: math\n/tmp/tmpvbiarve__test.go:29:25: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"find_closest_elements: input list must be at least two elements long\")\n    }\n\n    // Sort the list\n    sort_numbers(numbers)\n\n    // Find the closest pair\n    var closest_pair []interface{}\n    for i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] == numbers[j] {\n                continue\n            }\n            if numbers[i] < numbers[j] {\n                closest_pair = append(closest_pair, numbers[i])\n                closest_pair = append(closest_pair, numbers[j])\n                return closest_pair\n            }\n        }\n    }\n\n    // If we get here, we didn't find a pair\n    panic(\"find_closest_elements: no closest pair found\")\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbcm1nmnp_test.go:20:5: undefined: sort_numbers\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"find_closest_elements: list too short\")\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpv2iduebx_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpv2iduebx_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpv2iduebx_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpv2iduebx_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[(min_index+1)%len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoodm5pra_test.go:21:5: min_value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min, max float64\n    var minIndex, maxIndex int\n    \n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min || min == 0 {\n            min = numbers[i]\n            minIndex = i\n        }\n        if numbers[i] > max || max == 0 {\n            max = numbers[i]\n            maxIndex = i\n        }\n    }\n    \n    return []interface{}{numbers[minIndex], numbers[maxIndex]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp6yruh7y8_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp6yruh7y8_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp6yruh7y8_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp6yruh7y8_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp6yruh7y8_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index + 1) % len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmps1kgeh2c_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmps1kgeh2c_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmps1kgeh2c_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmps1kgeh2c_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmps1kgeh2c_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"numbers must be at least length 2\")\n    }\n    \n    min_distance := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        distance := numbers[i] - numbers[i-1]\n        if distance < min_distance {\n            min_distance = distance\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpxnijbwc4_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpxnijbwc4_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpxnijbwc4_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpxnijbwc4_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := numbers[0] - numbers[1]\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            result = []interface{}{numbers[i-1], numbers[i]}\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpvw5h0zs3_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpvw5h0zs3_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpvw5h0zs3_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpvw5h0zs3_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpvw5h0zs3_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    for i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_pair = append(closest_pair, numbers[i])\n                closest_pair = append(closest_pair, numbers[j])\n            } else {\n                closest_pair = append(closest_pair, numbers[j])\n                closest_pair = append(closest_pair, numbers[i])\n            }\n        }\n    }\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpo07lxuvl_test.go:47: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=3.9) %!s(float64=5) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpo07lxuvl_test.go:47: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=5.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=2) %!s(float64=5.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=4) %!s(float64=5.9) %!s(float64=5) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpo07lxuvl_test.go:47: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=3) %!s(float64=5) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpo07lxuvl_test.go:47: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(fl",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i, number := range numbers {\n        if i == 0 {\n            min = number\n            max = number\n            min_index = i\n            max_index = i\n        } else {\n            if number < min {\n                min = number\n                min_index = i\n            }\n            if number > max {\n                max = number\n                max_index = i\n            }\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[max_index])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmptmpwp86a_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmptmpwp86a_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmptmpwp86a_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmptmpwp86a_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmptmpwp86a_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var min_diff float64\n    var max_diff float64\n    \n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min_number = numbers[i]\n            max_number = numbers[i]\n            min_index = i\n            max_index = i\n            min_diff = numbers[i] - numbers[i]\n            max_diff = numbers[i] - numbers[i]\n        } else {\n            if numbers[i] < min_number {\n                min_number = numbers[i]\n                min_index = i\n                min_diff = numbers[i] - numbers[i]\n            } else if numbers[i] > max_number {\n                max_number = numbers[i]\n                max_index = i\n                max_diff = numbers[i] - numbers[i]\n            }\n        }\n    }\n    \n    closest_numbers = []interface{}{min_number, max_number}\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_ykr1t4k_test.go:18:9: min_index declared but not used\n/tmp/tmp_ykr1t4k_test.go:19:9: max_index declared but not used\n/tmp/tmp_ykr1t4k_test.go:20:9: min_diff declared but not used\n/tmp/tmp_ykr1t4k_test.go:21:9: max_diff declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64\n    var min_index int\n    var max float64\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpmvl4nmcu_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpmvl4nmcu_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpmvl4nmcu_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpmvl4nmcu_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpmvl4nmcu_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[max_index])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpw7xmq1mp_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpw7xmq1mp_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpw7xmq1mp_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpw7xmq1mp_test.go:52: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpw7xmq1mp_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    var min_value float64 = numbers[0]\n    var max_value float64 = numbers[0]\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] == min_value {\n            closest_pair = append(closest_pair, numbers[i])\n        }\n        if numbers[i] == max_value {\n            closest_pair = append(closest_pair, numbers[i])\n        }\n    }\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp6pm511cj_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp6pm511cj_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp6pm511cj_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp6pm511cj_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp6pm511cj_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    for i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_pair = append(closest_pair, numbers[i])\n                closest_pair = append(closest_pair, numbers[j])\n            } else if numbers[i] > numbers[j] {\n                closest_pair = append(closest_pair, numbers[j])\n                closest_pair = append(closest_pair, numbers[i])\n            }\n        }\n    }\n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx_qg89md_test.go:47: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=3.9) %!s(float64=5) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx_qg89md_test.go:47: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=5.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=2) %!s(float64=5.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=4) %!s(float64=5.9) %!s(float64=5) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx_qg89md_test.go:47: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=3) %!s(float64=5) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx_qg89md_test.go:47: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(fl",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    var min float64\n    var min_index int\n    var max float64\n    var max_index int\n\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n            max_index = i\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpkhrbbdda_test.go:55: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpkhrbbdda_test.go:55: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpkhrbbdda_test.go:55: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpkhrbbdda_test.go:55: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpkhrbbdda_test.go:55: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[min_index+1])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\npanic: runtime error: index out of range [6] with length 6 [recovered]\n\tpanic: runtime error: index out of range [6] with length 6\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.find_closest_elements(0xc0000b8df0, 0x6, 0x6, 0x4cd164, 0x0, 0x58a65f)\n\t/tmp/tmpgh7b40j7_test.go:29 +0x256\ncommand-line-arguments_test.TestFind_Closest_Elements(0xc000001380)\n\t/tmp/tmpgh7b40j7_test.go:40 +0xe2\ntesting.tRunner(0xc000001380, 0x54f210)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[min_index+1])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\npanic: runtime error: index out of range [6] with length 6 [recovered]\n\tpanic: runtime error: index out of range [6] with length 6\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.find_closest_elements(0xc0000b8df0, 0x6, 0x6, 0x4cd164, 0x0, 0x58a65f)\n\t/tmp/tmpgh7b40j7_test.go:29 +0x256\ncommand-line-arguments_test.TestFind_Closest_Elements(0xc000001380)\n\t/tmp/tmpgh7b40j7_test.go:40 +0xe2\ntesting.tRunner(0xc000001380, 0x54f210)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var closest_numbers []interface{} = []interface{}{}\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            closest_numbers = append(closest_numbers, number)\n        }\n        if number == max {\n            closest_numbers = append(closest_numbers, number)\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpmle9o0n__test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpmle9o0n__test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpmle9o0n__test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpmle9o0n__test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpmle9o0n__test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var result []interface{} = []interface{}{}\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4iozjwy8_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4iozjwy8_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min_number, max_number float64\n    var min_index, max_index int\n    var result []interface{}\n\n    if len(numbers) < 2 {\n        panic(\"The supplied list of numbers must be at least two.\")\n    }\n\n    min_number = numbers[0]\n    max_number = numbers[0]\n    min_index = 0\n    max_index = 0\n\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n\n    result = []interface{}{min_number, max_number}\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphnh3v7kz_test.go:16:9: min_index declared but not used\n/tmp/tmphnh3v7kz_test.go:16:20: max_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n\n    return []interface{}{numbers[min_index], numbers[(min_index + 1) % len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp1n2q7htq_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp1n2q7htq_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp1n2q7htq_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp1n2q7htq_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp1n2q7htq_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] > numbers[j] {\n                result = append(result, numbers[i])\n                result = append(result, numbers[j])\n                return result\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=3.9) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=5.9) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=3) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=3) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp_xex45mg_test.go:45: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2) %!s(float64=2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpx2ob3wnf_test.go:36: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    \n    if len(numbers) < 2 {\n        return closest_numbers\n    }\n    \n    min_value := numbers[0]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n            min_index = i\n        }\n    }\n    \n    closest_numbers = append(closest_numbers, min_value)\n    closest_numbers = append(closest_numbers, numbers[min_index])\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpv04_y8iv_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpv04_y8iv_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpv04_y8iv_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpv04_y8iv_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpv04_y8iv_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index+1)%len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4iozjwy8_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := math.MaxFloat64\n    min_diff_index := 0\n    min_diff_number := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[0]\n        if diff < min_diff {\n            min_diff = diff\n            min_diff_index = i\n            min_diff_number = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_diff_number, numbers[min_diff_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3cjuhniz_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_pair []interface{}\n    \n    for i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                closest_pair = append(closest_pair, numbers[i])\n                closest_pair = append(closest_pair, numbers[j])\n            } else {\n                closest_pair = append(closest_pair, numbers[j])\n                closest_pair = append(closest_pair, numbers[i])\n            }\n        }\n    }\n    \n    return closest_pair\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp515m0sav_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=3.9) %!s(float64=5) %!s(float64=2.2) %!s(float64=3.9) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp515m0sav_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=5.9) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=2) %!s(float64=5.9) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=4) %!s(float64=5.9) %!s(float64=5) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp515m0sav_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2.2) %!s(float64=2) %!s(float64=3) %!s(float64=2) %!s(float64=4) %!s(float64=2) %!s(float64=5) %!s(float64=2) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=3) %!s(float64=5) %!s(float64=2.2) %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2.2) %!s(float64=4) %!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp515m0sav_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2) %!s(float64=1) %!s(float64=3) %!s(float64=1) %!s(float64=4) %!s(float64=1) %!s(float64=5) %!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3) %!s(fl",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[(min_index+1)%len(numbers)]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpxz6zlc_v_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_number float64\n    var max_number float64\n    var min_index int\n    var max_index int\n    var min_diff float64\n    var max_diff float64\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff || min_diff == 0 {\n                min_diff = diff\n                min_number = numbers[i]\n                min_index = i\n            }\n            if diff > max_diff || max_diff == 0 {\n                max_diff = diff\n                max_number = numbers[i]\n                max_index = i\n            }\n        }\n    }\n    \n    closest_numbers = []interface{}{min_number, max_number}\n    \n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn67f0ok5_test.go:18:9: min_index declared but not used\n/tmp/tmpn67f0ok5_test.go:19:9: max_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min = numbers[i]\n            max = numbers[i]\n            min_index = i\n            max_index = i\n        } else {\n            if numbers[i] < min {\n                min = numbers[i]\n                min_index = i\n            }\n            if numbers[i] > max {\n                max = numbers[i]\n                max_index = i\n            }\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[max_index])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpm6qql6s6_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64\n    var min_index int\n    var max_index int\n    var max_distance float64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[i] - numbers[j]\n            if distance < 0 {\n                distance = -distance\n            }\n            if distance < min_distance || min_distance == 0 {\n                min_distance = distance\n                min_index = i\n                max_index = j\n            }\n        }\n    }\n    closest_numbers = []interface{}{numbers[min_index], numbers[max_index]}\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpccwftc6w_test.go:19:9: max_distance declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    var result []interface{} = []interface{}{}\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphqomjcy4_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := math.MaxFloat64\n    min_index := 0\n    max_index := 0\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            \n            if diff < min_diff {\n                min_diff = diff\n                min_index = i\n                max_index = j\n            }\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpckl30qom_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_diff float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5t8tjm7j_test.go:16:28: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n    \n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < 0 {\n            diff = -diff\n        }\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n    \n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpbyhcqr5k_test.go:55: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff = -diff\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4iozjwy8_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_value float64\n    var max_value float64\n    var min_index int\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            min_value = numbers[i]\n            max_value = numbers[i]\n            min_index = i\n            max_index = i\n        } else {\n            if numbers[i] < min_value {\n                min_value = numbers[i]\n                min_index = i\n            }\n            if numbers[i] > max_value {\n                max_value = numbers[i]\n                max_index = i\n            }\n        }\n    }\n    closest_numbers = []interface{}{min_value, max_value}\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8n17psjr_test.go:18:9: min_index declared but not used\n/tmp/tmp8n17psjr_test.go:19:9: max_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"Input list must be at least length 2\")\n    }\n    \n    min_diff := math.MaxFloat64\n    min_index := 0\n    max_index := 0\n    \n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i != j {\n                diff := numbers[i] - numbers[j]\n                if diff < 0 {\n                    diff *= -1\n                }\n                \n                if diff < min_diff {\n                    min_diff = diff\n                    min_index = i\n                    max_index = j\n                }\n            }\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcqh4vq00_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpal8lgfj7_test.go:17:6: expected '(', found TestFind_Closest_Elements\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        }\n    }\n    result = append(result, numbers[min_index])\n    result = append(result, numbers[min_index+1])\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\npanic: runtime error: index out of range [6] with length 6 [recovered]\n\tpanic: runtime error: index out of range [6] with length 6\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.find_closest_elements(0xc0000b8df0, 0x6, 0x6, 0x4cd164, 0x0, 0x58a65f)\n\t/tmp/tmpgh7b40j7_test.go:29 +0x256\ncommand-line-arguments_test.TestFind_Closest_Elements(0xc000001380)\n\t/tmp/tmpgh7b40j7_test.go:40 +0xe2\ntesting.tRunner(0xc000001380, 0x54f210)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    if len(numbers) < 2 {\n        return result\n    }\n    min_diff := math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff := numbers[i] - numbers[j]\n            if diff < 0 {\n                diff *= -1\n            }\n            if diff < min_diff {\n                min_diff = diff\n                result = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcvmt4bh0_test.go:19:17: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    var min float64 = numbers[0]\n    var max float64 = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min {\n            result = append(result, number)\n        }\n        if number == max {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpc_ueva_x_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i] < numbers[j] {\n                result = append(result, numbers[i])\n                result = append(result, numbers[j])\n                return result\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmp2hoqv29w_test.go:45: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min_number float64\n    var min_index int\n    var max_number float64\n    var max_index int\n    \n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n            min_index = i\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n            max_index = i\n        }\n    }\n    \n    return []interface{}{numbers[min_index], numbers[max_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmphv91ux0p_test.go:51: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmphv91ux0p_test.go:51: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphv91ux0p_test.go:51: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphv91ux0p_test.go:51: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphv91ux0p_test.go:51: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var min float64\n    var max float64\n    var min_index int\n    var max_index int\n    var result []interface{}\n    for i, number := range numbers {\n        if i == 0 {\n            min = number\n            max = number\n            min_index = i\n            max_index = i\n        } else {\n            if number < min {\n                min = number\n                min_index = i\n            }\n            if number > max {\n                max = number\n                max_index = i\n            }\n        }\n    }\n    result = []interface{}{numbers[min_index], numbers[max_index]}\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmplei79q0q_test.go:58: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmplei79q0q_test.go:58: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmplei79q0q_test.go:58: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmplei79q0q_test.go:58: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmplei79q0q_test.go:58: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    min_value := numbers[0]\n\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n            min_value = numbers[i]\n        }\n    }\n\n    return []interface{}{min_value, numbers[min_index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmprqbpp61i_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmprqbpp61i_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=4)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmprqbpp61i_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmprqbpp61i_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var closest_numbers []interface{}\n    var min_distance float64 = math.MaxFloat64\n    for i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(numbers); j++ {\n            if i == j {\n                continue\n            }\n            distance := math.Abs(numbers[i] - numbers[j])\n            if distance < min_distance {\n                min_distance = distance\n                closest_numbers = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n    return closest_numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpknq4nt03_test.go:16:32: undefined: math\n/tmp/tmpknq4nt03_test.go:22:25: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    var result []interface{}\n    \n    if len(numbers) < 2 {\n        return result\n    }\n    \n    min_diff := numbers[0] - numbers[1]\n    min_index := 0\n    max_index := 1\n    \n    for i := 2; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < min_diff {\n            min_diff = diff\n            min_index = i\n        } else if diff > min_diff {\n            max_index = i\n        }\n    }\n    \n    result = append(result, numbers[min_index])\n    result = append(result, numbers[max_index])\n    \n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0 (0.00s)\n        tmpo5fml7va_test.go:58: expected '[%!s(float64=3.9) %!s(float64=4)]', got '[%!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n        tmpo5fml7va_test.go:58: expected '[%!s(float64=5) %!s(float64=5.9)]', got '[%!s(float64=4) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpo5fml7va_test.go:58: expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=2.2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpo5fml7va_test.go:58: expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=2) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpo5fml7va_test.go:58: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}