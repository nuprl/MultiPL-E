{
  "name": "HumanEval_99_closest_integer",
  "language": "go_test.go",
  "prompt": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n",
  "tests": "func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var number float64\n    var sign float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1qrk49bz_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var number float64\n    var is_negative bool\n    var is_float bool\n    var is_int bool\n    var is_zero bool\n    var is_negative_int bool\n    var is_positive_int bool\n    var is_positive_float bool\n    var is_negative_float bool\n    var is_zero_float bool\n    var is_zero_int bool\n    var is_zero_negative_int bool\n    var is_zero_positive_int bool\n    var is_zero_negative_float bool\n    var is_zero_positive_float bool\n    var is_zero_negative_int_float bool\n    var is_zero_positive_int_float bool\n    var is_zero_negative_float_int bool\n    var is_zero_positive_float_int bool\n    var is_zero_negative_int_float_int bool\n    var is_zero_positive_int_float_int bool\n    var is_zero_negative_float_int_int bool\n    var is_zero_positive_float_int_int bool\n    var is_zero_negative_int_float_int_int bool\n    var is_zero_positive_int_float_int_int bool\n    var is_zero_negative_float_int_int_int bool\n    var is_zero_positive_float_int_int_int bool\n    var is_zero_negative_int_float_int_int_int bool\n    var is_zero_positive_int_float_int_int_int bool\n    var is_zero_negative_float_int_int_int_int bool\n    var is_zero_positive_float_int_int_int_int bool\n    var is_zero_negative_int_float_int_int_int_int bool\n    var is_zero_positive_int_float_int_int_int_int bool\n    var is_zero_negative_float_int_int_int_int_int bool\n    var is_zero_positive_float_int_int_int_int_int bool\n    var is_zero_negative_int_float_int_int_int_int_int bool\n    var is_zero_positive\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2rll00re_test.go:60:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi3n_jc32_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    fmt.Sscan(value, &result)\n    if err != nil {\n        panic(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpgqte_hde_test.go:48: expected '%!s(int=15)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpgqte_hde_test.go:48: expected '%!s(int=-16)', got '%!s(int=-15)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var i int\n    var j int\n    var diff int\n    var diff_min int\n    var diff_max int\n    var diff_min_sign int\n    var diff_max_sign int\n    var diff_min_sign_sign int\n    var diff_max_sign_sign int\n    var diff_min_sign_sign_sign int\n    var diff_max_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_min_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign int\n    var diff_max_sign_sign_sign_sign_sign_sign_sign_\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpafq3fc8k_test.go:52:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    if number < 0 {\n        number = -number\n    }\n    if number % 1 == 0 {\n        return number\n    }\n    return number + 1\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpuy6qoa3j_test.go:54: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpuy6qoa3j_test.go:54: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpuy6qoa3j_test.go:54: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpuy6qoa3j_test.go:54: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmpuy6qoa3j_test.go:54: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var num int\n    var err error\n    if num, err = fmt.Sscanf(value, \"%d\", &num); err != nil {\n        return 0\n    }\n    if num < 0 {\n        return -1 * closest_integer(-1 * num)\n    }\n    return closest_integer(num)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfyn17gx7_test.go:28:40: cannot use -1 * num (type int) as type string in argument to closest_integer\n/tmp/tmpfyn17gx7_test.go:30:27: cannot use num (type int) as type string in argument to closest_integer\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = strconv.Atoi(value)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10x_5sbh_test.go:25:19: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var number float64\n    var sign float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1axyps9j_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var digits []int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var zz int\n    var zzz int\n    var zzzz int\n    var zzzzz int\n    var zzzzzz int\n    var zzzzzzz int\n    var zzzzzzzz int\n    var zzzzzzzzz int\n    var zzzzzzzzzz int\n    var zzzzzzzzzzz int\n    var zzzzzzzzzzzz int\n    var zzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz int\n    var zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz int\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfeziihew_test.go:74:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscan(value, &number)\n    if err != nil {\n        panic(err)\n    }\n    if number < 0 {\n        number = -number\n    }\n    if number % 1 == 0 {\n        return number\n    }\n    number = number + 0.5\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpowtfr17w_test.go:34:21: constant 0.5 truncated to integer\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpewqv00mo_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\\\"\" + value + \"\\\")\")\n    \n    // Your code here\n    \n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "closest_integer(\"10\")\nclosest_integer(\"14.5\")\nclosest_integer(\"-15.5\")\nclosest_integer(\"15.3\")\nclosest_integer(\"0\")\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp7c65l5ow_test.go:46: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp7c65l5ow_test.go:46: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp7c65l5ow_test.go:46: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp7c65l5ow_test.go:46: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_float float64\n    var num_int_int int\n    var num_float_int float64\n    var num_int_float float64\n    var num_float_float float64\n    var num_int_float_int float64\n    var num_float_int_int float64\n    var num_int_float_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpm35i38g8_test.go:68:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = strconv.Atoi(value)\n    if err != nil {\n        fmt.Println(\"Error: \", err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10q2hch7_test.go:25:19: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    var result int\n    var err error\n    var i int\n    var j int\n    var diff float64\n    var min_diff float64\n    var min_diff_i int\n    var min_diff_j int\n    var min_diff_i_str string\n    var min_diff_j_str string\n    var i_str string\n    var j_str string\n    var i_int int\n    var j_int int\n    var i_float float64\n    var j_float float64\n    var i_str_float float64\n    var j_str_float float64\n    var i_str_float_str string\n    var j_str_float_str string\n    var i_str_float_str_int int\n    var j_str_float_str_int int\n    var i_str_float_str_int_str string\n    var j_str_float_str_int_str string\n    var i_str_float_str_int_str_int int\n    var j_str_float_str_int_str_int int\n    var i_str_float_str_int_str_int_str string\n    var j_str_float_str_int_str_int_str string\n    var i_str_float_str_int_str_int_str_int int\n    var j_str_float_str_int_str_int_str_int int\n    var i_str_float_str_int_str_int_str_int_str string\n    var j_str_float_str_int_str_int_str_int_str string\n    var i_str_float_str_int_str_int_str_int_str_int int\n    var j_str_float_str_int_str_int_str_int_str_int int\n    var i_str_float_str_int_str_int_str_int_str_int_str string\n    var j_str_float_str_int_str_int_str_int_str_int_str string\n    var i_str_float_str_int_\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4c5x08zt_test.go:59:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Printf(\"value: %s\\n\", value)\n    var num float64\n    var int_num int\n    var err error\n    num, err = strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n    int_num = int(num)\n    fmt.Printf(\"int_num: %d\\n\", int_num)\n    return int_num\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0ysvv9so_test.go:26:16: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var number float64\n    var sign float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1axyps9j_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    fmt.Sscan(value, &result)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmph8xxpqo0_test.go:48: expected '%!s(int=15)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmph8xxpqo0_test.go:48: expected '%!s(int=-16)', got '%!s(int=-15)'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var digits []int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa3agynef_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var i int\n    var j int\n    var diff int\n    var closest int\n    var closest_diff int\n    var closest_sign int\n    var closest_i int\n    var closest_j int\n    var closest_diff_sign int\n    var closest_diff_i int\n    var closest_diff_j int\n    var closest_diff_diff int\n    var closest_diff_closest int\n    var closest_diff_closest_sign int\n    var closest_diff_closest_i int\n    var closest_diff_closest_j int\n    var closest_diff_closest_diff int\n    var closest_diff_closest_closest int\n    var closest_diff_closest_closest_sign int\n    var closest_diff_closest_closest_i int\n    var closest_diff_closest_closest_j int\n    var closest_diff_closest_closest_diff int\n    var closest_diff_closest_closest_closest int\n    var closest_diff_closest_closest_closest_sign int\n    var closest_diff_closest_closest_closest_i int\n    var closest_diff_closest_closest_closest_j int\n    var closest_diff_closest_closest_closest_diff int\n    var closest_diff_closest_closest_closest_closest int\n    var closest_diff_closest_closest_closest_closest_sign int\n    var closest_diff_closest_closest_closest_closest_i int\n    var closest_diff_closest_closest_closest_closest_j int\n    var closest_diff_closest_closest_closest_closest_diff int\n    var closest_diff_closest_closest_closest_closest_closest int\n    var closest_diff_closest_closest_closest_cl\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpon74ik0__test.go:57:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var i int\n    var j int\n    var diff int\n    var closest int\n    var closest_diff int\n    var closest_sign int\n    var closest_i int\n    var closest_j int\n    var closest_diff_sign int\n    var closest_diff_i int\n    var closest_diff_j int\n    var closest_diff_diff int\n    var closest_diff_closest int\n    var closest_diff_closest_sign int\n    var closest_diff_closest_i int\n    var closest_diff_closest_j int\n    var closest_diff_closest_diff int\n    var closest_diff_closest_closest int\n    var closest_diff_closest_closest_sign int\n    var closest_diff_closest_closest_i int\n    var closest_diff_closest_closest_j int\n    var closest_diff_closest_closest_diff int\n    var closest_diff_closest_closest_closest int\n    var closest_diff_closest_closest_closest_sign int\n    var closest_diff_closest_closest_closest_i int\n    var closest_diff_closest_closest_closest_j int\n    var closest_diff_closest_closest_closest_diff int\n    var closest_diff_closest_closest_closest_closest int\n    var closest_diff_closest_closest_closest_closest_sign int\n    var closest_diff_closest_closest_closest_closest_i int\n    var closest_diff_closest_closest_closest_closest_j int\n    var closest_diff_closest_closest_closest_closest_diff int\n    var closest_diff_closest_closest_closest_closest_closest int\n    var closest_diff_closest_closest_closest_cl\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpon74ik0__test.go:57:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var number float64\n    var sign int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpowvsod1k_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_str string\n    var num_int_str string\n    var num_f_str string\n    var num_int_str_int int\n    var num_f_str_int int\n    var num_int_str_f float64\n    var num_f_str_f float64\n    var num_int_str_str string\n    var num_f_str_str string\n    var num_int_str_str_int int\n    var num_f_str_str_int int\n    var num_int_str_str_f float64\n    var num_f_str_str_f float64\n    var num_int_str_str_str string\n    var num_f_str_str_str string\n    var num_int_str_str_str_int int\n    var num_f_str_str_str_int int\n    var num_int_str_str_str_f float64\n    var num_f_str_str_str_f float64\n    var num_int_str_str_str_str string\n    var num_f_str_str_str_str string\n    var num_int_str_str_str_str_int int\n    var num_f_str_str_str_str_int int\n    var num_int_str_str_str_str_f float64\n    var num_f_str_str_str_str_f float64\n    var num_int_str_str_str_str_str string\n    var num_f_str_str_str_str_str string\n    var num_int_str_str_str_str_str_int int\n    var num_f_str_str_str_str_str_int int\n    var num_int_str_str_str_str_str_f float64\n    var num_f_str_str_str_str_str_f float64\n    var num_int_str_str_str_str_str_str string\n    var num_f_str_str_str_str_str\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptizh255g_test.go:59:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = closest_integer_aux(value)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprqj22f03_test.go:25:19: undefined: closest_integer_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    if number < 0 {\n        number = -number\n    }\n    number = number + 0.5\n    number = number / 1\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv7ywepm2_test.go:31:21: constant 0.5 truncated to integer\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Printf(\"closest_integer(%s)\\n\", value)\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "closest_integer(10)\nclosest_integer(14.5)\nclosest_integer(-15.5)\nclosest_integer(15.3)\nclosest_integer(0)\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer called with value:\", value)\n    var num int\n    var err error\n    if num, err = strconv.Atoi(value); err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    fmt.Println(\"num:\", num)\n    return num\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp83arcbg3_test.go:25:19: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = fmt.Sscanf(value, \"%d\", &result)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpzwi23iy4_test.go:50: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpzwi23iy4_test.go:50: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpzwi23iy4_test.go:50: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpzwi23iy4_test.go:50: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmpzwi23iy4_test.go:50: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_int_int int\n    var num_f_int int\n    var num_int_f float64\n    var num_f_f float64\n    var num_int_f_int int\n    var num_f_f_int int\n    var num_int_f_f float64\n    var num_f_f_f float64\n    var num_int_f_f_int int\n    var num_f_f_f_int int\n    var num_int_f_f_f float64\n    var num_f_f_f_f float64\n    var num_int_f_f_f_int int\n    var num_f_f_f_f_int int\n    var num_int_f_f_f_f float64\n    var num_f_f_f_f_f float64\n    var num_int_f_f_f_f_int int\n    var num_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f float64\n    var num_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_int int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6a925uel_test.go:58:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    if number < 0 {\n        number = -number\n    }\n    if number == 0 {\n        return 0\n    }\n    if number == 1 {\n        return 1\n    }\n    if number == 2 {\n        return 2\n    }\n    if number == 3 {\n        return 3\n    }\n    if number == 4 {\n        return 4\n    }\n    if number == 5 {\n        return 5\n    }\n    if number == 6 {\n        return 6\n    }\n    if number == 7 {\n        return 7\n    }\n    if number == 8 {\n        return 8\n    }\n    if number == 9 {\n        return 9\n    }\n    if number == 10 {\n        return 10\n    }\n    if number == 11 {\n        return 11\n    }\n    if number == 12 {\n        return 12\n    }\n    if number == 13 {\n        return 13\n    }\n    if number == 14 {\n        return 14\n    }\n    if number == 15 {\n        return 15\n    }\n    if number == 16 {\n        return 16\n    }\n    if number == 17 {\n        return 17\n    }\n    if number == 18 {\n        return 18\n    }\n    if number == 19 {\n        return 19\n    }\n    if number == 20 {\n        return 20\n    }\n    if number == 21 {\n        return 21\n    }\n    if number == 22 {\n        return 22\n    }\n    if number == 23 {\n        return 23\n    }\n    if number == 24 {\n        return 24\n    }\n    if number == 25 {\n        return 25\n    }\n    if number == 26 {\n        return 26\n    }\n    if number == 27 {\n        return 27\n    }\n    if number == 28 {\n        return 28\n    }\n    if number == 29 {\n        return 29\n    }\n    if number == 30 {\n        return 30\n    }\n    if number == 31 {\n        return 31\n    }\n    if\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpinnz8yt3_test.go:128:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var num int\n    var num_str string\n    var num_int int\n    var num_float float64\n    var num_float_str string\n    var num_float_int int\n    var num_float_float float64\n    var num_float_str_int int\n    var num_float_str_float float64\n    var num_float_str_str string\n    var num_float_str_str_int int\n    var num_float_str_str_float float64\n    var num_float_str_str_str string\n    var num_float_str_str_str_int int\n    var num_float_str_str_str_float float64\n    var num_float_str_str_str_str string\n    var num_float_str_str_str_str_int int\n    var num_float_str_str_str_str_float float64\n    var num_float_str_str_str_str_str string\n    var num_float_str_str_str_str_str_int int\n    var num_float_str_str_str_str_str_float float64\n    var num_float_str_str_str_str_str_str string\n    var num_float_str_str_str_str_str_str_int int\n    var num_float_str_str_str_str_str_str_float float64\n    var num_float_str_str_str_str_str_str_str string\n    var num_float_str_str_str_str_str_str_str_int int\n    var num_float_str_str_str_str_str_str_str_float float64\n    var num_float_str_str_str_str_str_str_str_str string\n    var num_float_str_str_str_str_str_str_str_str_int int\n    var num_float_str_str_str_str_str_str_str_str_float float64\n    var num_float_str_str_str_str_str_str_str_str_str string\n    var num_float_str\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpej26f0qe_test.go:55:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "closest_integer( 10 )\nclosest_integer( 14.5 )\nclosest_integer( -15.5 )\nclosest_integer( 15.3 )\nclosest_integer( 0 )\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpvtu1h1sg_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpvtu1h1sg_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpvtu1h1sg_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpvtu1h1sg_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var i int\n    var j int\n    var diff float64\n    var diff_int float64\n    var diff_int_float float64\n    var diff_int_float_int float64\n    var diff_int_float_int_int float64\n    var diff_int_float_int_int_int float64\n    var diff_int_float_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var diff_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5w7kwnyf_test.go:45:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    \n    // Convert the string to an int\n    var int_value int\n    var err error\n    int_value, err = strconv.Atoi(value)\n    if err != nil {\n        panic(err)\n    }\n    \n    // Get the absolute value of the number\n    abs_value := int_value\n    if int_value < 0 {\n        abs_value = -int_value\n    }\n    \n    // Get the closest integer to the number\n    closest_int := int_value\n    if abs_value - closest_int < closest_int - abs_value {\n        closest_int = closest_int - 1\n    } else {\n        closest_int = closest_int + 1\n    }\n    \n    // Return the closest integer\n    return closest_int\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0lkpsgej_test.go:27:22: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi3n_jc32_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_str string\n    var num_int_str string\n    var num_f_str string\n    var num_int_str_int int\n    var num_f_str_int int\n    var num_int_str_f float64\n    var num_f_str_f float64\n    var num_int_str_f_str string\n    var num_f_str_f_str string\n    var num_int_str_f_str_int int\n    var num_f_str_f_str_int int\n    var num_int_str_f_str_f float64\n    var num_f_str_f_str_f float64\n    var num_int_str_f_str_f_str string\n    var num_f_str_f_str_f_str string\n    var num_int_str_f_str_f_str_int int\n    var num_f_str_f_str_f_str_int int\n    var num_int_str_f_str_f_str_f float64\n    var num_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str string\n    var num_int_str_f_str_f_str_f_str_int int\n    var num_f_str_f_str_f_str_f_str_int int\n    var num_int_str_f_str_f_str_f_str_f float64\n    var num_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str string\n    var num_int_str_f_str_f_str_f_str_f_str_\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp64rtgj84_test.go:54:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_float float64\n    var num_int_str string\n    var num_float_str string\n    var num_int_str_int int\n    var num_float_str_int int\n    var num_int_str_float float64\n    var num_float_str_float float64\n    var num_int_str_float_int int\n    var num_float_str_float_int int\n    var num_int_str_float_float float64\n    var num_float_str_float_float float64\n    var num_int_str_float_float_int int\n    var num_float_str_float_float_int int\n    var num_int_str_float_float_float float64\n    var num_float_str_float_float_float float64\n    var num_int_str_float_float_float_int int\n    var num_float_str_float_float_float_int int\n    var num_int_str_float_float_float_float float64\n    var num_float_str_float_float_float_float float64\n    var num_int_str_float_float_float_float_int int\n    var num_float_str_float_float_float_float_int int\n    var num_int_str_float_float_float_float_float float64\n    var num_float_str_float_float_float_float_float float64\n    var num_int_str_float_float_float_float_float_int int\n    var num_float_str_float_float_float_float_float_int int\n    var num_int_str_float_float_float_float_float_float float64\n    var num_float_str_float_float_float_float_float_float float64\n    var num_int_str_float_float_float_float_float_float_int int\n    var num_float_str_float_float_float_float_float_float_int int\n    var num_int_str_float_float_float_float_float_float_float\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpij3hr7u6_test.go:55:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var num float64\n    var sign int\n    var num_str string\n    var num_int int\n    var num_float float64\n    var num_int_float float64\n    var num_int_float_int float64\n    var num_int_float_int_int float64\n    var num_int_float_int_int_int float64\n    var num_int_float_int_int_int_int float64\n    var num_int_float_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4j23rc6l_test.go:45:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi3n_jc32_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Printf(\"closest_integer(%s)\\n\", value)\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "closest_integer(10)\nclosest_integer(14.5)\nclosest_integer(-15.5)\nclosest_integer(15.3)\nclosest_integer(0)\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_float float64\n    var num_int_int int\n    var num_float_int float64\n    var num_int_float float64\n    var num_float_float float64\n    var num_int_float_int float64\n    var num_float_int_int float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_2ddnkmw_test.go:68:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(number)\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "1\n1\n1\n1\n1\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var number float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp93hzuo25_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer\")\n    fmt.Println(value)\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "closest_integer\n10\nclosest_integer\n14.5\nclosest_integer\n-15.5\nclosest_integer\n15.3\nclosest_integer\n0\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp3fk55dx4_test.go:44: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp3fk55dx4_test.go:44: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp3fk55dx4_test.go:44: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp3fk55dx4_test.go:44: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var err error\n    \n    number, sign, err = closest_integer_parse(value)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return 0\n    }\n    \n    if sign == 1 {\n        return number\n    } else {\n        return -number\n    }\n}\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphi2q5mh9_test.go:26:25: undefined: closest_integer_parse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var number float64\n    var int_number int\n    var int_number_2 int\n    var int_number_3 int\n    var int_number_4 int\n    var int_number_5 int\n    var int_number_6 int\n    var int_number_7 int\n    var int_number_8 int\n    var int_number_9 int\n    var int_number_10 int\n    var int_number_11 int\n    var int_number_12 int\n    var int_number_13 int\n    var int_number_14 int\n    var int_number_15 int\n    var int_number_16 int\n    var int_number_17 int\n    var int_number_18 int\n    var int_number_19 int\n    var int_number_20 int\n    var int_number_21 int\n    var int_number_22 int\n    var int_number_23 int\n    var int_number_24 int\n    var int_number_25 int\n    var int_number_26 int\n    var int_number_27 int\n    var int_number_28 int\n    var int_number_29 int\n    var int_number_30 int\n    var int_number_31 int\n    var int_number_32 int\n    var int_number_33 int\n    var int_number_34 int\n    var int_number_35 int\n    var int_number_36 int\n    var int_number_37 int\n    var int_number_38 int\n    var int_number_39 int\n    var int_number_40 int\n    var int_number_41 int\n    var int_number_42 int\n    var int_number_43 int\n    var int_number_44 int\n    var int_number_45 int\n    var int_number_46 int\n    var int_number_47 int\n    var int_number_48 int\n    var int_number_49 int\n    var int_number_50 int\n    var int_number_51 int\n    var int_number_52 int\n    var int_number_53 int\n    var int_number_54 int\n    var int_number_55 int\n    var int\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2aaqbso1_test.go:80:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var num float64\n    var err error\n    \n    num, err = strconv.ParseFloat(value, 64)\n    if err != nil {\n        fmt.Println(\"Error: \", err)\n        return 0\n    }\n    \n    result = int(num)\n    \n    if num - float64(result) == 0 {\n        if num > 0 {\n            result = result + 1\n        } else {\n            result = result - 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqntv55t4_test.go:26:16: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpw4sgkp_p_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_float float64\n    var num_int_float float64\n    var num_int_float_int float64\n    var num_int_float_int_int float64\n    var num_int_float_int_int_int float64\n    var num_int_float_int_int_int_int float64\n    var num_int_float_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7hlnlxds_test.go:44:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_float float64\n    var num_int_int int\n    var num_float_int float64\n    var num_int_float float64\n    var num_float_float float64\n    var num_int_float_int float64\n    var num_float_int_int float64\n    var num_int_float_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float64\n    var num_int_float_float float64\n    var num_float_int_float float64\n    var num_float_float_int float\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpm35i38g8_test.go:68:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var num int\n    var err error\n    if num, err = fmt.Sscanf(value, \"%d\", &num); err != nil {\n        panic(err)\n    }\n    if num == 0 {\n        return 0\n    }\n    if num < 0 {\n        num = -num\n    }\n    if num % 1 == 0 {\n        return num\n    }\n    return num - num % 2\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmptvusslxu_test.go:56: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmptvusslxu_test.go:56: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmptvusslxu_test.go:56: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmptvusslxu_test.go:56: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmptvusslxu_test.go:56: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = closest_integer_aux(value)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    \n    return result\n}\n\n// Auxiliary function that returns the closest integer to the given value\n// using the algorithm described above.\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps0cr0tnc_test.go:25:19: undefined: closest_integer_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n\n    number, _ = fmt.Sscanf(value, \"%d\", &number)\n\n    if number < 0 {\n        sign = -1\n    } else {\n        sign = 1\n    }\n\n    number = sign * number\n\n    if number % 1 == 0 {\n        return number\n    }\n\n    return number - 1\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp5tlylc0f_test.go:59: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp5tlylc0f_test.go:59: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp5tlylc0f_test.go:59: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp5tlylc0f_test.go:59: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmp5tlylc0f_test.go:59: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var number float64\n    var sign int\n\n    number, _ = fmt.Sscanf(value, \"%f\", &number)\n    sign = number < 0 ? -1 : 1\n\n    number = number * sign\n\n    if number - int(number) == 0 {\n        result = int(number)\n    } else {\n        result = int(number) + 1\n    }\n\n    result = result * sign\n\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jm3v72g_test.go:27:23: illegal character U+003F '?'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_int_int int\n    var num_f_int int\n    var num_int_f float64\n    var num_f_f float64\n    var num_int_f_int int\n    var num_f_f_int int\n    var num_int_f_f float64\n    var num_f_f_f float64\n    var num_int_f_f_int int\n    var num_f_f_f_int int\n    var num_int_f_f_f float64\n    var num_f_f_f_f float64\n    var num_int_f_f_f_int int\n    var num_f_f_f_f_int int\n    var num_int_f_f_f_f float64\n    var num_f_f_f_f_f float64\n    var num_int_f_f_f_f_int int\n    var num_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f float64\n    var num_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_int int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6a925uel_test.go:58:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxpzi3w26_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var num int\n    var num_str string\n    var num_int int\n    var num_f float64\n    var num_f_str string\n    var num_f_int int\n    var num_f_f float64\n    var num_f_f_str string\n    var num_f_f_int int\n    var num_f_f_f float64\n    var num_f_f_f_str string\n    var num_f_f_f_int int\n    var num_f_f_f_f float64\n    var num_f_f_f_f_str string\n    var num_f_f_f_f_int int\n    var num_f_f_f_f_f float64\n    var num_f_f_f_f_f_str string\n    var num_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp51pwan2z_test.go:55:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmp6fzen7cq_test.go:48: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_int_f float64\n    var num_int_f_int int\n    var num_int_f_int_f float64\n    var num_int_f_int_f_int int\n    var num_int_f_int_f_int_f float64\n    var num_int_f_int_f_int_f_int int\n    var num_int_f_int_f_int_f_int_f float64\n    var num_int_f_int_f_int_f_int_f_int int\n    var num_int_f_int_f_int_f_int_f_int_f float64\n    var num_int_f_int_f_int_f_int_f_int_f_int int\n    var num_int_f_int_f_int_f_int_f_int_f_int_f float64\n    var num_int_f_int_f_int_f_int_f_int_f_int_f_int int\n    var num_int_f_int_f_int_f_int_f_int_f_int_f_int_f float64\n    var num_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int int\n    var num_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int_f float64\n    var num_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int int\n    var num_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int_f float64\n    var num_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int_f_int int\n    var num_\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgcwjbdof_test.go:45:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var i int\n    var j int\n    var diff float64\n    var diff_int float64\n    var diff_int_float float64\n    var diff_float float64\n    var diff_float_int float64\n    var diff_int_float_int float64\n    var diff_float_int_int float64\n    var diff_int_float_float float64\n    var diff_float_int_float float64\n    var diff_float_float float64\n    var diff_float_float_int float64\n    var diff_float_float_float float64\n    var diff_float_float_float_int float64\n    var diff_float_float_float_float float64\n    var diff_float_float_float_float_int float64\n    var diff_float_float_float_float_float float64\n    var diff_float_float_float_float_float_int float64\n    var diff_float_float_float_float_float_float float64\n    var diff_float_float_float_float_float_float_int float64\n    var diff_float_float_float_float_float_float_float float64\n    var diff_float_float_float_float_float_float_float_int float64\n    var diff_float_float_float_float_float_float_float_float float64\n    var diff_float_float_float_float_float_float_float_float_int float64\n    var diff_float_float_float_float_float_float_float_float_float float64\n    var diff_float_float_float_float_float_float_float_float_float_int float64\n    var diff_float_float_float_float_float_float_float_float_float_float float64\n    var diff_float_float_float_float_float_float_float_float_float_float_int float64\n    var diff_float_float_float_float_float_float_float_float_float_float_float float64\n    var diff_float_float_float_float_float_float_float_float_float_float_float_int float64\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4oueyd16_test.go:56:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var num int\n    var num_str string\n    var num_int int\n    var num_float float64\n    var num_float_int int\n    var num_float_str string\n    var num_float_int_str string\n    var num_float_int_str_int int\n    var num_float_int_str_int_str string\n    var num_float_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp56vny0x8_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var num int\n    var num_str string\n    var num_int int\n    var num_float float64\n    var num_float_str string\n    var num_float_int int\n    var num_float_int_str string\n    var num_float_int_str_int int\n    var num_float_int_str_int_str string\n    var num_float_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy3p9cx5o_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n\n    // If the number is a float, we need to convert it to an integer\n    if value[0] == '-' {\n        sign = -1\n        value = value[1:]\n    } else {\n        sign = 1\n    }\n\n    // If the number is a float, we need to convert it to an integer\n    if value[0] == '.' {\n        number = 0\n        for i := 1; i < len(value); i++ {\n            number = number * 10 + int(value[i] - '0')\n        }\n    } else {\n        number = int(value[0] - '0')\n    }\n\n    // If the number is a float, we need to convert it to an integer\n    if value[len(value) - 1] == '.' {\n        number = number * 10 + 0\n        for i := len(value) - 2; i >= 0; i-- {\n            number = number * 10 + int(value[i] - '0')\n        }\n    } else {\n        number = number * 10 + int(value[len(value) - 1] - '0')\n    }\n\n    // If the number is a float, we need to convert it to an integer\n    if value[len(value) - 2] == '.' {\n        number = number * 10 + 0\n        for i := len(value) - 3; i >= 0; i-- {\n            number = number * 10 + int(value[i] - '0')\n        }\n    } else {\n        number = number * 10 + int(value[len(value) - 2] - '0')\n    }\n\n    // If the number is a float, we need to convert it to an integer\n    if value[len(value) - 3] == '.' {\n        number = number * 10 + 0\n        for i := len(value) - 4; i >= 0; i-- {\n            number = number * 10 + int(value[i] - '0')\n        }\n    } else {\n        number = number * 10 + int(value[len(value) - 3] - '0')\n    }\n\n    // If the number is a float, we need\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpytuc4z9k_test.go:74:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = strconv.Atoi(value)\n    if err != nil {\n        fmt.Println(\"Error: \", err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10q2hch7_test.go:25:19: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var num int\n    var sign int\n    var num_str string\n    var num_int int\n    var num_f float64\n    var num_f_int int\n    var num_f_f float64\n    var num_f_f_int int\n    var num_f_f_f float64\n    var num_f_f_f_int int\n    var num_f_f_f_f float64\n    var num_f_f_f_f_int int\n    var num_f_f_f_f_f float64\n    var num_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz0ex0oum_test.go:51:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var num int\n    var num_str string\n    var num_int int\n    var num_float float64\n    var num_float_int int\n    var num_float_str string\n    var num_float_int_str string\n    var num_float_int_str_int int\n    var num_float_int_str_int_str string\n    var num_float_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_float_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp56vny0x8_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    if number == 0 {\n        return 0\n    }\n    number = number / 2\n    if number > 0 {\n        number = number + 1\n    } else {\n        number = number - 1\n    }\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp9pto7fmd_test.go:57: expected '%!s(int=10)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp9pto7fmd_test.go:57: expected '%!s(int=15)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp9pto7fmd_test.go:57: expected '%!s(int=-16)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp9pto7fmd_test.go:57: expected '%!s(int=15)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmp9pto7fmd_test.go:57: expected '%!s(int=0)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvpyygy96_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpw4sgkp_p_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    return 0\n}\n\n// Test cases\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"14.5\")\n// 15\n// >>> closest_integer(\"-14.5\")\n// -15\n// >>> closest_integer(\"-15.3\")\n// -15\n// >>> closest_integer(\"-10\")\n// -10\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"15.5\")\n// 15\n// >>> closest_integer\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "closest_integer( 10 )\nclosest_integer( 14.5 )\nclosest_integer( -15.5 )\nclosest_integer( 15.3 )\nclosest_integer( 0 )\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp3ejo4mp0_test.go:109: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp3ejo4mp0_test.go:109: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp3ejo4mp0_test.go:109: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp3ejo4mp0_test.go:109: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(number)\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "1\n1\n1\n1\n1\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var i int\n    var j int\n    var k int\n    var digit int\n    var sum int\n    var diff int\n    var diff_sign int\n    var diff_sign_i int\n    var diff_sign_j int\n    var diff_sign_k int\n    var diff_sign_sum int\n    var diff_sign_diff int\n    var diff_sign_diff_sign int\n    var diff_sign_diff_sign_i int\n    var diff_sign_diff_sign_j int\n    var diff_sign_diff_sign_k int\n    var diff_sign_diff_sign_sum int\n    var diff_sign_diff_sign_diff int\n    var diff_sign_diff_sign_diff_sign int\n    var diff_sign_diff_sign_diff_sign_i int\n    var diff_sign_diff_sign_diff_sign_j int\n    var diff_sign_diff_sign_diff_sign_k int\n    var diff_sign_diff_sign_diff_sign_sum int\n    var diff_sign_diff_sign_diff_sign_diff int\n    var diff_sign_diff_sign_diff_sign_diff_sign int\n    var diff_sign_diff_sign_diff_sign_diff_sign_i int\n    var diff_sign_diff_sign_diff_sign_diff_sign_j int\n    var diff_sign_diff_sign_diff_sign_diff_sign_k int\n    var diff_sign_diff_sign_diff_sign_diff_sign_sum int\n    var diff_sign_diff_sign_diff_sign_diff_sign_diff int\n    var diff_sign_diff_sign_diff_sign_diff_sign_diff_sign int\n    var diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_i int\n    var diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_j int\n    var diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_k int\n    var diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa1omdo8d_test.go:58:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer\")\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.Println(\"value:\", value)\n    fmt.\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjz7q1u1z_test.go:62:1: expected selector or type assertion, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var number float64\n    var sign int\n    var is_negative bool\n    var is_float bool\n    var is_int bool\n    var is_zero bool\n    var is_positive bool\n    var is_negative_float bool\n    var is_positive_float bool\n    var is_negative_int bool\n    var is_positive_int bool\n    var is_zero_int bool\n    var is_zero_float bool\n    var is_zero_int_float bool\n    var is_zero_int_int bool\n    var is_zero_float_float bool\n    var is_zero_float_int bool\n    var is_zero_int_float_float bool\n    var is_zero_int_float_int bool\n    var is_zero_float_int_float bool\n    var is_zero_float_int_int bool\n    var is_zero_int_float_int_float bool\n    var is_zero_int_float_int_int bool\n    var is_zero_float_int_int_float bool\n    var is_zero_float_int_int_int bool\n    var is_zero_int_float_int_int_float bool\n    var is_zero_int_float_int_int_int bool\n    var is_zero_float_int_int_int_int bool\n    var is_zero_int_float_int_int_int_float bool\n    var is_zero_int_float_int_int_int_int bool\n    var is_zero_float_int_int_int_int_int bool\n    var is_zero_int_float_int_int_int_int_float bool\n    var is_zero_int_float_int_int_int_int_int bool\n    var is_zero_float_int_int_int_int_int_int bool\n    var is_zero_int_float_int_int_int_int_int_float bool\n    var is_zero_int_float_int_int_int_int_int_int bool\n    var is_zero_float_int_int_int_int_int_int_int bool\n    var is_zero_int_float_int\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphzx9d4sm_test.go:60:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = closest_integer_aux(value)\n    if err != nil {\n        panic(err)\n    }\n    \n    return result\n}\n\n// Auxiliary function that returns the closest integer to the given value.\n// If the value is equidistant from two integers, round it away from zero.\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjm4hmz0u_test.go:25:19: undefined: closest_integer_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var num int\n    var num_str string\n    var num_int int\n    var num_f float64\n    var num_f_str string\n    var num_f_int int\n    var num_f_f float64\n    var num_f_f_str string\n    var num_f_f_int int\n    var num_f_f_f float64\n    var num_f_f_f_str string\n    var num_f_f_f_int int\n    var num_f_f_f_f float64\n    var num_f_f_f_f_str string\n    var num_f_f_f_f_int int\n    var num_f_f_f_f_f float64\n    var num_f_f_f_f_f_str string\n    var num_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp51pwan2z_test.go:55:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var num int\n    var num_str string\n    var num_int int\n    var num_f float64\n    var num_f_str string\n    var num_f_int int\n    var num_f_f float64\n    var num_f_f_str string\n    var num_f_f_int int\n    var num_f_f_f float64\n    var num_f_f_f_str string\n    var num_f_f_f_int int\n    var num_f_f_f_f float64\n    var num_f_f_f_f_str string\n    var num_f_f_f_f_int int\n    var num_f_f_f_f_f float64\n    var num_f_f_f_f_f_str string\n    var num_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_str string\n    var num_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp51pwan2z_test.go:55:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi3n_jc32_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "closest_integer( 10 )\nclosest_integer( 14.5 )\nclosest_integer( -15.5 )\nclosest_integer( 15.3 )\nclosest_integer( 0 )\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpvtu1h1sg_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpvtu1h1sg_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpvtu1h1sg_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpvtu1h1sg_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_str string\n    var num_int_str string\n    var num_f_str string\n    var num_int_str_f float64\n    var num_f_str_f float64\n    var num_int_str_f_str string\n    var num_f_str_f_str string\n    var num_int_str_f_str_f float64\n    var num_f_str_f_str_f float64\n    var num_int_str_f_str_f_str string\n    var num_f_str_f_str_f_str string\n    var num_int_str_f_str_f_str_f float64\n    var num_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str_f_str_f_str_f_str\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxeyqeubl_test.go:49:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var number float64\n    var sign float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1axyps9j_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    fmt.Sscan(value, &result)\n    \n    if err != nil {\n        panic(err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpl3isimce_test.go:51: expected '%!s(int=15)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpl3isimce_test.go:51: expected '%!s(int=-16)', got '%!s(int=-15)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var sign float64\n\n    num, err = strconv.ParseFloat(value, 64)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return 0\n    }\n    sign = num\n    if num < 0 {\n        sign = -1\n    }\n    result = int(sign * math.Floor(math.Abs(num)))\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprxaa2m8h_test.go:27:16: undefined: strconv\n/tmp/tmprxaa2m8h_test.go:36:25: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var num float64\n    var err error\n    num, err = strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n    result = int(num)\n    if num < 0 {\n        result = result - 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmustlk_m_test.go:25:16: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvpyygy96_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    \n    // Your code here\n    \n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "closest_integer( 10 )\nclosest_integer( 14.5 )\nclosest_integer( -15.5 )\nclosest_integer( 15.3 )\nclosest_integer( 0 )\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpixzsdjr2_test.go:46: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpixzsdjr2_test.go:46: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpixzsdjr2_test.go:46: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpixzsdjr2_test.go:46: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = fmt.Sscan(value, &result)\n    if err != nil {\n        panic(err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var number float64\n    var sign float64\n    var is_negative bool\n    var is_float bool\n    var is_integer bool\n    var is_zero bool\n    var is_positive bool\n    var is_negative_float bool\n    var is_positive_float bool\n    var is_zero_float bool\n    var is_positive_integer bool\n    var is_negative_integer bool\n    var is_zero_integer bool\n    var is_positive_float_integer bool\n    var is_negative_float_integer bool\n    var is_zero_float_integer bool\n    var is_positive_integer_float bool\n    var is_negative_integer_float bool\n    var is_zero_integer_float bool\n    var is_positive_integer_float_integer bool\n    var is_negative_integer_float_integer bool\n    var is_zero_integer_float_integer bool\n    var is_positive_integer_float_integer_float bool\n    var is_negative_integer_float_integer_float bool\n    var is_zero_integer_float_integer_float bool\n    var is_positive_integer_float_integer_float_integer bool\n    var is_negative_integer_float_integer_float_integer bool\n    var is_zero_integer_float_integer_float_integer bool\n    var is_positive_integer_float_integer_float_integer_float bool\n    var is_negative_integer_float_integer_float_integer_float bool\n    var is_zero_integer_float_integer_float_integer_float bool\n    var is_positive_integer_float_integer_float_integer_float_integer bool\n    var is_negative_integer_float_integer_float_integer_float_integer bool\n    var is_zero_integer_float_integer_float_integer_float_integer bool\n    var is_positive_integer_float_integer_float_integer_float_integer_float bool\n    var is_negative_integer_float_integer_float_integer_float_integer_float bool\n    var is_zero_integer_float_integer_float_integer_float_integer_float bool\n    var is_positive_integer_float_integer\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpn7_6i375_test.go:61:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var digit string\n    var num int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe7k7mai6_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpw4sgkp_p_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var num_digits int\n    var num_decimals int\n    var num_int int\n    var num_fraction int\n    var num_fraction_decimals int\n    var num_fraction_int int\n    var num_fraction_decimals_int int\n    var num_fraction_decimals_fraction int\n    var num_fraction_decimals_fraction_int int\n    var num_fraction_decimals_fraction_decimals int\n    var num_fraction_decimals_fraction_decimals_int int\n    var num_fraction_decimals_fraction_decimals_fraction int\n    var num_fraction_decimals_fraction_decimals_fraction_int int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals_int int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals_fraction int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals_fraction_int int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals_fraction_decimals int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals_fraction_decimals_int int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals_fraction_decimals_fraction int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals_fraction_decimals_fraction_int int\n    var num_fraction_decimals_fraction_decimals_fraction_decimals_fraction_decimals_fraction_decimals int\n    var num_fraction_decimals_fraction_decimals_fraction\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsou02bao_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Printf(\"closest_integer(%s)\\n\", value)\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk5s27zvs_test.go:122:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    fmt.Sscan(value, &result)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmph8xxpqo0_test.go:48: expected '%!s(int=15)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmph8xxpqo0_test.go:48: expected '%!s(int=-16)', got '%!s(int=-15)'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_int_int int\n    var num_f_int int\n    var num_int_f float64\n    var num_f_f float64\n    var num_int_f_int int\n    var num_f_f_int int\n    var num_int_f_f float64\n    var num_f_f_f float64\n    var num_int_f_f_int int\n    var num_f_f_f_int int\n    var num_int_f_f_f float64\n    var num_f_f_f_f float64\n    var num_int_f_f_f_int int\n    var num_f_f_f_f_int int\n    var num_int_f_f_f_f float64\n    var num_f_f_f_f_f float64\n    var num_int_f_f_f_f_int int\n    var num_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f float64\n    var num_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_int int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6a925uel_test.go:58:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var num int\n    var err error\n    if num, err = fmt.Sscan(value, &num); err != nil {\n        return 0\n    }\n    if num == 0 {\n        return 0\n    }\n    if num < 0 {\n        num = -num\n    }\n    if num % 1 == 0 {\n        return num\n    }\n    return num + 1\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpshw56vvg_test.go:56: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpshw56vvg_test.go:56: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpshw56vvg_test.go:56: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpshw56vvg_test.go:56: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmpshw56vvg_test.go:56: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    \n    // Convert the string to an integer\n    var int_value int\n    fmt.Sscan(value, &int_value)\n    \n    // If the number is equidistant from two integers, round it away from zero\n    if int_value % 2 == 0 {\n        fmt.Println(\"Rounding away from zero\")\n        return int_value + 1\n    } else {\n        fmt.Println(\"Rounding towards zero\")\n        return int_value\n    }\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "closest_integer( 10 )\nRounding away from zero\nclosest_integer( 14.5 )\nRounding away from zero\nclosest_integer( -15.5 )\nRounding towards zero\nclosest_integer( 15.3 )\nRounding towards zero\nclosest_integer( 0 )\nRounding away from zero\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp71b998is_test.go:55: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp71b998is_test.go:55: expected '%!s(int=-16)', got '%!s(int=-15)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmp71b998is_test.go:55: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvpyygy96_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var sign int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp00hgwmbc_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\\\"\" + value + \"\\\")\")\n    \n    // Convert the string to an integer\n    var num int\n    fmt.Sscan(value, &num)\n    \n    // Get the absolute value of the number\n    abs_num := abs(num)\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num)) {\n        return int(abs_num)\n    }\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num) + 1) {\n        return int(abs_num) + 1\n    }\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num) - 1) {\n        return int(abs_num) - 1\n    }\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num) + 2) {\n        return int(abs_num) + 2\n    }\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num) - 2) {\n        return int(abs_num) - 2\n    }\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num) + 3) {\n        return int(abs_num) + 3\n    }\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num) - 3) {\n        return int(abs_num) - 3\n    }\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num) + 4) {\n        return int(abs_num) + 4\n    }\n    \n    // If the number is equal to an integer, return it\n    if abs_num == abs(int(abs_num) - 4) {\n        return int(abs_num) - 4\n    }\n    \n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyj9jji7j_test.go:77:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Printf(\"value: %s\\n\", value)\n    var num int\n    var err error\n    if num, err = strconv.Atoi(value); err != nil {\n        fmt.Printf(\"Error: %s\\n\", err)\n    }\n    fmt.Printf(\"num: %d\\n\", num)\n    return num\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcp266nwi_test.go:25:19: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    fmt.Println(\"closest_integer called\")\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "closest_integer called\nclosest_integer called\nclosest_integer called\nclosest_integer called\nclosest_integer called\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpz8v5a7_t_test.go:44: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpz8v5a7_t_test.go:44: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpz8v5a7_t_test.go:44: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpz8v5a7_t_test.go:44: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_float float64\n    var num_int_float int\n    var num_float_int float64\n    var num_int_float_int int\n    var num_float_int_int float64\n    var num_int_float_int_int int\n    var num_float_int_int_int float64\n    var num_int_float_int_int_int int\n    var num_float_int_int_int_int float64\n    var num_int_float_int_int_int_int int\n    var num_float_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int int\n    var num_float_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int int\n    var num_float_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int int\n    var num_float_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int float64\n    var num_int_float_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpeigqv24u_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer called with value: \", value)\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "closest_integer called with value:  10\nclosest_integer called with value:  14.5\nclosest_integer called with value:  -15.5\nclosest_integer called with value:  15.3\nclosest_integer called with value:  0\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp2axhvrhf_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp2axhvrhf_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp2axhvrhf_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp2axhvrhf_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = closest_integer_aux(value)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprqj22f03_test.go:25:19: undefined: closest_integer_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxpzi3w26_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxpzi3w26_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var num string\n    var num_int int\n    var num_f float64\n    var num_f_int int\n    var num_f_f float64\n    var num_f_f_int int\n    var num_f_f_f float64\n    var num_f_f_f_int int\n    var num_f_f_f_f float64\n    var num_f_f_f_f_int int\n    var num_f_f_f_f_f float64\n    var num_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_f_\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcv8gbkw7_test.go:50:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var digit string\n    var num int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe7k7mai6_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_str string\n    var num_int_str string\n    var num_f_str string\n    var num_int_str_f float64\n    var num_f_str_f float64\n    var num_int_str_f_str string\n    var num_f_str_f_str string\n    var num_int_str_f_str_f float64\n    var num_f_str_f_str_f float64\n    var num_int_str_f_str_f_str string\n    var num_f_str_f_str_f_str string\n    var num_int_str_f_str_f_str_f float64\n    var num_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str_f_str_f_str_f float64\n    var num_int_str_f_str_f_str_f_str_f_str_f_str_f_str_f_str string\n    var num_f_str_f_str_f_str_f_str_f_str_f_str_f_str_f_str\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxeyqeubl_test.go:49:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = closest_integer_aux(value)\n    if err != nil {\n        panic(err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsxu7j_hm_test.go:25:19: undefined: closest_integer_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps3n5qme8_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    return 0\n}\n\n// Test cases\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"14.5\")\n// 15\n// >>> closest_integer(\"-14.5\")\n// -15\n// >>> closest_integer(\"-15.3\")\n// -15\n// >>> closest_integer(\"-10\")\n// -10\n// >>> closest_integer(\"-15.3\")\n// -15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"-15.3\")\n// -15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"15.3\")\n// 15\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "closest_integer( 10 )\nclosest_integer( 14.5 )\nclosest_integer( -15.5 )\nclosest_integer( 15.3 )\nclosest_integer( 0 )\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmppxzky55p_test.go:112: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmppxzky55p_test.go:112: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmppxzky55p_test.go:112: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmppxzky55p_test.go:112: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvpyygy96_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var number float64\n    var sign int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpowvsod1k_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Printf(\"closest_integer(%s)\\n\", value)\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "closest_integer(10)\nclosest_integer(14.5)\nclosest_integer(-15.5)\nclosest_integer(15.3)\nclosest_integer(0)\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_int_str string\n    var num_int_str_int int\n    var num_int_str_int_str string\n    var num_int_str_int_str_int int\n    var num_int_str_int_str_int_str string\n    var num_int_str_int_str_int_str_int int\n    var num_int_str_int_str_int_str_int_str string\n    var num_int_str_int_str_int_str_int_str_int int\n    var num_int_str_int_str_int_str_int_str_int_str string\n    var num_int_str_int_str_int_str_int_str_int_str_int int\n    var num_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str string\n    var num_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int_str_int int\n    var num_int_str_int_str_int_str_int_str_int\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx4xq4430_test.go:44:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var num float64\n    var err error\n    \n    num, err = strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n    \n    result = int(num)\n    \n    if num < 0 {\n        result = result - 1\n    }\n    \n    if num > 0 {\n        result = result + 1\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp95phit9k_test.go:26:16: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_int_int int\n    var num_f_int int\n    var num_int_f float64\n    var num_f_f float64\n    var num_int_f_int int\n    var num_f_f_int int\n    var num_int_f_f float64\n    var num_f_f_f float64\n    var num_int_f_f_int int\n    var num_f_f_f_int int\n    var num_int_f_f_f float64\n    var num_f_f_f_f float64\n    var num_int_f_f_f_int int\n    var num_f_f_f_f_int int\n    var num_int_f_f_f_f float64\n    var num_f_f_f_f_f float64\n    var num_int_f_f_f_f_int int\n    var num_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f float64\n    var num_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_int int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6a925uel_test.go:58:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    result, err = fmt.Sscan(value, &result)\n    if err != nil {\n        panic(err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374930,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmpn4iklwsa_test.go:50: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_float float64\n    var num_int_int int\n    var num_int_float float64\n    var num_float_int int\n    var num_float_float float64\n    var num_int_int_int int\n    var num_int_int_float float64\n    var num_int_float_int int\n    var num_float_int_int int\n    var num_float_float_int int\n    var num_int_int_int_int int\n    var num_int_int_int_float float64\n    var num_int_int_float_int int\n    var num_int_float_int_int int\n    var num_float_int_int_int int\n    var num_float_float_int_int int\n    var num_int_int_int_int_int int\n    var num_int_int_int_int_float float64\n    var num_int_int_int_float_int int\n    var num_int_float_int_int_int int\n    var num_float_int_int_int_int int\n    var num_float_float_int_int_int int\n    var num_int_int_int_int_int_int int\n    var num_int_int_int_int_int_float float64\n    var num_int_int_int_float_int_int int\n    var num_int_float_int_int_int_int int\n    var num_float_int_int_int_int_int int\n    var num_float_float_int_int_int_int int\n    var num_int_int_int_int_int_int_int int\n    var num_int_int_int_int_int_int_float float64\n    var num_int_int_int_float_int_int_int int\n    var num_int_float_int_int_int_int_int int\n    var num_float_int_int_int_int_int_int int\n    var num_float_float_int_int_int_int_int int\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpusa33zmw_test.go:60:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpw4sgkp_p_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi3n_jc32_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    fmt.Printf(\"closest_integer(%s) = %d\\n\", value, value)\n    return value\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpetfb3l5c_test.go:24:5: cannot use value (type string) as type int in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var int_value int\n    var float_value float64\n    var float_value_int int64\n    var float_value_int_int int64\n    var float_value_int_int_int int64\n    var float_value_int_int_int_int int64\n    var float_value_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int64\n    var float_value_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int64\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz6uft4f2_test.go:45:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(number)\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "1\n1\n1\n1\n1\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmp19y4moj0_test.go:49: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n\n    if value[0] == '-' {\n        sign = -1\n        value = value[1:]\n    } else {\n        sign = 1\n    }\n\n    number, _ = fmt.Sscanf(value, \"%d\", &number)\n\n    if number == 0 {\n        return 0\n    }\n\n    if number < 0 {\n        number = -number\n    }\n\n    if number % 1 == 0 {\n        return number\n    }\n\n    if number % 1 < 0.5 {\n        return number - 1\n    }\n\n    return number + 1\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv6q0ipcc_test.go:46:19: constant 0.5 truncated to integer\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    \n    fmt.Sscan(value, &result)\n    \n    if err != nil {\n        fmt.Println(\"Error: \", err)\n    }\n    \n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp024pw1n5_test.go:51: expected '%!s(int=15)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp024pw1n5_test.go:51: expected '%!s(int=-16)', got '%!s(int=-15)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var err error\n    var num float64\n    var num_int int\n    var num_f float64\n    var num_int_int int\n    var num_f_int int\n    var num_int_f float64\n    var num_f_f float64\n    var num_int_f_int int\n    var num_f_f_int int\n    var num_int_f_f float64\n    var num_f_f_f float64\n    var num_int_f_f_int int\n    var num_f_f_f_int int\n    var num_int_f_f_f float64\n    var num_f_f_f_f float64\n    var num_int_f_f_f_int int\n    var num_f_f_f_f_int int\n    var num_int_f_f_f_f float64\n    var num_f_f_f_f_f float64\n    var num_int_f_f_f_f_int int\n    var num_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f float64\n    var num_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_int int\n    var num_int_f_f_f_f_f_f_f float64\n    var num_f_f_f_f_f_f_f_f float64\n    var num_int_f_f_f_f_f_f_f_int int\n    var num_f_f_f_f_f_f_f_f_int int\n    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374925,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6a925uel_test.go:58:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    \n    // Convert the string to an integer\n    var number int\n    fmt.Sscan(value, &number)\n    \n    // If the number is equidistant from two integers, round it away from zero\n    if number%2 == 0 {\n        return number/2\n    } else {\n        return number/2 + 1\n    }\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "closest_integer( 10 )\nclosest_integer( 14.5 )\nclosest_integer( -15.5 )\nclosest_integer( 15.3 )\nclosest_integer( 0 )\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpm0tacqnp_test.go:53: expected '%!s(int=10)', got '%!s(int=5)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpm0tacqnp_test.go:53: expected '%!s(int=15)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpm0tacqnp_test.go:53: expected '%!s(int=-16)', got '%!s(int=-6)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpm0tacqnp_test.go:53: expected '%!s(int=15)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprpwilcg8_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var sign int\n    var digit string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprpwilcg8_test.go:125:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var result int\n    var number float64\n    var sign float64\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374923,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1axyps9j_test.go:125:6: expected '(', found TestClosest_Integer\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Printf(\"closest_integer(%s)\\n\", value)\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "closest_integer(10)\nclosest_integer(14.5)\nclosest_integer(-15.5)\nclosest_integer(15.3)\nclosest_integer(0)\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpsen6_41i_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    fmt.Println(\"closest_integer\")\n    fmt.Println(value)\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "closest_integer\n10\nclosest_integer\n14.5\nclosest_integer\n-15.5\nclosest_integer\n15.3\nclosest_integer\n0\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpqsnsvkw0_test.go:45: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpqsnsvkw0_test.go:45: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpqsnsvkw0_test.go:45: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpqsnsvkw0_test.go:45: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    // Your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374927,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmphyt_3waq_test.go:43: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var num int\n    var err error\n    if num, err = fmt.Sscanf(value, \"%d\", &num); err != nil {\n        panic(err)\n    }\n    return num\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpstvru2yx_test.go:47: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpstvru2yx_test.go:47: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpstvru2yx_test.go:47: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpstvru2yx_test.go:47: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmpstvru2yx_test.go:47: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fmt.Println(\"closest_integer(\", value, \")\")\n    return 0\n}\n\n// Test cases\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// >>> closest_integer(\"14.5\")\n// 15\n// >>> closest_integer(\"-14.5\")\n// -15\n// >>> closest_integer(\"-15.3\")\n// -15\n// >>> closest_integer(\"-15.5\")\n// -15\n// >>> closest_integer(\"-15.7\")\n// -15\n// >>> closest_integer(\"-15.9\")\n// -15\n// >>> closest_integer(\"-16\")\n// -16\n// >>> closest_integer(\"-16.1\")\n// -16\n// >>> closest_integer(\"-16.5\")\n// -16\n// >>> closest_integer(\"-16.7\")\n// -16\n// >>> closest_integer(\"-16.9\")\n// -16\n// >>> closest_integer(\"-17\")\n// -17\n// >>> closest_integer(\"-17.1\")\n// -17\n// >>> closest_integer(\"-17.5\")\n// -17\n// >>> closest_integer(\"-17.7\")\n// -17\n// >>> closest_integer(\"-17.9\")\n// -17\n// >>> closest_integer(\"-18\")\n// -18\n// >>> closest_integer(\"-18.1\")\n// -18\n// >>> closest_integer(\"-18.5\")\n// -18\n// >>> closest_integer(\"-18.7\")\n// -18\n// >>> closest_integer(\"-18.9\")\n// -18\n// >>> closest_integer(\"-19\")\n// -19\n// >>> closest_integer(\"-19.1\")\n// -19\n// >>> closest_integer(\"-19.5\")\n// -19\n// >>> closest_integer(\"-19.7\")\n// -19\n// >>> closest_integer(\"-19.9\")\n// -19\n// >>> closest_integer(\"-20\")\n// -20\n// >>> closest_integer(\"-20.1\")\n// -20\n// >>> closest_integer(\"-20.5\")\n// -20\n// >>> closest\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "closest_integer( 10 )\nclosest_integer( 14.5 )\nclosest_integer( -15.5 )\nclosest_integer( 15.3 )\nclosest_integer( 0 )\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpgkbaybnd_test.go:107: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpgkbaybnd_test.go:107: expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpgkbaybnd_test.go:107: expected '%!s(int=-16)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpgkbaybnd_test.go:107: expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var number int\n    var err error\n    number, err = fmt.Sscanf(value, \"%d\", &number)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"number: %d\\n\", number)\n    return number\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "number: 1\nnumber: 1\nnumber: 1\nnumber: 1\nnumber: 1\n--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0 (0.00s)\n        tmpub3m8tt7_test.go:49: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpub3m8tt7_test.go:49: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpub3m8tt7_test.go:49: expected '%!s(int=-16)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpub3m8tt7_test.go:49: expected '%!s(int=15)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Integer/test_num__4 (0.00s)\n        tmpub3m8tt7_test.go:49: expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}