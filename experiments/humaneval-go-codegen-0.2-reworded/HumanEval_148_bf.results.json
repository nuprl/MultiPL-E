{
  "name": "HumanEval_148_bf",
  "language": "go_test.go",
  "prompt": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n",
  "tests": "func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmppw__femz_test.go:89: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmppw__femz_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Sat\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj140c9md_test.go:58:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 ==\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpm5ol41lo_test.go:69:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpf9qp7tgr_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp626g8ufg_test.go:68:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi8ncj_s9_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" || planet2 == \"Mercury\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" || planet2 == \"Venus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Earth\" || planet2 == \"Earth\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mars\" || planet2 == \"Mars\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Jupiter\" || planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" || planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" || planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Neptune\" || planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = []interface{}{}\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmp6j2e007i_test.go:69: expected '[Saturn Uranus]', got '[Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp6j2e007i_test.go:69: expected '[Venus]', got '[Mercury]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp6j2e007i_test.go:69: expected '[Venus Earth Mars Jupiter Saturn]', got '[Mercury]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp6j2e007i_test.go:69: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmp6j2e007i_test.go:69: expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmp6j2e007i_test.go:69: expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmp6j2e007i_test.go:69: expected '[]', got '[Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpogt_4ote_test.go:55:26: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdpghiant_test.go:61:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvmm_0tqv_test.go:70:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph0on13ww_test.go:58:33: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpl5283alb_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjsao3tip_test.go:70:40: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt0bam7wv_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_hours float64\n    var planet2_orbital_period_in_hours float64\n    var planet1_orbital_radius_in_m float64\n    var planet2_orbital_radius_in_m float64\n    var planet1_orbital_period_in_minutes float64\n    var planet2_orbital_period_in_minutes float64\n    var planet1_orbital_radius_in_mi float64\n    var planet2_orbital_radius_in_mi float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_au float64\n    var planet2_orbital_radius_in_au float64\n    var planet1_orbital_period_in_years float64\n    var planet2_orbital_period_in_years float64\n    var planet1_orbital_radius_in_earth_km float64\n    var planet2_orbital_radius_in_earth_km float64\n    var planet1_orbital_period_in_earth_days float64\n    var planet2_orbital_period_in_earth_days float64\n    var planet1_orbital_radius_in_earth_m float64\n    var planet2_orbital_radius_in_earth_m float64\n    var planet1_orbital_period_in_earth_hours float64\n    var planet2_orbital_period_in_earth_hours float64\n    var planet1_orbital_radius_in_earth_mi float64\n    var planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp016vz5l8_test.go:57:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpogt_4ote_test.go:55:26: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Sat\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2qkg5vqp_test.go:68:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpc5epu0ww_test.go:56:48: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_milliseconds, planet2_orbital_period_in_milliseconds float64\n    var planet1_orbital_period_in_microseconds, planet2_orbital_period_in_microseconds float64\n    var planet1_orbital_period_in_nanoseconds, planet2_orbital_period_in_nanoseconds float64\n    var planet1_orbital_period_in_picoseconds, planet2_orbital_period_in_picoseconds float64\n    var planet1_orbital_period_in_femtoseconds, planet2_orbital_period_in_femtoseconds float64\n    var planet1_orbital_period_in_attoseconds, planet2_orbital_period_in_attoseconds float64\n    var planet1_orbital_period_in_zeptoseconds, planet2_orbital_period_in_zeptoseconds float64\n    var planet1_orbital_period_in_yottaseconds, planet2_orbital_period_in_yottaseconds float64\n    var planet1_orbital_period_in_zettaseconds, planet2_orbital_period_in_zettaseconds float64\n    var planet1_orbital_period_in_exaseconds, planet2_orbital_period_in_exaseconds float64\n    var planet1_orbital_period_in_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2ps7mbq2_test.go:42:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_hours float64\n    var planet2_orbital_period_in_hours float64\n    var planet1_orbital_radius_in_m float64\n    var planet2_orbital_radius_in_m float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_m_per_day float64\n    var planet2_orbital_radius_in_m_per_day float64\n    var planet1_orbital_radius_in_m_per_hour float64\n    var planet2_orbital_radius_in_m_per_hour float64\n    var planet1_orbital_radius_in_m_per_second float64\n    var planet2_orbital_radius_in_m_per_second float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_m_per_day_per_day float64\n    var planet2_orbital_radius_in_m_per_day_per_day float64\n    var planet1_orbital_radius_in_m_per_day_per_hour float64\n    var planet2_orbital_radius_in_m_per_day_per_hour float64\n    var planet1_orbital_radius_in_m_per_day_per_second float64\n    var planet2_orbital_radius_in_m_per_day_per_second float64\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk_zm14ip_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj8npq83z_test.go:80:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Mars\"}\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Mars\"}\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Saturn\"}\n    } else {\n        return []interface{}{\"\"}\n    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpx59yh2am_test.go:77: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpx59yh2am_test.go:77: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpx59yh2am_test.go:77: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Earth Mars]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpx59yh2am_test.go:77: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv0crb1v9_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"J\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmlkebx97_test.go:55:50: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp626g8ufg_test.go:68:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv0crb1v9_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" || planet2 == \"Mercury\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" || planet2 == \"Venus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Earth\" || planet2 == \"Earth\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" || planet2 == \"Mars\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Jupiter\" || planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" || planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Uranus\" || planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Neptune\" || planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpvfpmokvm_test.go:73: expected '[Saturn Uranus]', got '[Jupiter Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpvfpmokvm_test.go:73: expected '[Venus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpvfpmokvm_test.go:73: expected '[Venus Earth Mars Jupiter Saturn]', got '[Mercury Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpvfpmokvm_test.go:73: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpvfpmokvm_test.go:73: expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpvfpmokvm_test.go:73: expected '[]', got '[Earth Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpvfpmokvm_test.go:73: expected '[]', got '[Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfxc9n0vh_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    }\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpowym6e_x_test.go:69:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgoex6s_8_test.go:59:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpw9_e8xdi_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uran\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbqbncgb6_test.go:70:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprs7sny_7_test.go:57:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    \n    if planet1 == \"Mercury\" {\n        planet1_orbit = 0.38709927\n    } else if planet1 == \"Venus\" {\n        planet1_orbit = 0.72333566\n    } else if planet1 == \"Earth\" {\n        planet1_orbit = 1.0\n    } else if planet1 == \"Mars\" {\n        planet1_orbit = 1.5241481\n    } else if planet1 == \"Jupiter\" {\n        planet1_orbit = 5.202887\n    } else if planet1 == \"Saturn\" {\n        planet1_orbit = 9.554798\n    } else if planet1 == \"Uranus\" {\n        planet1_orbit = 19.189164\n    } else if planet1 == \"Neptune\" {\n        planet1_orbit = 30.06982\n    } else {\n        return []interface{}{}\n    }\n    \n    if planet2 == \"Mercury\" {\n        planet2_orbit = 0.38709927\n    } else if planet2 == \"Venus\" {\n        planet2_orbit = 0.72333566\n    } else if planet2 == \"Earth\" {\n        planet2_orbit = 1.0\n    } else if planet2 == \"Mars\" {\n        planet2_orbit = 1.5241481\n    } else if planet2 == \"Jupiter\" {\n        planet2_orbit = 5.202887\n    } else if planet2 == \"Saturn\" {\n        planet2_orbit = 9.554798\n    } else if planet2 == \"Uranus\" {\n        planet2_orbit = 19.189164\n    } else if planet2 == \"Neptune\" {\n        planet2_orbit = 30.06982\n    } else {\n        return []interface{}{}\n    }\n    \n    if planet1_orbit > planet2_orbit {\n        return []interface{}{}\n    }\n    \n    for i := 0; i < 8; i++ {\n        if planet1_orbit > planets[i].(string) {\n            plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1vuwgbwj_test.go:75:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uran\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbqbncgb6_test.go:70:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3_z4x98o_test.go:58:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpogt_4ote_test.go:55:26: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpstb9w46l_test.go:67:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" || planet2 == \"Mercury\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" || planet2 == \"Venus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Earth\" || planet2 == \"Earth\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" || planet2 == \"Mars\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Jupiter\" || planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" || planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Uranus\" || planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Neptune\" || planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpxp1eiojo_test.go:74: expected '[Saturn Uranus]', got '[Jupiter Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpxp1eiojo_test.go:74: expected '[Venus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpxp1eiojo_test.go:74: expected '[Venus Earth Mars Jupiter Saturn]', got '[Mercury Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpxp1eiojo_test.go:74: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpxp1eiojo_test.go:74: expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpxp1eiojo_test.go:74: expected '[]', got '[Earth Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpxp1eiojo_test.go:74: expected '[]', got '[Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = get_orbit(planet1_name)\n    planet2_orbit = get_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_orbit, planet2_orbit = planet2_orbit, planet1_orbit\n        planet1_name, planet2_name = planet2_name, planet1_name\n    }\n    \n    for i := 0; i < 8; i++ {\n        if get_orbit(planet_names[i]) > planet1_orbit && get_orbit(planet_names[i]) < planet2_orbit {\n            planets = append(planets, planet_names[i])\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbuhll6oq_test.go:32:21: undefined: get_orbit\n/tmp/tmpbuhll6oq_test.go:33:21: undefined: get_orbit\n/tmp/tmpbuhll6oq_test.go:41:12: undefined: get_orbit\n/tmp/tmpbuhll6oq_test.go:41:22: undefined: planet_names\n/tmp/tmpbuhll6oq_test.go:41:58: undefined: get_orbit\n/tmp/tmpbuhll6oq_test.go:41:68: undefined: planet_names\n/tmp/tmpbuhll6oq_test.go:42:39: undefined: planet_names\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Saturn Uranus]', got '[Saturn Mercury]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n        planets = append(\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps2bh6gyq_test.go:58:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk998kf3w_test.go:61:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb8zuskhm_test.go:72:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph0w8goa__test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxup5f814_test.go:59:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float_float, planet2_orbital_period_in_days_float_float float64\n    var planet1_orbital_period_in_years_float_float, planet2_orbital_period_in_years_float_float float64\n    var planet1_orbital_period_in_seconds_float_float, planet2_orbital_period_in_seconds_float_float float64\n    var planet1_orbital_period_in_minutes_float_float, planet2_orbital_period_in_minutes\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe52931vz_test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxww3hi8h_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxguill1w_test.go:67:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float_float, planet2_orbital_period_in_days_float_float float64\n    var planet1_orbital_period_in_years_float_float, planet2_orbital_period_in_years_float_float float64\n    var planet1_orbital_period_in_seconds_float_float, planet2_orbital_period_in_seconds_float_float float64\n    var planet1_orbital_period_in_minutes_float_float, planet2_orbital_period_in_minutes\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmuji1ws7_test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet1_name string\n    var planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = bf_orbit(planet1_name)\n    planet2_orbit = bf_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_orbit = bf_orbit(planet2_name)\n        planet2_orbit = bf_orbit(planet1_name)\n    }\n    \n    if planet1_orbit == planet2_orbit {\n        planets = append(planets, planet1_name)\n        planets = append(planets, planet2_name)\n    } else if planet1_orbit < planet2_orbit {\n        for i := planet1_orbit; i <= planet2_orbit; i++ {\n            planets = append(planets, bf_planet(planet1_name, i))\n        }\n    } else {\n        for i := planet2_orbit; i <= planet1_orbit; i++ {\n            planets = append(planets, bf_planet(planet2_name, i))\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8jcvi6vf_test.go:34:21: undefined: bf_orbit\n/tmp/tmp8jcvi6vf_test.go:35:21: undefined: bf_orbit\n/tmp/tmp8jcvi6vf_test.go:38:25: undefined: bf_orbit\n/tmp/tmp8jcvi6vf_test.go:39:25: undefined: bf_orbit\n/tmp/tmp8jcvi6vf_test.go:47:39: undefined: bf_planet\n/tmp/tmp8jcvi6vf_test.go:51:39: undefined: bf_planet\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_2m3i2y4_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3cljx3ek_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mars\" && planet2 == \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdfopf38a_test.go:54:47: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj8npq83z_test.go:80:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet_orbit float64\n    var planet_name string\n    var planet_distance float64\n    var planet_distance_to_sun float64\n    var planet_distance_to_earth float64\n    var planet_distance_to_mercury float64\n    var planet_distance_to_venus float64\n    var planet_distance_to_mars float64\n    var planet_distance_to_jupiter float64\n    var planet_distance_to_saturn float64\n    var planet_distance_to_uranus float64\n    var planet_distance_to_neptune float64\n    \n    planet1_orbit = float64(8.98e14)\n    planet2_orbit = float64(4.87e14)\n    planet_orbit = float64(5.2e11)\n    \n    planet_name = \"Mercury\"\n    planet_distance = float64(0.38e9)\n    planet_distance_to_sun = float64(0.38e9)\n    planet_distance_to_earth = float64(0.38e9)\n    planet_distance_to_mercury = float64(0.38e9)\n    planet_distance_to_venus = float64(0.38e9)\n    planet_distance_to_mars = float64(0.38e9)\n    planet_distance_to_jupiter = float64(0.38e9)\n    planet_distance_to_saturn = float64(0.38e9)\n    planet_distance_to_uranus = float64(0.38e9)\n    planet_distance_to_neptune = float64(0.38e9)\n    \n    if planet1 == planet1_name {\n        planet_distance_to_earth = float64(0.38e9)\n        planet_distance_to_venus = float64(0.38e9)\n        planet_distance_to_mars = float64(0.38e9)\n        planet_distance_to_jupiter = float64(0.38e9\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzhkf9qhs_test.go:61:52: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmput96sb40_test.go:56:30: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4dzqmcpp_test.go:59:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Saturn Uranus]', got '[Saturn Mercury]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppxlami9a_test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp626g8ufg_test.go:68:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpqgt_foj7_test.go:83: expected '[Saturn Uranus]', got '[Saturn Mercury]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpqgt_foj7_test.go:83: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpqgt_foj7_test.go:83: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpqgt_foj7_test.go:83: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpqgt_foj7_test.go:83: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpqgt_foj7_test.go:83: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpqgt_foj7_test.go:83: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Venus\" {\n        planets = append(planets, \"Mars\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__n3qgs5_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Saturn\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2ii8_tpt_test.go:50:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = get_orbit(planet1_name)\n    planet2_orbit = get_orbit(planet2_name)\n    \n    planet1_distance = get_distance(planet1_name)\n    planet2_distance = get_distance(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_orbit, planet2_orbit = planet2_orbit, planet1_orbit\n        planet1_name, planet2_name = planet2_name, planet1_name\n        planet1_distance, planet2_distance = planet2_distance, planet1_distance\n    }\n    \n    if planet1_orbit > planet2_orbit {\n        return planets\n    }\n    \n    if planet1_orbit == planet2_orbit {\n        if planet1_distance > planet2_distance {\n            return planets\n        }\n        \n        return []interface{}{planet1_name, planet2_name}\n    }\n    \n    for i := planet1_orbit; i <= planet2_orbit; i++ {\n        planet := fmt.Sprintf(\"%s\", get_planet(i))\n        planets = append(planets, planet)\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw22806qy_test.go:33:21: undefined: get_orbit\n/tmp/tmpw22806qy_test.go:34:21: undefined: get_orbit\n/tmp/tmpw22806qy_test.go:36:24: undefined: get_distance\n/tmp/tmpw22806qy_test.go:37:24: undefined: get_distance\n/tmp/tmpw22806qy_test.go:58:37: undefined: get_planet\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmp878ybtv0_test.go:65: expected '[Saturn Uranus]', got '[Saturn]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp878ybtv0_test.go:65: expected '[Venus]', got '[Mars]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp878ybtv0_test.go:65: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp878ybtv0_test.go:65: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmp878ybtv0_test.go:65: expected '[]', got '[Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmp878ybtv0_test.go:65: expected '[]', got '[Jupiter]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmp878ybtv0_test.go:65: expected '[]', got '[Saturn]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqdbowfmn_test.go:58:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj4uxucvr_test.go:67:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdtwww_ja_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxguill1w_test.go:67:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph2iv17xn_test.go:57:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = bf_orbit(planet1_name)\n    planet2_orbit = bf_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_distance = bf_distance(planet1_name)\n        planet2_distance = bf_distance(planet2_name)\n        \n        if planet1_distance > planet2_distance {\n            planets = append(planets, planet1_name)\n        }\n        \n        if planet2_orbit > planet1_orbit {\n            planets = append(planets, planet2_name)\n        }\n    } else {\n        planet1_distance = bf_distance(planet1_name)\n        planet2_distance = bf_distance(planet2_name)\n        \n        if planet2_distance > planet1_distance {\n            planets = append(planets, planet2_name)\n        }\n        \n        if planet1_orbit > planet2_orbit {\n            planets = append(planets, planet1_name)\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptz3pmb33_test.go:33:21: undefined: bf_orbit\n/tmp/tmptz3pmb33_test.go:34:21: undefined: bf_orbit\n/tmp/tmptz3pmb33_test.go:37:28: undefined: bf_distance\n/tmp/tmptz3pmb33_test.go:38:28: undefined: bf_distance\n/tmp/tmptz3pmb33_test.go:48:28: undefined: bf_distance\n/tmp/tmptz3pmb33_test.go:49:28: undefined: bf_distance\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcjxx9272_test.go:61:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx1tbb6w9_test.go:69:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpogt_4ote_test.go:55:26: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqzzm4r5z_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = bf_orbit(planet1_name)\n    planet2_orbit = bf_orbit(planet2_name)\n    \n    planet1_distance = bf_distance(planet1_name)\n    planet2_distance = bf_distance(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet2_orbit = bf_orbit(planet2_name)\n        planet2_distance = bf_distance(planet2_name)\n    }\n    \n    if planet1_orbit < planet2_orbit {\n        planet1_orbit = bf_orbit(planet1_name)\n        planet1_distance = bf_distance(planet1_name)\n    }\n    \n    if planet1_distance > planet2_distance {\n        planet2_distance = bf_distance(planet2_name)\n    }\n    \n    if planet1_distance < planet2_distance {\n        planet1_distance = bf_distance(planet1_name)\n    }\n    \n    if planet1_orbit == planet2_orbit {\n        if planet1_distance == planet2_distance {\n            planets = append(planets, planet1_name)\n            planets = append(planets, planet2_name)\n        }\n    } else {\n        if planet1_orbit > planet2_orbit {\n            planets = append(planets, planet1_name)\n            planets = append(planets, planet2_name)\n        } else {\n            planets = append(planets, planet2_name)\n            planets = append(planets, planet1_name)\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppfpwv2rf_test.go:33:21: undefined: bf_orbit\n/tmp/tmppfpwv2rf_test.go:34:21: undefined: bf_orbit\n/tmp/tmppfpwv2rf_test.go:36:24: undefined: bf_distance\n/tmp/tmppfpwv2rf_test.go:37:24: undefined: bf_distance\n/tmp/tmppfpwv2rf_test.go:40:25: undefined: bf_orbit\n/tmp/tmppfpwv2rf_test.go:41:28: undefined: bf_distance\n/tmp/tmppfpwv2rf_test.go:45:25: undefined: bf_orbit\n/tmp/tmppfpwv2rf_test.go:46:28: undefined: bf_distance\n/tmp/tmppfpwv2rf_test.go:50:28: undefined: bf_distance\n/tmp/tmppfpwv2rf_test.go:54:28: undefined: bf_distance\n/tmp/tmppfpwv2rf_test.go:54:28: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmppw__femz_test.go:89: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmppw__femz_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xt06092_test.go:69:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years float64\n    var planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_months float64\n    var planet2_orbital_period_in_months float64\n    var planet1_orbital_period_in_hours float64\n    var planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_minutes float64\n    var planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_milliseconds float64\n    var planet2_orbital_period_in_milliseconds float64\n    var planet1_orbital_period_in_microseconds float64\n    var planet2_orbital_period_in_microseconds float64\n    var planet1_orbital_period_in_nanoseconds float64\n    var planet2_orbital_period_in_nanoseconds float64\n    var planet1_orbital_period_in_picoseconds float64\n    var planet2_orbital_period_in_picoseconds float64\n    var planet1_orbital_period_in_femtoseconds float64\n    var planet2_orbital_period_in_femtoseconds float64\n    var planet1_orbital_period_in_attoseconds float64\n    var planet2_orbital_period_in_attoseconds float64\n    var planet1_orbital_period_in_zeptoseconds float64\n    var planet2_orbital_period_in_zeptoseconds float64\n    var planet1_orbital_period_in_yottaseconds float64\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpl4iy9g6d_test.go:56:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3cljx3ek_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        result = append(result, \"Venus\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mercury\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mercury\")\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mars\")\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mars\")\n    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Earth\")\n    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        result = append(result, \"Earth\")\n    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        result = append(result, \"Mars\")\n    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mars\")\n    }\n    \n    if planet1 ==\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpo1p39d7o_test.go:84:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        result = append(result, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        result = append(result, \"Saturn\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Uranus\")\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp68fxymr6_test.go:72:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_period_in_years float64\n    var planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_hours float64\n    var planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_minutes float64\n    var planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_milliseconds float64\n    var planet2_orbital_period_in_milliseconds float64\n    var planet1_orbital_period_in_microseconds float64\n    var planet2_orbital_period_in_microseconds float64\n    var planet1_orbital_period_in_nanoseconds float64\n    var planet2_orbital_period_in_nanoseconds float64\n    var planet1_orbital_period_in_picoseconds float64\n    var planet2_orbital_period_in_picoseconds float64\n    var planet1_orbital_period_in_femtoseconds float64\n    var planet2_orbital_period_in_femtoseconds float64\n    var planet1_orbital_period_in_attoseconds float64\n    var planet2_orbital_period_in_attoseconds float64\n    var planet1_orbital_period_in_zettaseconds float64\n    var planet2_orbital_period_in_zettaseconds float64\n    var planet1_orbital_period_in_exaseconds float64\n    var planet2_orbital_period_in_exaseconds float64\n    var planet1_orbital_period_in_petase\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphpy38vxw_test.go:54:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet_name string\n    var planet_orbit float64\n    var planet_distance float64\n    var planet_distance_to_sun float64\n    var planet_distance_to_earth float64\n    var planet_distance_to_mercury float64\n    var planet_distance_to_venus float64\n    var planet_distance_to_mars float64\n    var planet_distance_to_jupiter float64\n    var planet_distance_to_saturn float64\n    var planet_distance_to_uranus float64\n    var planet_distance_to_neptune float64\n    var planet_distance_to_pluto float64\n    var planet_distance_to_moon float64\n    var planet_distance_to_earth_moon float64\n    var planet_distance_to_mercury_moon float64\n    var planet_distance_to_venus_moon float64\n    var planet_distance_to_mars_moon float64\n    var planet_distance_to_jupiter_moon float64\n    var planet_distance_to_saturn_moon float64\n    var planet_distance_to_uranus_moon float64\n    var planet_distance_to_neptune_moon float64\n    var planet_distance_to_pluto_moon float64\n    var planet_distance_to_moon float64\n    var planet_distance_to_earth_moon float64\n    var planet_distance_to_mercury_moon float64\n    var planet_distance_to_venus_moon float64\n    var planet_distance_to_mars_moon float64\n    var planet_distance_to_jupiter_moon float64\n    var planet_distance_to_saturn_moon float64\n    var planet_distance_to_uranus_moon float64\n    var planet_distance_to_neptune_moon float64\n    var planet_distance_to_pluto_moon float64\n    var planet_distance_to_moon_moon float64\n    var planet_distance_to_earth_moon_moon float64\n    var planet_distance_to\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptvjj9srs_test.go:63:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfxc9n0vh_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmppw__femz_test.go:89: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmppw__femz_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = get_orbit(planet1_name)\n    planet2_orbit = get_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet2_orbit = get_orbit(planet2_name)\n    }\n    \n    for i := 0; i < 8; i++ {\n        if get_orbit(planet_names[i]) >= planet1_orbit && get_orbit(planet_names[i]) <= planet2_orbit {\n            planets = append(planets, planet_names[i])\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoh6ntggl_test.go:32:21: undefined: get_orbit\n/tmp/tmpoh6ntggl_test.go:33:21: undefined: get_orbit\n/tmp/tmpoh6ntggl_test.go:36:25: undefined: get_orbit\n/tmp/tmpoh6ntggl_test.go:40:12: undefined: get_orbit\n/tmp/tmpoh6ntggl_test.go:40:22: undefined: planet_names\n/tmp/tmpoh6ntggl_test.go:40:59: undefined: get_orbit\n/tmp/tmpoh6ntggl_test.go:40:69: undefined: planet_names\n/tmp/tmpoh6ntggl_test.go:41:39: undefined: planet_names\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmppw__femz_test.go:89: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmppw__femz_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfxc9n0vh_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2xb4gg1y_test.go:66:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Earth\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptq0egxcd_test.go:58:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Neptune\" {\n        return []interface{}\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprhnleg5d_test.go:71:16: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Venus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Nept\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfrmtd64p_test.go:56:48: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpw9_e8xdi_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptrz7c3p0_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpoelb8q0f_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2xb4gg1y_test.go:66:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_in_seconds, planet2_orbital_period_in_days_in_seconds float64\n    var planet1_orbital_period_in_days_in_minutes, planet2_orbital_period_in_days_in_minutes float64\n    var planet1_orbital_period_in_days_in_hours, planet2_orbital_period_in_days_in_hours float64\n    var planet1_orbital_period_in_years_in_seconds, planet2_orbital_period_in_years_in_seconds float64\n    var planet1_orbital_period_in_years_in_minutes, planet2_orbital_period_in_years_in_minutes float64\n    var planet1_orbital_period_in_years_in_hours, planet2_orbital_period_in_years_in_hours float64\n    var planet1_orbital_period_in_seconds_in_minutes, planet2_orbital_period_in_seconds_in_minutes float64\n    var planet1_orbital_period_in_seconds_in_hours, planet2_orbital_period_in_seconds_in_hours float64\n    var planet1_orbital\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6ong3j_5_test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk2aolid2_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb459i38r_test.go:58:50: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets = append(planets, planet1)\n    }\n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets = append(planets, planet2)\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpcjtjb3f1_test.go:55: expected '[Saturn Uranus]', got '[Jupiter Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpcjtjb3f1_test.go:55: expected '[Venus]', got '[Earth Mercury]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcjtjb3f1_test.go:55: expected '[Venus Earth Mars Jupiter Saturn]', got '[Mercury Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpcjtjb3f1_test.go:55: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Neptune Venus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpcjtjb3f1_test.go:55: expected '[]', got '[Earth Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpcjtjb3f1_test.go:55: expected '[]', got '[Mars Earth]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpcjtjb3f1_test.go:55: expected '[]', got '[Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp994iuhej_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2xb4gg1y_test.go:66:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"U\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpaqtjcxcu_test.go:58:50: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Venus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpflf9hfxu_test.go:56:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz3j9kpte_test.go:71:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    } else\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8m8__zzg_test.go:57:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet_orbit float64\n    var planet_name string\n    var planet_distance float64\n    var planet_distance_list []interface{}\n    var planet_distance_list_length int\n    var planet_distance_list_index int\n    var planet_distance_list_index_max int\n    var planet_distance_list_index_min int\n    var planet_distance_list_index_min_max int\n    var planet_distance_list_index_min_min int\n    var planet_distance_list_index_min_max_max int\n    var planet_distance_list_index_min_min_max int\n    var planet_distance_list_index_min_min_max_max int\n    var planet_distance_list_index_min_min_max_min int\n    var planet_distance_list_index_min_min_max_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_min_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_min_min_min_min_max int\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3diaam_k_test.go:53:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfxc9n0vh_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpymbkryvy_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        result = append(result, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        result = append(result, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        result = append(result, \"Earth\")\n    }\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa7jmzyk8_test.go:72:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_index, planet2_index int\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_index, planet2_orbital_period_index int\n    var planet1_orbital_period_value, planet2_orbital_period_value float64\n    var planet1_orbital_period_index_value, planet2_orbital_period_index_value int\n    var planet1_orbital_period_value_value, planet2_orbital_period_value_value float64\n    var planet1_orbital_period_value_index_value, planet2_orbital_period_value_index_value int\n    var planet1_orbital_period_value_value_value, planet2_orbital_period_value_index_value_value float64\n    var planet1_orbital_period_value_index_value_value, planet2_orbital_period_value_index_value_value int\n    var planet1_orbital_period_value_value_value_value, planet2_orbital_period_value_index_value_value_value float64\n    var planet1_orbital_period_value_index_value_value_value, planet2_orbital_period_value_index_value_value_value int\n    var planet1_orbital_period_value_value_value_value_value, planet2_orbital_period_value_index_value_value_value_value float64\n    var planet1_orbital_period_value_index_value_value_value_value, planet2_orbital_period_value_index_value_value_value_value int\n    var planet1_orbital_period_value_value_value_value_value_value, planet2_orbital_period_value_index_value_value_value_value int\n    var planet1_orbital_period_value_index_value_value_value_value_value\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkelamwv2_test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpeiavon2u_test.go:57:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" || planet2 == \"Mercury\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" || planet2 == \"Venus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Earth\" || planet2 == \"Earth\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" || planet2 == \"Mars\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Jupiter\" || planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" || planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Uranus\" || planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Neptune\" || planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpjmdpokc7_test.go:73: expected '[Saturn Uranus]', got '[Jupiter Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpjmdpokc7_test.go:73: expected '[Venus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpjmdpokc7_test.go:73: expected '[Venus Earth Mars Jupiter Saturn]', got '[Mercury Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpjmdpokc7_test.go:73: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpjmdpokc7_test.go:73: expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpjmdpokc7_test.go:73: expected '[]', got '[Earth Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpjmdpokc7_test.go:73: expected '[]', got '[Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Uranus\" {\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplcww5boj_test.go:68:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx3koxq9x_test.go:68:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3vmp28s3_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp25xhdwn6_test.go:57:47: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk2aolid2_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_in_minutes, planet2_orbital_period_in_days_in_minutes float64\n    var planet1_orbital_period_in_days_in_hours, planet2_orbital_period_in_days_in_hours float64\n    var planet1_orbital_period_in_days_in_hours_in_minutes, planet2_orbital_period_in_days_in_hours_in_minutes float64\n    var planet1_orbital_period_in_days_in_hours_in_minutes_in_seconds, planet2_orbital_period_in_days_in_hours_in_minutes_in_seconds float64\n    var planet1_orbital_period_in_days_in_hours_in_minutes_in_seconds_in_minutes, planet2_orbital_period_in_days_in_hours_in_minutes_in_seconds_in_minutes float64\n    var planet1_orbital_period_in_days_in_hours_in_minutes_in_seconds_in_minutes_in_seconds, planet2_orbital_period_in_days_in_hours_in_minutes_in_seconds_in_minutes_in_seconds float64\n    var planet1_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi8mefp5j_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb8ewgu9t_test.go:61:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mars\" {\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi1jds6jj_test.go:67:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Neptune\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa645zs6o_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = get_orbit(planet1_name)\n    planet2_orbit = get_orbit(planet2_name)\n    \n    if planet1_orbit < planet2_orbit {\n        for i := 0; i < len(planets); i++ {\n            if get_orbit(planets[i].(string)) < planet2_orbit {\n                planets = append(planets, planets[i])\n            }\n        }\n    } else {\n        for i := 0; i < len(planets); i++ {\n            if get_orbit(planets[i].(string)) < planet1_orbit {\n                planets = append(planets, planets[i])\n            }\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzqmlbeys_test.go:32:21: undefined: get_orbit\n/tmp/tmpzqmlbeys_test.go:33:21: undefined: get_orbit\n/tmp/tmpzqmlbeys_test.go:37:16: undefined: get_orbit\n/tmp/tmpzqmlbeys_test.go:43:16: undefined: get_orbit\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprevhn7qd_test.go:56:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Saturn Uranus]', got '[Saturn Mercury]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph4ki8gij_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpf586xt8l_test.go:90: expected '[Saturn Uranus]', got '[Saturn Mercury]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpf586xt8l_test.go:90: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpf586xt8l_test.go:90: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpf586xt8l_test.go:90: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpf586xt8l_test.go:90: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpf586xt8l_test.go:90: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpf586xt8l_test.go:90: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfxc9n0vh_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvg5p_oje_test.go:67:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxtfwjifp_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpeiavon2u_test.go:57:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_days_float64 float64\n    var planet2_orbital_period_in_days_float64 float64\n    var planet1_orbital_radius_in_km_float64 float64\n    var planet2_orbital_radius_in_km_float64 float64\n    var planet1_orbital_period_in_days_float64 float64\n    var planet2_orbital_period_in_days_float64 float64\n    var planet1_orbital_radius_in_km_float64 float64\n    var planet2_orbital_radius_in_km_float64 float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6tsgptca_test.go:60:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp53769fai_test.go:57:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3_z4x98o_test.go:58:35: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Saturn Uranus]', got '[Saturn Mercury]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpexacgmri_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpexacgmri_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpyw2_o4ni_test.go:86: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_index, planet2_index int\n    var planet1_distance, planet2_distance float64\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_index = -1\n    planet2_index = -1\n    \n    for i, p := range planets {\n        if p == planet1_name {\n            planet1_index = i\n        }\n        if p == planet2_name {\n            planet2_index = i\n        }\n    }\n    \n    if planet1_index == -1 || planet2_index == -1 {\n        return []interface{}{}\n    }\n    \n    planet1_orbit = planets[planet1_index].(float64)\n    planet2_orbit = planets[planet2_index].(float64)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_orbit, planet2_orbit = planet2_orbit, planet1_orbit\n        planet1_name, planet2_name = planet2_name, planet1_name\n    }\n    \n    planet1_distance = planet1_orbit - sun_distance\n    planet2_distance = planet2_orbit - sun_distance\n    \n    if planet1_distance > planet2_distance {\n        planet1_distance, planet2_distance = planet2_distance, planet1_distance\n        planet1_name, planet2_name = planet2_name, planet1_name\n    }\n    \n    for i := planet1_index + 1; i < len(planets); i++ {\n        if planets[i].(float64) < planet1_orbit {\n            break\n        }\n        \n        if planets[i].(float64) > planet2_orbit {\n            break\n        }\n        \n        planets = append(planets, planets[i])\n    }\n    \n    for i := planet2_index + 1; i < len(planets); i++ {\n        if planets[i].(float64) < planet2_orbit {\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0k3vjtfb_test.go:80:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp626g8ufg_test.go:68:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppusvshg9_test.go:60:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgtv4uv7e_test.go:55:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = bf_orbit(planet1_name)\n    planet2_orbit = bf_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet2_orbit = bf_orbit(planet2_name)\n    }\n    \n    if planet1_orbit < planet2_orbit {\n        planet1_orbit = bf_orbit(planet1_name)\n    }\n    \n    if planet1_orbit == planet2_orbit {\n        planets = append(planets, planet1_name)\n        planets = append(planets, planet2_name)\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn_idl7_c_test.go:32:21: undefined: bf_orbit\n/tmp/tmpn_idl7_c_test.go:33:21: undefined: bf_orbit\n/tmp/tmpn_idl7_c_test.go:36:25: undefined: bf_orbit\n/tmp/tmpn_idl7_c_test.go:40:25: undefined: bf_orbit\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet1_name string\n    var planet2_name string\n    var planet1_distance float64\n    var planet2_distance float64\n    var planet_distance float64\n    var planet_name string\n    var planet_distance_diff float64\n    var planet_distance_diff_abs float64\n    var planet_distance_diff_abs_abs float64\n    var planet_distance_diff_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1k1tlco1_test.go:52:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Neptune\" {\n        return []interface{}\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5ohrteu1_test.go:71:16: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpc0fh6h7r_test.go:68:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years float64\n    var planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_years_float64 float64\n    var planet2_orbital_period_in_years_float64 float64\n    var planet1_orbital_period_in_years_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjcepilu__test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmppw__femz_test.go:89: expected '[Saturn Uranus]', got '[Saturn Jupiter]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmppw__femz_test.go:89: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmppw__femz_test.go:89: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmppw__femz_test.go:89: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Saturn\", \"Uranus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Saturn\", \"Uranus\", \"Neptune\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Saturn\", \"Uranus\", \"Neptune\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Jupiter\", \"Uranus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\", \"Uranus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Jupiter\", \"Uranus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    }\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpeemwfmrf_test.go:65:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets = append(planets, planet1)\n    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets = append(planets, planet2)\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpy_2uqbyd_test.go:57: expected '[Saturn Uranus]', got '[Jupiter Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpy_2uqbyd_test.go:57: expected '[Venus]', got '[Earth Mercury]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpy_2uqbyd_test.go:57: expected '[Venus Earth Mars Jupiter Saturn]', got '[Mercury Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpy_2uqbyd_test.go:57: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Neptune Venus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpy_2uqbyd_test.go:57: expected '[]', got '[Earth Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpy_2uqbyd_test.go:57: expected '[]', got '[Mars Earth]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpy_2uqbyd_test.go:57: expected '[]', got '[Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx3koxq9x_test.go:68:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwubqzfnj_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpd5qp4as1_test.go:48: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_milliseconds, planet2_orbital_period_in_milliseconds float64\n    var planet1_orbital_period_in_microseconds, planet2_orbital_period_in_microseconds float64\n    var planet1_orbital_period_in_nanoseconds, planet2_orbital_period_in_nanoseconds float64\n    var planet1_orbital_period_in_picoseconds, planet2_orbital_period_in_picoseconds float64\n    var planet1_orbital_period_in_femtoseconds, planet2_orbital_period_in_femtoseconds float64\n    var planet1_orbital_period_in_attoseconds, planet2_orbital_period_in_attoseconds float64\n    var planet1_orbital_period_in_zeptoseconds, planet2_orbital_period_in_zeptoseconds float64\n    var planet1_orbital_period_in_yottaseconds, planet2_orbital_period_in_yottaseconds float64\n    var planet1_orbital_period_in_zettaseconds, planet2_orbital_period_in_zettaseconds float64\n    var planet1_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_l1ehm_f_test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // ...\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmp215qepqz_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp215qepqz_test.go:48: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp215qepqz_test.go:48: expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp215qepqz_test.go:48: expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxww3hi8h_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3vmp28s3_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmp6925wfmd_test.go:82: expected '[Saturn Uranus]', got '[Saturn Mercury]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp6925wfmd_test.go:82: expected '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp6925wfmd_test.go:82: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp6925wfmd_test.go:82: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Earth]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmp6925wfmd_test.go:82: expected '[]', got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmp6925wfmd_test.go:82: expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmp6925wfmd_test.go:82: expected '[]', got '[Saturn Mercury]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptrz7c3p0_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu5eut1y2_test.go:58:49: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var result []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        result = []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result = []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        result = []interface{}{\"Saturn\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        result = []interface{}{\"Saturn\", \"Uranus\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mars\" {\n        result = []interface{}{\"Saturn\", \"Uranus\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        result = []interface{}{\"Jupiter\", \"Mercury\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        result = []interface{}{\"Mercury\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        result = []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Mars\" {\n        result = []interface{}{\"Earth\", \"Jupiter\", \"Mercury\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        result = []interface{}{\"Saturn\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        result = []interface{}{\"Venus\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        result = []interface{}{\"Jupiter\", \"Mercury\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Mars\" {\n        result = []interface{}{\"Earth\", \"Jupiter\", \"Mercury\"}\n    } else if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzjf9iitd_test.go:53:26: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\", \"Saturn\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Neptune\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Neptune\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Neptune\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Ne\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1ygvolk9_test.go:61:41: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptrz7c3p0_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3vmp28s3_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    var planet1_index int\n    var planet2_index int\n    var planet1_orbital_period int\n    var planet2_orbital_period int\n    var planet1_orbital_period_in_days int\n    var planet2_orbital_period_in_days int\n    var planet1_orbital_period_in_days_float float64\n    var planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_days_float_float float64\n    var planet2_orbital_period_in_days_float_float float64\n    var planet1_orbital_period_in_days_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float_float_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float_float_float_float_float_float float\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyz358lhw_test.go:49:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Venus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgr_099tp_test.go:57:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx1tbb6w9_test.go:69:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3vmp28s3_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpc5epu0ww_test.go:56:48: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Venus\" {\n        return []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Earth\" {\n        return []interface{}{\"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Mars\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Jupiter\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Saturn\" {\n        return []interface{}{\"Uranus\", \"Neptune\"}\n    } else if planet1 == \"Uranus\" {\n        return []interface{}{\"Neptune\"}\n    } else if planet1 == \"Neptune\" {\n        return []interface{}{\"Jupiter\"}\n    } else {\n        return []interface{}{\"\"}\n    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n        tmpk7gf_mbu_test.go:65: expected '[Saturn Uranus]', got '[Saturn]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpk7gf_mbu_test.go:65: expected '[Venus]', got '[Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpk7gf_mbu_test.go:65: expected '[Venus Earth Mars Jupiter Saturn]', got '[Venus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpk7gf_mbu_test.go:65: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Jupiter]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpk7gf_mbu_test.go:65: expected '[]', got '[Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpk7gf_mbu_test.go:65: expected '[]', got '[Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpk7gf_mbu_test.go:65: expected '[]', got '[Saturn]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 ==\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7yv4ilw8_test.go:57:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_days_float64 float64\n    var planet2_orbital_period_in_days_float64 float64\n    var planet1_orbital_period_in_days_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqqp96oow_test.go:45:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3vmp28s3_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmhxcuve5_test.go:61:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpparcu_dc_test.go:58:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk2aolid2_test.go:60:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8y0qqiop_test.go:65:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcodn6emt_test.go:59:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphuob_fta_test.go:59:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxk5spv8o_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpigxm0aam_test.go:45:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2k5pw48o_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Neptune\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6r1l0wy4_test.go:56:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz3j9kpte_test.go:71:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprevhn7qd_test.go:56:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp626g8ufg_test.go:68:19: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxvvi4_6r_test.go:69:6: expected '(', found TestBf\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}