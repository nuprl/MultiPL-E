{
  "name": "HumanEval_127_intersection",
  "language": "go_test.go",
  "prompt": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n",
  "tests": "func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1, interval2: two intervals\n//  [output] intersection: the intersection of interval1 and interval2\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp3unji45n_test.go:54: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp3unji45n_test.go:54: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpg2qa5wy4_test.go:134: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpg2qa5wy4_test.go:134: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpg2qa5wy4_test.go:134: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpg2qa5wy4_test.go:134: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpg2qa5wy4_test.go:134: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmpg2qa5wy4_test.go:134: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) && interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) && interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) && interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp0m016mcx_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp0m016mcx_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp0m016mcx_test.go:91: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        if interval1[1] == interval2[1] {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_kp47_7w_test.go:33:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmp_kp47_7w_test.go:37:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmp_kp47_7w_test.go:41:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmp_kp47_7w_test.go:45:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < start2 {\n        return \"NO\"\n    }\n    \n    if end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmphf8ejmt5_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmphf8ejmt5_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmphf8ejmt5_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 > start2 && end2 > start1 {\n        return \"YES\"\n    }\n    \n    if end1 == start2 && end2 == start1 {\n        return \"YES\"\n    }\n    \n    if end1 == start2 {\n        return \"YES\"\n    }\n    \n    if end2 == start1 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp68dr1dlz_test.go:92: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp68dr1dlz_test.go:92: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp68dr1dlz_test.go:92: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp68dr1dlz_test.go:92: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8wiv1l5s_test.go:73:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdp9a3ow4_test.go:77:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if start1 < start2 {\n        return \"NO\"\n    }\n    \n    if end1 > end2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpavf96pou_test.go:92: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpavf96pou_test.go:92: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpavf96pou_test.go:92: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.012s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 < end2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start2 < end1 && end2 > end1 {\n        return \"YES\"\n    }\n    \n    if start1 < end2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start2 < end1 && end2 > end1 {\n        return \"YES\"\n    }\n    \n    if start1 < end2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start2 < end1 && end2\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe03s2k37_test.go:105:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpkzpmfya__test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpkzpmfya__test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpkzpmfya__test.go:94: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpkzpmfya__test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnt5658pl_test.go:100:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsijzgk48_test.go:32:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpsijzgk48_test.go:36:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmpsijzgk48_test.go:40:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpsijzgk48_test.go:44:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5f6w4yp0_test.go:52: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp5f6w4yp0_test.go:52: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < start2 {\n        return \"NO\"\n    }\n    \n    if end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        if i >= start2 && i <= end2 {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpabfxte6k_test.go:89: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpabfxte6k_test.go:89: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpabfxte6k_test.go:89: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmpabfxte6k_test.go:89: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && start2 < end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 < end2 {\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdcjo6t1m_test.go:100:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"NO\"\n    }\n    \n    if start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpd150274x_test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpd150274x_test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpd150274x_test.go:110: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        if end1 == end2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        if start1 == start2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpm40u43q2_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpm40u43q2_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpm40u43q2_test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpwagow8dy_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpwagow8dy_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpwagow8dy_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpreebsy4j_test.go:76: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpreebsy4j_test.go:76: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpreebsy4j_test.go:76: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1, interval2: []interface{}\n//  [output] isIntersect: string\n//  [desc] check whether two intervals intersect\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpyyxzrniu_test.go:55: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpyyxzrniu_test.go:55: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5733mohp_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp5733mohp_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp5733mohp_test.go:91: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        interval1[0], interval2[0] = interval2[0], interval1[0]\n    }\n    \n    if interval1[1] > interval2[1] {\n        interval1[1], interval2[1] = interval2[1], interval1[1]\n    }\n    \n    if interval1[0] > interval1[1] || interval2[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval1[1] || interval2[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdt2qi_h1_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpdt2qi_h1_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmpdt2qi_h1_test.go:36:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmpdt2qi_h1_test.go:40:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmpdt2qi_h1_test.go:44:21: invalid operation: interval1[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmpdt2qi_h1_test.go:44:52: invalid operation: interval2[0] > interval2[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpniqlvi7z_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpniqlvi7z_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmpniqlvi7z_test.go:48:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmpniqlvi7z_test.go:52:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmpniqlvi7z_test.go:56:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmpniqlvi7z_test.go:60:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpniqlvi7z_test.go:64:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n/tmp/tmpniqlvi7z_test.go:76:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpniqlvi7z_test.go:80:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) && interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) && interval1[0].(int) == interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374749,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcotcve_v_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374749,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsl5g36z6_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpwems12ku_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpwems12ku_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpwems12ku_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    start1, end1 := interval1[0], interval1[1]\n    start2, end2 := interval2[0], interval2[1]\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkijwgi1m_test.go:32:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpkijwgi1m_test.go:39:15: invalid operation: start1 > end2 (operator > not defined on interface)\n/tmp/tmpkijwgi1m_test.go:39:32: invalid operation: start2 > end1 (operator > not defined on interface)\n/tmp/tmpkijwgi1m_test.go:43:15: invalid operation: start1 <= start2 (operator <= not defined on interface)\n/tmp/tmpkijwgi1m_test.go:43:33: invalid operation: end1 >= end2 (operator >= not defined on interface)\n/tmp/tmpkijwgi1m_test.go:47:15: invalid operation: start1 <= start2 (operator <= not defined on interface)\n/tmp/tmpkijwgi1m_test.go:47:33: invalid operation: end1 < end2 (operator < not defined on interface)\n/tmp/tmpkijwgi1m_test.go:51:15: invalid operation: start1 > start2 (operator > not defined on interface)\n/tmp/tmpkijwgi1m_test.go:51:32: invalid operation: end1 > end2 (operator > not defined on interface)\n/tmp/tmpkijwgi1m_test.go:55:15: invalid operation: start1 > start2 (operator > not defined on interface)\n/tmp/tmpkijwgi1m_test.go:55:15: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 > end2 || end1 < start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        for j := start2; j <= end2; j++ {\n            if i == j {\n                continue\n            }\n            \n            if i > j {\n                return \"NO\"\n            }\n            \n            if i + j > end2 {\n                return \"NO\"\n            }\n        }\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpvjmncjty_test.go:98: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpvjmncjty_test.go:98: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpvjmncjty_test.go:98: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    var i1, i2 int\n    var result string\n    \n    for i1 = interval1[0]; i1 <= interval1[1]; i1++ {\n        for i2 = interval2[0]; i2 <= interval2[1]; i2++ {\n            if i1 == i2 {\n                result = \"YES\"\n                break\n            }\n        }\n        if result != \"YES\" {\n            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vbq1t2m_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmp0vbq1t2m_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmp0vbq1t2m_test.go:39:12: cannot use interval1[0] (type interface {}) as type int in assignment: need type assertion\n/tmp/tmp0vbq1t2m_test.go:39:31: invalid operation: i1 <= interval1[1] (operator <= not defined on interface)\n/tmp/tmp0vbq1t2m_test.go:40:16: cannot use interval2[0] (type interface {}) as type int in assignment: need type assertion\n/tmp/tmp0vbq1t2m_test.go:40:35: invalid operation: i2 <= interval2[1] (operator <= not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 > end2 || end1 < start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        for j := start2; j <= end2; j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpu7m1ytqh_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpu7m1ytqh_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpu7m1ytqh_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n// test\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmplblxb5wu_test.go:53: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmplblxb5wu_test.go:53: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1, interval2: []interface{}\n//  [output] isIntersect: bool\n//  [output] intersection: []interface{}\n//  [output] intersectionLength: int\n//  [output] intersectionLengthIsPrime: bool\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpg70borax_test.go:57: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpg70borax_test.go:57: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpadhrepui_test.go:32:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpadhrepui_test.go:36:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpadhrepui_test.go:40:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmpadhrepui_test.go:44:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp71slfnoy_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp71slfnoy_test.go:91: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpt_r1sar__test.go:70: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpt_r1sar__test.go:70: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpt_r1sar__test.go:70: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxgkhzh2a_test.go:73:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if start2 > start1 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end2 < end1 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end2 - start1 > end1 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end1 - start2 {\n        return \"YES\"\n    }\n    \n    if end2 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp80q_0hc7_test.go:100: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp80q_0hc7_test.go:100: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp80q_0hc7_test.go:100: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1, interval2: two intervals\n//  [output] isIntersect: whether the two intervals intersect\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpnwpdqhec_test.go:54: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpnwpdqhec_test.go:54: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < start2 {\n        return \"NO\"\n    }\n    \n    if end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        if i >= start2 && i <= end2 {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmph5x8g5jg_test.go:89: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmph5x8g5jg_test.go:89: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmph5x8g5jg_test.go:89: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmph5x8g5jg_test.go:89: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbblelz9q_test.go:32:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpbblelz9q_test.go:36:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpbblelz9q_test.go:40:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmpbblelz9q_test.go:44:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmph16l9ok9_test.go:75: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmph16l9ok9_test.go:75: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmph16l9ok9_test.go:75: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1, interval2: []interface{}\n//  [output] isIntersect: string\n//  [desc] check whether the two intervals intersect\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp9fgrm15x_test.go:55: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp9fgrm15x_test.go:55: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6dfp3a63_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmp6dfp3a63_test.go:36:21: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmp6dfp3a63_test.go:52:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmp6dfp3a63_test.go:56:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmp6dfp3a63_test.go:60:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp0wndelfj_test.go:88: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp0wndelfj_test.go:88: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp0wndelfj_test.go:88: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_ma59qb_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpl_ma59qb_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        for j := start2; j <= end2; j++ {\n            if i == j {\n                continue\n            }\n            \n            if i > j {\n                return \"NO\"\n            }\n            \n            if i < j {\n                continue\n            }\n            \n            if i - j == end1 - start1 {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpz1mn9kz7_test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpz1mn9kz7_test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpz1mn9kz7_test.go:110: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 <= start1 && end2 > end1 {\n        return \"NO\"\n    }\n    \n    if start2 <= start1 && end2 < end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5j3drev5_test.go:78: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp5j3drev5_test.go:78: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp5j3drev5_test.go:78: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 + 1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpqpk71v0g_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpqpk71v0g_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpqpk71v0g_test.go:74: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        interval1[0], interval2[0] = interval2[0], interval1[0]\n    }\n    \n    if interval1[1] > interval2[1] {\n        interval1[1], interval2[1] = interval2[1], interval1[1]\n    }\n    \n    if interval1[0] > interval1[1] || interval2[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval1[1] && interval2[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval1[1] {\n        return \"YES\"\n    }\n    \n    if interval2[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptxf1ru6i_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmptxf1ru6i_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmptxf1ru6i_test.go:36:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmptxf1ru6i_test.go:40:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmptxf1ru6i_test.go:44:21: invalid operation: interval1[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmptxf1ru6i_test.go:44:52: invalid operation: interval2[0] > interval2[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start2 < start1 {\n        return \"NO\"\n    }\n    \n    if end2 < end1 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start2 > start1 {\n        return \"NO\"\n    }\n    \n    if end2 < end1 {\n        return \"NO\"\n    }\n    \n    if start1 > start\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfgb_mhjv_test.go:116:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp2n_cx769_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp2n_cx769_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp2n_cx769_test.go:74: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 > start2 && end2 > start1 {\n        return \"YES\"\n    }\n    \n    if end1 == start2 {\n        return \"YES\"\n    }\n    \n    if end2 == start1 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp39nv3rc0_test.go:32:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"YES\"\n    }\n    \n    if start2 > end1 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        return \"YES\"\n    }\n    \n    if end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp4k3c8wkj_test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp4k3c8wkj_test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp4k3c8wkj_test.go:110: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp4k3c8wkj_test.go:110: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    for i := interval1[0].(int); i <= interval1[1].(int); i++ {\n        for j := interval2[0].(int); j <= interval2[1].(int); j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if start1 < start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy5_43e5a_test.go:102: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpy5_43e5a_test.go:102: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpy5_43e5a_test.go:102: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy5_43e5a_test.go:102: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 == start2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 == start2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 == start2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpl_wmfnr1_test.go:118: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpl_wmfnr1_test.go:118: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpl_wmfnr1_test.go:118: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpl_wmfnr1_test.go:118: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    for i := interval1[0].(int); i <= interval1[1].(int); i++ {\n        for j := interval2[0].(int); j <= interval2[1].(int); j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 > start2 && end2 > start1 {\n        return \"YES\"\n    }\n    \n    if end1 == start2 && end2 == start1 {\n        return \"YES\"\n    }\n    \n    if end1 < start2 && end2 > start1 {\n        return \"YES\"\n    }\n    \n    if end1 > start2 && end2 < start1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmphutjqylt_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmphutjqylt_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmphutjqylt_test.go:84: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmphutjqylt_test.go:84: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        } else {\n            return \"YES\"\n        }\n    }\n    \n    if start1 > start2 {\n        if end1 > end2 {\n            return \"NO\"\n        } else {\n            return \"YES\"\n        }\n    }\n    \n    if end1 < end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpsohojx7q_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpsohojx7q_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpsohojx7q_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        interval1[0] = interval1[0] - 1\n    }\n    \n    if interval1[1] < interval2[1] {\n        interval1[1] = interval1[1] + 1\n    }\n    \n    if interval1[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval1[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd0ugvolm_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpd0ugvolm_test.go:36:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmpd0ugvolm_test.go:40:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpd0ugvolm_test.go:41:37: invalid operation: interval1[0] - 1 (mismatched types interface {} and int)\n/tmp/tmpd0ugvolm_test.go:44:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n/tmp/tmpd0ugvolm_test.go:45:37: invalid operation: interval1[1] + 1 (mismatched types interface {} and int)\n/tmp/tmpd0ugvolm_test.go:48:21: invalid operation: interval1[0] > interval1[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdp9a3ow4_test.go:77:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgge5c1bj_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    var start1, end1, start2, end2 int\n    var isIntersect bool\n    \n    start1 = interval1[0].(int)\n    end1 = interval1[1].(int)\n    start2 = interval2[0].(int)\n    end2 = interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 >= start2 && start1 <= end2 {\n        isIntersect = true\n    }\n    \n    if start2 >= start1 && start2 <= end1 {\n        isIntersect = true\n    }\n    \n    if end1 >= start2 && end1 <= end2 {\n        isIntersect = true\n    }\n    \n    if end2 >= start1 && end2 <= end1 {\n        isIntersect = true\n    }\n    \n    if isIntersect {\n        if (end1 - start1) == (end2 - start2) {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpy7zxiw47_test.go:89: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy7zxiw47_test.go:89: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy7zxiw47_test.go:89: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && start2 < end1 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpvbwk34g2_test.go:126: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpvbwk34g2_test.go:126: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpvbwk34g2_test.go:126: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpvbwk34g2_test.go:126: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmpvbwk34g2_test.go:126: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpm7la64o2_test.go:92: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpm7la64o2_test.go:92: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpm7la64o2_test.go:92: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpm7la64o2_test.go:92: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        return \"NO\"\n    }\n    \n    if end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    if start1 < end2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 < start2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpijpr6xl7_test.go:106: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpijpr6xl7_test.go:106: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpijpr6xl7_test.go:106: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8wiv1l5s_test.go:73:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    for i := interval1[0]; i <= interval1[1]; i++ {\n        for j := interval2[0]; j <= interval2[1]; j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphc3n37bs_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmphc3n37bs_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmphc3n37bs_test.go:36:30: invalid operation: i <= interval1[1] (operator <= not defined on interface)\n/tmp/tmphc3n37bs_test.go:36:48: invalid operation: i++ (non-numeric type interface {})\n/tmp/tmphc3n37bs_test.go:37:34: invalid operation: j <= interval2[1] (operator <= not defined on interface)\n/tmp/tmphc3n37bs_test.go:37:52: invalid operation: j++ (non-numeric type interface {})\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if start2 > start1 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end2 < end1 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpbk4v48dn_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpbk4v48dn_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpbk4v48dn_test.go:84: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if start2 > start1 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end2 < end1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpr9gl_e0x_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpr9gl_e0x_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpr9gl_e0x_test.go:84: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1, interval2: []interface{}\n//  [output] isIntersect: bool\n//  [output] intersection: []interface{}\n//  [output] intersectionLength: int\n//  [output] intersectionLengthStr: string\n//  [output] intersectionLengthStr2: string\n//  [output] intersectionLengthStr3: string\n//  [output] intersectionLengthStr4: string\n//  [output] intersectionLengthStr5: string\n//  [output] intersectionLengthStr6: string\n//  [output] intersectionLengthStr7: string\n//  [output] intersectionLengthStr8: string\n//  [output] intersectionLengthStr9: string\n//  [output] intersectionLengthStr10: string\n//  [output] intersectionLengthStr11: string\n//  [output] intersectionLengthStr12: string\n//  [output] intersectionLengthStr13: string\n//  [output] intersectionLengthStr14: string\n//  [output] intersectionLengthStr15: string\n//  [output] intersectionLengthStr16: string\n//  [output] intersectionLengthStr17: string\n//  [output] intersectionLengthStr18: string\n//  [output] intersectionLengthStr19: string\n//  [output] intersectionLengthStr20: string\n//  [output] intersectionLengthStr21: string\n//  [output] intersectionLengthStr22: string\n//  [output] intersectionLengthStr23: string\n//  [output] intersectionLengthStr24: string\n//  [output] intersectionLengthStr25: string\n//  [output] intersectionLengthStr26: string\n//  [output] intersectionLengthStr27: string\n//  [output] intersectionLengthStr28: string\n//  [output] intersectionLengthStr29: string\n//  [output] intersectionLengthStr30: string\n//  [output] intersectionLengthStr31: string\n//  [output] intersectionLengthStr32: string\n//  [output] intersectionLengthStr33: string\n//  [output] intersectionLengthStr34: string\n//  [output] intersectionLengthStr35: string\n//  [output] intersectionLengthStr36: string\n//  [output] intersectionLengthStr37: string\n//  [output]\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpqhmi6hl4_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpqhmi6hl4_test.go:94: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp_h676ag2_test.go:99: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp_h676ag2_test.go:99: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp_h676ag2_test.go:99: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp4q9elf84_test.go:102: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp4q9elf84_test.go:102: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp4q9elf84_test.go:102: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 <= end2 && end1 >= start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpva5ee49k_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpva5ee49k_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpva5ee49k_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__5 (0.00s)\n        tmpva5ee49k_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpva5ee49k_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmpva5ee49k_test.go:74: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    var start1, end1, start2, end2 int\n    \n    start1 = interval1[0].(int)\n    end1 = interval1[1].(int)\n    start2 = interval2[0].(int)\n    end2 = interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        \n        if end1 < end2 {\n            return \"NO\"\n        }\n    }\n    \n    if start1 > start2 {\n        if end1 < end2 {\n            return \"NO\"\n        }\n        \n        if end1 > end2 {\n            return \"YES\"\n        }\n    }\n    \n    if end1 < end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        if start1 < start2 {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpupl4vl_5_test.go:104: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpupl4vl_5_test.go:104: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpupl4vl_5_test.go:104: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpb60xv2dj_test.go:88: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpb60xv2dj_test.go:88: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpb60xv2dj_test.go:88: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpb60xv2dj_test.go:88: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpo7ocq_uw_test.go:123: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpo7ocq_uw_test.go:123: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpo7ocq_uw_test.go:123: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpo7ocq_uw_test.go:123: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 < end2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 < start2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if start1 < start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if end1 > end2 {\n        if start1 < start2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpac9utnv__test.go:98: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpac9utnv__test.go:98: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpac9utnv__test.go:98: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpac9utnv__test.go:98: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpc1mska3i_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpc1mska3i_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpc1mska3i_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 < end2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpiewvgp8o_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpiewvgp8o_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpiewvgp8o_test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmprmu9w7q8_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmprmu9w7q8_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmprmu9w7q8_test.go:86: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmprmu9w7q8_test.go:86: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    var start1, end1, start2, end2 int\n    \n    start1, end1 = interval1[0].(int), interval1[1].(int)\n    start2, end2 = interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"NO\"\n    }\n    \n    if start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"NO\"\n    }\n    \n    if start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"NO\"\n    }\n    \n    if start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2896w7yy_test.go:107:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpwtgupd_t_test.go:92: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpwtgupd_t_test.go:92: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpwtgupd_t_test.go:92: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if start2 > start1 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end2 < end1 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end2 - start2 > end1 - start1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end2 - start2 == end1 - start1 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end2 - start2 > end1 - start1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end2 - start2 == end1 - start1 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi7_wh831_test.go:98:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 < end2 {\n            return \"YES\"\n        }\n    } else if start1 > start2 {\n        if end1 < end2 {\n            return \"NO\"\n        }\n    }\n    \n    if end1 == end2 {\n        if start1 < start2 {\n            return \"YES\"\n        }\n    } else if end1 < end2 {\n        if start1 < start2 {\n            return \"NO\"\n        }\n    }\n    \n    if start1 == start2 {\n        if end1 < end2 {\n            return \"YES\"\n        }\n    } else if start1 > start2 {\n        if end1 < end2 {\n            return \"NO\"\n        }\n    }\n    \n    if end1 == end2 {\n        if start1 < start2 {\n            return \"YES\"\n        }\n    } else if end1 < end2 {\n        if start1 < start2 {\n            return \"NO\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5e6t173w_test.go:111: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp5e6t173w_test.go:111: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp5e6t173w_test.go:111: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpkjql8nof_test.go:86: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpkjql8nof_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpkjql8nof_test.go:86: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpkjql8nof_test.go:86: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmpkjql8nof_test.go:86: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpapu_txjj_test.go:98: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpapu_txjj_test.go:98: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpapu_txjj_test.go:98: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0] > interval2[0] || interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    if interval1[0] == interval2[0] {\n        if interval1[1] == interval2[1] {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppdaqpbq7_test.go:32:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmppdaqpbq7_test.go:32:52: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n/tmp/tmppdaqpbq7_test.go:38:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmppdaqpbq7_test.go:41:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmprcb_k45c_test.go:87: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmprcb_k45c_test.go:87: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmprcb_k45c_test.go:87: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 <= start1 && end2 > end1 {\n        return \"NO\"\n    }\n    \n    if start2 <= start1 && end2 < end1 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 > start1 && end2 > end1 {\n        return \"NO\"\n    }\n    \n    if start2 > start1 && end2 < end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp4igl4p48_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp4igl4p48_test.go:94: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp4igl4p48_test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < start2 {\n        return \"NO\"\n    }\n    \n    if end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1 + 1; i < end1; i++ {\n        if end1 - i == end2 - start2 {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp114cb5w2_test.go:93: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp114cb5w2_test.go:93: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp114cb5w2_test.go:93: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval1[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3tukvfzl_test.go:33:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmp3tukvfzl_test.go:37:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmp3tukvfzl_test.go:41:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmp3tukvfzl_test.go:45:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpohyo5m_0_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpohyo5m_0_test.go:86: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpohyo5m_0_test.go:86: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        for j := start2; j <= end2; j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpzcgxgojq_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpzcgxgojq_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpzcgxgojq_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1, interval2: []interface{}\n//  [output] isIntersect: string\n//  [desc] check if two intervals intersect\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpc3_1w8j1_test.go:55: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpc3_1w8j1_test.go:55: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1: []interface{}\n//  [input] interval2: []interface{}\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect: string\n//  [output] isIntersect:\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmphy4jz250_test.go:97: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmphy4jz250_test.go:97: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5733mohp_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp5733mohp_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp5733mohp_test.go:91: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        if end1 < end2 {\n            return \"YES\"\n        }\n    }\n    \n    if start1 > start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        if end1 < end2 {\n            return \"YES\"\n        }\n    }\n    \n    if end1 > end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        if start1 < start2 {\n            return \"YES\"\n        }\n    }\n    \n    if end1 < end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        \n        if start1 < start2 {\n            return \"NO\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp84hzsx8__test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp84hzsx8__test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp84hzsx8__test.go:110: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp84hzsx8__test.go:110: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy4zxz0dk_test.go:106:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start2 > start1 || end2 < end1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for start1 <= end1 && start2 <= end2 {\n        if end1 - start1 == end2 - start2 {\n            return \"YES\"\n        }\n        \n        if end1 - start1 > end2 - start2 {\n            return \"NO\"\n        }\n        \n        if end1 - start1 < end2 - start2 {\n            start1++\n        } else {\n            start2++\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmphk5q607v_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmphk5q607v_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmphk5q607v_test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start2 <= start1 && end2 >= end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpsjn3gyp9_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpsjn3gyp9_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpsjn3gyp9_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmpsjn3gyp9_test.go:74: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3pclp85v_test.go:32:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmp3pclp85v_test.go:36:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmp3pclp85v_test.go:40:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmp3pclp85v_test.go:44:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    for i := interval1[0].(int); i <= interval1[1].(int); i++ {\n        for j := interval2[0].(int); j <= interval2[1].(int); j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp020_blbl_test.go:72: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp020_blbl_test.go:72: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp020_blbl_test.go:72: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp020_blbl_test.go:72: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        if end1 < end2 {\n            return \"YES\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        if start1 < start2 {\n            return \"YES\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpxstl0z4a_test.go:102: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpxstl0z4a_test.go:102: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpxstl0z4a_test.go:102: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < start2 {\n        return \"NO\"\n    }\n    \n    if end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp03t0rczx_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp03t0rczx_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp03t0rczx_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if start1 < start2 {\n        return \"NO\"\n    }\n    \n    if end1 > end2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpxzcaozxi_test.go:96: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpxzcaozxi_test.go:96: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpxzcaozxi_test.go:96: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    if start1 == end2 || start2 == end1 {\n        return \"\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpaeh_lone_test.go:86:16: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpr46w_3iq_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    \n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"YES\"\n    }\n    \n    if start2 > end1 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        return \"YES\"\n    }\n    \n    if start2 < start1 {\n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"YES\"\n    }\n    \n    if end2 < end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"YES\"\n    }\n    \n    if start2 > end1 {\n        return \"YES\"\n    }\n    \n    if start1 < end2 {\n        return \"YES\"\n    }\n    \n    if start2 < end1 {\n        return \"YES\"\n    }\n    \n    if end1 > end2 {\n        return \"YES\"\n    }\n    \n    if end2 > end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9dck1pi8_test.go:116:12: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && start2 < end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmprea4llzm_test.go:70: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmprea4llzm_test.go:70: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmprea4llzm_test.go:70: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmprea4llzm_test.go:70: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmprea4llzm_test.go:70: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && end1 > start2 {\n        return \"YES\"\n    }\n    \n    if start2 < end1 && end2 > start1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpovgvcfh5_test.go:106: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpovgvcfh5_test.go:106: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpovgvcfh5_test.go:106: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpovgvcfh5_test.go:106: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start2 > start1 || end2 < end1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp3tweh85z_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp3tweh85z_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp3tweh85z_test.go:74: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpqvh1eh68_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpqvh1eh68_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpqvh1eh68_test.go:84: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 == end2 || start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        start1, end1 = start2, end2\n    }\n    \n    if start2 > end1 {\n        start2, end2 = start1, end1\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        start1, end1 = start2, end2\n    }\n    \n    if start2 > end1 {\n        start2, end2 = start1, end1\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        start1, end1 = start2, end2\n    }\n    \n    if start2 > end1 {\n        start2, end2 = start1, end1\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        start1, end1 = start2, end2\n    }\n    \n    if start2 > end1 {\n        start2, end2 = start1, end1\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphlvp_61n_test.go:106:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for start1 <= end1 && start2 <= end2 {\n        if start1 == start2 {\n            return \"YES\"\n        }\n        \n        if start1 == end1 {\n            break\n        }\n        \n        if start2 == end2 {\n            break\n        }\n        \n        if start1 + 1 == start2 {\n            start1++\n            start2++\n        } else if start1 + 1 == end2 {\n            start1++\n            end2++\n        } else if start2 + 1 == start1 {\n            start2++\n            start1++\n        } else if start2 + 1 == end1 {\n            start2++\n            end1++\n        } else {\n            start1++\n            start2++\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp7yw2ot3c_test.go:105: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp7yw2ot3c_test.go:105: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp7yw2ot3c_test.go:105: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprfoud_ub_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmprfoud_ub_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmprfoud_ub_test.go:48:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmprfoud_ub_test.go:52:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmprfoud_ub_test.go:56:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmprfoud_ub_test.go:60:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpslc132w3_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpslc132w3_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpslc132w3_test.go:91: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0tfc1x40_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmp0tfc1x40_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmp0tfc1x40_test.go:48:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmp0tfc1x40_test.go:52:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmp0tfc1x40_test.go:56:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmp0tfc1x40_test.go:60:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmp0tfc1x40_test.go:64:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        for j := 0; j < len(interval2); j++ {\n            if interval1[i].(int) <= interval2[j].(int) && interval1[i+1].(int) >= interval2[j+1].(int) {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpkajoor5y_test.go:67: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpkajoor5y_test.go:67: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpkajoor5y_test.go:67: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpkajoor5y_test.go:67: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpkx7wvw0b_test.go:70: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpkx7wvw0b_test.go:70: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpkx7wvw0b_test.go:70: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        interval2[0] = interval2[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        interval2[1] = interval2[1].(int) + 1\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpoeuoh8l2_test.go:73:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        if interval1[1].(int) > interval2[1].(int) {\n            return \"NO\"\n        }\n        \n        if interval1[1].(int) == interval2[1].(int) {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        if interval1[1].(int) > interval2[1].(int) {\n            return \"NO\"\n        }\n        \n        if interval1[1].(int) == interval2[1].(int) {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp_w2mclj5_test.go:99: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp_w2mclj5_test.go:99: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp_w2mclj5_test.go:99: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp_w_3bulg_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpxy31z3fh_test.go:79: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpxy31z3fh_test.go:79: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpxy31z3fh_test.go:79: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpe9jzt8_t_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpe9jzt8_t_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpe9jzt8_t_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpf23w2_pv_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpf23w2_pv_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpf23w2_pv_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprh1qm8h2_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmprh1qm8h2_test.go:36:21: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 == end2 {\n            return \"YES\"\n        }\n        \n        if end1 > end2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if end1 > end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpbq3lpw5q_test.go:98: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpbq3lpw5q_test.go:98: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpbq3lpw5q_test.go:98: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpbq3lpw5q_test.go:98: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    return \"NO\"\n}\n\n//  [input] interval1, interval2: []interface{}\n//  [output] isIntersect: bool\n//  [output] intersection: []interface{}\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpcm385k4m_test.go:55: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpcm385k4m_test.go:55: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) || interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpmu1vzssw_test.go:83: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpmu1vzssw_test.go:83: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpmu1vzssw_test.go:83: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"NO\"\n    }\n    \n    for start1 <= end1 && start2 <= end2 {\n        if end1 - start1 == end2 - start2 {\n            return \"YES\"\n        }\n        \n        if end1 - start1 < end2 - start2 {\n            return \"NO\"\n        }\n        \n        if end1 - start1 > end2 - start2 {\n            return \"NO\"\n        }\n        \n        start1++\n        start2++\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmp5bwkbyv9_test.go:99: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5bwkbyv9_test.go:99: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp5bwkbyv9_test.go:99: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        for j := start2; j <= end2; j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpgf8wkcm9_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpgf8wkcm9_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpgf8wkcm9_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_0bltr12_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmp_0bltr12_test.go:36:21: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmp_0bltr12_test.go:48:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmp_0bltr12_test.go:52:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n/tmp/tmp_0bltr12_test.go:64:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmp_0bltr12_test.go:68:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 < end2 {\n            return \"YES\"\n        }\n    }\n    \n    if end1 == end2 {\n        if start1 < start2 {\n            return \"YES\"\n        }\n    }\n    \n    if start1 < start2 {\n        if end1 > end2 {\n            return \"YES\"\n        }\n    }\n    \n    if end1 > end2 {\n        if start1 < start2 {\n            return \"YES\"\n        }\n    }\n    \n    if start1 > start2 {\n        if end1 < end2 {\n            return \"YES\"\n        }\n    }\n    \n    if end1 < end2 {\n        if start1 > start2 {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpyj_vl3b__test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpyj_vl3b__test.go:110: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpyj_vl3b__test.go:110: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpyj_vl3b__test.go:110: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        if end1 == end2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        if start1 == start2 {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpm40u43q2_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpm40u43q2_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpm40u43q2_test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 <= start1 && end2 > end1 {\n        return \"NO\"\n    }\n    \n    if start2 <= start1 && end2 < end1 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 > start1 && end2 > end1 {\n        return \"NO\"\n    }\n    \n    if start2 > start1 && end2 < end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp4igl4p48_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp4igl4p48_test.go:94: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp4igl4p48_test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 && end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < start2 && end1 < end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpprm48xzv_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpprm48xzv_test.go:86: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpprm48xzv_test.go:86: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpkx7wvw0b_test.go:70: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpkx7wvw0b_test.go:70: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpkx7wvw0b_test.go:70: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"NO\"\n    }\n    \n    if start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end2 {\n        return \"NO\"\n    }\n    \n    if start2 == end1 {\n        return \"NO\"\n    }\n    \n    if start1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpernh3gil_test.go:110:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5r7aqt0a_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp5r7aqt0a_test.go:91: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp5r7aqt0a_test.go:91: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmp5r7aqt0a_test.go:91: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        for j := start2; j <= end2; j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpgf8wkcm9_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpgf8wkcm9_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpgf8wkcm9_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) && interval1[1].(int) < interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) && interval1[1].(int) > interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) && interval1[1].(int) < interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) && interval1[1].(int) > interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp0efuq76i_test.go:99: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp0efuq76i_test.go:99: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp0efuq76i_test.go:99: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmp0efuq76i_test.go:99: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp58ly8zo5_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp58ly8zo5_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp58ly8zo5_test.go:86: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp58ly8zo5_test.go:86: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyow_qa4d_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpyow_qa4d_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmpyow_qa4d_test.go:48:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmpyow_qa4d_test.go:52:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmpyow_qa4d_test.go:56:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpyow_qa4d_test.go:60:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmpyow_qa4d_test.go:72:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmpyow_qa4d_test.go:76:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n/tmp/tmpyow_qa4d_test.go:80:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpyow_qa4d_test.go:84:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmpyow_qa4d_test.go:84:21: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpw18kxwtd_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpw18kxwtd_test.go:94: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpw18kxwtd_test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    for i := interval1[0]; i <= interval1[1]; i++ {\n        for j := interval2[0]; j <= interval2[1]; j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphc3n37bs_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmphc3n37bs_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmphc3n37bs_test.go:36:30: invalid operation: i <= interval1[1] (operator <= not defined on interface)\n/tmp/tmphc3n37bs_test.go:36:48: invalid operation: i++ (non-numeric type interface {})\n/tmp/tmphc3n37bs_test.go:37:34: invalid operation: j <= interval2[1] (operator <= not defined on interface)\n/tmp/tmphc3n37bs_test.go:37:52: invalid operation: j++ (non-numeric type interface {})\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) || interval1[1].(int) == interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx19ug487_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"NO\"\n    }\n    \n    if start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpm9js5r04_test.go:108:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmphy2ij620_test.go:76: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmphy2ij620_test.go:76: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmphy2ij620_test.go:76: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0tfc1x40_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmp0tfc1x40_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmp0tfc1x40_test.go:48:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmp0tfc1x40_test.go:52:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmp0tfc1x40_test.go:56:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmp0tfc1x40_test.go:60:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmp0tfc1x40_test.go:64:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0] > interval2[0] {\n        return \"NO\"\n    }\n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    if interval2[1] < interval1[0] {\n        return \"NO\"\n    }\n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjujrxan1_test.go:32:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpjujrxan1_test.go:35:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmpjujrxan1_test.go:38:21: invalid operation: interval2[1] < interval1[0] (operator < not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        } else {\n            return \"YES\"\n        }\n    }\n    \n    if start1 < start2 {\n        if end1 > end2 {\n            return \"NO\"\n        } else {\n            return \"YES\"\n        }\n    }\n    \n    if end1 < end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpby0bkrk7_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpby0bkrk7_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpby0bkrk7_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpe92_dm7j_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpe92_dm7j_test.go:95: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpe92_dm7j_test.go:95: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if start2 > start1 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end2 < end1 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpr9gl_e0x_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpr9gl_e0x_test.go:84: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpr9gl_e0x_test.go:84: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 > end2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        if start1 > start2 {\n            return \"NO\"\n        }\n        \n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp1iarp3gz_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 || start2 == end1 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && start2 < end1 {\n        return \"YES\"\n    }\n    \n    if start1 < end2 && start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 > end2 && start2 < end1 {\n        return \"NO\"\n    }\n    \n    if start1 > end2 && start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && start2 < end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmplppx6b5q_test.go:98: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmplppx6b5q_test.go:98: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmplppx6b5q_test.go:98: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[1].(int) == interval2[0].(int) && interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp6asp1rdb_test.go:73: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp6asp1rdb_test.go:73: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp6asp1rdb_test.go:73: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if start1 < end2 {\n        end1 = end2\n    }\n    \n    if start2 < end1 {\n        end2 = end1\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    for i := start1; i <= end1; i++ {\n        for j := start2; j <= end2; j++ {\n            if i == j {\n                continue\n            }\n            \n            if i > j {\n                return \"NO\"\n            }\n        }\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpcpguxfoc_test.go:111: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpcpguxfoc_test.go:111: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpcpguxfoc_test.go:111: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) || interval1[1].(int) == interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) > interval2[0].(int) || interval1[0].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) > interval2[1].(int) || interval1[0].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    return\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk21vslm2_test.go:77:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[1].(int) > interval2[0].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpnlx_jbpo_test.go:87: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpnlx_jbpo_test.go:87: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpnlx_jbpo_test.go:87: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpnlx_jbpo_test.go:87: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"NO\"\n    }\n    \n    if start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3x392ayt_test.go:109:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        if end1 == end2 {\n            return \"YES\"\n        } else {\n            return \"NO\"\n        }\n    } else {\n        if end1 == end2 {\n            return \"YES\"\n        } else {\n            return \"NO\"\n        }\n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp9yij8wht_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmp9yij8wht_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp9yij8wht_test.go:86: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end2 {\n        return \"YES\"\n    }\n    \n    if start2 == end1 {\n        return \"YES\"\n    }\n    \n    if start1 > end2 {\n        return \"YES\"\n    }\n    \n    if start2 > end1 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        return \"YES\"\n    }\n    \n    if start2 < start1 {\n        return \"YES\"\n    }\n    \n    if end1 > end2 {\n        return \"YES\"\n    }\n    \n    if end2 > end1 {\n        return \"YES\"\n    }\n    \n    if end1 < end2 {\n        return \"YES\"\n    }\n    \n    if end2 < end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpvo4k_rk6_test.go:130: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpvo4k_rk6_test.go:130: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpvo4k_rk6_test.go:130: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpvo4k_rk6_test.go:130: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzmag4s0l_test.go:74:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    for start1 <= end2 && start2 <= end1 {\n        if start1 == start2 && end1 == end2 {\n            return \"YES\"\n        }\n        \n        if start1 == start2 {\n            start1++\n        } else if start1 < start2 {\n            start1++\n        } else {\n            start2++\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpmmwniigz_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpmmwniigz_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpmmwniigz_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] || interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        interval1[0], interval2[0] = interval2[0], interval1[0]\n    }\n    \n    if interval1[1] > interval2[1] {\n        interval1[1], interval2[1] = interval2[1], interval1[1]\n    }\n    \n    if interval1[0] > interval1[1] || interval2[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval1[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg6e9s_m8_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpg6e9s_m8_test.go:32:52: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmpg6e9s_m8_test.go:36:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmpg6e9s_m8_test.go:40:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n/tmp/tmpg6e9s_m8_test.go:44:21: invalid operation: interval1[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmpg6e9s_m8_test.go:44:52: invalid operation: interval2[0] > interval2[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n    }\n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    if interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmppykfq5m5_test.go:81: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmppykfq5m5_test.go:81: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmppykfq5m5_test.go:81: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmppykfq5m5_test.go:81: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 < start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 > end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 < end2 - start2 {\n        return \"NO\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpxnzmkfbd_test.go:102: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpxnzmkfbd_test.go:102: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpxnzmkfbd_test.go:102: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] > interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp7tn8b25_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpp7tn8b25_test.go:36:21: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n/tmp/tmpp7tn8b25_test.go:48:21: invalid operation: interval1[0] < interval2[0] (operator < not defined on interface)\n/tmp/tmpp7tn8b25_test.go:52:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n/tmp/tmpp7tn8b25_test.go:64:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpp7tn8b25_test.go:68:21: invalid operation: interval1[1] > interval2[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    for i := interval1[0].(int); i <= interval1[1].(int); i++ {\n        for j := interval2[0].(int); j <= interval2[1].(int); j++ {\n            if i == j {\n                return \"YES\"\n            }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpj8_dtoy4_test.go:71: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 <= start2 && end1 >= end2 {\n        return \"YES\"\n    }\n    \n    if start1 <= start2 && end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start2 <= start1 && end2 < end1 {\n        return \"NO\"\n    }\n    \n    if start2 <= start1 && end2 >= end1 {\n        return \"YES\"\n    }\n    \n    if start1 > start2 {\n        return \"NO\"\n    }\n    \n    if end1 < end2 {\n        return \"NO\"\n    }\n    \n    if end1 > end2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpwej4a7_v_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpwej4a7_v_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpwej4a7_v_test.go:90: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmpwej4a7_v_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    \n    if start1 > end1 {\n        start1, end1 = end1, start1\n    }\n    \n    if start2 > end2 {\n        start2, end2 = end2, start2\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 < end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 {\n        return \"YES\"\n    }\n    \n    if start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsd97w3nm_test.go:101:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 {\n        start1, start2 = start2, start1\n    }\n    \n    if end1 > end2 {\n        end1, end2 = end2, end1\n    }\n    \n    if start1 == end1 && start2 == end2 {\n        return \"YES\"\n    }\n    \n    if start1 == end1 {\n        return \"NO\"\n    }\n    \n    if start2 == end2 {\n        return \"NO\"\n    }\n    \n    if start1 == end2 {\n        return \"NO\"\n    }\n    \n    if start2 == end1 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if start2 == start1 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end2 == end1 {\n        return \"YES\"\n    }\n    \n    if end1 == start2 {\n        return \"YES\"\n    }\n    \n    if end2 == start1 {\n        return \"YES\"\n    }\n    \n    if end1 == start1 {\n        return \"YES\"\n    }\n    \n    if end2 == start2 {\n        return \"YES\"\n    }\n    \n    if start1 == start2 {\n        return \"YES\"\n    }\n    \n    if start2 == start1 {\n        return \"YES\"\n    }\n    \n    if end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end2 == end1 {\n        return \"YES\"\n    }\n    \n    return \"NO\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfu7dwtfj_test.go:115:12: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpi50__5ew_test.go:76: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpi50__5ew_test.go:76: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpi50__5ew_test.go:76: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0xuqc_xf_test.go:69:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) && interval1[1].(int) < interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) < interval2[0].(int) && interval1[1].(int) > interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmph_dt5dmh_test.go:83: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmph_dt5dmh_test.go:83: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmph_dt5dmh_test.go:83: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmph_dt5dmh_test.go:83: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    // Your code here\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    if interval1[0].(int) == interval2[1].(int) && interval1[1].(int) == interval2[0].(int) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpe7t5xpyq_test.go:73: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpe7t5xpyq_test.go:73: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpe7t5xpyq_test.go:73: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 > start2 || end1 < end2 {\n        return \"NO\"\n    }\n    \n    if start1 == start2 && end1 == end2 {\n        return \"YES\"\n    }\n    \n    if end1 - start1 == end2 - start2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpw2_vznvq_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpw2_vznvq_test.go:74: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpw2_vznvq_test.go:74: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    start1, end1 := interval1[0].(int), interval1[1].(int)\n    start2, end2 := interval2[0].(int), interval2[1].(int)\n    \n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    \n    if start1 < end2 && end1 > start2 {\n        return \"YES\"\n    }\n    \n    if start2 < end1 && end2 > start1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpvbryn9qa_test.go:70: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpvbryn9qa_test.go:70: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpvbryn9qa_test.go:70: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval2[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] && interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprh1qm8h2_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmprh1qm8h2_test.go:36:21: invalid operation: interval2[0] > interval1[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) || interval1[1].(int) < interval2[1].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n    if interval1[0].(int) == interval2[0].(int) && interval1[1].(int) == interval2[1].(int) {\n        return \"YES\"\n    }\n    \n    if interval1[0].(int) > interval2[0].(int) {\n        interval1[0] = interval1[0].(int) - 1\n    }\n    \n    if interval1[1].(int) < interval2[1].(int) {\n        interval1[1] = interval1[1].(int) + 1\n    }\n    \n    if interval1[0].(int) > interval2[1].(int) || interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\n    }\n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8wiv1l5s_test.go:73:6: expected '(', found TestIntersection\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[1] {\n        return \"NO\"\n    }\n    \n    if interval1[1] < interval2[0] {\n        return \"NO\"\n    }\n    \n    if interval1[0] > interval2[0] {\n        interval1[0] = interval1[0] - 1\n    }\n    \n    if interval1[1] < interval2[1] {\n        interval1[1] = interval1[1] + 1\n    }\n    \n    if interval1[0] == interval1[1] {\n        return \"YES\"\n    }\n    \n    if interval1[0] > interval1[1] {\n        return \"NO\"\n    }\n    \n    if interval1[0] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[0] == interval2[1] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[0] {\n        return \"YES\"\n    }\n    \n    if interval1[1] == interval2[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdotp48ef_test.go:32:21: invalid operation: interval1[0] > interval2[1] (operator > not defined on interface)\n/tmp/tmpdotp48ef_test.go:36:21: invalid operation: interval1[1] < interval2[0] (operator < not defined on interface)\n/tmp/tmpdotp48ef_test.go:40:21: invalid operation: interval1[0] > interval2[0] (operator > not defined on interface)\n/tmp/tmpdotp48ef_test.go:41:37: invalid operation: interval1[0] - 1 (mismatched types interface {} and int)\n/tmp/tmpdotp48ef_test.go:44:21: invalid operation: interval1[1] < interval2[1] (operator < not defined on interface)\n/tmp/tmpdotp48ef_test.go:45:37: invalid operation: interval1[1] + 1 (mismatched types interface {} and int)\n/tmp/tmpdotp48ef_test.go:52:21: invalid operation: interval1[0] > interval1[1] (operator > not defined on interface)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}