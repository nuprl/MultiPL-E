{
  "name": "HumanEval_132_is_nested",
  "language": "go_test.go",
  "prompt": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n",
  "tests": "func TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What happens if you don't return a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\n// What happens if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp0mu3sogx_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp0mu3sogx_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp0mu3sogx_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp0mu3sogx_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp0mu3sogx_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var is_nested bool\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            is_nested = true\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    is_nested = false\n                    break\n                }\n            }\n            if is_nested {\n                break\n            }\n        }\n    }\n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpvbbo0nqp_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpvbbo0nqp_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpvbbo0nqp_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpvbbo0nqp_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpvbbo0nqp_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpvbbo0nqp_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpvbbo0nqp_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What if you have a string with nested square brackets?\n// >>> is_nested(\"[[[[]]]]\")\n// true\n// >>> is_nested(\"[[[[[]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[[]]]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmps7nlmakl_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmps7nlmakl_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmps7nlmakl_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmps7nlmakl_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmps7nlmakl_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to store the brackets\n    bracketStack := make([]int, 0)\n    \n    // Iterate through the string and push the brackets onto the stack\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            bracketStack = append(bracketStack, i)\n        }\n    }\n    \n    // Iterate through the stack and pop the brackets off the stack\n    for i := len(bracketStack) - 1; i >= 0; i-- {\n        if myString[bracketStack[i]] == ']' {\n            bracketStack = append(bracketStack[:i], bracketStack[i+1:]...)\n        }\n    }\n    \n    // If the stack is empty, then the brackets are not nested\n    if len(bracketStack) == 0 {\n        return false\n    }\n    \n    // If the stack is not empty, then the brackets are nested\n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpym6cy1o7_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpym6cy1o7_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpym6cy1o7_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpym6cy1o7_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpym6cy1o7_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpym6cy1o7_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpym6cy1o7_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a slice of brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add brackets to the slice\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            brackets = append(brackets, \"[\")\n        } else if myString[i] == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // Check if the slice contains at least one nested bracket\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == \"]\" && brackets[i-1] == \"[\" {\n            return true\n        }\n    }\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x537320, 0xc00015a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x537320, 0xc00015a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.is_nested(...)\n\t/tmp/tmpnss_ytfr_test.go:39\ncommand-line-arguments_test.TestIs_Nested(0xc000102600)\n\t/tmp/tmpnss_ytfr_test.go:67 +0x2190\ntesting.tRunner(0xc000102600, 0x550238)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Your code here\n    \n    return false\n}\n\n// This test will fail because the function is_nested() is not defined.\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpxndqtntx_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpxndqtntx_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpxndqtntx_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxndqtntx_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpxndqtntx_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What if you have a list of strings?\n// >>> is_nested([\"[[]]\", \"[[][[]]\", \"[[][]]\"])\n// [true, false, false]\n// >>> is_nested([\"[[]]\", \"[[][[]]\", \"[[][]]\", \"[[][[]]\", \"[[][[][[]]\", \"[[][[][]]\", \"[[][[][]]\"])\n// [true, false, false, false, false, false, false]\n// >>> is_nested([\"[[]]\", \"[[][[]]\", \"[[][]]\", \"[[][[]]\", \"[[][[][[]]\", \"[[][[][]]\", \"[[][[][]]\", \"[[][[][]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[[][[][[]]\", \"[\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp0e2tp_pg_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp0e2tp_pg_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp0e2tp_pg_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp0e2tp_pg_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp0e2tp_pg_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice to hold the brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add each bracket to the brackets slice\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            brackets = append(brackets, \"[\")\n        } else if myString[i] == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // If the brackets slice is empty, then the string is not nested\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // Create a string slice to hold the brackets that are nested\n    nestedBrackets := make([]string, 0)\n    \n    // Iterate through the brackets slice and add each bracket to the nestedBrackets slice\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == \"[\" {\n            nestedBrackets = append(nestedBrackets, brackets[i])\n        }\n    }\n    \n    // If the nestedBrackets slice is empty, then the brackets are not nested\n    if len(nestedBrackets) == 0 {\n        return false\n    }\n    \n    // Iterate through the nestedBrackets slice and remove each bracket from the brackets slice\n    for i := 0; i < len(nestedBrackets); i++ {\n        for j := 0; j < len(brackets); j++ {\n            if nestedBrackets[i] == brackets[j] {\n                brackets = append(brackets[:j], brackets[j+1:]...)\n            }\n        }\n    }\n    \n    // If the brackets slice is empty, then the brackets are not nested\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // Iterate through the brackets slice and remove each bracket from the nestedBrackets slice\n    for i := 0; i < len(brackets); i++ {\n        for j := 0; j < len(nestedBrackets); j++ {\n            if brackets[i] == nestedBrackets[j] {\n                nestedBrackets = append\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374748,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8x49akui_test.go:76:6: expected '(', found TestIs_Nested\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    for j = 0; j < len(myString); j++ {\n        if myString[j] == '[' {\n            if count > 0 {\n                count--\n            } else {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__13 (0.00s)\n        tmpmyo1dtc6_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp48s9hnid_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp48s9hnid_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp48s9hnid_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp48s9hnid_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp48s9hnid_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice that will hold the brackets in the string\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add the brackets to the slice\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            brackets = append(brackets, \"[\")\n        } else if myString[i] == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // Check if the string is empty\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // Check if the string is a single bracket\n    if len(brackets) == 1 {\n        return true\n    }\n    \n    // Check if the string is a double bracket\n    if len(brackets) == 2 {\n        return true\n    }\n    \n    // Check if the string is a triple bracket\n    if len(brackets) == 3 {\n        return true\n    }\n    \n    // Check if the string is a quad bracket\n    if len(brackets) == 4 {\n        return true\n    }\n    \n    // Check if the string is a nested bracket\n    if len(brackets) > 4 {\n        return true\n    }\n    \n    // Return false if the string is not a nested bracket\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmp0xt3nh4n_test.go:97: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmp0xt3nh4n_test.go:97: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp0xt3nh4n_test.go:97: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmp0xt3nh4n_test.go:97: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmp0xt3nh4n_test.go:97: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmp0xt3nh4n_test.go:97: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmp0xt3nh4n_test.go:97: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__13 (0.00s)\n        tmp0xt3nh4n_test.go:97: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    var result bool\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else if char == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        result = true\n    }\n    return result\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf5nvr8lf_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf5nvr8lf_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf5nvr8lf_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpf5nvr8lf_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf5nvr8lf_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpf5nvr8lf_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What happens if you don't return a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\n// What happens if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: is_nested() expects to return bool, not int\n\n// What if you return a value that's not a boolean?\n// >>> is\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpquju5tku_test.go:98: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpquju5tku_test.go:98: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpquju5tku_test.go:98: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpquju5tku_test.go:98: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpquju5tku_test.go:98: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What if you want to test more than one string?\n// Create a function that takes a string as input and returns true if and only if there is a valid\n// subsequence of brackets where at least one bracket in the subsequence is nested.\n// >>> is_nested_multiple_strings(\"[[]]\")\n// true\n// >>> is_nested_multiple_strings(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested_multiple_strings(\"[][]\")\n// false\n// >>> is_nested_multiple_strings(\"[]\")\n// false\n// >>> is_nested_multiple_strings(\"[[][]\")\n// true\n// >>> is_nested_multiple_strings(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpbcq4g_6i_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpbcq4g_6i_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpbcq4g_6i_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpbcq4g_6i_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpbcq4g_6i_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to store the brackets\n    brackets := make([]int, 0)\n    \n    // Iterate through the string\n    for i := 0; i < len(myString); i++ {\n        \n        // If the current character is a left bracket, push it onto the stack\n        if myString[i] == '[' {\n            brackets = append(brackets, i)\n        }\n        \n        // If the current character is a right bracket, pop the top of the stack\n        // and check if it is a left bracket\n        if myString[i] == ']' {\n            if len(brackets) == 0 {\n                return false\n            }\n            \n            // Pop the top of the stack\n            top := brackets[len(brackets) - 1]\n            \n            // If the top of the stack is a left bracket, then the stack is valid\n            if myString[top] == '[' {\n                brackets = brackets[:len(brackets) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    \n    // If the stack is empty, then the string is valid\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    // If the stack is not empty, then the string is invalid\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmp_f9hqf4n_test.go:90: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp_f9hqf4n_test.go:90: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp_f9hqf4n_test.go:90: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmp_f9hqf4n_test.go:90: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    for j = 0; j < len(myString); j++ {\n        if myString[j] == '[' {\n            count++\n        }\n        if myString[j] == ']' {\n            count--\n        }\n        if count < 0 {\n            is_nested = false\n            break\n        }\n    }\n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpall_kj8v_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpall_kj8v_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpall_kj8v_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpall_kj8v_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpall_kj8v_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n        \n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                \n                if myString[j] == ']' {\n                    count--\n                }\n                \n                if count < 0 {\n                    is_nested = false\n                    break\n                }\n            }\n            \n            if is_nested == true {\n                break\n            }\n        }\n    }\n    \n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpcbtk8pfm_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpcbtk8pfm_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpcbtk8pfm_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpcbtk8pfm_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpcbtk8pfm_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    var result bool\n    \n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, char)\n        } else if char == ']' {\n            if len(stack) == 0 {\n                result = false\n                break\n            } else {\n                stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    \n    if len(stack) > 0 {\n        result = true\n    }\n    \n    return result\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmt6q1ibs_test.go:29:27: cannot use char (type rune) as type string in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var is_nested bool\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            is_nested = true\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    is_nested = false\n                    break\n                }\n            }\n            if is_nested == true {\n                break\n            }\n        }\n    }\n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmp98nx7zdz_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmp98nx7zdz_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp98nx7zdz_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmp98nx7zdz_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmp98nx7zdz_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmp98nx7zdz_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmp98nx7zdz_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var is_nested bool\n    var stack []int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            stack = append(stack, i)\n        } else {\n            if len(stack) > 0 {\n                if myString[i] == ']' && myString[stack[len(stack)-1]] == '[' {\n                    stack = stack[:len(stack)-1]\n                } else {\n                    stack = stack[:len(stack)-1]\n                }\n            } else {\n                is_nested = false\n                break\n            }\n        }\n    }\n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp53qa9ais_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp53qa9ais_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp53qa9ais_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp53qa9ais_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp53qa9ais_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a slice of brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add brackets to the slice\n    for _, char := range myString {\n        if char == '[' {\n            brackets = append(brackets, \"[\")\n        } else if char == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // If there are no brackets, return false\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // Iterate through the slice and check if any bracket is nested\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == \"[\" && brackets[i+1] == \"]\" {\n            return true\n        }\n    }\n    \n    // If there are no nested brackets, return false\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\npanic: runtime error: index out of range [8] with length 8 [recovered]\n\tpanic: runtime error: index out of range [8] with length 8\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001680)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.is_nested(0x545d03, 0x8, 0x400)\n\t/tmp/tmpee3u3jq4_test.go:44 +0x2aa\ncommand-line-arguments_test.TestIs_Nested(0xc000001680)\n\t/tmp/tmpee3u3jq4_test.go:72 +0x282\ntesting.tRunner(0xc000001680, 0x54f238)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice to hold the brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add the brackets to the slice\n    for _, char := range myString {\n        if char == '[' {\n            brackets = append(brackets, \"[\")\n        } else if char == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // Check if the brackets are nested\n    for i := 0; i < len(brackets) - 1; i++ {\n        if brackets[i] == brackets[i+1] {\n            return true\n        }\n    }\n    \n    // If the brackets are not nested, return false\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpp6076utz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpp6076utz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpp6076utz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpp6076utz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpp6076utz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__13 (0.00s)\n        tmpp6076utz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n        \n        if count == 0 {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                \n                if myString[j] == ']' {\n                    count--\n                }\n                \n                if count == 0 {\n                    is_nested = true\n                    break\n                }\n            }\n            \n            if is_nested {\n                break\n            }\n        }\n    }\n    \n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp48_p8s2x_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmp48_p8s2x_test.go:91: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp48_p8s2x_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp48_p8s2x_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp48_p8s2x_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp48_p8s2x_test.go:91: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What if you have a string with a lot of brackets in it?\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpy93zt256_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpy93zt256_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpy93zt256_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpy93zt256_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpy93zt256_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else if char == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpu94pl4hw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpu94pl4hw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpu94pl4hw_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpu94pl4hw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the sum of the first 100 integers?\n// >>> sum(range(100))\n// 4950\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpbvmc2n8d_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpbvmc2n8d_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpbvmc2n8d_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpbvmc2n8d_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpbvmc2n8d_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What happens if you don't return a value from your function?\n// What does the compiler do? Can you still run your code?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpwwfcwb4d_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpwwfcwb4d_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpwwfcwb4d_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpwwfcwb4d_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpwwfcwb4d_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            stack = append(stack, \"\")\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if myString[i] == ']' {\n                if len(stack[len(stack)-1]) == 0 {\n                    return false\n                }\n                stack = stack[:len(stack)-1]\n            } else {\n                stack[len(stack)-1] += myString[i]\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpma015c8f_test.go:38:37: invalid operation: stack[len(stack) - 1] += myString[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What if you want to test a string that contains nested square brackets?\n// >>> is_nested_test(\"[[]]\")\n// true\n// >>> is_nested_test(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested_test(\"[][]\")\n// false\n// >>> is_nested_test(\"[]\")\n// false\n// >>> is_nested_test(\"[[][]\")\n// true\n// >>> is_nested_test(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmportom756_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmportom756_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmportom756_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmportom756_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmportom756_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to hold the brackets\n    bracketStack := make([]int, 0)\n    \n    // Iterate through the string\n    for i := 0; i < len(myString); i++ {\n        \n        // If the current character is a bracket, push it onto the stack\n        if myString[i] == '[' {\n            bracketStack = append(bracketStack, i)\n        }\n        \n        // If the current character is a bracket and the top of the stack is a bracket,\n        // pop the top of the stack and compare the brackets\n        if myString[i] == '[' && bracketStack[len(bracketStack) - 1] == i {\n            bracketStack = bracketStack[:len(bracketStack) - 1]\n            if len(bracketStack) == 0 {\n                return true\n            }\n        }\n    }\n    \n    // If the stack is not empty, there is a mismatch\n    if len(bracketStack) > 0 {\n        return false\n    }\n    \n    // If the stack is empty, there is a match\n    return true\n}\n\n// Test 1: [[]]\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__13 (0.00s)\n        tmpdlmaza5i_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    var i int\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            stack = append(stack, \"\")\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if myString[i] == ']' {\n                if len(stack[len(stack) - 1]) == 0 {\n                    return false\n                }\n                stack = stack[:len(stack) - 1]\n            } else {\n                stack[len(stack) - 1] += myString[i]\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprl9iy9gt_test.go:39:39: invalid operation: stack[len(stack) - 1] += myString[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    for j = 0; j < len(myString); j++ {\n        if myString[j] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpm4sem4gr_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpm4sem4gr_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpm4sem4gr_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpm4sem4gr_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpm4sem4gr_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpj_atbu6t_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpj_atbu6t_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpj_atbu6t_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpj_atbu6t_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What happens if you don't return a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// NameError: name 'is_nested' is not defined\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: 'bool' object is not callable\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: 'bool' object is not callable\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: 'bool' object is not callable\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: 'bool' object is not callable\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: 'bool' object is not callable\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\", line 1, in <module>\n// TypeError: 'bool' object is not callable\n\n// What if you return a value that's not a boolean?\n// >>> is_nested(\"[[]]\")\n// Traceback (most recent call last):\n//   File \"<stdin>\",\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmps4aclhx4_test.go:100: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmps4aclhx4_test.go:100: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmps4aclhx4_test.go:100: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmps4aclhx4_test.go:100: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmps4aclhx4_test.go:100: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var isNested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n        \n        if count == 0 {\n            isNested = true\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                \n                if myString[j] == ']' {\n                    count--\n                }\n                \n                if count == 0 {\n                    isNested = false\n                    break\n                }\n            }\n            \n            if isNested {\n                break\n            }\n        }\n    }\n    \n    return isNested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpzcq_o9y9_test.go:92: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpzcq_o9y9_test.go:92: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpzcq_o9y9_test.go:92: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpzcq_o9y9_test.go:92: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpzcq_o9y9_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to hold the brackets\n    bracketStack := make([]int, 0)\n    \n    // Iterate through the string\n    for i := 0; i < len(myString); i++ {\n        \n        // If the current character is a left bracket, push it onto the stack\n        if myString[i] == '[' {\n            bracketStack = append(bracketStack, i)\n        }\n        \n        // If the current character is a right bracket, pop it off the stack\n        if myString[i] == ']' {\n            if len(bracketStack) == 0 {\n                return false\n            }\n            bracketStack = bracketStack[:len(bracketStack)-1]\n        }\n    }\n    \n    // If the stack is empty, then the brackets are all nested\n    if len(bracketStack) == 0 {\n        return true\n    }\n    \n    // If the stack is not empty, then the brackets are not nested\n    return false\n}\n\n// Test function\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpn2bp5mi7_test.go:81: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpn2bp5mi7_test.go:81: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpn2bp5mi7_test.go:81: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpn2bp5mi7_test.go:81: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code goes here\n    return false\n}\n\n// This test will not run unless the environment variable RUN_TESTS is defined\n// To run tests, use the command: go run -tags=run_tests is_nested_test.go\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp1y2xvb6y_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp1y2xvb6y_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp1y2xvb6y_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp1y2xvb6y_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp1y2xvb6y_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice of the string\n    mySlice := []string{}\n    \n    // Create a string slice of the string\n    mySlice2 := []string{}\n    \n    // Create a string slice of the string\n    mySlice3 := []string{}\n    \n    // Create a string slice of the string\n    mySlice4 := []string{}\n    \n    // Create a string slice of the string\n    mySlice5 := []string{}\n    \n    // Create a string slice of the string\n    mySlice6 := []string{}\n    \n    // Create a string slice of the string\n    mySlice7 := []string{}\n    \n    // Create a string slice of the string\n    mySlice8 := []string{}\n    \n    // Create a string slice of the string\n    mySlice9 := []string{}\n    \n    // Create a string slice of the string\n    mySlice10 := []string{}\n    \n    // Create a string slice of the string\n    mySlice11 := []string{}\n    \n    // Create a string slice of the string\n    mySlice12 := []string{}\n    \n    // Create a string slice of the string\n    mySlice13 := []string{}\n    \n    // Create a string slice of the string\n    mySlice14 := []string{}\n    \n    // Create a string slice of the string\n    mySlice15 := []string{}\n    \n    // Create a string slice of the string\n    mySlice16 := []string{}\n    \n    // Create a string slice of the string\n    mySlice17 := []string{}\n    \n    // Create a string slice of the string\n    mySlice18 := []string{}\n    \n    // Create a string slice of the string\n    mySlice19 := []string{}\n    \n    // Create a string slice of the string\n    mySlice20 := []string{}\n    \n    // Create a string slice of the string\n    mySlice21 := []string{}\n    \n    // Create a string slice of the string\n    mySlice22 := []string{}\n    \n    // Create a string\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1qp8vgsl_test.go:92:6: expected '(', found TestIs_Nested\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Initialize a stack to hold the brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and push the brackets onto the stack\n    for _, char := range myString {\n        if char == '[' {\n            brackets = append(brackets, char)\n        } else if char == ']' {\n            brackets = brackets[:len(brackets) - 1]\n        }\n    }\n    \n    // Check if the stack is empty\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // Check if the first bracket is nested\n    if brackets[0] == '[' {\n        return true\n    }\n    \n    // Check if the last bracket is nested\n    if brackets[len(brackets) - 1] == ']' {\n        return true\n    }\n    \n    // Check if the first and last brackets are nested\n    if brackets[0] == '[' && brackets[len(brackets) - 1] == ']' {\n        return true\n    }\n    \n    // Check if the first and last brackets are nested\n    if brackets[0] == '[' && brackets[len(brackets) - 1] == ']' {\n        return true\n    }\n    \n    // Check if the first and last brackets are nested\n    if brackets[0] == '[' && brackets[len(brackets) - 1] == ']' {\n        return true\n    }\n    \n    // Check if the first and last brackets are nested\n    if brackets[0] == '[' && brackets[len(brackets) - 1] == ']' {\n        return true\n    }\n    \n    // Check if the first and last brackets are nested\n    if brackets[0] == '[' && brackets[len(brackets) - 1] == ']' {\n        return true\n    }\n    \n    // Check if the first and last brackets are nested\n    if brackets[0] == '[' && brackets[len(brackets) - 1] == ']' {\n        return true\n    }\n    \n    // Check if the first and last brackets are nested\n    if brackets[0] == '[' && brackets[len(brackets) - 1] == '\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpizjsbm9b_test.go:83:61: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n    }\n    \n    if count == 0 {\n        return true\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n            }\n        }\n    }\n    \n    if count == 0 {\n        return true\n    }\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk66gozh3_test.go:27:9: is_nested declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code goes here\n    return false\n}\n\n// The main function\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Check if the string is empty\n    if len(myString) == 0 {\n        return false\n    }\n    \n    // Check if the string contains only square brackets\n    if myString[0] != '[' || myString[len(myString)-1] != ']' {\n        return false\n    }\n    \n    // Check if the string is valid\n    var valid bool = true\n    for i := 1; i < len(myString)-1; i++ {\n        if myString[i] == '[' && myString[i+1] == '[' {\n            i++\n            continue\n        }\n        if myString[i] == ']' && myString[i-1] == ']' {\n            i--\n            continue\n        }\n        valid = false\n        break\n    }\n    \n    return valid\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpae7fs816_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpae7fs816_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpae7fs816_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpae7fs816_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpae7fs816_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpae7fs816_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n        \n        if myString[i] == ']' {\n            count--\n        }\n        \n        if count < 0 {\n            return false\n        }\n    }\n    \n    for j = 0; j < len(myString); j++ {\n        if myString[j] == '[' {\n            count++\n        }\n        \n        if myString[j] == ']' {\n            count--\n        }\n        \n        if count < 0 {\n            return true\n        }\n    }\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp33l2islv_test.go:85: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp33l2islv_test.go:85: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp33l2islv_test.go:85: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp33l2islv_test.go:85: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp33l2islv_test.go:85: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice of the string\n    mySlice := []rune(myString)\n    \n    // Create a stack of brackets\n    myStack := make([]rune, 0)\n    \n    // Iterate through the string slice\n    for i := 0; i < len(mySlice); i++ {\n        \n        // If the current character is a left bracket\n        if mySlice[i] == '[' {\n            \n            // Push the current character onto the stack\n            myStack = append(myStack, mySlice[i])\n            \n        } else if mySlice[i] == ']' {\n            \n            // Pop the top character off the stack\n            myStack = myStack[:len(myStack) - 1]\n            \n            // If the stack is empty, return false\n            if len(myStack) == 0 {\n                return false\n            }\n            \n            // If the top character is a left bracket, then return true\n            if myStack[len(myStack) - 1] == '[' {\n                return true\n            }\n            \n        }\n    }\n    \n    // If the stack is empty, return false\n    if len(myStack) == 0 {\n        return false\n    }\n    \n    // If the top character is a left bracket, then return true\n    if myStack[len(myStack) - 1] == '[' {\n        return true\n    }\n    \n    // If the stack is not empty, return false\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.is_nested(0x545d33, 0x8, 0x401)\n\t/tmp/tmpvrhmg5jw_test.go:43 +0x1cd\ncommand-line-arguments_test.TestIs_Nested(0xc000001380)\n\t/tmp/tmpvrhmg5jw_test.go:92 +0x2b0\ntesting.tRunner(0xc000001380, 0x54f238)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if len(stack) == 1 {\n                stack[0] = stack[0] + char\n            } else {\n                stack[len(stack)-1] = stack[len(stack)-1] + char\n            }\n        }\n    }\n    return len(stack) > 0 && len(stack[0]) > 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk5gemjex_test.go:33:37: invalid operation: stack[0] + char (mismatched types string and rune)\n/tmp/tmpk5gemjex_test.go:35:59: invalid operation: stack[len(stack) - 1] + char (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else if char == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpu94pl4hw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpu94pl4hw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpu94pl4hw_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpu94pl4hw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a slice of brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add brackets to the slice\n    for _, char := range myString {\n        if char == '[' {\n            brackets = append(brackets, \"[\")\n        } else if char == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // Check if the slice has any nested brackets\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == \"]\" && brackets[i-1] == \"[\" {\n            return true\n        }\n    }\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc00015a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc00015a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.is_nested(0x545d33, 0x8, 0x400)\n\t/tmp/tmpmmw2pjx8_test.go:39 +0x295\ncommand-line-arguments_test.TestIs_Nested(0xc000102600)\n\t/tmp/tmpmmw2pjx8_test.go:67 +0x2b0\ntesting.tRunner(0xc000102600, 0x54f238)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to store the brackets\n    brackets := make([]int, 0)\n    \n    // Iterate through the string and push the brackets onto the stack\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            brackets = append(brackets, i)\n        }\n    }\n    \n    // Iterate through the stack and pop the brackets off the stack\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if myString[brackets[i]] == ']' {\n            brackets = append(brackets, brackets[i])\n        }\n    }\n    \n    // If the stack is empty, then the brackets are not nested\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // If the stack is not empty, then the brackets are nested\n    return true\n}\n\n// Test is_nested\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpbzufxy_c_test.go:78: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpbzufxy_c_test.go:78: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpbzufxy_c_test.go:78: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpbzufxy_c_test.go:78: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpbzufxy_c_test.go:78: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpbzufxy_c_test.go:78: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpbzufxy_c_test.go:78: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Your code here\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What if you have a string with nested square brackets?\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Your code here\n    \n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpc6tevo4w_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpc6tevo4w_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpc6tevo4w_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpc6tevo4w_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpc6tevo4w_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code here\n    return false\n}\n\n// What if you want to test a string that contains nested square brackets?\n// Write a test program that prompts the user to enter a string and displays \n// whether the string is nested or not.\n// >>> nested_test()\n// Enter a string: [[]]\n// true\n// Enter a string: [[]]]]]]][[[[[]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n// Enter a string: [[][]][[]]\n// true\n// Enter a string: [[][]][[]]\n// false\n//\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpp9qdsv_1_test.go:119: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpp9qdsv_1_test.go:119: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpp9qdsv_1_test.go:119: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpp9qdsv_1_test.go:119: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpp9qdsv_1_test.go:119: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code here\n    return false\n}\n\n// What if you want to test a string that contains nested square brackets?\n// >>> is_nested_test(\"[[]]\")\n// true\n// >>> is_nested_test(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested_test(\"[][]\")\n// false\n// >>> is_nested_test(\"[]\")\n// false\n// >>> is_nested_test(\"[[][]\")\n// true\n// >>> is_nested_test(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpul7fij5c_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpul7fij5c_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpul7fij5c_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpul7fij5c_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpul7fij5c_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n        \n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                if myString[j] == ']' {\n                    count--\n                }\n                \n                if count == 0 {\n                    is_nested = true\n                    break\n                }\n            }\n            \n            if is_nested == true {\n                break\n            }\n        }\n    }\n    \n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpn7axhf7k_test.go:90: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpn7axhf7k_test.go:90: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpn7axhf7k_test.go:90: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpn7axhf7k_test.go:90: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpn7axhf7k_test.go:90: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            stack = append(stack, \"\")\n        } else if myString[i] == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += myString[i]\n        }\n    }\n    return len(stack) > 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq3oonuf4_test.go:34:33: invalid operation: stack[len(stack) - 1] += myString[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack of brackets\n    bracketStack := make([]int, 0)\n    \n    // Iterate through the string\n    for i := 0; i < len(myString); i++ {\n        \n        // If the current character is a bracket, push it onto the stack\n        if myString[i] == '[' {\n            bracketStack = append(bracketStack, i)\n        }\n        \n        // If the current character is a bracket and the top of the stack is a bracket,\n        // pop the top of the stack and compare it to the current bracket\n        if myString[i] == '[' && len(bracketStack) > 0 && bracketStack[len(bracketStack) - 1] == i {\n            bracketStack = bracketStack[:len(bracketStack) - 1]\n        }\n        \n        // If the current character is a bracket and the top of the stack is not a bracket,\n        // pop the top of the stack and compare it to the current bracket\n        if myString[i] == '[' && len(bracketStack) > 0 && bracketStack[len(bracketStack) - 1] != i {\n            bracketStack = bracketStack[:len(bracketStack) - 1]\n        }\n        \n        // If the current character is a bracket and the top of the stack is a bracket and the\n        // current bracket is not nested, pop the top of the stack and compare it to the current bracket\n        if myString[i] == '[' && len(bracketStack) > 0 && bracketStack[len(bracketStack) - 1] == i && bracketStack[len(bracketStack) - 2] != i {\n            bracketStack = bracketStack[:len(bracketStack) - 1]\n        }\n        \n        // If the current character is a bracket and the top of the stack is a bracket and the\n        // current bracket is nested, pop the top of the stack and compare it to the current bracket\n        if myString[i] == '[' && len(bracketStack) > 0 && bracketStack[len(bracketStack) - 1] == i && bracketStack[len(bracketStack) - 2] == i {\n            bracketStack = bracketStack[:\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpujwt2cwf_test.go:58:6: expected '(', found TestIs_Nested\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What is the expected output?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp5t_c8h9i_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp5t_c8h9i_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp5t_c8h9i_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp5t_c8h9i_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp5t_c8h9i_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to hold the brackets\n    brackets := make([]int, 0)\n    \n    // Iterate through the string and push the brackets onto the stack\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            brackets = append(brackets, i)\n        }\n    }\n    \n    // Iterate through the stack and pop the brackets off the stack\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if myString[brackets[i]] == ']' {\n            brackets = append(brackets[:i], brackets[i+1:]...)\n        }\n    }\n    \n    // If the stack is empty, then the brackets are all nested\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    // If the stack is not empty, then the brackets are not nested\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpc5_nznik_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpc5_nznik_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpc5_nznik_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpc5_nznik_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpc5_nznik_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpc5_nznik_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__13 (0.00s)\n        tmpc5_nznik_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice to hold the brackets\n    brackets := make([]string, 0)\n    \n    // Create a string slice to hold the brackets that are not nested\n    nonNestedBrackets := make([]string, 0)\n    \n    // Create a string slice to hold the brackets that are nested\n    nestedBrackets := make([]string, 0)\n    \n    // Iterate through the string and create a slice of brackets\n    for _, char := range myString {\n        if char == '[' {\n            brackets = append(brackets, char)\n        } else if char == ']' {\n            brackets = append(brackets, char)\n        }\n    }\n    \n    // Iterate through the string and create a slice of brackets that are not nested\n    for _, char := range brackets {\n        if char == '[' {\n            nonNestedBrackets = append(nonNestedBrackets, char)\n        } else if char == ']' {\n            nonNestedBrackets = append(nonNestedBrackets, char)\n        }\n    }\n    \n    // Iterate through the string and create a slice of brackets that are nested\n    for _, char := range brackets {\n        if char == '[' {\n            nestedBrackets = append(nestedBrackets, char)\n        } else if char == ']' {\n            nestedBrackets = append(nestedBrackets, char)\n        }\n    }\n    \n    // Check if there is a valid subsequence of brackets where at least one bracket in the subsequence is nested\n    if len(nestedBrackets) > 0 {\n        return true\n    } else {\n        return false\n    }\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl5_cr8rh_test.go:37:30: cannot use char (type rune) as type string in append\n/tmp/tmpl5_cr8rh_test.go:39:30: cannot use char (type rune) as type string in append\n/tmp/tmpl5_cr8rh_test.go:45:17: cannot use '[' (type untyped rune) as type string\n/tmp/tmpl5_cr8rh_test.go:47:24: cannot use ']' (type untyped rune) as type string\n/tmp/tmpl5_cr8rh_test.go:54:17: cannot use '[' (type untyped rune) as type string\n/tmp/tmpl5_cr8rh_test.go:56:24: cannot use ']' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code goes here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmphqn4nulk_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmphqn4nulk_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmphqn4nulk_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmphqn4nulk_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmphqn4nulk_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice that will hold the brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add the brackets to the slice\n    for _, char := range myString {\n        if char == '[' {\n            brackets = append(brackets, \"[\")\n        } else if char == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // If the slice is empty, then the string is not nested\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // Create a slice that will hold the indices of the brackets\n    indices := make([]int, 0)\n    \n    // Iterate through the string and add the indices to the slice\n    for i, char := range myString {\n        if char == '[' {\n            indices = append(indices, i)\n        } else if char == ']' {\n            indices = append(indices, i)\n        }\n    }\n    \n    // If the slice is empty, then the string is not nested\n    if len(indices) == 0 {\n        return false\n    }\n    \n    // Create a slice that will hold the indices of the brackets that are not nested\n    nonNestedIndices := make([]int, 0)\n    \n    // Iterate through the indices and add the indices to the slice\n    for i, index := range indices {\n        if i == 0 || i == len(indices) - 1 {\n            continue\n        }\n        if brackets[index] == brackets[indices[i - 1]] && brackets[index] == brackets[indices[i + 1]] {\n            continue\n        }\n        nonNestedIndices = append(nonNestedIndices, index)\n    }\n    \n    // If the slice is empty, then the string is not nested\n    if len(nonNestedIndices) == 0 {\n        return false\n    }\n    \n    // Iterate through the indices and remove the brackets from the string\n    for _, index := range nonNestedIndices {\n        myString = myString[:index] + myString[index + 1:]\n    }\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpg2fysgy2_test.go:82:6: expected '(', found TestIs_Nested\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Your code here\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Your code here\n    \n    return false\n}\n\n// This test will not pass.\n// >>> is_nested(\"[[[]]\")\n// false\n// >>> is_nested(\"[[[]]]\")\n// true\n// >>> is_nested(\"[[[[]]]\")\n// false\n// >>> is_nested(\"[[[[]]]\")\n// true\n// >>> is_nested(\"[[[[[]]]]\")\n// false\n// >>> is_nested(\"[[[[[]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// true\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpyeqa9i1h_test.go:108: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpyeqa9i1h_test.go:108: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpyeqa9i1h_test.go:108: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpyeqa9i1h_test.go:108: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpyeqa9i1h_test.go:108: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to hold the brackets\n    bracketStack := make([]int, 0)\n    \n    // Iterate through the string\n    for i := 0; i < len(myString); i++ {\n        \n        // If the current character is a bracket, push it onto the stack\n        if myString[i] == '[' {\n            bracketStack = append(bracketStack, i)\n        }\n        \n        // If the current character is a bracket and the top of the stack is a bracket,\n        // pop the top of the stack and compare it to the current bracket\n        if myString[i] == '[' && len(bracketStack) > 0 && bracketStack[len(bracketStack) - 1] == i {\n            bracketStack = bracketStack[:len(bracketStack) - 1]\n        }\n        \n        // If the current character is a bracket and the top of the stack is not a bracket,\n        // pop the top of the stack and compare it to the current bracket\n        if myString[i] == '[' && len(bracketStack) > 0 && bracketStack[len(bracketStack) - 1] != i {\n            bracketStack = bracketStack[:len(bracketStack) - 1]\n        }\n        \n        // If the current character is a bracket and the top of the stack is an empty bracket,\n        // pop the top of the stack and compare it to the current bracket\n        if myString[i] == '[' && len(bracketStack) > 0 && bracketStack[len(bracketStack) - 1] == 0 {\n            bracketStack = bracketStack[:len(bracketStack) - 1]\n        }\n        \n        // If the current character is a bracket and the top of the stack is not an empty bracket,\n        // push the current bracket onto the stack\n        if myString[i] == '[' && len(bracketStack) > 0 && bracketStack[len(bracketStack) - 1] != 0 {\n            bracketStack = append(bracketStack, i)\n        }\n    }\n    \n    // If the stack is empty, the string is valid\n    if len(bracketStack) == 0 {\n        return true\n    }\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8_h10ct1_test.go:65:6: expected '(', found TestIs_Nested\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            j = i + 1\n            for j < len(myString) {\n                if myString[j] == '[' {\n                    j++\n                } else if myString[j] == ']' {\n                    j++\n                    if j < len(myString) && myString[j] == ']' {\n                        j++\n                    } else {\n                        break\n                    }\n                } else {\n                    break\n                }\n            }\n            if j == len(myString) {\n                is_nested = true\n            }\n        }\n    }\n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpqoln3dc__test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpqoln3dc__test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpqoln3dc__test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmpqoln3dc__test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpqoln3dc__test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmpqoln3dc__test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpqoln3dc__test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Your code here\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            stack = append(stack, \"\")\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if myString[i] == ']' {\n                stack[len(stack)-1] = stack[len(stack)-1] + myString[i]\n            } else {\n                stack[len(stack)-1] = stack[len(stack)-1] + myString[i]\n            }\n        }\n    }\n    return len(stack) > 0 && stack[len(stack)-1] != \"\"\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb81er7b9_test.go:33:59: invalid operation: stack[len(stack) - 1] + myString[i] (mismatched types string and byte)\n/tmp/tmpb81er7b9_test.go:35:59: invalid operation: stack[len(stack) - 1] + myString[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    var result bool\n    \n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else if char == ']' {\n            if len(stack) == 0 {\n                result = false\n                break\n            } else {\n                stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    \n    if len(stack) > 0 {\n        result = true\n    }\n    \n    return result\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpjz4qah7a_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpjz4qah7a_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpjz4qah7a_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpjz4qah7a_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpjz4qah7a_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpjz4qah7a_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested_test(\"[[]]\")\n// true\n// >>> is_nested_test(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested_test(\"[][]\")\n// false\n// >>> is_nested_test(\"[]\")\n// false\n// >>> is_nested_test(\"[[][]\")\n// true\n// >>> is_nested_test(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpn2vud6on_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpn2vud6on_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpn2vud6on_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpn2vud6on_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    return len(stack) > 1\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpcshkpxsy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpcshkpxsy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpcshkpxsy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpcshkpxsy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n        \n        if count < 0 {\n            return false\n        }\n        \n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                \n                if myString[j] == ']' {\n                    count--\n                }\n                \n                if count < 0 {\n                    return false\n                }\n            }\n        }\n    }\n    \n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp72c26gvt_test.go:27:9: is_nested declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested_test(\"[[]]\")\n// true\n// >>> is_nested_test(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested_test(\"[][]\")\n// false\n// >>> is_nested_test(\"[]\")\n// false\n// >>> is_nested_test(\"[[][]\")\n// true\n// >>> is_nested_test(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpn2vud6on_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpn2vud6on_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpn2vud6on_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpn2vud6on_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to store the brackets\n    brackets := make([]int, 0)\n    \n    // Iterate through the string\n    for i := 0; i < len(myString); i++ {\n        \n        // If the current character is a left bracket, push it onto the stack\n        if myString[i] == '[' {\n            brackets = append(brackets, i)\n        }\n        \n        // If the current character is a right bracket, pop it off the stack\n        if myString[i] == ']' {\n            brackets = brackets[:len(brackets)-1]\n        }\n    }\n    \n    // If the stack is empty, the string is valid\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    // If the stack is not empty, the string is invalid\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.is_nested(...)\n\t/tmp/tmp5rm9bglq_test.go:38\ncommand-line-arguments_test.TestIs_Nested(0xc000001380)\n\t/tmp/tmp5rm9bglq_test.go:59 +0x12d3\ntesting.tRunner(0xc000001380, 0x54f238)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var is_nested bool\n    var i int\n    var j int\n    var open_bracket_count int\n    var close_bracket_count int\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            open_bracket_count++\n        }\n        if myString[i] == ']' {\n            close_bracket_count++\n        }\n    }\n    \n    if open_bracket_count == close_bracket_count {\n        is_nested = true\n    } else {\n        is_nested = false\n    }\n    \n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp88l3mfyk_test.go:26:9: j declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpo122g9z8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to store the brackets\n    bracketStack := make([]int, 0)\n    \n    // Iterate through the string\n    for i := 0; i < len(myString); i++ {\n        \n        // If the current character is a left bracket, push it onto the stack\n        if myString[i] == '[' {\n            bracketStack = append(bracketStack, i)\n        }\n        \n        // If the current character is a right bracket, pop the top of the stack\n        // and compare it to the current character\n        if myString[i] == ']' {\n            if len(bracketStack) > 0 {\n                if bracketStack[len(bracketStack) - 1] == i {\n                    bracketStack = bracketStack[:len(bracketStack) - 1]\n                } else {\n                    return false\n                }\n            } else {\n                return false\n            }\n        }\n    }\n    \n    // If the stack is empty, then the brackets are nested\n    if len(bracketStack) == 0 {\n        return true\n    }\n    \n    // If the stack is not empty, then the brackets are not nested\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpmm9q3t7u_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpmm9q3t7u_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpmm9q3t7u_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpmm9q3t7u_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpmm9q3t7u_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpmm9q3t7u_test.go:86: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var isNested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for j = 0; j < len(myString); j++ {\n        if myString[j] == ']' {\n            count--\n        }\n        \n        if count < 0 {\n            return false\n        }\n        \n        if myString[j] == '[' {\n            count++\n        }\n    }\n    \n    if count == 0 {\n        isNested = true\n    }\n    \n    return isNested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp_g395eqv_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp_g395eqv_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp_g395eqv_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmp_g395eqv_test.go:82: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp_g395eqv_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp_g395eqv_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmp_g395eqv_test.go:82: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the sum of the first 10 digits of the sum of the first 100 digits of the sum of the first 1000 digits of the sum of the first 10000 digits of the sum of the first 100000 digits of the sum of the first 1000000 digits of the sum of the first 10000000 digits of the sum of the first 100000000 digits of the sum of the first 1000000000 digits of the sum of the first 10000000000 digits of the sum of the first 100000000000 digits of the sum of the first 1000000000000 digits of the sum of the first 10000000000000 digits of the sum of the first 100000000000000 digits of the sum of the first 1000000000000000 digits of the sum of the first 10000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of the first 100000000000000000 digits of the sum of the first 10000000000000000000 digits of the sum of\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpktmwgxcd_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpktmwgxcd_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpktmwgxcd_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpktmwgxcd_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpktmwgxcd_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n        if myString[i] == '[' && count > 0 {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                if myString[j] == ']' {\n                    count--\n                }\n                if myString[j] == ']' && count == 0 {\n                    is_nested = true\n                    break\n                }\n            }\n            if is_nested {\n                break\n            }\n        }\n    }\n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmp8tphj0rc_test.go:84: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp8tphj0rc_test.go:84: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmp8tphj0rc_test.go:84: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp8tphj0rc_test.go:84: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmp8tphj0rc_test.go:84: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp8tphj0rc_test.go:84: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n    }\n    \n    if count == 0 {\n        return true\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                if myString[j] == ']' {\n                    count--\n                }\n                if count == 0 {\n                    is_nested = true\n                    break\n                }\n            }\n            if is_nested {\n                break\n            }\n        }\n    }\n    \n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmp5c935c6h_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmp5c935c6h_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp5c935c6h_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmp5c935c6h_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp5c935c6h_test.go:94: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmp5c935c6h_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a slice of strings that will hold the brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add each bracket to the slice\n    for _, char := range myString {\n        if char == '[' {\n            brackets = append(brackets, \"[\")\n        } else if char == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // Check if the brackets are nested\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == \"]\" && brackets[i+1] == \"[\" {\n            return true\n        }\n    }\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.is_nested(0x54543e, 0x4, 0x438)\n\t/tmp/tmpnqohugjd_test.go:39 +0x295\ncommand-line-arguments_test.TestIs_Nested(0xc000102600)\n\t/tmp/tmpnqohugjd_test.go:54 +0x56\ntesting.tRunner(0xc000102600, 0x54f238)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a stack to store the brackets\n    brackets := make([]int, 0)\n    \n    // Iterate through the string\n    for i := 0; i < len(myString); i++ {\n        \n        // If the current character is a bracket, push it onto the stack\n        if myString[i] == '[' {\n            brackets = append(brackets, i)\n        }\n        \n        // If the current character is a bracket and the top of the stack is a bracket,\n        // then the brackets are nested\n        if myString[i] == '[' && len(brackets) > 0 && brackets[len(brackets) - 1] == i {\n            return true\n        }\n        \n        // If the current character is a bracket and the top of the stack is not a bracket,\n        // then pop the top of the stack and continue\n        if myString[i] == '[' && len(brackets) > 0 && brackets[len(brackets) - 1] != i {\n            brackets = brackets[:len(brackets) - 1]\n            continue\n        }\n    }\n    \n    // If the stack is empty, then the brackets are not nested\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // If the stack is not empty, then the brackets are nested\n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmp4ng8ju1a_test.go:85: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmp4ng8ju1a_test.go:85: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp4ng8ju1a_test.go:85: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmp4ng8ju1a_test.go:85: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmp4ng8ju1a_test.go:85: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmp4ng8ju1a_test.go:85: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmp4ng8ju1a_test.go:85: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    return len(stack) > 1\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmpcshkpxsy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpcshkpxsy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpcshkpxsy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpcshkpxsy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What if you have a string with nested square brackets?\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpd5kt_spe_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n        if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                if myString[j] == ']' {\n                    count--\n                }\n                if count < 0 {\n                    return false\n                }\n            }\n        }\n    }\n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp7sxrr475_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp7sxrr475_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp7sxrr475_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmp7sxrr475_test.go:82: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp7sxrr475_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmp7sxrr475_test.go:82: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmp7sxrr475_test.go:82: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a slice of brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add brackets to the slice\n    for _, char := range myString {\n        if char == '[' {\n            brackets = append(brackets, \"[\")\n        } else if char == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // If the slice is empty, return false\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // Create a slice of brackets that are not nested\n    nonNestedBrackets := make([]string, 0)\n    \n    // Iterate through the slice and add brackets to the nonNestedBrackets slice\n    for _, char := range brackets {\n        if char == '[' {\n            nonNestedBrackets = append(nonNestedBrackets, \"[\")\n        } else if char == ']' {\n            nonNestedBrackets = append(nonNestedBrackets, \"]\")\n        }\n    }\n    \n    // If the slice is empty, return false\n    if len(nonNestedBrackets) == 0 {\n        return false\n    }\n    \n    // Iterate through the nonNestedBrackets slice and check if there is a nested bracket\n    for i := 0; i < len(nonNestedBrackets); i++ {\n        if nonNestedBrackets[i] == '[' {\n            for j := i + 1; j < len(nonNestedBrackets); j++ {\n                if nonNestedBrackets[j] == '[' {\n                    return true\n                }\n            }\n        }\n    }\n    \n    // If there is no nested bracket, return false\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf7nnc620_test.go:47:17: cannot use '[' (type untyped rune) as type string\n/tmp/tmpf7nnc620_test.go:49:24: cannot use ']' (type untyped rune) as type string\n/tmp/tmpf7nnc620_test.go:61:33: cannot use '[' (type untyped rune) as type string\n/tmp/tmpf7nnc620_test.go:63:41: cannot use '[' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Your code here\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Check if the string is empty\n    if len(myString) == 0 {\n        return false\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '[' && myString[len(myString)-1] == ']' {\n        return true\n    }\n    \n    // Check if the string is a single bracket\n    if myString[0] == '['\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0wmd3qqy_test.go:82:6: expected '(', found TestIs_Nested\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Your code here\n    \n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpqixi_osf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n            stack = append(stack, myString[i])\n        } else if myString[i] == ']' {\n            count--\n            if count < 0 {\n                return false\n            } else if count == 0 {\n                stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpja7mnsib_test.go:29:27: cannot use myString[i] (type byte) as type string in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n        \n        if myString[i] == '[' && count > 0 {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                \n                if myString[j] == ']' && count > 0 {\n                    count--\n                    is_nested = true\n                    break\n                }\n            }\n            \n            if is_nested == true {\n                break\n            }\n        }\n    }\n    \n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmp5_m8e8qh_test.go:88: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmp5_m8e8qh_test.go:88: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp5_m8e8qh_test.go:88: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmp5_m8e8qh_test.go:88: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmp5_m8e8qh_test.go:88: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmp5_m8e8qh_test.go:88: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice that will hold the brackets\n    brackets := make([]string, 0)\n    \n    // Iterate through the string and add each bracket to the slice\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            brackets = append(brackets, \"[\")\n        } else if myString[i] == ']' {\n            brackets = append(brackets, \"]\")\n        }\n    }\n    \n    // If the slice is empty, then the string is not nested\n    if len(brackets) == 0 {\n        return false\n    }\n    \n    // Create a slice that will hold the indices of the brackets\n    indices := make([]int, 0)\n    \n    // Iterate through the string and add each index to the slice\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            indices = append(indices, i)\n        } else if myString[i] == ']' {\n            indices = append(indices, i)\n        }\n    }\n    \n    // Iterate through the indices and check if any of them are nested\n    for i := 0; i < len(indices); i++ {\n        if indices[i] > indices[i+1] {\n            return true\n        }\n    }\n    \n    // If the slice is empty, then the string is not nested\n    if len(indices) == 0 {\n        return false\n    }\n    \n    // Iterate through the indices and check if any of them are nested\n    for i := 0; i < len(indices); i++ {\n        if indices[i] > indices[i+1] {\n            return true\n        }\n    }\n    \n    // If the slice is empty, then the string is not nested\n    if len(indices) == 0 {\n        return false\n    }\n    \n    // Iterate through the indices and check if any of them are nested\n    for i := 0; i < len(indices); i++ {\n        if indices[i] > indices[i+1] {\n            return\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph5oidbq__test.go:82:6: expected '(', found TestIs_Nested\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\n// This test will call your function and verify if your code returns the correct results.\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpq16buykn_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpq16buykn_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpq16buykn_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpq16buykn_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpq16buykn_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code goes here\n    return false\n}\n\n// The main function\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpitu3_zgy_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code goes here\n    return false\n}\n\n// This test will not run because it depends on your solution to the previous test.\n// We just want to make sure that your solution works for the test cases provided.\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpqvj7sfrn_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpqvj7sfrn_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpqvj7sfrn_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpqvj7sfrn_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpqvj7sfrn_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    var result bool\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else if char == ']' {\n            if len(stack) == 0 {\n                result = false\n                break\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) > 0 {\n        result = true\n    }\n    return result\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpt7nf08v6_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpt7nf08v6_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpt7nf08v6_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmpt7nf08v6_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpt7nf08v6_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmpt7nf08v6_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\n// What if you cannot use the brackets?\n// >>> is_nested(\"[[[[]]]]\")\n// false\n// >>> is_nested(\"[[[[[]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[]]]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]\")\n// false\n// >>> is_nested(\"[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpqjb7whfb_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpqjb7whfb_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpqjb7whfb_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpqjb7whfb_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpqjb7whfb_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            j = i\n            is_nested = false\n            for j < len(myString) {\n                if myString[j] == '[' {\n                    is_nested = true\n                    break\n                }\n                j++\n            }\n            if !is_nested {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__1 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__5 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__7 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__8 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__12 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__13 (0.00s)\n        tmp5zejs1wd_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the above function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp7jn5wrjd_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp7jn5wrjd_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp7jn5wrjd_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp7jn5wrjd_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp7jn5wrjd_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n    }\n    \n    if count == 0 {\n        is_nested = true\n    } else {\n        is_nested = false\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n            }\n        }\n    }\n    \n    if count == 0 {\n        is_nested = true\n    } else {\n        is_nested = false\n    }\n    \n    return is_nested\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpkmwkjqow_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpkmwkjqow_test.go:92: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpkmwkjqow_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpkmwkjqow_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpkmwkjqow_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpkmwkjqow_test.go:92: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpkmwkjqow_test.go:92: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What is the expected output of the function?\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpghxapwhv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\n// What happens if we change the string to \"]][[]]\"\n// >>> is_nested(\"]][[]]\")\n// true\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[][]][[\")\n// true\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmp2h5o8otl_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmp2h5o8otl_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmp2h5o8otl_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp2h5o8otl_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmp2h5o8otl_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpxpc89c1b_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    \n    // Create a string slice of the string\n    mySlice := []rune(myString)\n    \n    // Create a variable to hold the index of the first bracket\n    firstBracketIndex := -1\n    \n    // Create a variable to hold the index of the last bracket\n    lastBracketIndex := -1\n    \n    // Create a variable to hold the index of the current bracket\n    currentBracketIndex := -1\n    \n    // Create a variable to hold the index of the previous bracket\n    previousBracketIndex := -1\n    \n    // Create a variable to hold the index of the next bracket\n    nextBracketIndex := -1\n    \n    // Create a variable to hold the index of the first square bracket\n    firstSquareBracketIndex := -1\n    \n    // Create a variable to hold the index of the last square bracket\n    lastSquareBracketIndex := -1\n    \n    // Create a variable to hold the index of the current square bracket\n    currentSquareBracketIndex := -1\n    \n    // Create a variable to hold the index of the previous square bracket\n    previousSquareBracketIndex := -1\n    \n    // Create a variable to hold the index of the next square bracket\n    nextSquareBracketIndex := -1\n    \n    // Create a variable to hold the index of the first parenthesis\n    firstParenthesisIndex := -1\n    \n    // Create a variable to hold the index of the last parenthesis\n    lastParenthesisIndex := -1\n    \n    // Create a variable to hold the index of the current parenthesis\n    currentParenthesisIndex := -1\n    \n    // Create a variable to hold the index of the previous parenthesis\n    previousParenthesisIndex := -1\n    \n    // Create a variable to hold the index of the next parenthesis\n    nextParenthesisIndex := -1\n    \n    // Create a variable to hold the index of the first curly bracket\n    firstCurlyBracketIndex := -1\n    \n    // Create a variable to hold the index of the last curly bracket\n    lastCurlyBracketIndex := -1\n    \n    // Create a variable to hold the index of the current curly bracket\n    currentCurlyBracketIndex := -1\n    \n    // Create a variable to hold the\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpp0u1f92n_test.go:83:6: expected '(', found TestIs_Nested\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // your code goes here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpraa7dj1j_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpnf5bf8s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmpf1x6s0at_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var count int\n    var i int\n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        } else if myString[i] == ']' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmp82po84bd_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmp82po84bd_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmp82po84bd_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmp82po84bd_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n        \n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                \n                if myString[j] == ']' {\n                    count--\n                }\n                \n                if count < 0 {\n                    return false\n                }\n            }\n        }\n    }\n    \n    return count == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7q6krvmx_test.go:27:9: is_nested declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var stack []string\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, \"\")\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__2 (0.00s)\n        tmpfcc_6qr4_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__3 (0.00s)\n        tmpfcc_6qr4_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmpfcc_6qr4_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__11 (0.00s)\n        tmpfcc_6qr4_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    var i int\n    var j int\n    var count int\n    var is_nested bool\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            count++\n        }\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == ']' {\n            count--\n        }\n    }\n    \n    if count < 0 {\n        return false\n    }\n    \n    for i = 0; i < len(myString); i++ {\n        if myString[i] == '[' {\n            for j = i + 1; j < len(myString); j++ {\n                if myString[j] == '[' {\n                    count++\n                }\n                if myString[j] == ']' {\n                    count--\n                }\n                if count < 0 {\n                    return false\n                }\n            }\n        }\n    }\n    \n    return true\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpys824xiz_test.go:27:9: is_nested declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestIs_Nested (0.00s)\n    --- FAIL: TestIs_Nested/test_num__0 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__4 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__6 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__9 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Nested/test_num__10 (0.00s)\n        tmph209blzj_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}