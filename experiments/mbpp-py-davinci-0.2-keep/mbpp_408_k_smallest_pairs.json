{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "py",
  "prompt": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "def check(candidate):\n    assert candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]\n    assert candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]]\n    assert candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n\ndef test_check():\n    check(k_smallest_pairs)\n\ntest_check()\n",
  "stop_tokens": [
    "\ndef",
    "\n#",
    "\nif",
    "\nclass"
  ],
  "completions": [
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [i[1] for i in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]\n\nprint(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            elif nums1[i] + nums2[j] < heap[0][0]:\n                heapq.heappushpop(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    if k <= 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappushpop(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for i in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [pair[1] for pair in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        if heap:\n            res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k <= 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n\nprint(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        if heap:\n            res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    if k <= 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    res = []\n    visited = set()\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))\nprint(k_smallest_pairs([1,1,2], [1,2,3], 2))\nprint(k_smallest_pairs([1,2], [3], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))\nprint(k_smallest_pairs([1,1,2], [1,2,3], 2))\nprint(k_smallest_pairs([1,2], [3], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(min(k, len(heap))):\n        res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappushpop(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n                else:\n                    break\n    return [[-x[0] - nums2[x[2]], nums2[x[2]]] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    res = []\n    while heap:\n        res.append([nums1[heap[0][1]], nums2[heap[0][2]]])\n        heapq.heappop(heap)\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    res = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            res.append([nums1[i], nums2[j]])\n    res.sort(key=lambda x: x[0] + x[1])\n    return res[:k]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], nums1[i], nums2[j]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], nums1[i], nums2[j]))\n                else:\n                    break\n    return [[x[1], x[2]] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    while k > 0 and heap:\n        res.append(heapq.heappop(heap)[1])\n        k -= 1\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n\n    # heapify the first array\n    heap = []\n    for i in range(len(nums1)):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n    result = []\n    while heap and len(result) < k:\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return result",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [i[1] for i in heap]\n\nprint(k_smallest_pairs([1,1,2], [1,2,3], 10))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappushpop(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    return sorted(itertools.product(nums1, nums2), key=sum)[:k]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i]-nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i]-nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)] if k < len(heap) else [heapq.heappop(heap)[1] for _ in range(len(heap))]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "\n    if not nums1 or not nums2:\n        return []\n\n    if k == 0:\n        return []\n\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n\n    heap = []\n\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n\n    result = []\n    for i in range(k):\n        result.append(heapq.heappop(heap)[1])\n\n    return result\n\n\nprint(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3))\nprint(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2))\nprint(k_smallest_pairs([1, 2], [3], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)] if k <= len(heap) else [heapq.heappop(heap)[1] for _ in range(len(heap))]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            elif -nums1[i] - nums2[j] < heap[0][0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))][::-1]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    heap = []\n    for i in range(len(nums1)):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    while len(res) < k and heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    while k > 0 and heap:\n        res.append(heapq.heappop(heap)[1])\n        k -= 1\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < -heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: sum(x))\n    return pairs[:k]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[x, y] for x in nums1 for y in nums2]\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(res) < k:\n                res.append([nums1[i], nums2[j]])\n            else:\n                res.sort(key=lambda x: x[0] + x[1])\n                if nums1[i] + nums2[j] < res[-1][0] + res[-1][1]:\n                    res[-1] = [nums1[i], nums2[j]]\n    return res\n",
    "    # TODO: Implement me\n    pass\n\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    res = []\n    while heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n    return res[::-1]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [(nums1[i], nums2[j]) for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            elif nums1[i] + nums2[j] < heap[0][0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    res = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(res) < k:\n                res.append([nums1[i], nums2[j]])\n            else:\n                res.sort(key=lambda x: x[0] + x[1])\n                if nums1[i] + nums2[j] < res[-1][0] + res[-1][1]:\n                    res[-1] = [nums1[i], nums2[j]]\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    queue = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(queue) < k:\n                heapq.heappush(queue, (-nums1[i]-nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -queue[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(queue)\n                    heapq.heappush(queue, (-nums1[i]-nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [pair[1] for pair in queue]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    result = []\n    while k > 0:\n        result.append(heapq.heappop(heap)[1])\n        k -= 1\n    return result\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            elif nums1[i] + nums2[j] < heap[0][0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k <= 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    res = []\n    while heap:\n        res.append([nums1[heap[0][1]], nums2[heap[0][2]]])\n        heapq.heappop(heap)\n    return res[::-1]\n",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    while heap and k > 0:\n        res.append(heapq.heappop(heap)[1])\n        k -= 1\n    return res",
    "    # Time: O(klogk)\n    # Space: O(k)\n    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            res.append([nums1[i], nums2[j]])\n    res.sort(key=lambda x: x[0] + x[1])\n    return res[:k]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n\n    pairs.sort(key=lambda x: x[0] + x[1])\n\n    return pairs[:k]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while len(res) < k and heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    # Time: O(k*log(k))\n    # Space: O(k)\n    if not nums1 or not nums2:\n        return []\n    res = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(res) < k:\n                res.append([nums1[i], nums2[j]])\n            else:\n                res.sort(key=lambda x: x[0] + x[1])\n                if nums1[i] + nums2[j] < res[-1][0] + res[-1][1]:\n                    res.pop()\n                    res.append([nums1[i], nums2[j]])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k >= len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)]",
    "    if not nums1 or not nums2:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j == len(nums2) - 1:\n            continue\n        heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    return sorted([(x, y) for x in nums1 for y in nums2], key=lambda x: x[0] + x[1])[:k]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [item[1] for item in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        if heap:\n            res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        if heap:\n            res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i]-nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -nums1[i]-nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i]-nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]"
  ]
}