name: HumanEval_10_make_palindrome
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Find the shortest palindrome that begins with a supplied\
  \ string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of\
  \ supplied string that is a palindrome.\n    // - Append to the end of the string\
  \ reverse of a string prefix that comes before the palindromic suffix.\n    // >>>\
  \ makePalindrome((\"\"))\n    // (\"\")\n    // >>> makePalindrome((\"cat\"))\n\
  \    // (\"catac\")\n    // >>> makePalindrome((\"cata\"))\n    // (\"catac\")\n\
  \    public static String makePalindrome(String string) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        int n = string.length();\n        int i = 0;\n        int j\
    \ = n - 1;\n        int k = 0;\n        while (i < j) {\n            if (string.charAt(i)\
    \ == string.charAt(j)) {\n                i++;\n                j--;\n       \
    \     } else {\n                i = 0;\n                k++;\n               \
    \ j = n - 1 - k;\n            }\n        }\n        StringBuilder builder = new\
    \ StringBuilder(string);\n        builder.append(string.substring(0, n - k).reverse());\n\
    \        return builder.toString();", "        int n = string.length();\n    \
    \    if (n == 0) {\n            return string;\n        }\n        int i = n -\
    \ 1;\n        while (i >= 0) {\n            if (isPalindrome(string, i)) {\n \
    \               break;\n            }\n            i--;\n        }\n        String\
    \ prefix = string.substring(0, i + 1);\n        StringBuilder sb = new StringBuilder(prefix);\n\
    \        sb.reverse();\n        return string + sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          break;\n            }\n        }\n        if (i == j) {\n         \
    \   return string;\n        }\n        String prefix = string.substring(0, i);\n\
    \        StringBuilder reversePrefix = new StringBuilder(prefix);\n        reversePrefix.reverse();\n\
    \        sb.append(reversePrefix);\n        return sb.toString();", "        int\
    \ n = string.length();\n        int i = 0;\n        int j = n - 1;\n        while\
    \ (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n       \
    \         break;\n            }\n            i += 1;\n            j -= 1;\n  \
    \      }\n        if (i >= j) {\n            return string;\n        }\n     \
    \   StringBuilder builder = new StringBuilder();\n        builder.append(string);\n\
    \        for (int k = i - 1; k >= 0; k -= 1) {\n            builder.append(string.charAt(k));\n\
    \        }\n        return builder.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int i = string.length()\
    \ - 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(0,\
    \ i + 1))) {\n                break;\n            }\n            i--;\n      \
    \  }\n        String prefix = string.substring(0, i);\n        StringBuilder sb\
    \ = new StringBuilder(string);\n        sb.append(reverse(prefix));\n        return\
    \ sb.toString();", "        StringBuilder sb = new StringBuilder(string);\n  \
    \      StringBuilder rev = new StringBuilder(string).reverse();\n        int i\
    \ = 0;\n        for (; i < sb.length(); i++) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ sb.length() - i))) {\n                break;\n            }\n        }\n   \
    \     return sb.append(rev.substring(sb.length() - i)).toString();", "       \
    \ int n = string.length();\n        int[] z = new int[n];\n        int l = 0,\
    \ r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n \
    \               z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n       \
    \     while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n\
    \                z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n      \
    \      if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n    \
    \        }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = n - max - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n  \
    \          }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = n - max - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = n - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n      \
    \  }\n        sb.append(string);\n        return sb.toString();", "        if\
    \ (string.length() == 0) {\n            return string;\n        }\n        int\
    \ suffixLength = 0;\n        for (int i = string.length() - 1; i >= 0; i--) {\n\
    \            if (isPalindrome(string.substring(i))) {\n                suffixLength\
    \ = string.length() - i;\n                break;\n            }\n        }\n \
    \       String prefix = string.substring(0, string.length() - suffixLength);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = string.length() - 1;\n        while (i >= 0) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                sb.append(sb.substring(0,\
    \ string.length() - i).reverse());\n                break;\n            }\n  \
    \          i--;\n        }\n        return sb.toString();", "        // >>> findLongestPalindromicSuffix((\"\
    \"))\n        // (\"\")\n        // >>> findLongestPalindromicSuffix((\"cat\"\
    ))\n        // (\"t\")\n        // >>> findLongestPalindromicSuffix((\"cata\"\
    ))\n        // (\"a\")\n        // >>> findLongestPalindromicSuffix((\"catac\"\
    ))\n        // (\"catac\")\n        // >>> findLongestPalindromicSuffix((\"cataca\"\
    ))\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix((\"catacat\"\
    ))\n        // (\"catacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacata\"))\n        // (\"atacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatac\"))\n        // (\"catacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacataca\"))\n        // (\"atacataca\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacat\"))\n        // (\"catacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacata\"))\n        // (\"atacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatac\"))\n        // (\"catacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacataca\"))\n        // (\"atacatacataca\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacat\"))\n        // (\"catacatacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacata\"))\n        // (\"atacatacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacatac\"))\n        // (\"catacatacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacataca\"))\n        // (\"atac", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int i =\
    \ n - 1;\n        while (i >= 0) {\n            if (isPalindrome(string, i)) {\n\
    \                break;\n            }\n            i--;\n        }\n        String\
    \ prefix = string.substring(0, i + 1);\n        String suffix = string.substring(i\
    \ + 1);\n        StringBuilder sb = new StringBuilder();\n        sb.append(string);\n\
    \        sb.append(reverse(prefix));\n        return sb.toString();", "      \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    \
    \    int palindromeLength = 0;\n        for (int i = 0; i < string.length(); i++)\
    \ {\n            if (isPalindrome(string.substring(i))) {\n                palindromeLength\
    \ = string.length() - i;\n                break;\n            }\n        }\n \
    \       // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        StringBuilder builder = new StringBuilder(string);\n\
    \        builder.append(reverse(string.substring(0, string.length() - palindromeLength)));\n\
    \        return builder.toString();", "        String reversed = new StringBuilder(string).reverse().toString();\n\
    \        String palindrome = string + reversed;\n        return palindrome;",
  "        StringBuilder sb = new StringBuilder(string);\n        StringBuilder rev\
    \ = new StringBuilder(string).reverse();\n        int n = string.length();\n \
    \       int i = 0;\n        while (i < n) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ n - i))) {\n                break;\n            }\n            i++;\n      \
    \  }\n        return sb.append(rev.substring(n - i)).toString();", "        int\
    \ n = string.length();\n        int[] z = new int[n];\n        z[0] = n;\n   \
    \     int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if\
    \ (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n        \
    \    }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        return string + new StringBuilder(string.substring(0, n - max)).reverse().toString();",
  "        int length = string.length();\n        if (length == 0) {\n           \
    \ return string;\n        }\n        int longestPalindromeLength = 0;\n      \
    \  int longestPalindromeIndex = 0;\n        for (int i = 0; i < length; i++) {\n\
    \            int palindromeLength = 0;\n            int palindromeIndex = i;\n\
    \            int j = i;\n            int k = i;\n            while (j >= 0 &&\
    \ k < length && string.charAt(j) == string.charAt(k)) {\n                palindromeLength\
    \ = k - j + 1;\n                palindromeIndex = j;\n                j--;\n \
    \               k++;\n            }\n            if (palindromeLength > longestPalindromeLength)\
    \ {\n                longestPalindromeLength = palindromeLength;\n           \
    \     longestPalindromeIndex = palindromeIndex;\n            }\n            palindromeLength\
    \ = 0;\n            palindromeIndex = i;\n            j = i;\n            k =\
    \ i + 1;\n            while (j >= 0 && k < length && string.charAt(j) == string.charAt(k))\
    \ {\n                palindromeLength = k - j + 1;\n                palindromeIndex\
    \ = j;\n                j--;\n                k++;\n            }\n          \
    \  if (palindromeLength > longestPalindromeLength) {\n                longestPalindromeLength\
    \ = palindromeLength;\n                longestPalindromeIndex = palindromeIndex;\n\
    \            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string);\n        for (int i = longestPalindromeIndex\
    \ - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n       \
    \ }\n        return builder.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - z[n - 1]; i++) {\n            sb.append(string.charAt(n\
    \ - 1 - i));\n        }\n        sb.append(string);\n        return sb.toString();",
  "        int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int i = 0;\n        int j = n - 1;\n        while (i < j)\
    \ {\n            if (string.charAt(i) != string.charAt(j)) {\n               \
    \ break;\n            }\n            i++;\n            j--;\n        }\n     \
    \   if (i >= j) {\n            return string;\n        }\n        StringBuilder\
    \ sb = new StringBuilder(string);\n        for (int k = 0; k < i; k++) {\n   \
    \         sb.append(string.charAt(i - k - 1));\n        }\n        return sb.toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i > r) {\n                l = r = i;\n                while (r < n\
    \ && string.charAt(r - l) == string.charAt(r)) {\n                    r++;\n \
    \               }\n                z[i] = r - l;\n                r--;\n     \
    \       } else {\n                int k = i - l;\n                if (z[k] < r\
    \ - i + 1) {\n                    z[i] = z[k];\n                } else {\n   \
    \                 l = i;\n                    while (r < n && string.charAt(r\
    \ - l) == string.charAt(r)) {\n                        r++;\n                \
    \    }\n                    z[i] = r - l;\n                    r--;\n        \
    \        }\n            }\n        }\n        int max = 0;\n        for (int i\
    \ = 0; i < n; i++) {\n            if (z[i] == i + 1) {\n                max =\
    \ i + 1;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = max; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int[] z = new int[n];\n        int l = 0, r = 0;\n       \
    \ for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i]\
    \ = Math.min(r - i + 1, z[i - l]);\n            }\n            while (i + z[i]\
    \ < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n                z[i]++;\n\
    \            }\n            if (i + z[i] - 1 > r) {\n                l = i;\n\
    \                r = i + z[i] - 1;\n            }\n        }\n        int max\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (z[i] == i) {\n\
    \                max = i;\n            }\n        }\n        StringBuilder sb\
    \ = new StringBuilder();\n        for (int i = n - 1; i >= max; i--) {\n     \
    \       sb.append(string.charAt(i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();", "        int length = string.length();\n    \
    \    if (length == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < length; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = length - i;\n           \
    \     break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ length - longestPalindromeSuffixLength);\n        String reversePrefix = new\
    \ StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int i = 0;\n        int j = string.length() - 1;\n        while (i < j)\
    \ {\n            if (string.charAt(i) != string.charAt(j)) {\n               \
    \ break;\n            }\n            i += 1;\n            j -= 1;\n        }\n\
    \        if (i >= j) {\n            return string;\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        sb.append(string.substring(0, i));\n    \
    \    sb.append(makePalindrome(string.substring(i, j + 1)));\n        sb.append(string.substring(i,\
    \ j + 1));\n        return sb.toString();", "        StringBuilder builder = new\
    \ StringBuilder(string);\n        String reverse = builder.reverse().toString();\n\
    \        StringBuilder result = new StringBuilder();\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            if (string.substring(i).equals(reverse.substring(0,\
    \ string.length() - i))) {\n                result.append(string.substring(0,\
    \ i));\n                result.append(reverse);\n                return result.toString();\n\
    \            }\n        }\n        return \"\";", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        return string + reverse(string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength));", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (z[i] == n - i && i > max) {\n        \
    \        max = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - max; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.reverse();\n        sb.append(string);\n        return\
    \ sb.toString();", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int i = string.length() - 1;\n        while (i >= 0) {\n \
    \           if (isPalindrome(string.substring(i))) {\n                break;\n\
    \            }\n            i--;\n        }\n        String prefix = string.substring(0,\
    \ i);\n        StringBuilder sb = new StringBuilder(prefix);\n        sb.reverse();\n\
    \        return string + sb.toString();", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int maxPalindromeLength = 0;\n\
    \        int maxPalindromeIndex = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindromeLength = 0;\n            int palindromeIndex\
    \ = i;\n            int j = 0;\n            while (i - j >= 0 && i + j < string.length())\
    \ {\n                if (string.charAt(i - j) == string.charAt(i + j)) {\n   \
    \                 palindromeLength = 2 * j + 1;\n                    palindromeIndex\
    \ = i - j;\n                } else {\n                    break;\n           \
    \     }\n                j++;\n            }\n            if (palindromeLength\
    \ > maxPalindromeLength) {\n                maxPalindromeLength = palindromeLength;\n\
    \                maxPalindromeIndex = palindromeIndex;\n            }\n      \
    \      palindromeLength = 0;\n            palindromeIndex = i;\n            j\
    \ = 0;\n            while (i - j >= 0 && i + j + 1 < string.length()) {\n    \
    \            if (string.charAt(i - j) == string.charAt(i + j + 1)) {\n       \
    \             palindromeLength = 2 * j + 2;\n                    palindromeIndex\
    \ = i - j;\n                } else {\n                    break;\n           \
    \     }\n                j++;\n            }\n            if (palindromeLength\
    \ > maxPalindromeLength) {\n                maxPalindromeLength = palindromeLength;\n\
    \                maxPalindromeIndex = palindromeIndex;\n            }\n      \
    \  }\n        StringBuilder builder = new StringBuilder();\n        builder.append(string.substring(0,\
    \ maxPalindromeIndex));\n        builder.append(new StringBuilder(string.substring(maxPalindromeIndex\
    \ + maxPalindromeLength)).reverse());\n        builder.append(string.substring(maxPalindromeIndex\
    \ + maxPalindromeLength));\n        return builder.toString();", "        int\
    \ n = string.length();\n        int[] z = new int[n];\n        int l = 0, r =\
    \ 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n     \
    \           z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n           \
    \ while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n \
    \               z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n      \
    \      if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n    \
    \        }\n        }\n        return string + new StringBuilder(string.substring(0,\
    \ n - max)).reverse().toString();", "        // Find the longest palindromic suffix.\n\
    \        int longestPalindromicSuffixLength = 0;\n        for (int i = 0; i <\
    \ string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromicSuffixLength = string.length() - i;\n \
    \               break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - longestPalindromicSuffixLength)).reverse().toString();", "        int n =\
    \ string.length();\n        int[] dp = new int[n];\n        for (int i = 0; i\
    \ < n; i++) {\n            dp[i] = 1;\n        }\n        for (int i = 1; i <\
    \ n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (string.charAt(i)\
    \ == string.charAt(j)) {\n                    dp[i] = Math.max(dp[i], dp[j] +\
    \ 1);\n                }\n            }\n        }\n        int max = 0;\n   \
    \     for (int i = 0; i < n; i++) {\n            max = Math.max(max, dp[i]);\n\
    \        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(string);\n\
    \        for (int i = max; i < n; i++) {\n            sb.append(string.charAt(n\
    \ - i - 1));\n        }\n        return sb.toString();", "        StringBuilder\
    \ builder = new StringBuilder(string);\n        StringBuilder reverse = new StringBuilder(string);\n\
    \        reverse.reverse();\n        int i = 0;\n        while (i < string.length())\
    \ {\n            if (builder.toString().equals(reverse.toString())) {\n      \
    \          break;\n            }\n            builder.append(reverse.charAt(i));\n\
    \            i += 1;\n        }\n        return builder.toString();", "      \
    \  int length = string.length();\n        if (length == 0) {\n            return\
    \ string;\n        }\n        int[] z = new int[length];\n        int left = 0;\n\
    \        int right = 0;\n        for (int i = 1; i < length; i++) {\n        \
    \    if (i > right) {\n                left = right = i;\n                while\
    \ (right < length && string.charAt(right) == string.charAt(right - left)) {\n\
    \                    right++;\n                }\n                z[i] = right\
    \ - left;\n                right--;\n            } else {\n                int\
    \ k = i - left;\n                if (z[k] < right - i + 1) {\n               \
    \     z[i] = z[k];\n                } else {\n                    left = i;\n\
    \                    while (right < length && string.charAt(right) == string.charAt(right\
    \ - left)) {\n                        right++;\n                    }\n      \
    \              z[i] = right - left;\n                    right--;\n          \
    \      }\n            }\n        }\n        int maxZ = 0;\n        int maxZIndex\
    \ = 0;\n        for (int i = 1; i < length; i++) {\n            if (z[i] > maxZ)\
    \ {\n                maxZ = z[i];\n                maxZIndex = i;\n          \
    \  }\n        }\n        StringBuilder builder = new StringBuilder();\n      \
    \  builder.append(string);\n        for (int i = maxZIndex - maxZ - 1; i >= 0;\
    \ i--) {\n            builder.append(string.charAt(i));\n        }\n        return\
    \ builder.toString();", "        int n = string.length();\n        int[] z = new\
    \ int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n\
    \            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++)\
    \ {\n            if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n\
    \            }\n        }\n        StringBuilder sb = new StringBuilder();\n \
    \       for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    if (string.length() == 0) {\n            return string;\n        }\n    \
    \    int length = string.length();\n        int i = 0;\n        int j = length\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i += 1;\n            j\
    \ -= 1;\n        }\n        if (i == j) {\n            return string;\n      \
    \  }\n        String prefix = string.substring(0, i);\n        String suffix =\
    \ string.substring(i);\n        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return suffix + reversedPrefix + suffix;", "        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        StringBuilder sb = new StringBuilder(string);\n        sb.append(reverse(prefix));\n\
    \        return sb.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(0,\
    \ string.length() - i));\n        return sb.toString();", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int i =\
    \ n - 1;\n        while (i >= 0) {\n            if (isPalindrome(string, 0, i))\
    \ {\n                break;\n            }\n            i--;\n        }\n    \
    \    return string + reverse(string.substring(0, n - i - 1));", "        int n\
    \ = string.length();\n        int[] z = new int[n];\n        int l = 0, r = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n          \
    \      z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n            while\
    \ (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n       \
    \         z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n      \
    \          l = i;\n                r = i + z[i] - 1;\n            }\n        }\n\
    \        int max = 0;\n        for (int i = 0; i < n; i++) {\n            if (i\
    \ + z[i] == n) {\n                max = Math.max(max, z[i]);\n            }\n\
    \        }\n        StringBuilder sb = new StringBuilder();\n        for (int\
    \ i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    StringBuilder result = new StringBuilder(string);\n        StringBuilder\
    \ reverse = new StringBuilder(string).reverse();\n        int length = string.length();\n\
    \        for (int i = length; i >= 0; i--) {\n            if (string.substring(0,\
    \ i).equals(reverse.substring(length - i))) {\n                result.append(reverse.substring(0,\
    \ length - i));\n                break;\n            }\n        }\n        return\
    \ result.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        for (int i = 0; i < n; i++) {\n            if\
    \ (sb.substring(i).equals(rev.substring(0, n - i))) {\n                return\
    \ sb.append(rev.substring(n - i)).toString();\n            }\n        }\n    \
    \    return sb.append(rev.substring(1)).toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        StringBuilder sb\
    \ = new StringBuilder(prefix);\n        sb.reverse();\n        return string +\
    \ sb.toString();", "        StringBuilder sb = new StringBuilder(string);\n  \
    \      int i = 0;\n        for (; i < string.length(); i++) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                break;\n            }\n\
    \        }\n        sb.append(sb.reverse().substring(0, string.length() - i));\n\
    \        return sb.toString();", "        StringBuilder builder = new StringBuilder(string);\n\
    \        StringBuilder reverse = new StringBuilder(string);\n        reverse.reverse();\n\
    \        int length = string.length();\n        for (int i = 0; i < length; i++)\
    \ {\n            if (builder.toString().equals(reverse.toString())) {\n      \
    \          break;\n            }\n            builder.append(reverse.charAt(i));\n\
    \        }\n        return builder.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int maxPalindromeLength\
    \ = 0;\n        int maxPalindromeIndex = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindromeLength = 0;\n            int palindromeIndex\
    \ = i;\n            while (palindromeIndex >= 0 && palindromeIndex < string.length()\
    \ && string.charAt(palindromeIndex) == string.charAt(i)) {\n                palindromeLength++;\n\
    \                palindromeIndex--;\n            }\n            if (palindromeLength\
    \ > maxPalindromeLength) {\n                maxPalindromeLength = palindromeLength;\n\
    \                maxPalindromeIndex = palindromeIndex;\n            }\n      \
    \  }\n        StringBuilder result = new StringBuilder(string);\n        for (int\
    \ i = maxPalindromeIndex; i >= 0; i--) {\n            result.append(string.charAt(i));\n\
    \        }\n        return result.toString();", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        StringBuilder builder =\
    \ new StringBuilder(string);\n        for (int k = i; k >= 0; k--) {\n       \
    \     builder.append(string.charAt(k));\n        }\n        return builder.toString();",
  "        int length = string.length();\n        int longestPalindromeLength = 0;\n\
    \        for (int i = 0; i < length; i++) {\n            if (isPalindrome(string,\
    \ i, length - 1)) {\n                longestPalindromeLength = length - i;\n \
    \               break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ length - longestPalindromeLength);\n        return string + reverse(prefix);",
  "        int i = 0;\n        int j = string.length() - 1;\n        while (i < j)\
    \ {\n            if (string.charAt(i) != string.charAt(j)) {\n               \
    \ break;\n            }\n            i += 1;\n            j -= 1;\n        }\n\
    \        StringBuilder builder = new StringBuilder(string.substring(0, i));\n\
    \        builder.reverse();\n        builder.append(string);\n        return builder.toString();",
  "        int length = string.length();\n        int[] z = new int[length];\n   \
    \     int left = 0;\n        int right = 0;\n        for (int i = 1; i < length;\
    \ i++) {\n            if (i > right) {\n                left = right = i;\n  \
    \              while (right < length && string.charAt(right) == string.charAt(right\
    \ - left)) {\n                    right++;\n                }\n              \
    \  z[i] = right - left;\n                right--;\n            } else {\n    \
    \            int k = i - left;\n                if (z[k] < right - i + 1) {\n\
    \                    z[i] = z[k];\n                } else {\n                \
    \    left = i;\n                    while (right < length && string.charAt(right)\
    \ == string.charAt(right - left)) {\n                        right++;\n      \
    \              }\n                    z[i] = right - left;\n                 \
    \   right--;\n                }\n            }\n        }\n        int max = 0;\n\
    \        int index = 0;\n        for (int i = 1; i < length; i++) {\n        \
    \    if (z[i] == i) {\n                if (max < z[i]) {\n                   \
    \ max = z[i];\n                    index = i;\n                }\n           \
    \ }\n        }\n        StringBuilder builder = new StringBuilder();\n       \
    \ builder.append(string.substring(index));\n        builder.reverse();\n     \
    \   builder.append(string);\n        return builder.toString();", "        //\
    \ Find the longest palindromic suffix.\n        int maxPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                maxPalindromeSuffixLength = string.length() - i;\n      \
    \          break;\n            }\n        }\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        StringBuilder sb = new StringBuilder(string);\n        for (int i = 0;\
    \ i < string.length() - maxPalindromeSuffixLength; i++) {\n            sb.append(string.charAt(string.length()\
    \ - maxPalindromeSuffixLength - i - 1));\n        }\n        return sb.toString();",
  "        String reverse = new StringBuilder(string).reverse().toString();\n    \
    \    String lcs = longestCommonSubstring(string, reverse);\n        return string\
    \ + reverse.substring(lcs.length());", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversePrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;",
  "        StringBuilder sb = new StringBuilder(string);\n        int n = string.length();\n\
    \        for (int i = 0; i < n; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                sb.append(new StringBuilder(string.substring(0, i)).reverse());\n\
    \                break;\n            }\n        }\n        return sb.toString();",
  "        StringBuilder result = new StringBuilder(string);\n        int length =\
    \ string.length();\n        for (int i = 0; i < length; i++) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                result.append(new StringBuilder(string.substring(0,\
    \ i)).reverse());\n                break;\n            }\n        }\n        return\
    \ result.toString();", "        int n = string.length();\n        int[] z = new\
    \ int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n\
    \            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n\
    \            }\n        }\n        StringBuilder sb = new StringBuilder();\n \
    \       for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    // Find the longest palindromic suffix.\n        int suffixLength = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append the reverse of the prefix to the\
    \ end of the string.\n        return string + new StringBuilder(string.substring(0,\
    \ string.length() - suffixLength)).reverse().toString();", "        // >>> findLongestPalindromicSuffix(\"\
    cat\")\n        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"cata\"\
    )\n        // (\"a\")\n        // >>> findLongestPalindromicSuffix(\"catac\")\n\
    \        // (\"catac\")\n        // >>> findLongestPalindromicSuffix(\"cataca\"\
    )\n        // (\"aca\")\n        // >>> findLongestPalindromicSuffix(\"catacat\"\
    )\n        // (\"catacat\")\n        // >>> findLongestPalindromicSuffix(\"catacata\"\
    )\n        // (\"atacata\")\n        // >>> findLongestPalindromicSuffix(\"catacatac\"\
    )\n        // (\"catacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacataca\")\n        // (\"acatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacat\")\n        // (\"catacatacat\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacata\")\n        // (\"atacatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatac\")\n        // (\"catacatacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacataca\")\n        // (\"acatacatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacat\")\n        // (\"catacatacatacat\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacata\")\n        // (\"atacatacatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacatac\")\n        // (\"catacatacatacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacataca\")\n        // (\"acatacatacatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacatacat\")\n        // (\"catacatac", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversePrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;",
  "        int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int i = 0;\n        int j = n - 1;\n        while (i < j)\
    \ {\n            if (string.charAt(i) != string.charAt(j)) {\n               \
    \ break;\n            }\n            i++;\n            j--;\n        }\n     \
    \   if (i >= j) {\n            return string;\n        }\n        StringBuilder\
    \ sb = new StringBuilder(string);\n        for (int k = j - 1; k >= i; k--) {\n\
    \            sb.append(string.charAt(k));\n        }\n        return sb.toString();",
  "        StringBuilder sb = new StringBuilder(string);\n        StringBuilder sb2\
    \ = new StringBuilder(string);\n        StringBuilder sb3 = new StringBuilder(string);\n\
    \        StringBuilder sb4 = new StringBuilder(string);\n        StringBuilder\
    \ sb5 = new StringBuilder(string);\n        StringBuilder sb6 = new StringBuilder(string);\n\
    \        StringBuilder sb7 = new StringBuilder(string);\n        StringBuilder\
    \ sb8 = new StringBuilder(string);\n        StringBuilder sb9 = new StringBuilder(string);\n\
    \        StringBuilder sb10 = new StringBuilder(string);\n        StringBuilder\
    \ sb11 = new StringBuilder(string);\n        StringBuilder sb12 = new StringBuilder(string);\n\
    \        StringBuilder sb13 = new StringBuilder(string);\n        StringBuilder\
    \ sb14 = new StringBuilder(string);\n        StringBuilder sb15 = new StringBuilder(string);\n\
    \        StringBuilder sb16 = new StringBuilder(string);\n        StringBuilder\
    \ sb17 = new StringBuilder(string);\n        StringBuilder sb18 = new StringBuilder(string);\n\
    \        StringBuilder sb19 = new StringBuilder(string);\n        StringBuilder\
    \ sb20 = new StringBuilder(string);\n        StringBuilder sb21 = new StringBuilder(string);\n\
    \        StringBuilder sb22 = new StringBuilder(string);\n        StringBuilder\
    \ sb23 = new StringBuilder(string);\n        StringBuilder sb24 = new StringBuilder(string);\n\
    \        StringBuilder sb25 = new StringBuilder(string);\n        StringBuilder\
    \ sb26 = new StringBuilder(string);\n        StringBuilder sb27 = new StringBuilder(string);\n\
    \        StringBuilder sb28 = new StringBuilder(string);\n        StringBuilder\
    \ sb29 = new StringBuilder(string);\n        StringBuilder sb30 = new StringBuilder(string);\n\
    \        StringBuilder sb31 = new StringBuilder(string);\n        StringBuilder\
    \ sb32 = new StringBuilder(string);\n        StringBuilder sb33 = new StringBuilder(string);\n\
    \        StringBuilder sb34 = new StringBuilder(string);\n        StringBuilder\
    \ sb35 = new StringBuilder(string);\n        StringBuilder sb36 = new StringBuilder(string);\n\
    \        StringBuilder sb37 = new", "        int length = string.length();\n \
    \       int longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < length;\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromeSuffixLength = length - i;\n                break;\n    \
    \        }\n        }\n        String prefix = string.substring(0, length - longestPalindromeSuffixLength);\n\
    \        StringBuilder sb = new StringBuilder(prefix);\n        sb.reverse();\n\
    \        return string + sb.toString();", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ i = 0;\n        int j = length - 1;\n        while (i < j) {\n            if\
    \ (string.charAt(i) != string.charAt(j)) {\n                break;\n         \
    \   }\n            i++;\n            j--;\n        }\n        if (i >= j) {\n\
    \            return string;\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int k = j - 1; k >= i; k--) {\n            builder.append(string.charAt(k));\n\
    \        }\n        return builder.toString();", "        // Find the longest\
    \ palindromic suffix.\n        int length = string.length();\n        int suffixLength\
    \ = 0;\n        for (int i = 0; i < length; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = length - i;\n                break;\n    \
    \        }\n        }\n        // Append the reverse of the prefix to the end\
    \ of the string.\n        String prefix = string.substring(0, length - suffixLength);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        if (string.length() == 0) return\
    \ string;\n        int i = string.length() - 1;\n        while (i >= 0) {\n  \
    \          if (isPalindrome(string.substring(0, i + 1))) break;\n            i--;\n\
    \        }\n        return string + new StringBuilder(string.substring(0, i)).reverse().toString();",
  "        StringBuilder sb = new StringBuilder(string);\n        int i = 0;\n   \
    \     int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i)\
    \ == string.charAt(j)) {\n                i++;\n                j--;\n       \
    \     } else {\n                i = 0;\n                j--;\n            }\n\
    \        }\n        sb.append(sb.reverse().substring(string.length() - i));\n\
    \        return sb.toString();", "        // >>> findLongestPalindromicSuffix(\"\
    \")\n        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"cat\")\n\
    \        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"cata\")\n  \
    \      // (\"a\")\n        // >>> findLongestPalindromicSuffix(\"catac\")\n  \
    \      // (\"ac\")\n        // >>> findLongestPalindromicSuffix(\"cataca\")\n\
    \        // (\"aca\")\n        // >>> findLongestPalindromicSuffix(\"catacat\"\
    )\n        // (\"cat\")\n        // >>> findLongestPalindromicSuffix(\"catacatac\"\
    )\n        // (\"atac\")\n        // >>> findLongestPalindromicSuffix(\"catacataca\"\
    )\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix(\"catacatacat\"\
    )\n        // (\"cat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacata\"\
    )\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatac\"\
    )\n        // (\"atac\")\n        // >>> findLongestPalindromicSuffix(\"catacatacataca\"\
    )\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacat\"\
    )\n        // (\"cat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacata\"\
    )\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacatac\"\
    )\n        // (\"atac\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacataca\"\
    )\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacatacat\"\
    )\n        // (\"cat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacatacata\"\
    )\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatac",
  "        StringBuilder sb = new StringBuilder(string);\n        int i = 0;\n   \
    \     int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i)\
    \ == string.charAt(j)) {\n                i++;\n                j--;\n       \
    \     } else {\n                i = 0;\n                j--;\n            }\n\
    \        }\n        sb.append(sb.reverse().substring(string.length() - i));\n\
    \        return sb.toString();", "        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        if (i >= j) {\n            return string;\n        }\n   \
    \     String suffix = string.substring(i);\n        String prefix = string.substring(0,\
    \ i);\n        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return prefix + makePalindrome(suffix) + reversedPrefix;", "        int\
    \ n = string.length();\n        if (n == 0) {\n            return string;\n  \
    \      }\n        int[] z = new int[n];\n        z[0] = n;\n        int l = 0;\n\
    \        int r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i\
    \ <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n           \
    \ }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int palindromeSuffixLength = z[n - 1];\n      \
    \  StringBuilder result = new StringBuilder(string);\n        for (int i = n -\
    \ palindromeSuffixLength - 1; i >= 0; i--) {\n            result.append(string.charAt(i));\n\
    \        }\n        return result.toString();", "        if (string.length() ==\
    \ 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        return string + reverse(prefix);",
  "        // Find the longest palindromic suffix.\n        String suffix = \"\";\n\
    \        for (int i = string.length() - 1; i >= 0; i--) {\n            String\
    \ candidate = string.substring(i);\n            if (isPalindrome(candidate)) {\n\
    \                suffix = candidate;\n                break;\n            }\n\
    \        }\n        // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        String prefix = string.substring(0,\
    \ string.length() - suffix.length());\n        return string + reverse(prefix);",
  "        int n = string.length();\n        int[] p = new int[n];\n        for (int\
    \ i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        int c = 0;\n\
    \        int r = 0;\n        for (int i = 1; i < n; i++) {\n            int mirror\
    \ = 2 * c - i;\n            if (i < r) {\n                p[i] = Math.min(r -\
    \ i, p[mirror]);\n            }\n            while (i + 1 + p[i] < n && i - 1\
    \ - p[i] >= 0 && string.charAt(i + 1 + p[i]) == string.charAt(i - 1 - p[i])) {\n\
    \                p[i]++;\n            }\n            if (i + p[i] > r) {\n   \
    \             c = i;\n                r = i + p[i];\n            }\n        }\n\
    \        int maxLen = 0;\n        int centerIndex = 0;\n        for (int i = 1;\
    \ i < n; i++) {\n            if (i - p[i] == 0) {\n                if (p[i] >\
    \ maxLen) {\n                    maxLen = p[i];\n                    centerIndex\
    \ = i;\n                }\n            }\n        }\n        StringBuilder sb\
    \ = new StringBuilder();\n        sb.append(string.substring(maxLen));\n     \
    \   sb.reverse();\n        sb.append(string);\n        return sb.toString();",
  "        int longestPalindrome = longestPalindrome(string);\n        String prefix\
    \ = string.substring(0, string.length() - longestPalindrome);\n        String\
    \ reversePrefix = new StringBuilder(prefix).reverse().toString();\n        return\
    \ string + reversePrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        for (int i = 0; i < n; i++) {\n            if\
    \ (sb.substring(i).equals(rev.substring(0, n - i))) {\n                return\
    \ sb.append(rev.substring(n - i)).toString();\n            }\n        }\n    \
    \    return sb.append(rev.substring(1)).toString();", "        // Find the longest\
    \ palindromic suffix.\n        int suffixLength = 0;\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        String\
    \ prefix = string.substring(0, string.length() - suffixLength);\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        // Find the longest postfix of\
    \ supplied string that is a palindrome.\n        int longestPalindromeSuffixIndex\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixIndex = i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        return\
    \ string + new StringBuilder(string.substring(0, longestPalindromeSuffixIndex)).reverse().toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int longestPalindromePostfixLength = 0;\n        for (int i = 0; i <\
    \ string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromePostfixLength = string.length() - i;\n \
    \               break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - longestPalindromePostfixLength)).reverse().toString();", "        int n =\
    \ string.length();\n        if (n == 0) {\n            return string;\n      \
    \  }\n        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        return string + new\
    \ StringBuilder(string.substring(0, n - max)).reverse().toString();", "      \
    \  StringBuilder sb = new StringBuilder(string);\n        StringBuilder rev =\
    \ new StringBuilder(string).reverse();\n        int i = 0;\n        while (i <\
    \ sb.length() && !sb.substring(i).equals(rev.substring(0, sb.length() - i))) {\n\
    \            i++;\n        }\n        return sb.append(rev.substring(sb.length()\
    \ - i)).toString();", "        // Find the longest palindromic suffix.\n     \
    \   int longestPalindromicSuffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromicSuffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        return\
    \ string + reverse(string.substring(0, string.length() - longestPalindromicSuffixLength));",
  "        int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = n - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n      \
    \  }\n        sb.append(string);\n        return sb.toString();", "        int\
    \ length = string.length();\n        if (length == 0) {\n            return string;\n\
    \        }\n        int maxPalindromeLength = 0;\n        int maxPalindromeStart\
    \ = 0;\n        for (int i = 0; i < length; i++) {\n            int palindromeLength\
    \ = 0;\n            int palindromeStart = 0;\n            for (int j = 0; j <\
    \ length; j++) {\n                if (i + j >= length || i - j < 0) {\n      \
    \              break;\n                }\n                if (string.charAt(i\
    \ + j) != string.charAt(i - j)) {\n                    break;\n              \
    \  }\n                palindromeLength = j * 2 + 1;\n                palindromeStart\
    \ = i - j;\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n               \
    \ maxPalindromeStart = palindromeStart;\n            }\n            palindromeLength\
    \ = 0;\n            palindromeStart = 0;\n            for (int j = 0; j < length;\
    \ j++) {\n                if (i + j + 1 >= length || i - j < 0) {\n          \
    \          break;\n                }\n                if (string.charAt(i + j\
    \ + 1) != string.charAt(i - j)) {\n                    break;\n              \
    \  }\n                palindromeLength = j * 2 + 2;\n                palindromeStart\
    \ = i - j;\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n               \
    \ maxPalindromeStart = palindromeStart;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder();\n        builder.append(string);\n        for\
    \ (int i = maxPalindromeStart - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();", "        // Find the longest\
    \ palindromic suffix of the string.\n        int suffixLength = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        builder.append(new StringBuilder(string.substring(0,\
    \ string.length() - suffixLength)).reverse());\n        return builder.toString();",
  "        int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int i = 0;\n        int j = n - 1;\n        int k = 0;\n \
    \       while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                k++;\n                j = n - 1 - k;\n    \
    \        }\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        builder.append(new StringBuilder(string.substring(0, n - k)).reverse());\n\
    \        return builder.toString();", "        int n = string.length();\n    \
    \    int i = 0;\n        int j = n - 1;\n        while (i < j) {\n           \
    \ if (string.charAt(i) != string.charAt(j)) {\n                break;\n      \
    \      }\n            i += 1;\n            j -= 1;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        String prefix = string.substring(0,\
    \ i);\n        String suffix = string.substring(i);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return suffix + reversedPrefix\
    \ + suffix;", "        StringBuilder sb = new StringBuilder(string);\n       \
    \ int n = string.length();\n        int i = 0;\n        while (i < n) {\n    \
    \        if (isPalindrome(string.substring(i))) {\n                sb.append(sb.substring(0,\
    \ n - i));\n                break;\n            }\n            i++;\n        }\n\
    \        return sb.toString();", "        int n = string.length();\n        int[]\
    \ z = new int[n];\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\n     \
    \       if (i <= r)\n                z[i] = Math.min(r - i + 1, z[i - l]);\n \
    \           while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\n\
    \                ++z[i];\n            if (i + z[i] - 1 > r) {\n              \
    \  l = i;\n                r = i + z[i] - 1;\n            }\n        }\n     \
    \   int longestPalindrome = 0;\n        for (int i = 1; i < n; ++i) {\n      \
    \      if (i + z[i] == n) {\n                longestPalindrome = z[i];\n     \
    \           break;\n            }\n        }\n        StringBuilder sb = new StringBuilder(string.substring(longestPalindrome));\n\
    \        sb.reverse();\n        sb.append(string);\n        return sb.toString();",
  "        int n = string.length();\n        int i = 0;\n        while (i < n) {\n\
    \            if (isPalindrome(string.substring(i))) {\n                break;\n\
    \            }\n            i += 1;\n        }\n        String prefix = string.substring(0,\
    \ i);\n        String suffix = string.substring(i);\n        return suffix + reverse(prefix);",
  "        StringBuilder sb = new StringBuilder(string);\n        String reverse =\
    \ new StringBuilder(string).reverse().toString();\n        int length = string.length();\n\
    \        for (int i = length; i >= 0; i--) {\n            if (string.substring(0,\
    \ i).equals(reverse.substring(length - i))) {\n                return sb.append(reverse.substring(0,\
    \ length - i)).toString();\n            }\n        }\n        return null;", " \
    \       int n = string.length();\n        int[] z = new int[n];\n        for (int\
    \ i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n              \
    \  z[i] = Math.min(r - i + 1, z[i - l]);\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int[] z2 = new int[n];\n        for (int i = 1,\
    \ l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n                z2[i]\
    \ = Math.min(r - i + 1, z2[i - l]);\n            while (i + z2[i] < n && string.charAt(n\
    \ - z2[i] - 1) == string.charAt(n - i - z2[i] - 1))\n                ++z2[i];\n\
    \            if (i + z2[i] - 1 > r) {\n                l = i;\n              \
    \  r = i + z2[i] - 1;\n            }\n        }\n        int max = 0;\n      \
    \  for (int i = 0; i < n; ++i) {\n            if (z[i] + z2[n - i - 1] >= n) {\n\
    \                max = Math.max(max, z[i]);\n            }\n        }\n      \
    \  StringBuilder sb = new StringBuilder();\n        for (int i = n - max - 1;\
    \ i >= 0; --i) {\n            sb.append(string.charAt(i));\n        }\n      \
    \  sb.append(string);\n        return sb.toString();", "        // Find the longest\
    \ palindromic suffix.\n        int suffixLength = 0;\n        int stringLength\
    \ = string.length();\n        for (int i = 0; i < stringLength; i++) {\n     \
    \       if (string.charAt(i) == string.charAt(stringLength - 1 - i)) {\n     \
    \           suffixLength++;\n            } else {\n                break;\n  \
    \          }\n        }\n        // Reverse the prefix and append it to the end\
    \ of the string.\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int i = 0; i < stringLength - suffixLength; i++) {\n           \
    \ builder.append(string.charAt(stringLength - 1 - i));\n        }\n        return\
    \ builder.toString();", "        int length = string.length();\n        if (length\
    \ == 0) {\n            return string;\n        }\n        int longestPalindrome\
    \ = 0;\n        for (int i = 0; i < length; i++) {\n            int palindrome\
    \ = 0;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindrome++;\n       \
    \         } else {\n                    break;\n                }\n          \
    \  }\n            if (palindrome > longestPalindrome) {\n                longestPalindrome\
    \ = palindrome;\n            }\n        }\n        StringBuilder builder = new\
    \ StringBuilder(string);\n        for (int i = longestPalindrome; i < length;\
    \ i++) {\n            builder.append(string.charAt(length - i - 1));\n       \
    \ }\n        return builder.toString();", "        // >>> findLongestPalindromicSuffix((\"\
    \"))\n        // (\"\")\n        // >>> findLongestPalindromicSuffix((\"cat\"\
    ))\n        // (\"\")\n        // >>> findLongestPalindromicSuffix((\"cata\"))\n\
    \        // (\"a\")\n        // >>> findLongestPalindromicSuffix((\"catac\"))\n\
    \        // (\"catac\")\n        // >>> findLongestPalindromicSuffix((\"cataca\"\
    ))\n        // (\"aca\")\n        // >>> findLongestPalindromicSuffix((\"catacat\"\
    ))\n        // (\"catacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacata\"))\n        // (\"atacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatac\"))\n        // (\"catacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacataca\"))\n        // (\"acatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacat\"))\n        // (\"catacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacata\"))\n        // (\"atacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatac\"))\n        // (\"catacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacataca\"))\n        // (\"acatacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacat\"))\n        // (\"catacatacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacata\"))\n        // (\"atacatacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacatac\"))\n        // (\"catacatacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacataca\"))\n        // (\"acatacat", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int length = string.length();\n\
    \        int[] z = new int[length];\n        int l = 0;\n        int r = 0;\n\
    \        for (int i = 1; i < length; i++) {\n            if (i <= r) {\n     \
    \           z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n           \
    \ while (i + z[i] < length && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        int maxIndex = 0;\n        for (int\
    \ i = 0; i < length; i++) {\n            if (z[i] > max) {\n                max\
    \ = z[i];\n                maxIndex = i;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder();\n        for (int i = maxIndex + max; i < length;\
    \ i++) {\n            builder.append(string.charAt(i));\n        }\n        builder.append(string);\n\
    \        return builder.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int length = string.length();\n        for (int i = length - 1; i >=\
    \ 0; i--) {\n            if (isPalindrome(string.substring(i))) {\n          \
    \      sb.append(sb.substring(0, length - i));\n                break;\n     \
    \       }\n        }\n        return sb.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();", "        int n = string.length();\n        int[]\
    \ z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (z[i] == n - i && i > max) {\n        \
    \        max = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - max; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return string + sb.reverse().toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        String reverse = sb.reverse().toString();\n\
    \        StringBuilder sb2 = new StringBuilder(string);\n        int i = 0;\n\
    \        for (; i < string.length(); i++) {\n            if (string.substring(i).equals(reverse.substring(0,\
    \ string.length() - i))) {\n                break;\n            }\n        }\n\
    \        return string + reverse.substring(string.length() - i);", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder reverse = new StringBuilder(string).reverse();\n\
    \        int n = string.length();\n        int i = 0;\n        while (i < n) {\n\
    \            if (sb.substring(i).equals(reverse.substring(0, n - i))) {\n    \
    \            break;\n            }\n            i++;\n        }\n        return\
    \ sb.append(reverse.substring(n - i)).toString();", "        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        int length = string.length();\n\
    \        int i = length;\n        while (i > 0) {\n            if (isPalindrome(string.substring(length\
    \ - i))) {\n                break;\n            }\n            i--;\n        }\n\
    \        // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        String prefix = string.substring(0,\
    \ length - i);\n        return string + reverse(prefix);", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder rev = new StringBuilder(string).reverse();\n\
    \        int i = 0;\n        for (; i < string.length(); i++) {\n            if\
    \ (sb.substring(i).equals(rev.substring(0, string.length() - i))) {\n        \
    \        break;\n            }\n        }\n        return sb.append(rev.substring(string.length()\
    \ - i)).toString();", "        int n = string.length();\n        int[] z = new\
    \ int[n];\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\n            if\
    \ (i <= r)\n                z[i] = Math.min(r - i + 1, z[i - l]);\n          \
    \  while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\n  \
    \              ++z[i];\n            if (i + z[i] - 1 > r) {\n                l\
    \ = i;\n                r = i + z[i] - 1;\n            }\n        }\n        int\
    \ max = 0;\n        for (int i = 1; i < n; ++i) {\n            if (i + z[i] ==\
    \ n) {\n                max = i;\n                break;\n            }\n    \
    \    }\n        StringBuilder builder = new StringBuilder();\n        for (int\
    \ i = 0; i < n - max; ++i) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int maxLength = 0;\n        int maxIndex = 0;\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            int length = 0;\n            for (int\
    \ j = 0; j <= i; j++) {\n                if (string.charAt(i - j) == string.charAt(i\
    \ + j)) {\n                    length += 1;\n                } else {\n      \
    \              break;\n                }\n            }\n            if (length\
    \ > maxLength) {\n                maxLength = length;\n                maxIndex\
    \ = i;\n            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string.substring(0, maxIndex - maxLength + 1));\n    \
    \    builder.append(string);\n        builder.append(new StringBuilder(string.substring(0,\
    \ maxIndex - maxLength + 1)).reverse());\n        return builder.toString();",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int longestPalindromeLength = longestPalindromeLength(string);\n      \
    \  String prefix = string.substring(0, string.length() - longestPalindromeLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ i = 0;\n        for (; i < string.length(); i++) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ string.length() - i))) {\n                break;\n            }\n        }\n\
    \        return sb.append(rev.substring(string.length() - i)).toString();", " \
    \       StringBuilder sb = new StringBuilder(string);\n        StringBuilder sb2\
    \ = new StringBuilder(string);\n        StringBuilder sb3 = new StringBuilder(string);\n\
    \        StringBuilder sb4 = new StringBuilder(string);\n        StringBuilder\
    \ sb5 = new StringBuilder(string);\n        StringBuilder sb6 = new StringBuilder(string);\n\
    \        StringBuilder sb7 = new StringBuilder(string);\n        StringBuilder\
    \ sb8 = new StringBuilder(string);\n        StringBuilder sb9 = new StringBuilder(string);\n\
    \        StringBuilder sb10 = new StringBuilder(string);\n        StringBuilder\
    \ sb11 = new StringBuilder(string);\n        StringBuilder sb12 = new StringBuilder(string);\n\
    \        StringBuilder sb13 = new StringBuilder(string);\n        StringBuilder\
    \ sb14 = new StringBuilder(string);\n        StringBuilder sb15 = new StringBuilder(string);\n\
    \        StringBuilder sb16 = new StringBuilder(string);\n        StringBuilder\
    \ sb17 = new StringBuilder(string);\n        StringBuilder sb18 = new StringBuilder(string);\n\
    \        StringBuilder sb19 = new StringBuilder(string);\n        StringBuilder\
    \ sb20 = new StringBuilder(string);\n        StringBuilder sb21 = new StringBuilder(string);\n\
    \        StringBuilder sb22 = new StringBuilder(string);\n        StringBuilder\
    \ sb23 = new StringBuilder(string);\n        StringBuilder sb24 = new StringBuilder(string);\n\
    \        StringBuilder sb25 = new StringBuilder(string);\n        StringBuilder\
    \ sb26 = new StringBuilder(string);\n        StringBuilder sb27 = new StringBuilder(string);\n\
    \        StringBuilder sb28 = new StringBuilder(string);\n        StringBuilder\
    \ sb29 = new StringBuilder(string);\n        StringBuilder sb30 = new StringBuilder(string);\n\
    \        StringBuilder sb31 = new StringBuilder(string);\n        StringBuilder\
    \ sb32 = new StringBuilder(string);\n        StringBuilder sb33 = new StringBuilder(string);\n\
    \        StringBuilder sb34 = new StringBuilder(string);\n        StringBuilder\
    \ sb35 = new StringBuilder(string);\n        StringBuilder sb36 = new StringBuilder(string);\n\
    \        StringBuilder sb37 = new", "        if (string.length() == 0) {\n   \
    \         return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        StringBuilder sb\
    \ = new StringBuilder(prefix);\n        sb.reverse();\n        return string +\
    \ sb.toString();", "        int n = string.length();\n        int[] z = new int[n];\n\
    \        for (int i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n\
    \                z[i] = Math.min(r - i + 1, z[i - l]);\n            while (i +\
    \ z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\n              \
    \  ++z[i];\n            if (i + z[i] - 1 > r) {\n                l = i;\n    \
    \            r = i + z[i] - 1;\n            }\n        }\n        int max = 0;\n\
    \        for (int i = 0; i < n; ++i) {\n            if (i + z[i] == n) {\n   \
    \             max = Math.max(max, z[i]);\n            }\n        }\n        return\
    \ string + new StringBuilder(string.substring(0, n - max)).reverse().toString();",
  "        int length = string.length();\n        int i = 0;\n        int j = length\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        StringBuilder builder = new StringBuilder(string.substring(i));\n\
    \        builder.reverse();\n        return string + builder.toString();", " \
    \       int length = string.length();\n        if (length == 0) {\n          \
    \  return string;\n        }\n        int longestPalindromeSuffixLength = 0;\n\
    \        for (int i = 0; i < length; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = length - i;\n           \
    \     break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ length - longestPalindromeSuffixLength);\n        String reversePrefix = new\
    \ StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromeSuffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        return\
    \ string + new StringBuilder(string.substring(0, string.length() - longestPalindromeSuffixLength)).reverse().toString();",
  "        StringBuilder sb = new StringBuilder(string);\n        String rev = sb.reverse().toString();\n\
    \        String longestPalindrome = \"\";\n        for (int i = 0; i < string.length();\
    \ i++) {\n            String prefix = string.substring(0, i);\n            String\
    \ postfix = rev.substring(0, i);\n            if (prefix.equals(postfix)) {\n\
    \                longestPalindrome = prefix;\n            }\n        }\n     \
    \   String prefix = string.substring(longestPalindrome.length());\n        StringBuilder\
    \ sb2 = new StringBuilder(prefix);\n        String revPrefix = sb2.reverse().toString();\n\
    \        return string + revPrefix;", "        // Find the longest palindromic\
    \ suffix.\n        int suffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   suffixLength = string.length() - i;\n                break;\n            }\n\
    \        }\n        // Reverse the prefix and append it to the end of the string.\n\
    \        String prefix = new StringBuilder(string.substring(0, string.length()\
    \ - suffixLength)).reverse().toString();\n        return string + prefix;", " \
    \       int length = string.length();\n        if (length == 0) {\n          \
    \  return string;\n        }\n        int[] z = new int[length];\n        z[0]\
    \ = 0;\n        int left = 0;\n        int right = 0;\n        for (int i = 1;\
    \ i < length; i++) {\n            if (i > right) {\n                left = right\
    \ = i;\n                while (right < length && string.charAt(right) == string.charAt(right\
    \ - left)) {\n                    right++;\n                }\n              \
    \  z[i] = right - left;\n                right--;\n            } else {\n    \
    \            int k = i - left;\n                if (z[k] < right - i + 1) {\n\
    \                    z[i] = z[k];\n                } else {\n                \
    \    left = i;\n                    while (right < length && string.charAt(right)\
    \ == string.charAt(right - left)) {\n                        right++;\n      \
    \              }\n                    z[i] = right - left;\n                 \
    \   right--;\n                }\n            }\n        }\n        int maxZ =\
    \ 0;\n        int maxZIndex = 0;\n        for (int i = 0; i < length; i++) {\n\
    \            if (z[i] > maxZ) {\n                maxZ = z[i];\n              \
    \  maxZIndex = i;\n            }\n        }\n        StringBuilder builder = new\
    \ StringBuilder();\n        for (int i = maxZIndex + maxZ; i < length; i++) {\n\
    \            builder.append(string.charAt(i));\n        }\n        for (int i\
    \ = 0; i < maxZIndex; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversePrefix\
    \ = reverse(prefix);\n        return string + reversePrefix;", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int length = string.length();\n\
    \        int maxPalindromeLength = 0;\n        int maxPalindromeIndex = 0;\n \
    \       for (int i = 0; i < length; i++) {\n            int palindromeLength =\
    \ 0;\n            int palindromeIndex = i;\n            for (int j = 0; j <= i;\
    \ j++) {\n                if (string.charAt(j) == string.charAt(i - j)) {\n  \
    \                  palindromeLength++;\n                    palindromeIndex =\
    \ i - j;\n                } else {\n                    break;\n             \
    \   }\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n               \
    \ maxPalindromeIndex = palindromeIndex;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder();\n        builder.append(string);\n        for\
    \ (int i = 0; i < maxPalindromeIndex; i++) {\n            builder.append(string.charAt(maxPalindromeIndex\
    \ - i - 1));\n        }\n        return builder.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int i =\
    \ 0;\n        int j = n - 1;\n        int k = 0;\n        while (i < j) {\n  \
    \          if (string.charAt(i) == string.charAt(j)) {\n                i++;\n\
    \                j--;\n            } else {\n                i = 0;\n        \
    \        k++;\n                j = n - 1 - k;\n            }\n        }\n    \
    \    String prefix = string.substring(0, n - k);\n        StringBuilder sb = new\
    \ StringBuilder(prefix);\n        return string + sb.reverse().toString();", " \
    \       int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int longestPalindromeSuffix = longestPalindromeSuffix(string);\n\
    \        String prefix = string.substring(0, n - longestPalindromeSuffix);\n \
    \       String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;", "        // Find the longest palindromic\
    \ suffix.\n        int suffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   suffixLength = string.length() - i;\n                break;\n            }\n\
    \        }\n        // Append the reverse of the prefix to the end of the string.\n\
    \        String prefix = string.substring(0, string.length() - suffixLength);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        int n = string.length();\n    \
    \    int i = 0;\n        int j = n - 1;\n        while (i < j) {\n           \
    \ if (string.charAt(i) != string.charAt(j)) {\n                break;\n      \
    \      }\n            i += 1;\n            j -= 1;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        StringBuilder builder =\
    \ new StringBuilder();\n        builder.append(string.substring(0, i));\n    \
    \    builder.append(makePalindrome(string.substring(i, j + 1)));\n        builder.append(string.substring(i,\
    \ j + 1));\n        return builder.toString();", "        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        return string + reverse(prefix);", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder reversed = new StringBuilder(string);\n        reversed.reverse();\n\
    \        int i = string.length();\n        while (i > 0) {\n            String\
    \ postfix = string.substring(string.length() - i);\n            String prefix\
    \ = reversed.substring(0, i);\n            if (postfix.equals(prefix)) {\n   \
    \             sb.append(reversed.substring(i));\n                break;\n    \
    \        }\n            i--;\n        }\n        return sb.toString();", "   \
    \     if (string.length() == 0) {\n            return string;\n        }\n   \
    \     int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;", "        // Find the longest postfix\
    \ that is a palindrome.\n        int longestPalindromeSuffixLength = 0;\n    \
    \    for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + reverse(string.substring(0, string.length() - longestPalindromeSuffixLength));",
  "        int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int i = 0;\n        int j = n - 1;\n        while (i < j)\
    \ {\n            if (string.charAt(i) != string.charAt(j)) {\n               \
    \ break;\n            }\n            i++;\n            j--;\n        }\n     \
    \   if (i >= j) {\n            return string;\n        }\n        StringBuilder\
    \ sb = new StringBuilder(string);\n        for (int k = 0; k < i; k++) {\n   \
    \         sb.append(string.charAt(i - k - 1));\n        }\n        return sb.toString();",
  "        StringBuilder result = new StringBuilder(string);\n        StringBuilder\
    \ reversed = new StringBuilder(string).reverse();\n        int n = string.length();\n\
    \        for (int i = 0; i < n; i++) {\n            if (string.substring(i).equals(reversed.substring(0,\
    \ n - i))) {\n                result.append(reversed.substring(n - i));\n    \
    \            break;\n            }\n        }\n        return result.toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int longestPalindromePostfixLength = 0;\n        for (int i = 0; i <\
    \ string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromePostfixLength = string.length() - i;\n \
    \               break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(new\
    \ StringBuilder(string.substring(0, string.length() - longestPalindromePostfixLength)).reverse());\n\
    \        return builder.toString();", "        int longestPalindromeSuffix = longestPalindromeSuffix(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffix);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversedPrefix;",
  "        // Find the longest palindromic suffix.\n        int suffixLength = longestPalindromicSuffix(string);\n\
    \        // Reverse the prefix.\n        String prefix = new StringBuilder(string.substring(0,\
    \ string.length() - suffixLength)).reverse().toString();\n        // Append the\
    \ prefix to the end of the string.\n        return string + prefix;", "      \
    \  StringBuilder stringBuilder = new StringBuilder(string);\n        String reversed\
    \ = stringBuilder.reverse().toString();\n        String palindrome = string +\
    \ reversed;\n        return palindrome;", "        // Find the longest postfix\
    \ of supplied string that is a palindrome.\n        int longestPalindromeLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeLength = string.length() - i;\n        \
    \        break;\n            }\n        }\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeLength);\n\
    \        return string + reverse(prefix);", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        int i = 0;\n        while (i < n) {\n        \
    \    if (sb.substring(i).equals(rev.substring(0, n - i))) {\n                break;\n\
    \            }\n            i++;\n        }\n        return sb.append(rev.substring(n\
    \ - i)).toString();", "        int length = string.length();\n        if (length\
    \ == 0) {\n            return string;\n        }\n        int[] z = zFunction(string);\n\
    \        int max = 0;\n        for (int i = 1; i < length; i++) {\n          \
    \  if (z[i] == length - i) {\n                max = Math.max(max, z[i]);\n   \
    \         }\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        builder.append(string.substring(0, length - max).reverse());\n      \
    \  return builder.toString();", "        if (string.length() == 0) {\n       \
    \     return string;\n        }\n        int longestPalindromeSuffix = longestPalindromeSuffix(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffix);\n\
    \        return string + reverse(prefix);", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ longestPalindromeLength = 0;\n        for (int i = 0; i < length; i++) {\n \
    \           int palindromeLength = 0;\n            for (int j = 0; j <= i; j++)\
    \ {\n                if (string.charAt(i - j) == string.charAt(i + j)) {\n   \
    \                 palindromeLength = 2 * j + 1;\n                } else {\n  \
    \                  break;\n                }\n            }\n            if (palindromeLength\
    \ > longestPalindromeLength) {\n                longestPalindromeLength = palindromeLength;\n\
    \            }\n        }\n        for (int i = 0; i < length - 1; i++) {\n  \
    \          int palindromeLength = 0;\n            for (int j = 0; j <= i; j++)\
    \ {\n                if (string.charAt(i - j) == string.charAt(i + 1 + j)) {\n\
    \                    palindromeLength = 2 * j + 2;\n                } else {\n\
    \                    break;\n                }\n            }\n            if\
    \ (palindromeLength > longestPalindromeLength) {\n                longestPalindromeLength\
    \ = palindromeLength;\n            }\n        }\n        return string + new StringBuilder(string.substring(0,\
    \ length - longestPalindromeLength)).reverse().toString();", "        int length\
    \ = string.length();\n        if (length == 0) {\n            return string;\n\
    \        }\n        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, length - longestPalindromeSuffixLength);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ i = 0;\n        for (; i < string.length(); i++) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ string.length() - i))) {\n                break;\n            }\n        }\n\
    \        return sb.append(rev.substring(string.length() - i)).toString();", " \
    \       int length = string.length();\n        if (length == 0) {\n          \
    \  return string;\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int i = 0; i < length; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                builder.append(string.substring(0, i).reverse());\n     \
    \           return builder.toString();\n            }\n        }\n        return\
    \ builder.toString();", "        String palindrome = string;\n        int length\
    \ = string.length();\n        for (int i = length; i > 0; i--) {\n           \
    \ String postfix = string.substring(length - i);\n            if (isPalindrome(postfix))\
    \ {\n                String prefix = string.substring(0, length - i);\n      \
    \          palindrome = string + reverse(prefix);\n                break;\n  \
    \          }\n        }\n        return palindrome;", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversePrefix\
    \ = reverse(prefix);\n        return string + reversePrefix;", "        int length\
    \ = string.length();\n        for (int i = length - 1; i >= 0; i--) {\n      \
    \      if (isPalindrome(string.substring(i))) {\n                return string\
    \ + reverse(string.substring(0, i));\n            }\n        }\n        return\
    \ string;", "        // Find the longest postfix of supplied string that is a\
    \ palindrome.\n        int palindromeLength = 0;\n        for (int i = 0; i <\
    \ string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                palindromeLength = string.length() - i;\n               \
    \ break;\n            }\n        }\n        // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n     \
    \   StringBuilder builder = new StringBuilder(string);\n        builder.append(new\
    \ StringBuilder(string.substring(0, string.length() - palindromeLength)).reverse());\n\
    \        return builder.toString();", "        // Find the longest postfix of\
    \ supplied string that is a palindrome.\n        // This can be done by iterating\
    \ over the string from the end,\n        // and checking if the prefix of the\
    \ string is a palindrome.\n        // The first prefix that is a palindrome is\
    \ the longest palindromic suffix.\n        int suffixLength = 0;\n        for\
    \ (int i = string.length() - 1; i >= 0; i--) {\n            if (isPalindrome(string.substring(0,\
    \ i + 1))) {\n                suffixLength = i + 1;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        return\
    \ string + new StringBuilder(string.substring(0, string.length() - suffixLength)).reverse().toString();",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversedPrefix;",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        return string + reverse(string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength));", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i += 1;\n            j -= 1;\n        }\n        String\
    \ prefix = string.substring(0, i);\n        String suffix = string.substring(i);\n\
    \        StringBuilder sb = new StringBuilder();\n        sb.append(suffix);\n\
    \        sb.reverse();\n        sb.append(prefix);\n        sb.append(suffix);\n\
    \        return sb.toString();", "        if (string.length() == 0) {\n      \
    \      return string;\n        }\n        int maxPalindromeLength = 0;\n     \
    \   for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = 0;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindromeLength += 1;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            maxPalindromeLength = Math.max(maxPalindromeLength, palindromeLength);\n\
    \        }\n        StringBuilder builder = new StringBuilder();\n        for\
    \ (int i = string.length() - maxPalindromeLength; i >= 0; i--) {\n           \
    \ builder.append(string.charAt(i));\n        }\n        builder.append(string);\n\
    \        return builder.toString();", "        int n = string.length();\n    \
    \    int[] p = new int[n];\n        int c = 0, r = 0;\n        for (int i = 1;\
    \ i < n; i++) {\n            int mirror = 2 * c - i;\n            if (i < r) {\n\
    \                p[i] = Math.min(r - i, p[mirror]);\n            }\n         \
    \   while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && string.charAt(i + 1 + p[i])\
    \ == string.charAt(i - 1 - p[i])) {\n                p[i]++;\n            }\n\
    \            if (i + p[i] > r) {\n                c = i;\n                r =\
    \ i + p[i];\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (p[i] > p[max]) {\n                max\
    \ = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = max - p[max]; i < max + p[max]; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        for (int i = 0; i < max - p[max]; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();", "        String result = \"\";\n \
    \       if (string.length() == 0) {\n            return result;\n        }\n \
    \       int longestPalindromeSuffixLength = 0;\n        for (int i = string.length()\
    \ - 1; i >= 0; i--) {\n            if (isPalindrome(string.substring(i))) {\n\
    \                longestPalindromeSuffixLength = string.length() - i;\n      \
    \          break;\n            }\n        }\n        String longestPalindromeSuffix\
    \ = string.substring(string.length() - longestPalindromeSuffixLength);\n     \
    \   String longestPalindromePrefix = new StringBuilder(string.substring(0, string.length()\
    \ - longestPalindromeSuffixLength)).reverse().toString();\n        result = string\
    \ + longestPalindromePrefix;\n        return result;", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int[] z = zFunction(string);\n\
    \        int longestPalindromeSuffix = z[string.length()];\n        String prefix\
    \ = string.substring(0, string.length() - longestPalindromeSuffix);\n        String\
    \ reversedPrefix = new StringBuilder(prefix).reverse().toString();\n        return\
    \ string + reversedPrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        for (int i = 0; i < n; i++) {\n            if\
    \ (sb.substring(i).equals(rev.substring(0, n - i))) {\n                return\
    \ sb.append(rev.substring(n - i)).toString();\n            }\n        }\n    \
    \    return sb.append(rev.substring(1)).toString();", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int[] z\
    \ = new int[n];\n        z[0] = 0;\n        int l = 0;\n        int r = 0;\n \
    \       for (int i = 1; i < n; i++) {\n            if (i <= r) {\n           \
    \     z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n            while\
    \ (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n       \
    \         z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n      \
    \          l = i;\n                r = i + z[i] - 1;\n            }\n        }\n\
    \        int max = 0;\n        int maxIndex = 0;\n        for (int i = 0; i <\
    \ n; i++) {\n            if (z[i] > max) {\n                max = z[i];\n    \
    \            maxIndex = i;\n            }\n        }\n        StringBuilder sb\
    \ = new StringBuilder();\n        for (int i = 0; i < n - max; i++) {\n      \
    \      sb.append(string.charAt(n - i - 1));\n        }\n        sb.append(string);\n\
    \        return sb.toString();", "        StringBuilder result = new StringBuilder(string);\n\
    \        StringBuilder reversed = new StringBuilder(string).reverse();\n     \
    \   for (int i = 0; i < string.length(); i++) {\n            if (string.startsWith(reversed.substring(i)))\
    \ {\n                result.append(reversed.substring(0, i));\n              \
    \  break;\n            }\n        }\n        return result.toString();", "   \
    \     int maxPalindromeLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindromeLength = 0;\n            for (int j = 0; j\
    \ < string.length() - i; j++) {\n                if (string.charAt(i + j) == string.charAt(string.length()\
    \ - 1 - j)) {\n                    palindromeLength++;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if (palindromeLength > maxPalindromeLength) {\n                maxPalindromeLength\
    \ = palindromeLength;\n            }\n        }\n        StringBuilder sb = new\
    \ StringBuilder(string);\n        for (int i = 0; i < string.length() - maxPalindromeLength;\
    \ i++) {\n            sb.append(string.charAt(string.length() - 1 - i));\n   \
    \     }\n        return sb.toString();", "        // Find the longest palindromic\
    \ suffix of the string.\n        int suffixLength = 0;\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append the reverse of the prefix to the\
    \ end of the string.\n        String prefix = string.substring(0, string.length()\
    \ - suffixLength);\n        return string + reverse(prefix);", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder rev = new StringBuilder(string).reverse();\n\
    \        int n = string.length();\n        int i = 0;\n        for (; i < n; i++)\
    \ {\n            if (sb.substring(i).equals(rev.substring(0, n - i))) {\n    \
    \            break;\n            }\n        }\n        return sb.append(rev.substring(n\
    \ - i)).toString();", "        int n = string.length();\n        int[] z = new\
    \ int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n\
    \            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++)\
    \ {\n            if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n\
    \            }\n        }\n        StringBuilder sb = new StringBuilder();\n \
    \       for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return string + sb.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r)\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i]))\n                z[i]++;\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++)\n\
    \            if (z[i] == n - i)\n                max = Math.max(max, z[i]);\n\
    \        StringBuilder sb = new StringBuilder();\n        for (int i = n - max\
    \ - 1; i >= 0; i--)\n            sb.append(string.charAt(i));\n        return\
    \ string + sb.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        for (int i = 0; i < n; i++) {\n            if\
    \ (sb.substring(i).equals(rev.substring(0, n - i))) {\n                return\
    \ sb.append(rev.substring(n - i)).toString();\n            }\n        }\n    \
    \    return sb.append(rev.substring(1)).toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int suffixLength = longestPalindromicSuffix(string);\n\
    \        String prefix = string.substring(0, string.length() - suffixLength);\n\
    \        return prefix + string + new StringBuilder(prefix).reverse().toString();",
  "        int length = string.length();\n        if (length == 0) {\n           \
    \ return string;\n        }\n        int longestPalindromeLength = 0;\n      \
    \  int longestPalindromeStart = 0;\n        for (int i = 0; i < length; i++) {\n\
    \            int palindromeLength = 0;\n            int palindromeStart = i;\n\
    \            while (palindromeStart - palindromeLength >= 0 && palindromeStart\
    \ + palindromeLength < length && string.charAt(palindromeStart - palindromeLength)\
    \ == string.charAt(palindromeStart + palindromeLength)) {\n                palindromeLength++;\n\
    \            }\n            if (palindromeLength > longestPalindromeLength) {\n\
    \                longestPalindromeLength = palindromeLength;\n               \
    \ longestPalindromeStart = palindromeStart;\n            }\n        }\n      \
    \  StringBuilder builder = new StringBuilder(string);\n        for (int i = longestPalindromeStart\
    \ - longestPalindromeLength - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i += 1;\n            j -= 1;\n        }\n        if\
    \ (i >= j) {\n            return string;\n        }\n        String suffix = string.substring(i);\n\
    \        String prefix = string.substring(0, i);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return prefix + suffix\
    \ + reversedPrefix;", "        StringBuilder result = new StringBuilder(string);\n\
    \        StringBuilder reverse = new StringBuilder(string).reverse();\n      \
    \  int length = string.length();\n        for (int i = length; i >= 0; i--) {\n\
    \            if (string.substring(0, i).equals(reverse.substring(length - i)))\
    \ {\n                result.append(reverse.substring(0, length - i));\n      \
    \          break;\n            }\n        }\n        return result.toString();",
  "        // >>> findLongestPalindromicSuffix((\"\"))\n        // (\"\")\n      \
    \  // >>> findLongestPalindromicSuffix((\"cat\"))\n        // (\"\")\n       \
    \ // >>> findLongestPalindromicSuffix((\"cata\"))\n        // (\"a\")\n      \
    \  // >>> findLongestPalindromicSuffix((\"catac\"))\n        // (\"catac\")\n\
    \        // >>> findLongestPalindromicSuffix((\"cataca\"))\n        // (\"ataca\"\
    )\n        // >>> findLongestPalindromicSuffix((\"catacat\"))\n        // (\"\
    atacat\")\n        // >>> findLongestPalindromicSuffix((\"catacata\"))\n     \
    \   // (\"atacata\")\n        // >>> findLongestPalindromicSuffix((\"catacatac\"\
    ))\n        // (\"atacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacataca\"))\n        // (\"atacataca\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacat\"))\n        // (\"atacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacata\"))\n        // (\"atacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatac\"))\n        // (\"atacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacataca\"))\n        // (\"atacatacataca\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacat\"))\n        // (\"atacatacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacata\"))\n        // (\"atacatacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacatac\"))\n        // (\"atacatacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacataca\"))\n        // (\"atacat", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < length; i++)\
    \ {\n            if (isPalindrome(string.substring(i))) {\n                longestPalindromeSuffixLength\
    \ = length - i;\n                break;\n            }\n        }\n        String\
    \ prefix = string.substring(0, length - longestPalindromeSuffixLength);\n    \
    \    String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ i = 0;\n        for (; i < string.length(); i++) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ string.length() - i))) {\n                break;\n            }\n        }\n\
    \        sb.append(rev.substring(string.length() - i));\n        return sb.toString();",
  "        int length = string.length();\n        for (int i = length - 1; i >= 0;\
    \ i--) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   return string + reverse(string.substring(0, i));\n            }\n        }\n\
    \        return string;", "        // >>> findLongestPalindromicSuffix((\"\"))\n\
    \        // (\"\")\n        // >>> findLongestPalindromicSuffix((\"cat\"))\n \
    \       // (\"\")\n        // >>> findLongestPalindromicSuffix((\"cata\"))\n \
    \       // (\"a\")\n        // >>> findLongestPalindromicSuffix((\"catac\"))\n\
    \        // (\"catac\")\n        // >>> findLongestPalindromicSuffix((\"cataca\"\
    ))\n        // (\"aca\")\n        // >>> findLongestPalindromicSuffix((\"catacat\"\
    ))\n        // (\"catacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacata\"))\n        // (\"atacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatac\"))\n        // (\"catacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacataca\"))\n        // (\"acatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacat\"))\n        // (\"catacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacata\"))\n        // (\"atacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatac\"))\n        // (\"catacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacataca\"))\n        // (\"acatacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacat\"))\n        // (\"catacatacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacata\"))\n        // (\"atacatacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacatac\"))\n        // (\"catacatacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacataca\"))\n        // (\"acatacat", "        int length = string.length();\n\
    \        int maxPalindromeLength = 0;\n        for (int i = 0; i < length; i++)\
    \ {\n            if (isPalindrome(string, i, length - 1)) {\n                maxPalindromeLength\
    \ = length - i;\n                break;\n            }\n        }\n        String\
    \ prefix = string.substring(0, length - maxPalindromeLength);\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i += 1;\n            j -= 1;\n        }\n        if\
    \ (i >= j) {\n            return string;\n        }\n        String prefix = string.substring(0,\
    \ i);\n        String suffix = string.substring(i);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return suffix + reversedPrefix\
    \ + suffix;", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int maxPalindromeLength = 0;\n        int maxPalindromeStart\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = 0;\n            int palindromeStart = i;\n            while (palindromeStart\
    \ - palindromeLength >= 0 && palindromeStart + palindromeLength < string.length()\
    \ && string.charAt(palindromeStart - palindromeLength) == string.charAt(palindromeStart\
    \ + palindromeLength)) {\n                palindromeLength++;\n            }\n\
    \            if (palindromeLength > maxPalindromeLength) {\n                maxPalindromeLength\
    \ = palindromeLength;\n                maxPalindromeStart = palindromeStart;\n\
    \            }\n        }\n        StringBuilder sb = new StringBuilder(string);\n\
    \        for (int i = maxPalindromeStart - maxPalindromeLength + 1; i < maxPalindromeStart;\
    \ i++) {\n            sb.append(string.charAt(i));\n        }\n        return\
    \ sb.toString();", "        int n = string.length();\n        int[] z = new int[n];\n\
    \        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n          \
    \  if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n    \
    \        }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++)\
    \ {\n            if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n\
    \            }\n        }\n        return string + new StringBuilder(string.substring(0,\
    \ n - max)).reverse().toString();", "        StringBuilder builder = new StringBuilder(string);\n\
    \        StringBuilder reverse = new StringBuilder(string);\n        reverse.reverse();\n\
    \        StringBuilder result = new StringBuilder();\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            if (string.substring(i).equals(reverse.substring(0,\
    \ string.length() - i))) {\n                result.append(reverse.substring(string.length()\
    \ - i));\n                result.append(string);\n                return result.toString();\n\
    \            }\n        }\n        return string;", "        int n = string.length();\n\
    \        int[] p = new int[n];\n        int c = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            int mirror = 2 * c - i;\n            if (i <\
    \ r) {\n                p[i] = Math.min(r - i, p[mirror]);\n            }\n  \
    \          while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && string.charAt(i + 1\
    \ + p[i]) == string.charAt(i - 1 - p[i])) {\n                p[i]++;\n       \
    \     }\n            if (i + p[i] > r) {\n                c = i;\n           \
    \     r = i + p[i];\n            }\n        }\n        int max_len = 0;\n    \
    \    int center_index = 0;\n        for (int i = 1; i < n; i++) {\n          \
    \  if (i - p[i] == 0) {\n                if (p[i] > max_len) {\n             \
    \       max_len = p[i];\n                    center_index = i;\n             \
    \   }\n            }\n        }\n        String prefix = string.substring(0, center_index\
    \ - max_len);\n        StringBuilder sb = new StringBuilder(prefix);\n       \
    \ sb.reverse();\n        return string + sb.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversePrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;",
  "        // Find the longest palindromic suffix.\n        int suffixLength = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append reverse of the prefix to the end\
    \ of the string.\n        String prefix = string.substring(0, string.length()\
    \ - suffixLength);\n        StringBuilder builder = new StringBuilder(string);\n\
    \        builder.append(reverse(prefix));\n        return builder.toString();",
  "        int length = string.length();\n        int i = 0;\n        int j = length\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        if (i >= j) {\n            return string;\n        }\n   \
    \     StringBuilder builder = new StringBuilder(string);\n        for (int k =\
    \ 0; k < i; k++) {\n            builder.append(string.charAt(i - k - 1));\n  \
    \      }\n        return builder.toString();", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        String prefix = string.substring(0,\
    \ i);\n        String suffix = string.substring(i);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return suffix + reversedPrefix\
    \ + suffix;", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int maxLength = 0;\n        int maxIndex = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            int length = 0;\n     \
    \       for (int j = 0; j <= i; j++) {\n                if (string.charAt(i -\
    \ j) == string.charAt(i + j)) {\n                    length++;\n             \
    \   } else {\n                    break;\n                }\n            }\n \
    \           if (length > maxLength) {\n                maxLength = length;\n \
    \               maxIndex = i;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder();\n        for (int i = 0; i < maxIndex - maxLength\
    \ + 1; i++) {\n            builder.append(string.charAt(i));\n        }\n    \
    \    return string + builder.reverse().toString();", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ i = length - 1;\n        while (i >= 0) {\n            if (isPalindrome(string,\
    \ i)) {\n                break;\n            }\n            i--;\n        }\n\
    \        StringBuilder builder = new StringBuilder(string);\n        for (int\
    \ j = 0; j < length - i - 1; j++) {\n            builder.append(string.charAt(j));\n\
    \        }\n        return builder.toString();", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        StringBuilder sb = new\
    \ StringBuilder(string);\n        for (int k = j - 1; k >= i; k--) {\n       \
    \     sb.append(string.charAt(k));\n        }\n        return sb.toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromeSuffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        return\
    \ string + new StringBuilder(string.substring(0, string.length() - longestPalindromeSuffixLength)).reverse().toString();",
  "        StringBuilder builder = new StringBuilder(string);\n        int i = string.length()\
    \ - 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                builder.append(reverse(string.substring(0, i)));\n      \
    \          break;\n            }\n            i--;\n        }\n        return\
    \ builder.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        String rev = sb.reverse().toString();\n        StringBuilder sb2 = new\
    \ StringBuilder(string);\n        String rev2 = sb2.reverse().toString();\n  \
    \      StringBuilder sb3 = new StringBuilder(string);\n        String rev3 = sb3.reverse().toString();\n\
    \        StringBuilder sb4 = new StringBuilder(string);\n        String rev4 =\
    \ sb4.reverse().toString();\n        StringBuilder sb5 = new StringBuilder(string);\n\
    \        String rev5 = sb5.reverse().toString();\n        StringBuilder sb6 =\
    \ new StringBuilder(string);\n        String rev6 = sb6.reverse().toString();\n\
    \        StringBuilder sb7 = new StringBuilder(string);\n        String rev7 =\
    \ sb7.reverse().toString();\n        StringBuilder sb8 = new StringBuilder(string);\n\
    \        String rev8 = sb8.reverse().toString();\n        StringBuilder sb9 =\
    \ new StringBuilder(string);\n        String rev9 = sb9.reverse().toString();\n\
    \        StringBuilder sb10 = new StringBuilder(string);\n        String rev10\
    \ = sb10.reverse().toString();\n        StringBuilder sb11 = new StringBuilder(string);\n\
    \        String rev11 = sb11.reverse().toString();\n        StringBuilder sb12\
    \ = new StringBuilder(string);\n        String rev12 = sb12.reverse().toString();\n\
    \        StringBuilder sb13 = new StringBuilder(string);\n        String rev13\
    \ = sb13.reverse().toString();\n        StringBuilder sb14 = new StringBuilder(string);\n\
    \        String rev14 = sb14.reverse().toString();\n        StringBuilder sb15\
    \ = new StringBuilder(string);\n        String rev15 = sb15.reverse().toString();\n\
    \        StringBuilder sb16 = new StringBuilder(string);\n        String rev16\
    \ = sb16.reverse().toString();\n        StringBuilder sb17 = new StringBuilder(string);\n\
    \        String rev17 = sb17.reverse().toString();\n        StringBuilder sb18\
    \ = new StringBuilder(string);\n        String rev18 = sb", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeEnd\
    \ = 0;\n        int longestPalindromeLength = 0;\n        for (int i = 0; i <\
    \ string.length(); i++) {\n            int palindromeLength = 0;\n           \
    \ for (int j = 0; j <= i; j++) {\n                if (string.charAt(i - j) ==\
    \ string.charAt(i + j)) {\n                    palindromeLength += 2;\n      \
    \          } else {\n                    break;\n                }\n         \
    \   }\n            if (palindromeLength > longestPalindromeLength) {\n       \
    \         longestPalindromeLength = palindromeLength;\n                longestPalindromeEnd\
    \ = i;\n            }\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int i = longestPalindromeEnd - longestPalindromeLength / 2 + 1;\
    \ i < string.length(); i++) {\n            builder.append(string.charAt(string.length()\
    \ - 1 - i));\n        }\n        return builder.toString();", "        int n =\
    \ string.length();\n        int[] z = new int[n];\n        int l = 0, r = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n          \
    \      z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n            while\
    \ (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n       \
    \         z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n      \
    \          l = i;\n                r = i + z[i] - 1;\n            }\n        }\n\
    \        int longestPalindrome = 0;\n        for (int i = 1; i < n; i++) {\n \
    \           if (z[i] == i) {\n                longestPalindrome = i;\n       \
    \     }\n        }\n        StringBuilder sb = new StringBuilder();\n        for\
    \ (int i = longestPalindrome; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.reverse();\n        sb.append(string);\n        return\
    \ sb.toString();", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        int length = string.length();\n\
    \        int[] z = new int[length];\n        int l = 0, r = 0;\n        for (int\
    \ i = 1; i < length; i++) {\n            z[i] = i < r ? Math.min(r - i + 1, z[i\
    \ - l]) : 0;\n            while (i + z[i] < length && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < length;\
    \ i++) {\n            if (z[i] == i) {\n                max = i;\n           \
    \ }\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int\
    \ i = length - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return string + sb.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder();\n        for (int i = max; i < n; i++) {\n          \
    \  builder.append(string.charAt(i));\n        }\n        builder.reverse();\n\
    \        builder.append(string);\n        return builder.toString();", "     \
    \   int n = string.length();\n        int[] z = new int[n];\n        z[0] = n;\n\
    \        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n          \
    \  if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n    \
    \        }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = n - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n      \
    \  }\n        return string + sb.toString();", "        if (string.length() ==\
    \ 0) {\n            return string;\n        }\n        int maxPalindromeLength\
    \ = 0;\n        int maxPalindromeIndex = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindromeLength = 0;\n            int palindromeIndex\
    \ = i;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindromeLength = 2 *\
    \ j + 1;\n                    palindromeIndex = i - j;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if (palindromeLength > maxPalindromeLength) {\n                maxPalindromeLength\
    \ = palindromeLength;\n                maxPalindromeIndex = palindromeIndex;\n\
    \            }\n            palindromeLength = 0;\n            palindromeIndex\
    \ = i;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j + 1)) {\n                    palindromeLength =\
    \ 2 * j + 2;\n                    palindromeIndex = i - j;\n                }\
    \ else {\n                    break;\n                }\n            }\n     \
    \       if (palindromeLength > maxPalindromeLength) {\n                maxPalindromeLength\
    \ = palindromeLength;\n                maxPalindromeIndex = palindromeIndex;\n\
    \            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string.substring(0, maxPalindromeIndex));\n        builder.append(string.substring(maxPalindromeIndex\
    \ + maxPalindromeLength));\n        builder.reverse();\n        builder.append(string);\n\
    \        return builder.toString();", "        if (string.length() == 0) {\n \
    \           return string;\n        }\n        int length = string.length();\n\
    \        int[] z = new int[length];\n        z[0] = 0;\n        int left = 0;\n\
    \        int right = 0;\n        for (int i = 1; i < length; i++) {\n        \
    \    if (i > right) {\n                left = right = i;\n                while\
    \ (right < length && string.charAt(right) == string.charAt(right - left)) {\n\
    \                    right++;\n                }\n                z[i] = right\
    \ - left;\n                right--;\n            } else {\n                int\
    \ k = i - left;\n                if (z[k] < right - i + 1) {\n               \
    \     z[i] = z[k];\n                } else {\n                    left = i;\n\
    \                    while (right < length && string.charAt(right) == string.charAt(right\
    \ - left)) {\n                        right++;\n                    }\n      \
    \              z[i] = right - left;\n                    right--;\n          \
    \      }\n            }\n        }\n        int max = 0;\n        int maxIndex\
    \ = 0;\n        for (int i = 0; i < length; i++) {\n            if (z[i] > max)\
    \ {\n                max = z[i];\n                maxIndex = i;\n            }\n\
    \        }\n        String prefix = string.substring(0, maxIndex - max + 1);\n\
    \        StringBuilder builder = new StringBuilder(prefix);\n        builder.reverse();\n\
    \        return string + builder.toString();", "        StringBuilder sb = new\
    \ StringBuilder(string);\n        int i = string.length() - 1;\n        while\
    \ (i >= 0) {\n            if (isPalindrome(string.substring(i))) {\n         \
    \       sb.append(reverse(string.substring(0, i)));\n                break;\n\
    \            }\n            i--;\n        }\n        return sb.toString();"]
stop_tokens:
- "\n    }\n"
