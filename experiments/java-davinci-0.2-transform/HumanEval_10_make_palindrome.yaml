name: HumanEval_10_make_palindrome
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Find the shortest palindrome that begins with a supplied\
  \ string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of\
  \ supplied string that is a palindrome.\n    // - Append to the end of the string\
  \ reverse of a string prefix that comes before the palindromic suffix.\n    // >>>\
  \ makePalindrome((\"\"))\n    // (\"\")\n    // >>> makePalindrome((\"cat\"))\n\
  \    // (\"catac\")\n    // >>> makePalindrome((\"cata\"))\n    // (\"catac\")\n\
  \    public static String makePalindrome(String string) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        int n = string.length();\n        int i = 0;\n        int j\
    \ = n - 1;\n        int k = 0;\n        while (i < j) {\n            if (string.charAt(i)\
    \ == string.charAt(j)) {\n                i++;\n                j--;\n       \
    \     } else {\n                i = 0;\n                k++;\n               \
    \ j = n - 1 - k;\n            }\n        }\n        StringBuilder builder = new\
    \ StringBuilder(string);\n        builder.append(string.substring(0, n - k).reverse());\n\
    \        return builder.toString();", "        int n = string.length();\n    \
    \    if (n == 0) {\n            return string;\n        }\n        int i = n -\
    \ 1;\n        while (i >= 0) {\n            if (isPalindrome(string, i)) {\n \
    \               break;\n            }\n            i--;\n        }\n        String\
    \ prefix = string.substring(0, i + 1);\n        StringBuilder sb = new StringBuilder(prefix);\n\
    \        sb.reverse();\n        return string + sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          break;\n            }\n        }\n        if (i == j) {\n         \
    \   return string;\n        }\n        String prefix = string.substring(0, i);\n\
    \        StringBuilder reversePrefix = new StringBuilder(prefix);\n        reversePrefix.reverse();\n\
    \        sb.append(reversePrefix);\n        return sb.toString();", "        int\
    \ n = string.length();\n        int i = 0;\n        int j = n - 1;\n        while\
    \ (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n       \
    \         break;\n            }\n            i += 1;\n            j -= 1;\n  \
    \      }\n        if (i >= j) {\n            return string;\n        }\n     \
    \   StringBuilder builder = new StringBuilder();\n        builder.append(string);\n\
    \        for (int k = i - 1; k >= 0; k -= 1) {\n            builder.append(string.charAt(k));\n\
    \        }\n        return builder.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int i = string.length()\
    \ - 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(0,\
    \ i + 1))) {\n                break;\n            }\n            i--;\n      \
    \  }\n        String prefix = string.substring(0, i);\n        StringBuilder sb\
    \ = new StringBuilder(string);\n        sb.append(reverse(prefix));\n        return\
    \ sb.toString();", "        StringBuilder sb = new StringBuilder(string);\n  \
    \      StringBuilder rev = new StringBuilder(string).reverse();\n        int i\
    \ = 0;\n        for (; i < sb.length(); i++) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ sb.length() - i))) {\n                break;\n            }\n        }\n   \
    \     return sb.append(rev.substring(sb.length() - i)).toString();", "       \
    \ int n = string.length();\n        int[] z = new int[n];\n        int l = 0,\
    \ r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n \
    \               z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n       \
    \     while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n\
    \                z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n      \
    \      if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n    \
    \        }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = n - max - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n  \
    \          }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = n - max - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = n - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n      \
    \  }\n        sb.append(string);\n        return sb.toString();", "        if\
    \ (string.length() == 0) {\n            return string;\n        }\n        int\
    \ suffixLength = 0;\n        for (int i = string.length() - 1; i >= 0; i--) {\n\
    \            if (isPalindrome(string.substring(i))) {\n                suffixLength\
    \ = string.length() - i;\n                break;\n            }\n        }\n \
    \       String prefix = string.substring(0, string.length() - suffixLength);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = string.length() - 1;\n        while (i >= 0) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                sb.append(sb.substring(0,\
    \ string.length() - i).reverse());\n                break;\n            }\n  \
    \          i--;\n        }\n        return sb.toString();", "        // >>> findLongestPalindromicSuffix((\"\
    \"))\n        // (\"\")\n        // >>> findLongestPalindromicSuffix((\"cat\"\
    ))\n        // (\"t\")\n        // >>> findLongestPalindromicSuffix((\"cata\"\
    ))\n        // (\"a\")\n        // >>> findLongestPalindromicSuffix((\"catac\"\
    ))\n        // (\"catac\")\n        // >>> findLongestPalindromicSuffix((\"cataca\"\
    ))\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix((\"catacat\"\
    ))\n        // (\"catacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacata\"))\n        // (\"atacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatac\"))\n        // (\"catacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacataca\"))\n        // (\"atacataca\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacat\"))\n        // (\"catacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacata\"))\n        // (\"atacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatac\"))\n        // (\"catacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacataca\"))\n        // (\"atacatacataca\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacat\"))\n        // (\"catacatacatacat\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacata\"))\n        // (\"atacatacatacata\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacatac\"))\n        // (\"catacatacatacatac\")\n        // >>> findLongestPalindromicSuffix((\"\
    catacatacatacataca\"))\n        // (\"atac", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int i =\
    \ n - 1;\n        while (i >= 0) {\n            if (isPalindrome(string, i)) {\n\
    \                break;\n            }\n            i--;\n        }\n        String\
    \ prefix = string.substring(0, i + 1);\n        String suffix = string.substring(i\
    \ + 1);\n        StringBuilder sb = new StringBuilder();\n        sb.append(string);\n\
    \        sb.append(reverse(prefix));\n        return sb.toString();", "      \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    \
    \    int palindromeLength = 0;\n        for (int i = 0; i < string.length(); i++)\
    \ {\n            if (isPalindrome(string.substring(i))) {\n                palindromeLength\
    \ = string.length() - i;\n                break;\n            }\n        }\n \
    \       // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        StringBuilder builder = new StringBuilder(string);\n\
    \        builder.append(reverse(string.substring(0, string.length() - palindromeLength)));\n\
    \        return builder.toString();", "        String reversed = new StringBuilder(string).reverse().toString();\n\
    \        String palindrome = string + reversed;\n        return palindrome;",
  "        StringBuilder sb = new StringBuilder(string);\n        StringBuilder rev\
    \ = new StringBuilder(string).reverse();\n        int n = string.length();\n \
    \       int i = 0;\n        while (i < n) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ n - i))) {\n                break;\n            }\n            i++;\n      \
    \  }\n        return sb.append(rev.substring(n - i)).toString();", "        int\
    \ n = string.length();\n        int[] z = new int[n];\n        z[0] = n;\n   \
    \     int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if\
    \ (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n        \
    \    }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        return string + new StringBuilder(string.substring(0, n - max)).reverse().toString();",
  "        int length = string.length();\n        if (length == 0) {\n           \
    \ return string;\n        }\n        int longestPalindromeLength = 0;\n      \
    \  int longestPalindromeIndex = 0;\n        for (int i = 0; i < length; i++) {\n\
    \            int palindromeLength = 0;\n            int palindromeIndex = i;\n\
    \            int j = i;\n            int k = i;\n            while (j >= 0 &&\
    \ k < length && string.charAt(j) == string.charAt(k)) {\n                palindromeLength\
    \ = k - j + 1;\n                palindromeIndex = j;\n                j--;\n \
    \               k++;\n            }\n            if (palindromeLength > longestPalindromeLength)\
    \ {\n                longestPalindromeLength = palindromeLength;\n           \
    \     longestPalindromeIndex = palindromeIndex;\n            }\n            palindromeLength\
    \ = 0;\n            palindromeIndex = i;\n            j = i;\n            k =\
    \ i + 1;\n            while (j >= 0 && k < length && string.charAt(j) == string.charAt(k))\
    \ {\n                palindromeLength = k - j + 1;\n                palindromeIndex\
    \ = j;\n                j--;\n                k++;\n            }\n          \
    \  if (palindromeLength > longestPalindromeLength) {\n                longestPalindromeLength\
    \ = palindromeLength;\n                longestPalindromeIndex = palindromeIndex;\n\
    \            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string);\n        for (int i = longestPalindromeIndex\
    \ - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n       \
    \ }\n        return builder.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - z[n - 1]; i++) {\n            sb.append(string.charAt(n\
    \ - 1 - i));\n        }\n        sb.append(string);\n        return sb.toString();",
  "        int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int i = 0;\n        int j = n - 1;\n        while (i < j)\
    \ {\n            if (string.charAt(i) != string.charAt(j)) {\n               \
    \ break;\n            }\n            i++;\n            j--;\n        }\n     \
    \   if (i >= j) {\n            return string;\n        }\n        StringBuilder\
    \ sb = new StringBuilder(string);\n        for (int k = 0; k < i; k++) {\n   \
    \         sb.append(string.charAt(i - k - 1));\n        }\n        return sb.toString();"]
stop_tokens:
- "\n    }\n"
