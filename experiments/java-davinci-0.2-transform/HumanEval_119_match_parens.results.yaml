language: java
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s3 = s1 + s2;\n        String s4 = s2 + s1;\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            return \"Yes\";\n        } else {\n          \
    \  return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n       \
    \ if (isGood(s3) || isGood(s4)) {\n                          ^\n  symbol:   method\
    \ isGood(String)\n  location: class Problem\n2 errors\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i\
    \ < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \           if (count < 0) {\n                return \"No\";\n            }\n\
    \        }\n        if (count == 0) {\n            return \"Yes\";\n        }\
    \ else {\n            return \"No\";\n        }\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3au9wdli.java:47)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       int count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i <\
    \ s1.length(); i++) {\n            if (s1.charAt(i) == '(') {\n              \
    \  count1++;\n            } else {\n                count1--;\n            }\n\
    \        }\n        for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 < 0 || count2 < 0) {\n\
    \            return \"No\";\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        }\n        if (count1 == 0 && count2\
    \ > 0) {\n            return \"Yes\";\n        }\n        if (count1 > 0 && count2\
    \ == 0) {\n            return \"Yes\";\n        }\n        if (count1 > 0 && count2\
    \ > 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n   \
    \ }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp6_yxy1xh.java:59)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s3 = s1 + s2;\n        String s4 = s2 + s1;\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            return \"Yes\";\n        } else {\n          \
    \  return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n       \
    \ if (isGood(s3) || isGood(s4)) {\n                          ^\n  symbol:   method\
    \ isGood(String)\n  location: class Problem\n2 errors\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       int count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i <\
    \ s1.length(); i++) {\n            if (s1.charAt(i) == '(') {\n              \
    \  count1++;\n            } else {\n                count1--;\n            }\n\
    \        }\n        for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 1 && count2 ==\
    \ -1) {\n            return \"Yes\";\n        } else if (count1 == -1 && count2\
    \ == 1) {\n            return \"Yes\";\n        } else {\n            return \"\
    No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpi_tis_92.java:55)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i\
    \ < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \           if (count < 0) {\n                return \"No\";\n            }\n\
    \        }\n        if (count == 0) {\n            return \"Yes\";\n        }\
    \ else {\n            return \"No\";\n        }\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3au9wdli.java:47)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i\
    \ < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \           if (count < 0) {\n                return \"No\";\n            }\n\
    \        }\n        if (count == 0) {\n            return \"Yes\";\n        }\
    \ else {\n            return \"No\";\n        }\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3au9wdli.java:47)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s3 = s1 + s2;\n        String s4 = s2 + s1;\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            return \"Yes\";\n        } else {\n          \
    \  return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n       \
    \ if (isGood(s3) || isGood(s4)) {\n                          ^\n  symbol:   method\
    \ isGood(String)\n  location: class Problem\n2 errors\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s3 = s1 + s2;\n        String s4 = s2 + s1;\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            return \"Yes\";\n        } else {\n          \
    \  return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n       \
    \ if (isGood(s3) || isGood(s4)) {\n                          ^\n  symbol:   method\
    \ isGood(String)\n  location: class Problem\n2 errors\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       int count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i <\
    \ s1.length(); i++) {\n            if (s1.charAt(i) == '(') {\n              \
    \  count1++;\n            } else {\n                count1--;\n            }\n\
    \        }\n        for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 < 0)\
    \ {\n            return \"No\";\n        } else if (count1 > 0 && count2 > 0)\
    \ {\n            return \"No\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 > 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfcv4_fik.java:62)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s3 = s1 + s2;\n        String s4 = s2 + s1;\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            return \"Yes\";\n        } else {\n          \
    \  return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n       \
    \ if (isGood(s3) || isGood(s4)) {\n                          ^\n  symbol:   method\
    \ isGood(String)\n  location: class Problem\n2 errors\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        // Your code here\n        return \"\";\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpm9_rzy6y.java:27)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       int count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i <\
    \ s1.length(); i++) {\n            if (s1.charAt(i) == '(') {\n              \
    \  count1++;\n            } else {\n                count1--;\n            }\n\
    \        }\n        for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else if (count1 < 0 && count2 > 0) {\n            if (count2 == -count1) {\n\
    \                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else {\n            return \"No\";\n     \
    \   }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpkqnb6mo6.java:69)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i\
    \ < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \           if (count < 0) {\n                return \"No\";\n            }\n\
    \        }\n        if (count == 0) {\n            return \"Yes\";\n        }\
    \ else {\n            return \"No\";\n        }\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3au9wdli.java:47)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       int open1 = 0;\n        int open2 = 0;\n        int close1 = 0;\n    \
    \    int close2 = 0;\n        for (int i = 0; i < s1.length(); i++) {\n      \
    \      if (s1.charAt(i) == '(') {\n                open1++;\n            } else\
    \ {\n                close1++;\n            }\n        }\n        for (int i =\
    \ 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n       \
    \         open2++;\n            } else {\n                close2++;\n        \
    \    }\n        }\n        if (open1 == close1 && open2 == close2) {\n       \
    \     return \"Yes\";\n        } else if (open1 == close1 && open2 != close2)\
    \ {\n            return \"No\";\n        } else if (open1 != close1 && open2 ==\
    \ close2) {\n            return \"No\";\n        } else if (open1 != close1 &&\
    \ open2 != close2) {\n            return \"Yes\";\n        }\n        return \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp4jtoer_r.java:56)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i\
    \ < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \           if (count < 0) {\n                return \"No\";\n            }\n\
    \        }\n        if (count == 0) {\n            return \"Yes\";\n        }\
    \ else {\n            return \"No\";\n        }\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3au9wdli.java:47)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s3 = s1 + s2;\n        String s4 = s2 + s1;\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            return \"Yes\";\n        } else {\n          \
    \  return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n/tmp/tmp3dlpmcsi.java:27: error: cannot find symbol\n       \
    \ if (isGood(s3) || isGood(s4)) {\n                          ^\n  symbol:   method\
    \ isGood(String)\n  location: class Problem\n2 errors\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s = s1 + s2;\n        int cnt = 0;\n        for (int i = 0; i <\
    \ s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                cnt++;\n\
    \            } else {\n                cnt--;\n            }\n            if (cnt\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (cnt == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpaq922o9r.java:47)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       int count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i <\
    \ s1.length(); i++) {\n            if (s1.charAt(i) == '(') {\n              \
    \  count1++;\n            } else {\n                count1--;\n            }\n\
    \        }\n        for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpbvjetp32.java:56)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n \
    \       String s = s1 + s2;\n        int open = 0;\n        int close = 0;\n \
    \       for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) ==\
    \ '(') {\n                open++;\n            } else {\n                close++;\n\
    \            }\n            if (close > open) {\n                return \"No\"\
    ;\n            }\n        }\n        if (open == close) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_fia9nza.java:48)\n"
  stdout: ''
