completions:
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ middleIndex = Math.floor(sortedList.length / 2);\n  return sortedList[middleIndex];\n\
  }\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  return median(l[mid], l[mid-1]);\n}\n"
- "  const n = l.length;\n  if (n < 1) {\n    throw new Error(\"median requires at\
  \ least one argument\");\n  }\n  if (n === 1) {\n    return l[0];\n  }\n  const\
  \ mid = Math.floor(n / 2);\n  const left = median(l.slice(0, mid));\n  const right\
  \ = median(l.slice(mid));\n  return ((left + right) / 2) | 0;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return left + Math.ceil(right\
  \ - left);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1 +\
  \ median2) / 2.0;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len\
  \ = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[(len - 1) / 2];\n\
  \  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle];\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ middle = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  l.sort((a, b) => a - b);\n  const half = Math.floor(l.length\
  \ / 2);\n  return l[half];\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2 - 1;\n  const left = median(l.slice(0, mid));\n  const right\
  \ = median(l.slice(mid));\n  return left + right;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a:\
  \ number, b: number) => a - b);\n  const len = sorted.length;\n  if (len % 2 ===\
  \ 0) {\n    return sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len /\
  \ 2);\n  const median1 = sorted[middle];\n  const median2 = sorted[middle + 1];\n\
  \  return (median1 + median2) / 2.0;\n}\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return ((left\
  \ + right) / 2) | 0;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return left + right;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return left + right;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2);\n\
  }\n"
language: ts
name: HumanEval_47_median
prompt: '//Return median of elements in the list l.

  // >>> median([3, 1, 2, 4, 5])

  // 3

  // >>> median([-10, 4, 6, 1000, 10, 20])

  // 15.0

  function median(l: number[]): number {

  '
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4,\
  \ 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n\
  \  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1,\
  \ 3, 9, 9, 2, 7]),7);\n}\n\ntest();"
