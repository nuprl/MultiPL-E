completions:
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ middleIndex = Math.floor(sortedList.length / 2);\n  return sortedList[middleIndex];\n\
  }\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  return median(l[mid], l[mid-1]);\n}\n"
- "  const n = l.length;\n  if (n < 1) {\n    throw new Error(\"median requires at\
  \ least one argument\");\n  }\n  if (n === 1) {\n    return l[0];\n  }\n  const\
  \ mid = Math.floor(n / 2);\n  const left = median(l.slice(0, mid));\n  const right\
  \ = median(l.slice(mid));\n  return ((left + right) / 2) | 0;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return left + Math.ceil(right\
  \ - left);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1 +\
  \ median2) / 2.0;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len\
  \ = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[(len - 1) / 2];\n\
  \  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle];\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ middle = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  l.sort((a, b) => a - b);\n  const half = Math.floor(l.length\
  \ / 2);\n  return l[half];\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2 - 1;\n  const left = median(l.slice(0, mid));\n  const right\
  \ = median(l.slice(mid));\n  return left + right;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a:\
  \ number, b: number) => a - b);\n  const len = sorted.length;\n  if (len % 2 ===\
  \ 0) {\n    return sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len /\
  \ 2);\n  const median1 = sorted[middle];\n  const median2 = sorted[middle + 1];\n\
  \  return (median1 + median2) / 2.0;\n}\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return ((left\
  \ + right) / 2) | 0;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return left + right;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return left + right;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2);\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  return median(l[mid], l[mid-1]);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  return median(l[mid], l[mid-1]);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ middleIndex = Math.floor(sortedList.length / 2);\n  return sortedList[middleIndex];\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return\
  \ l.length % 2 ? left + (right - left) / 2 : left + right;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  if (l[mid] >= l[mid+1]) {\n    return l[mid];\n\
  \  }\n  return l[mid+1];\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n === 1) {\n    return l[0];\n  }\n\
  \  const mid = Math.floor(n / 2);\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return ((left + right) / 2) | 0;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return left + right;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)]\n  }\n  const\
  \ mid = l.length / 2\n  const left = l.slice(0, mid)\n  const right = l.slice(mid)\n\
  \  return median(left) + median(right)\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1 +\
  \ median2) / 2.0;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const n = l.length;\n  if (n %\
  \ 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n  const\
  \ left = median(l.slice(0, half));\n  const right = median(l.slice(half));\n  return\
  \ left + Math.abs(right - left);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len\
  \ = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n  }\n\
  \  const middle = Math.floor(len / 2);\n  const medianOfMiddle = median(sorted.slice(0,\
  \ middle));\n  const medianOfRest = median(sorted.slice(middle));\n  return medianOfMiddle\
  \ + medianOfRest;\n}\n"
- "  const n = l.length\n  if (n < 1) return NaN\n  if (n === 1) return l[0]\n  const\
  \ mid = n >> 1\n  const a = median(l.slice(0, mid))\n  const b = median(l.slice(mid))\n\
  \  return ((a + b) / 2)\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len\
  \ = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n  }\n\
  \  const middle = Math.floor(len / 2);\n  return sorted[middle];\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ middleIndex = Math.floor(sortedList.length / 2);\n  return sortedList[middleIndex];\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error('Cannot compute median of an empty\
  \ list');\n  }\n  const n = l.length;\n  if (n === 1) {\n    return l[0];\n  }\n\
  \  const half = n / 2;\n  if (n % 2) {\n    return median(l[half]) < median(l[half\
  \ - 1]) ? l[half] : l[half - 1];\n  }\n  return median(l[half]);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[l.length / 2 - 1]\n  }\n  const mid =\
  \ l.length / 2\n  const left = l.slice(0, mid)\n  const right = l.slice(mid)\n \
  \ return median(left) + median(right)\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left < right) ? left : right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return (left + right) / 2;\n\
  }\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const middle = l.length / 2;\n  if (middle === 0) {\n    return\
  \ l[middle];\n  }\n  if (middle === 1) {\n    return l[middle - 1];\n  }\n  const\
  \ medianValue = l[middle];\n  const leftMedian = median(l.slice(0, middle));\n \
  \ const rightMedian = median(l.slice(middle + 1));\n  return medianValue + Math.max(leftMedian,\
  \ rightMedian);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ midIndex = Math.floor(sortedList.length / 2);\n  return sortedList[midIndex];\n\
  }\n"
- "  if (l.length === 0) {\n    throw Error('Cannot calculate median of an empty list');\n\
  \  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[(n - 1) / 2] as\
  \ number;\n  }\n  const half = n / 2;\n  let i = 0;\n  let m = 0;\n  while (i <\
  \ half) {\n    m = l[i];\n    if (m > l[half]) {\n      i++;\n    }\n    else if\
  \ (m === l[half]) {\n      i++;\n      m++;\n    }\n    else {\n      m++;\n   \
  \ }\n  }\n  return m / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  if (sorted.length % 2 === 0) {\n    return sorted[mid];\n  }\n\
  \  const medianOfMiddle = Math.floor(mid / 2);\n  return sorted[medianOfMiddle];\n\
  }\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = Math.floor(l.length / 2);\n  const left = l.slice(0, middle);\n  const right\
  \ = l.slice(middle);\n  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const n = l.length;\n  if (n %\
  \ 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n  const\
  \ left = median(l.slice(0, half));\n  const right = median(l.slice(half));\n  return\
  \ (left + right) / 2;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2) | 0;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const mid = Math.floor(n / 2);\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return left + right + l[mid];\n\
  }\n"
- "  const n = l.length\n  if (n < 2) return NaN\n  const mid = ~~(n / 2)\n  const\
  \ a = l[mid]\n  const b = l[n - 1]\n  const c = l[mid]\n  const d = l[n - 1]\n \
  \ return ((a + b + c + d) / 4).toFixed(2) // toFixed returns string, not number\n\
  }\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return ((l[mid]\
  \ + l[mid-1] + l[mid+1] + right) / 4) as number;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right =\
  \ median(l.slice(mid));\n  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error('Cannot compute median of an empty\
  \ list');\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return left + right;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return (left + right) / 2;\n}\n"
- "  const n = l.length\n  if (n < 2) {\n    return l[0]\n  }\n  const half = Math.floor(n\
  \ / 2)\n  const left = median(l[half])\n  const right = median(l[n - half])\n  return\
  \ (left + right) / 2\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return (left + right) / 2;\n\
  }\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ middle = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n === 1) {\n    return l[0];\n  }\n\
  \  const mid = Math.floor(n / 2);\n  if (n % 2) {\n    return median(l[mid]);\n\
  \  }\n  return median(l[mid], l[n - 1]);\n}\n"
- "  const n = l.length\n  if (n < 2) return l[0]\n  const half = n / 2\n  const i\
  \ = half\n  const a = l[half]\n  const b = l[n - 1]\n  let c = l[n - 2]\n  let d\
  \ = l[n - 3]\n  let m\n  if (a > b && a > c) m = a\n  else if (b > c && b > d) m\
  \ = b\n  else m = c\n  if (m === 0) return 0\n  else if (m === 1) return l[n - 1]\n\
  \  else if (m === 2) return l[n - 2]\n  else if (m === 3) return l[n - 3]\n  else\
  \ if (m === 4) return l[n - 4]\n  else if (m === 5) return l[n - 5]\n  else if (m\
  \ === 6) return l[n - 6]\n  else if (m === 7) return l[n - 7]\n  else if (m ===\
  \ 8) return l[n - 8]\n  else if (m === 9) return l[n - 9]\n  else if (m === 10)\
  \ return l[n - 10]\n  else if (m === 11) return l[n - 11]\n  else if (m === 12)\
  \ return l[n - 12]\n  else if (m === 13) return l[n - 13]\n  else if (m === 14)\
  \ return l[n - 14]\n  else if (m === 15) return l[n - 15]\n  else if (m === 16)\
  \ return l[n - 16]\n  else if (m === 17) return l[n - 17]\n  else if (m === 18)\
  \ return l[n - 18]\n  else if (m === 19) return l[n - 19]\n  else if (m === 20)\
  \ return l[n - 20]\n  else if (m === 21) return l[n - 21]\n  else if (m === 22)\
  \ return l[n - 22]\n  else if (m === 23) return l[n - 23]\n  else if (m === 24)\
  \ return l[n - 24]\n  else if (m === 25) return l[n - 25]\n  else if (m === 26)\
  \ return l[n - 26]\n  else if (m === 27) return l[n - 27]\n  else if (m === 28)\
  \ return l[n - 28]\n  else if (m === 29) return l[n - 29]\n  else if (m === 30)\
  \ return l[n - 30]\n  else if (m === 31) return l[n - 31]\n  else if (m === 32)\
  \ return l[n - 32]\n  else if (m === 33) return l[n - 33]\n  else if (m === 34)\
  \ return l[n - 34]\n  else if (m === 35) return l[n - 35]\n  else if (m === 36)\
  \ return l[n - 36]"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return (left + right) / 2;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right =\
  \ median(l.slice(mid));\n  return ((left + right) / 2) | 0;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2);\n\
  }\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[(len - 1) / 2];\n  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle];\n\
  }\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = Math.floor(l.length / 2);\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  l.sort((a, b) => a - b);\n  const mid = l.length / 2;\n  if (mid\
  \ % 1 !== 0) {\n    return l[mid];\n  }\n  const lower = [];\n  const upper = [];\n\
  \  for (let i = 0; i < l.length; i++) {\n    if (i < mid) {\n      lower.push(l[i]);\n\
  \    } else {\n      upper.push(l[i]);\n    }\n  }\n  return median(lower) + median(upper);\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedArr = l.slice().sort((a, b) => a - b);\n  const mid\
  \ = Math.floor(sortedArr.length / 2);\n  if (sortedArr.length % 2 === 0) {\n   \
  \ return sortedArr[mid];\n  }\n  return sortedArr[mid - 1] + sortedArr[mid];\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  if (l.length === 1) {\n    return l[0];\n  }\n  const middle\
  \ = Math.floor(l.length / 2);\n  const medianOfMiddle = median(l.slice(0, middle));\n\
  \  const medianOfRest = median(l.slice(middle));\n  return medianOfMiddle + medianOfRest;\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  return median(l.slice(0, mid), l.slice(mid));\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ middle = Math.floor(sortedList.length / 2);\n  return sortedList[middle];\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle - 1];\n  const median2 = sorted[middle];\n  return (median1 +\
  \ median2) / 2.0;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle];\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len\
  \ = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n  }\n\
  \  const middle = Math.floor(len / 2);\n  const medianOfMiddle = median(sorted.slice(0,\
  \ middle));\n  const medianOfRest = median(sorted.slice(middle));\n  return medianOfMiddle\
  \ + medianOfRest;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left > right) ? left : right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = Math.floor(l.length\
  \ / 2);\n  if (l.length % 2) {\n    return l[mid];\n  }\n  return median(l[mid],\
  \ l[mid-1]);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2);\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list.\");\n  }\n  const n = l.length;\n  if (n === 1) {\n    return l[0];\n  }\n\
  \  const mid = Math.floor(n / 2);\n  if (n % 2) {\n    return median(l[mid]);\n\
  \  }\n  return median(l[mid], l[n - 1]);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const n = l.length;\n  if (n %\
  \ 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n  const\
  \ left = median(l.slice(0, half));\n  const right = median(l.slice(half));\n  return\
  \ left + right;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  l.sort((a, b) => a - b);\n  const mid = l.length / 2;\n  if (l.length\
  \ % 2 === 0) {\n    return l[mid];\n  }\n  return (l[mid] + l[mid-1]) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return l.length % 2 === 0\n    ? left + right\n\
  \    : (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ middle = Math.floor(sortedList.length / 2);\n  if (sortedList.length % 2 === 0)\
  \ {\n    return sortedList[middle];\n  }\n  return sortedList[middle - 1] + sortedList[middle];\n\
  }\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[(len - 1) / 2];\n  }\n  const middle = len / 2;\n  const left = sorted[middle\
  \ - 1];\n  const right = sorted[middle];\n  return ((right - left) / 2 + left);\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  if (l.length === 1) {\n    return l[0];\n  }\n  const mid = l.length\
  \ / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ middleIndex = Math.floor(sortedList.length / 2);\n  return sortedList[middleIndex];\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return (left + right) / 2;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ mid = sortedList.length / 2;\n  if (sortedList.length % 2) {\n    return sortedList[mid];\n\
  \  }\n  return (sortedList[mid - 1] + sortedList[mid]) / 2;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[(len - 1) / 2];\n  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle];\n\
  }\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return\
  \ l.length % 2 ? left + (right - left) / 2 : left + right;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  l.sort((a, b) => a - b);\n  const mid = l.length / 2;\n  if (l.length\
  \ % 2 === 0) {\n    return l[mid];\n  }\n  return (l[mid] + l[mid-1]) / 2;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return left + Math.abs(right\
  \ - left);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[l.length / 2 - 1]\n  }\n  const mid =\
  \ l.length / 2\n  const left = l.slice(0, mid)\n  const right = l.slice(mid)\n \
  \ return median(left) + median(right)\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return ((left + right) / 2);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2 - 1;\n  const left = median(l.slice(0, mid));\n  const right\
  \ = median(l.slice(mid));\n  return left + right;\n}\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return ((left\
  \ + right) / 2) | 0;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list.\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return left + right;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle];\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return (left + right) / 2;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ middle = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return ((l[mid]\
  \ + l[mid-1] + l[mid+1] + right) / 4) as number;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1 +\
  \ median2) / 2.0;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (mid === 0) {\n    return l[mid];\n\
  \  }\n  if (mid === 1) {\n    return l[mid];\n  }\n  return median(l[mid], l[mid\
  \ - 1], l[mid]);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  l.sort((a, b) => a - b);\n  const mid = l.length / 2;\n  if (mid\
  \ % 1 !== 0) {\n    return l[mid];\n  }\n  const lower = [];\n  const upper = [];\n\
  \  for (let i = 0; i < l.length; i++) {\n    if (i < mid) {\n      lower.push(l[i]);\n\
  \    } else {\n      upper.push(l[i]);\n    }\n  }\n  return median(lower) + median(upper);\n\
  }\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2 - 1;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1 +\
  \ median2) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return ((left + right) / 2);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw Error('Cannot compute median of an empty list');\n\
  \  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[(n - 1) / 2] as\
  \ number;\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return left + Math.abs(right - left);\n\
  }\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = Math.floor(l.length / 2);\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return left + Math.abs(right - left);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle];\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  if (l.length === 1) {\n    return l[0];\n  }\n  const mid = Math.floor(l.length\
  \ / 2);\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return l.length % 2 ? left + ((right - left) / 2) : left + right;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle];\n  const median2 = sorted[len - 1 - middle];\n  return median1\
  \ + median2 / (len / 2);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ middle = Math.floor(l.length / 2);\n  const left = l.slice(0, middle);\n  const\
  \ right = l.slice(middle);\n  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle - 1];\n  const median2 = sorted[middle];\n  return median1 + median2\
  \ / (len / 2 - 1);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  l.sort((a, b) => a - b);\n  const mid = l.length / 2;\n  if (l.length\
  \ % 2 === 0) {\n    return l[mid];\n  }\n  return (l[mid] + l[mid-1]) / 2;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const n = l.length;\n  if (n %\
  \ 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n  const\
  \ left = median(l.slice(0, half));\n  const right = median(l.slice(half));\n  return\
  \ (left + right) / 2;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return left + right;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error('Cannot compute median of an empty\
  \ list');\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len =\
  \ sorted.length;\n  if (len % 2 === 0) {\n    return sorted[(len - 1) / 2];\n  }\n\
  \  const middle = Math.floor(len / 2);\n  return sorted[middle];\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const middle = Math.floor(l.length / 2);\n  if (middle === 0)\
  \ {\n    return l[0];\n  }\n  if (middle === 1) {\n    return l[l.length - 1];\n\
  \  }\n  if (middle > 1) {\n    return median(l[middle - 1] + l[middle]);\n  }\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return ((left + right) / 2);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const middle = Math.floor(l.length / 2);\n  if (middle === 0)\
  \ {\n    return l[0];\n  }\n  if (middle === 1) {\n    return l[l.length - 1];\n\
  \  }\n  if (middle > 1) {\n    return median(l[middle - 1] + l[middle]);\n  }\n\
  \  return median(l[middle - 1]);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const middle = l.length / 2;\n  if (middle === 0) {\n    return\
  \ l[0];\n  }\n  if (middle === 1) {\n    return l[l.length - 1];\n  }\n  const medianValue\
  \ = median(l);\n  const leftMedian = median(l.slice(0, middle));\n  const rightMedian\
  \ = median(l.slice(middle + 1));\n  return ((leftMedian + rightMedian) / 2);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const n = l.length;\n  if (n %\
  \ 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n  const\
  \ left = median(l.slice(0, half));\n  const right = median(l.slice(half));\n  return\
  \ (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n === 1) {\n    return l[0];\n  }\n\
  \  const half = n / 2;\n  if (n % 2) {\n    return median(l[half]) < median(l[half\
  \ - 1]) ? l[half] : l[half - 1];\n  }\n  return median(l[half]);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[(len - 1) / 2];\n  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle];\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n === 1) {\n    return l[0];\n  }\n\
  \  const mid = Math.floor(n / 2);\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return ((left + right) / 2) | 0;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2) |\
  \ 0;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const left\
  \ = sorted[middle - 1];\n  const right = sorted[middle];\n  return ((right - left)\
  \ / 2 + left);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = Math.floor(l.length\
  \ / 2);\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return\
  \ median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2) |\
  \ 0;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[l.length / 2 - 1]\n  }\n  const middle\
  \ = Math.floor(l.length / 2)\n  const left = l.slice(0, middle)\n  const right =\
  \ l.slice(middle)\n  return median(left) + median(right)\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
  \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2) | 0;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ middle = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  if (l.length === 1) {\n    return l[0];\n  }\n  const mid = l.length\
  \ / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2);\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return l.length % 2 ? left + right : Math.max(left,\
  \ right);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2 - 1;\n  const left = median(l.slice(0, mid));\n  const right\
  \ = median(l.slice(mid));\n  return left + right;\n}\n"
- "  const n = l.length;\n  if (n < 1) {\n    throw new Error(\"Cannot calculate median\
  \ of an empty list\");\n  }\n  const mid = Math.floor(n / 2);\n  const left = l.slice(0,\
  \ mid);\n  const right = l.slice(mid);\n  return median(left) + median(right);\n\
  }\n"
- "  const n = l.length;\n  if (n < 1) {\n    throw new Error(\"median requires at\
  \ least one argument\");\n  }\n  if (n === 1) {\n    return l[0];\n  }\n  const\
  \ middle = Math.floor(n / 2);\n  const left = l.slice(0, middle);\n  const right\
  \ = l.slice(middle);\n  return median(left) + median(right);\n}\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return ((left\
  \ + right) / 2) | 0;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = Math.floor(l.length\
  \ / 2);\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return\
  \ median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a:\
  \ number, b: number) => a - b);\n  const len = sorted.length;\n  if (len % 2 ===\
  \ 0) {\n    return sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len /\
  \ 2);\n  const median1 = sorted[middle - 1];\n  const median2 = sorted[middle];\n\
  \  return (median1 + median2) / 2.0;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ middle = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  const n = l.length;\n  if (n < 2) {\n    return l[0];\n  }\n  const mid = Math.floor((n\
  \ - 1) / 2);\n  if (l[mid] >= l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid\
  \ + 1];\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  const medianOfLeft =\
  \ getMedian(left);\n  const medianOfRight = getMedian(right);\n  return medianOfLeft\
  \ + medianOfRight;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const middle = Math.floor(l.length / 2);\n  if (middle === 0)\
  \ {\n    return l[0];\n  }\n  if (middle === 1) {\n    return l[l.length - 1];\n\
  \  }\n  const medianValue = median(l[middle]);\n  return l.slice(0, middle).concat([medianValue]).concat(l.slice(middle\
  \ + 1));\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  if (l.length === 1) {\n    return l[0];\n  }\n  const mid = Math.floor(l.length\
  \ / 2);\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return\
  \ median(left) + median(right);\n}\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return ((left\
  \ > right) ? left : right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a - b);\n  const\
  \ middleIndex = Math.floor(sortedList.length / 2);\n  return sortedList[middleIndex];\n\
  }\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left < right) ? left\
  \ : right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
  \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list.\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = Math.floor(n / 2);\n  return median(l[half], l[n -\
  \ half]);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  return sorted[middle\
  \ - 1] + sorted[middle];\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const mid = Math.floor(n / 2);\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2);\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len\
  \ = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n  }\n\
  \  const middle = Math.floor(len / 2);\n  const medianOfMiddle = median(sorted.slice(0,\
  \ middle));\n  const medianOfRest = median(sorted.slice(middle));\n  return medianOfMiddle\
  \ + medianOfRest;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return ((left + right) / 2);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const middle\
  \ = l.length / 2;\n  const left = l.slice(0, middle);\n  const right = l.slice(middle);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const n = l.length;\n  if (n %\
  \ 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n  const\
  \ left = median(l);\n  const right = median(l.slice(half));\n  return half\n   \
  \ ? Math.max(left, right) < Math.abs(left - right) ? left : right\n    : left;\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const middle = Math.floor(l.length / 2);\n  if (l.length % 2\
  \ === 0) {\n    return l[middle];\n  }\n  const left = l.slice(0, middle);\n  const\
  \ right = l.slice(middle);\n  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1 +\
  \ median2) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const leftMedian = median(l.slice(0, mid));\n  const rightMedian\
  \ = median(l.slice(mid));\n  return leftMedian + rightMedian / 2;\n}\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return l.length\
  \ % 2 ? Math.max(left, right) : left + right;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2 - 1;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n\
  \  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2);\n\
  }\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const n = l.length;\n  if (n %\
  \ 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n  const\
  \ left = median(l.slice(0, half));\n  const right = median(l.slice(half));\n  return\
  \ (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const n = l.length;\n  if (n %\
  \ 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n  const\
  \ left = median(l.slice(0, half));\n  const right = median(l.slice(half));\n  return\
  \ ((left < right) ? left : right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle - 1];\n  const median2 = sorted[middle];\n  return median1 + median2\
  \ / (len / 2);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
  \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
  \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
  \ = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1 +\
  \ median2) / 2.0;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = l.length / 2 - 1;\n  const left = median(l.slice(0, mid));\n  const right\
  \ = median(l.slice(mid));\n  return left + right;\n}\n"
- "  const n = l.length;\n  if (n < 2) {\n    return l[0];\n  }\n  const mid = n /\
  \ 2;\n  const left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
  \ + median(right);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
  \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
  \  const right = median(l.slice(half));\n  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len\
  \ = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n  }\n\
  \  const middle = Math.floor(len / 2);\n  return sorted[middle];\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ mid = Math.floor(l.length / 2);\n  const left = l.slice(0, mid);\n  const right\
  \ = l.slice(mid);\n  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2) |\
  \ 0;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const\
  \ right = median(l.slice(mid));\n  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
  \ list\");\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len\
  \ = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n  }\n\
  \  const middle = Math.floor(len / 2);\n  return sorted[middle];\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n\
  \  const right = median(l.slice(mid));\n  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = Math.floor(l.length / 2);\n  if (l.length % 2 ===\
  \ 0) {\n    return l[mid];\n  }\n  const leftMedian = median(l.slice(0, mid));\n\
  \  const rightMedian = median(l.slice(mid));\n  return leftMedian + rightMedian\
  \ / 2;\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[l.length / 2 - 1]\n  }\n  const mid =\
  \ l.length / 2\n  const left = l.slice(0, mid)\n  const right = l.slice(mid)\n \
  \ return median(left) + median(right)\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length <= 1) return l[0];\n  const mid = l.length / 2;\n  const left =\
  \ median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return ((l[mid]\
  \ + l[mid]) / 2) < left ? (left + right) / 2 : left;\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return (left + right) / 2;\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return left + Math.abs(right\
  \ - left);\n}\n"
- "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
  \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
  \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
  \  return ((left + right) / 2);\n}\n"
- "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n  }\n  const\
  \ middle = Math.floor(l.length / 2);\n  const left = l.slice(0, middle);\n  const\
  \ right = l.slice(middle);\n  return median(left) + median(right);\n}\n"
- "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
  \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
  \ mid));\n  const right = median(l.slice(mid));\n  return (left + right) / 2;\n\
  }\n"
language: ts
name: HumanEval_47_median
prompt: '//Return median of elements in the list l.

  // >>> median([3, 1, 2, 4, 5])

  // 3

  // >>> median([-10, 4, 6, 1000, 10, 20])

  // 15.0

  function median(l: number[]): number {

  '
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4,\
  \ 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n\
  \  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1,\
  \ 3, 9, 9, 2, 7]),7);\n}\n\ntest();"
