completions:
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const min: number = Number.MAX_SAFE_INTEGER;\n  const max: number = Number.MIN_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < min) {\n      min = num;\n    } else\
  \ if (num > max) {\n      max = num;\n    }\n  }\n  return [min, max];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst;\n  if (smallest > largest) {\n    return [undefined, undefined];\n\
  \  }\n  if (smallest < 0) {\n    return [smallest, undefined];\n  }\n  return [smallest,\
  \ largest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst;\n  if (smallest > largest) {\n    return [undefined, undefined];\n\
  \  }\n  if (smallest === 0) {\n    return [undefined, smallest];\n  }\n  if (smallest\
  \ < 0) {\n    return [smallest, undefined];\n  }\n  return [smallest, largest];\n\
  }\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
  \  for (const num of lst) {\n    if (num < smallest) {\n      smallest = num;\n\
  \    } else if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  const largest = lst.sort((a, b) => b - a)[0];\n  const smallest = lst.sort((a,\
  \ b) => a - b)[0];\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const [smallest, largest] = lst.reduce(\n    (acc, [smallest, largest]) =>\n\
  \      smallest > largest ? [smallest, largest] : [largest, smallest],\n    [Number.NEGATIVE_INFINITY,\
  \ Number.POSITIVE_INFINITY]\n  );\n  return [smallest, largest];\n}\n"
- "  const smallest = lst.reduce((a, b) => a < b ? a : b);\n  const largest = lst.reduce((a,\
  \ b) => a > b ? a : b);\n  return smallest === undefined ? [undefined, undefined]\
  \ : largest === undefined ? [undefined, undefined] : [smallest, largest];\n}\n"
- "  let max_num = -Infinity;\n  let min_num = Infinity;\n  for (let num of lst) {\n\
  \    if (num < min_num) {\n      min_num = num;\n    }\n    if (num > max_num) {\n\
  \      max_num = num;\n    }\n  }\n  return [max_num, min_num];\n}\n"
- "  const [smallest, largest] = lst.reduce(\n    ([smallest, largest], num) => {\n\
  \      if (num < smallest) {\n        return [num, smallest]\n      } else if (num\
  \ > largest) {\n        return [smallest, num]\n      } else {\n        return [smallest,\
  \ largest]\n      }\n    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n\
  \  )\n  return [smallest, largest]\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < 0) {\n      if (largest < num) {\n        largest = num;\n      }\n    } else\
  \ {\n      if (smallest > num) {\n        smallest = num;\n      }\n    }\n  }\n\
  \  return [largest, smallest];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst.reduce(\n    (acc, val) => (val < acc ? [val, acc] : [acc, val]),\n\
  \    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],\n  );\n  return [smallest,\
  \ largest];\n}\n"
- "  const largest = lst.sort((a, b) => b - a)[0]\n  const smallest = lst.sort((a,\
  \ b) => a - b)[0]\n  return [largest, smallest]\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let num of lst) {\n    if (num > largest) {\n      largest = num;\n    }\
  \ else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst;\n  if (smallest > largest) {\n    return [smallest, largest];\n\
  \  }\n  const [smallest2, largest2] = largest_smallest_integers(lst.slice(1));\n\
  \  if (smallest > smallest2) {\n    return [smallest, smallest2];\n  }\n  if (largest\
  \ < largest2) {\n    return [largest, largest2];\n  }\n  return [smallest2, largest2];\n\
  }\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  const largest = lst.reduce((a, b) => Math.max(a, b), -Infinity);\n  const smallest\
  \ = lst.reduce((a, b) => Math.min(a, b), Infinity);\n  return [largest, smallest];\n\
  }\n"
- "  const [smallest, largest] = lst.reduce(\n    ([smallest, largest], num) => {\n\
  \      if (num < smallest) {\n        return [num, smallest];\n      } else if (num\
  \ > largest) {\n        return [smallest, num];\n      } else {\n        return\
  \ [smallest, largest];\n      }\n    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n\
  \  );\n\n  return [smallest, largest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const min: number = Number.MAX_SAFE_INTEGER;\n  const max: number = Number.MIN_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < min) {\n      min = num;\n    }\n   \
  \ if (num > max) {\n      max = num;\n    }\n  }\n  return [min, max];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0) {\n    return [positive[0], negative[0]];\n\
  \  }\n  if (negative.length > 0) {\n    return [negative[0], undefined];\n  }\n\
  \  return [undefined, undefined];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n\n  const [smallest,\
  \ largest] = lst.reduce(\n    (minMax, [min, max]) => [\n      min > max ? [max,\
  \ min] : [min, max],\n      minMax\n    ],\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n\
  \  );\n\n  return [smallest, largest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const min = -Infinity;\n  const max = Infinity;\n  for (let i = 0; i < lst.length;\
  \ i++) {\n    const n = lst[i];\n    if (n < min) min = n;\n    if (n > max) max\
  \ = n;\n  }\n  return [min, max];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  const negatives = lst.filter(n => n < 0);\n  const positives = lst.filter(n =>\
  \ n > 0);\n  if (negatives.length == 0 && positives.length == 0) {\n    return [undefined,\
  \ undefined];\n  }\n  if (negatives.length == 0) {\n    return [positives[0], undefined];\n\
  \  }\n  if (positives.length == 0) {\n    return [undefined, positives[0]];\n  }\n\
  \  const maxNegative = Math.max(...negatives);\n  const minPositive = Math.min(...positives);\n\
  \  return [maxNegative, minPositive];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst.reduce(\n    (minMax, [cur, next]) => {\n      if (cur > next)\
  \ {\n        return [cur, next];\n      } else if (cur < next) {\n        return\
  \ [next, cur];\n      } else {\n        return [minMax[0], minMax[1]];\n      }\n\
  \    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],\n  );\n  return\
  \ [smallest, largest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    } else if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0) {\n    return [positive[0], negative[0]];\n\
  \  } else if (negative.length > 0) {\n    return [negative[0], undefined];\n  }\
  \ else {\n    return [undefined, undefined];\n  }\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const min_negative = Number.MAX_SAFE_INTEGER;\n  const max_positive = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < 0) {\n      if (min_negative > num) {\n        min_negative = num;\n      }\n\
  \    } else if (num > 0) {\n      if (max_positive < num) {\n        max_positive\
  \ = num;\n      }\n    }\n  }\n  return [min_negative, max_positive];\n}\n"
- "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length;\
  \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i]\
  \ < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n\
  }\n"
- "  const smallest = lst.reduce((a, b) => a < b ? a : b);\n  const largest = lst.reduce((a,\
  \ b) => a > b ? a : b);\n  return smallest === undefined ? [undefined, undefined]\
  \ : largest === undefined ? [undefined, undefined] : [smallest, largest];\n}\n"
- "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length;\
  \ i++) {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n\
  \    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  if (smallest\
  \ === -Infinity) {\n    return [undefined, undefined];\n  }\n  if (largest === Infinity)\
  \ {\n    return [undefined, undefined];\n  }\n  return [smallest, largest];\n}\n"
- "  const negatives = lst.filter(x => x < 0);\n  const positives = lst.filter(x =>\
  \ x > 0);\n  if (negatives.length === 0 && positives.length === 0) {\n    return\
  \ [undefined, undefined];\n  }\n  if (negatives.length === 0) {\n    return [positives[0],\
  \ undefined];\n  }\n  if (positives.length === 0) {\n    return [undefined, positives[0]];\n\
  \  }\n  const largest = negatives.reduce((a, b) => a > b ? a : b);\n  const smallest\
  \ = positives.reduce((a, b) => a < b ? a : b);\n  return [largest, smallest];\n\
  }\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < 0) {\n      smallest = num;\n    } else\
  \ {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
  \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n  \
  \  } else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const negMin = lst.filter(x => x < 0);\n  const posMax = lst.filter(x => x >\
  \ 0);\n  if (negMin.length && posMax.length) {\n    return [Math.min(...negMin),\
  \ Math.max(...posMax)];\n  }\n  return [undefined, undefined];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < 0) {\n      largest = Math.max(largest, num);\n    } else if (num > 0) {\n \
  \     smallest = Math.min(smallest, num);\n    }\n  }\n  return [largest, smallest];\n\
  }\n"
- "  const [minInt, maxInt] = lst.reduce(\n    ([minInt, maxInt], num) => {\n    \
  \  if (num < minInt) {\n        return [num, minInt];\n      } else if (num > maxInt)\
  \ {\n        return [minInt, num];\n      }\n      return [minInt, maxInt];\n  \
  \  },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n  );\n  return\
  \ [minInt, maxInt];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    } else if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const [minInt, maxInt] = lst.reduce(\n    ([minInt, maxInt], num) => {\n    \
  \  if (num < minInt) {\n        return [num, minInt];\n      } else if (num > maxInt)\
  \ {\n        return [minInt, num];\n      }\n      return [minInt, maxInt];\n  \
  \  },\n    [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]\n  );\n  return [minInt,\
  \ maxInt];\n}\n"
- "  const n = lst.length;\n  if (n < 2) {\n    return [undefined, undefined];\n \
  \ }\n  const maxNegative = Number.NEGATIVE_INFINITY;\n  const minPositive = Number.POSITIVE_INFINITY;\n\
  \  let maxNegativeIndex = -1;\n  let minPositiveIndex = -1;\n  for (let i = 0; i\
  \ < n; ++i) {\n    const value = lst[i];\n    if (value < minPositive) {\n     \
  \ minPositiveIndex = i;\n      minPositive = value;\n    } else if (value > maxNegative)\
  \ {\n      maxNegativeIndex = i;\n      maxNegative = value;\n    }\n  }\n  return\
  \ [maxNegative, minPositive];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let num of lst) {\n    if (num > largest) {\n      largest = num;\n    }\
  \ else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  const positive = lst.filter(n => n > 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (negative.length == 0 && positive.length == 0) {\n    return [undefined,\
  \ undefined];\n  }\n  if (negative.length > 0) {\n    return [negative[0], positive[0]];\n\
  \  }\n  if (positive.length > 0) {\n    return [positive[0], negative[0]];\n  }\n\
  \  return [undefined, undefined];\n}\n"
- "  const [smallest, largest] = lst.reduce(\n    ([smallest, largest], num) => {\n\
  \      if (num < smallest) {\n        return [num, smallest];\n      } else if (num\
  \ > largest) {\n        return [smallest, num];\n      }\n      return [smallest,\
  \ largest];\n    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n\
  \  );\n  return [smallest, largest];\n}\n"
- "  const [smallest, largest] = lst.reduce(\n    ([smallest, largest], num) => {\n\
  \      if (num < smallest) {\n        return [num, smallest]\n      } else if (num\
  \ > largest) {\n        return [smallest, num]\n      } else {\n        return [smallest,\
  \ largest]\n      }\n    },\n    [undefined, undefined]\n  )\n  return [smallest,\
  \ largest]\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  const smallest = lst.sort((a, b) => a - b)[0];\n  const largest = lst.sort((a,\
  \ b) => b - a)[0];\n  return [smallest, largest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n  \
  \  } else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  const positive = lst.filter(x => x >= 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  return [undefined, undefined];\n}\n"
- "  const smallest = lst.reduce((a, b) => a < b ? a : b);\n  const largest = lst.reduce((a,\
  \ b) => a > b ? a : b);\n  return smallest === undefined ? [undefined, undefined]\
  \ : largest === undefined ? [undefined, undefined] : [smallest, largest];\n}\n"
- "  const [smallest, largest] = lst.reduce(\n    ([smallest, largest], num) => {\n\
  \      if (num < 0) {\n        return [smallest, num];\n      } else if (num > largest)\
  \ {\n        return [num, largest];\n      } else {\n        return [smallest, num];\n\
  \      }\n    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n  );\n\
  \  return [smallest, largest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let num of lst) {\n    if (num > largest) {\n      largest = num;\n    }\
  \ else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positives = lst.filter(n => n >= 0);\n  const negatives = lst.filter(n\
  \ => n < 0);\n  if (positives.length === 0) {\n    return [undefined, undefined];\n\
  \  }\n  if (negatives.length === 0) {\n    return [positives[0], undefined];\n \
  \ }\n  const maxNegative = Math.max(...negatives);\n  const minPositive = Math.min(...positives);\n\
  \  return [maxNegative, minPositive];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest\
  \ = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n\
  \  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n > 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  let max_num = -Infinity;\n  let min_num = Infinity;\n  for (let num of lst) {\n\
  \    if (num < min_num) {\n      min_num = num;\n    } else if (num > max_num) {\n\
  \      max_num = num;\n    }\n  }\n  return [max_num, min_num];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst.reduce(\n    ([smallest, largest], num) => {\n      if (num < 0)\
  \ {\n        return [smallest, num];\n      } else if (num > largest) {\n      \
  \  return [num, largest];\n      } else {\n        return [smallest, num];\n   \
  \   }\n    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n  );\n\
  \  return [smallest, largest];\n}\n"
- "  const positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return positive;\n\
  \  }\n  if (negative.length > 0) {\n    return negative;\n  }\n  return [undefined,\
  \ undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    } else if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst.reduce(\n    (minLargest, num) => {\n      if (num < minLargest)\
  \ {\n        return [num, minLargest];\n      } else if (num > minLargest) {\n \
  \       return [minLargest, num];\n      }\n      return [minLargest, num];\n  \
  \  },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],\n  );\n  return\
  \ [smallest, largest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const largest = lst.sort((a, b) => b - a)[0];\n  const smallest = lst.sort((a,\
  \ b) => a - b)[0];\n  return [largest, smallest];\n}\n"
- "  const min: number = Number.MAX_SAFE_INTEGER;\n  const max: number = Number.MIN_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < min) min = num;\n    if (num > max) max\
  \ = num;\n  }\n  return [max, min];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (const num of lst) {\n    if (num < smallest) {\n      smallest = num;\n\
  \    } else if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const min: number = Number.MAX_SAFE_INTEGER;\n  const max: number = Number.MIN_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < min) {\n      min = num;\n    }\n   \
  \ if (num > max) {\n      max = num;\n    }\n  }\n  return [min, max];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < 0) {\n      largest = num;\n    } else if (num > 0) {\n      smallest = num;\n\
  \    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positives = lst.filter(n => n >= 0);\n  const negatives = lst.filter(n\
  \ => n < 0);\n  if (positives.length >= negatives.length) {\n    return [positives[positives.length\
  \ - 1] || undefined, negatives[0] || undefined];\n  }\n  return [negatives[negatives.length\
  \ - 1] || undefined, positives[0] || undefined];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const min: number = Number.MAX_SAFE_INTEGER;\n  const max: number = Number.MIN_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < min) min = num;\n    if (num > max) max\
  \ = num;\n  }\n  return [min, max];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const [smallest, largest] = lst.reduce(\n    ([smallest, largest], num) => {\n\
  \      if (num < smallest) {\n        return [num, smallest];\n      } else if (num\
  \ > largest) {\n        return [smallest, num];\n      } else {\n        return\
  \ [smallest, largest];\n      }\n    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n\
  \  );\n  return [smallest, largest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.max(...negative), undefined];\n\
  \  }\n  return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < 0) {\n      largest = Math.max(largest,\
  \ num);\n    } else {\n      smallest = Math.min(smallest, num);\n    }\n  }\n \
  \ return [largest, smallest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  const positives = lst.filter(n => n > 0);\n  const negatives = lst.filter(n =>\
  \ n < 0);\n  if (positives.length === 0) {\n    return [undefined, undefined];\n\
  \  }\n  if (negatives.length === 0) {\n    return [positives[0], undefined];\n \
  \ }\n  const max = Math.max(...negatives);\n  const min = Math.min(...positives);\n\
  \  return [max, min];\n}\n"
- "  const largest = lst.reduce((a, b) => a > b ? a : b);\n  const smallest = lst.reduce((a,\
  \ b) => a < b ? a : b);\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const smallest = Math.min(...lst);\n  const largest = Math.max(...lst);\n  return\
  \ [smallest, largest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const smallest = lst.reduce((a, b) => a < b ? a : b);\n  const largest = lst.reduce((a,\
  \ b) => a > b ? a : b);\n  return [smallest, largest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  const negMin = lst.filter(x => x < 0);\n  const posMax = lst.filter(x => x >\
  \ 0);\n  if (negMin.length && posMax.length) {\n    return [Math.max(...negMin),\
  \ Math.min(...posMax)];\n  }\n  return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.max(...negative), undefined];\n\
  \  }\n  return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positives = lst.filter(x => x > 0);\n  const negatives = lst.filter(x =>\
  \ x < 0);\n  if (positives.length === 0) {\n    return [undefined, undefined];\n\
  \  }\n  if (negatives.length === 0) {\n    return [positives[0], undefined];\n \
  \ }\n  const max = Math.max(...negatives);\n  const min = Math.min(...positives);\n\
  \  return [max, min];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    } else if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < smallest) {\n      smallest = num;\n\
  \    } else if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const [smallest, largest] = lst.reduce(\n    ([smallest, largest], val) => {\n\
  \      if (val < smallest) {\n        smallest = val;\n      }\n      if (val >\
  \ largest) {\n        largest = val;\n      }\n      return [smallest, largest];\n\
  \    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n  );\n  return\
  \ [smallest, largest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  const largest = lst.reduce((a, b) => Math.max(a, b), -Infinity);\n  const smallest\
  \ = lst.reduce((a, b) => Math.min(a, b), Infinity);\n  return [largest, smallest];\n\
  }\n"
- "  let max_negative = Number.NEGATIVE_INFINITY;\n  let min_positive = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < 0) {\n      max_negative = Math.max(max_negative, num);\n    } else if (num\
  \ > 0) {\n      min_positive = Math.min(min_positive, num);\n    } else {\n    \
  \  return [max_negative, min_positive];\n    }\n  }\n  return [max_negative, min_positive];\n\
  }\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.max(...negative), undefined];\n\
  \  }\n  return [undefined, undefined];\n}\n"
- "  const min: number = Number.MAX_SAFE_INTEGER;\n  const max: number = Number.MIN_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num < min) min = num;\n    if (num > max) max\
  \ = num;\n  }\n  return [min, max];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n  \
  \  }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  let largest\
  \ = lst[0];\n  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n\
  \    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest)\
  \ {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    } else if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest\
  \ = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n\
  \  }\n  return [largest, smallest];\n}\n"
- "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length;\
  \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i]\
  \ < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n\
  }\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ > largest) {\n      largest = num;\n    } else if (num < smallest) {\n      smallest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  const min = -Infinity;\n  const max = Infinity;\n  for (const num of lst) {\n\
  \    if (num < min) min = num;\n    if (num > max) max = num;\n  }\n  return [min,\
  \ max];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst;\n  if (smallest > largest) {\n    return [smallest, largest];\n\
  \  }\n  const [smaller, larger] = lst;\n  if (smaller < largest) {\n    return [smaller,\
  \ largest];\n  }\n  const [small, large] = lst;\n  if (small > large) {\n    return\
  \ [small, large];\n  }\n  return [undefined, undefined];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    } else if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let max_negative = Number.NEGATIVE_INFINITY;\n  let min_positive = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < 0) {\n      max_negative = Math.max(max_negative, num);\n    } else if (num\
  \ > 0) {\n      min_positive = Math.min(min_positive, num);\n    } else {\n    \
  \  return [max_negative, min_positive];\n    }\n  }\n  return [max_negative, min_positive];\n\
  }\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length;\
  \ i++) {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n\
  \    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return [smallest,\
  \ largest];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const max_negative\
  \ = lst.reduce((a, b) => Math.max(a, b), -Infinity);\n  const min_positive = lst.reduce((a,\
  \ b) => Math.min(a, b), Infinity);\n  return [max_negative, min_positive];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let num of lst) {\n    if (num > largest) {\n      largest = num;\n    }\n\
  \    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
- "  const positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x =>\
  \ x < 0);\n  if (positive.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.max(...positive), Math.min(...negative)];\n\
  \  }\n  return [undefined, undefined];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < 0) {\n      largest = num;\n    } else if (num > 0) {\n      smallest = num;\n\
  \    }\n  }\n  return [largest, smallest];\n}\n"
- "  let max_negative = Number.NEGATIVE_INFINITY;\n  let min_positive = Number.POSITIVE_INFINITY;\n\
  \  for (let num of lst) {\n    if (num < 0) {\n      max_negative = Math.max(max_negative,\
  \ num);\n    } else {\n      min_positive = Math.min(min_positive, num);\n    }\n\
  \  }\n  return [max_negative, min_positive];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
  \ largest] = lst.reduce(\n    ([smallest, largest], item) => {\n      if (item <\
  \ 0) {\n        return [smallest, item];\n      } else if (item > 0) {\n       \
  \ return [item, largest];\n      } else {\n        return [smallest, largest];\n\
  \      }\n    },\n    [undefined, lst[0]],\n  );\n  return [smallest, largest];\n\
  }\n"
- "  const negative = lst.filter(x => x < 0);\n  const positive = lst.filter(x =>\
  \ x > 0);\n  if (negative.length > 0) {\n    return [negative[0], positive[0]];\n\
  \  }\n  if (positive.length > 0) {\n    return [positive[0], undefined];\n  }\n\
  \  return [undefined, undefined];\n}\n"
- "  const largest = lst.reduce((largest, value) => {\n    if (value > largest) {\n\
  \      return value;\n    }\n    return largest;\n  }, Number.NEGATIVE_INFINITY);\n\
  \  const smallest = lst.reduce((smallest, value) => {\n    if (value < smallest)\
  \ {\n      return value;\n    }\n    return smallest;\n  }, Number.POSITIVE_INFINITY);\n\
  \  return [largest, smallest];\n}\n"
- "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n\n  const [smallest,\
  \ largest] = lst;\n\n  if (smallest > largest) {\n    return [undefined, undefined];\n\
  \  }\n\n  if (smallest === 0) {\n    return [undefined, smallest];\n  }\n\n  if\
  \ (largest === 0) {\n    return [largest, undefined];\n  }\n\n  const [smallest2,\
  \ largest2] = largest_smallest_integers(lst.filter(x => x < smallest));\n\n  if\
  \ (smallest2 === undefined) {\n    return [smallest, largest];\n  }\n\n  const [largest3,\
  \ smallest3] = largest_smallest_integers(lst.filter(x => x > largest));\n\n  if\
  \ (largest3 === undefined) {\n    return [smallest2, largest2];\n  }\n\n  return\
  \ [smallest3, largest3];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return positive;\n\
  \  }\n  if (negative.length > 0) {\n    return negative;\n  }\n  return [undefined,\
  \ undefined];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const smallest = lst.reduce((a, b) => a < b ? a : b);\n  const largest = lst.reduce((a,\
  \ b) => a > b ? a : b);\n  return [smallest, largest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n > 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return [Math.max(...negative),\
  \ Math.min(...positive)];\n  }\n  if (positive.length > 0) {\n    return [Math.min(...positive)];\n\
  \  }\n  if (negative.length > 0) {\n    return [Math.max(...negative)];\n  }\n \
  \ return [undefined, undefined];\n}\n"
- "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
  \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n   \
  \ }\n  }\n  return [largest, smallest];\n}\n"
- "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
  \ n < 0);\n  if (negative.length > 0) {\n    return [negative[0], positive[0]];\n\
  \  }\n  if (positive.length > 0) {\n    return [positive[0], negative[0]];\n  }\n\
  \  return [undefined, undefined];\n}\n"
- "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
  \ < smallest || smallest === Number.MAX_SAFE_INTEGER) {\n      smallest = num;\n\
  \    }\n    if (num > largest || largest === Number.MIN_SAFE_INTEGER) {\n      largest\
  \ = num;\n    }\n  }\n  return [largest, smallest];\n}\n"
- "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
  \  for (let num of lst) {\n    if (num > largest) {\n      largest = num;\n    }\n\
  \    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest,\
  \ smallest];\n}\n"
language: ts
name: HumanEval_136_largest_smallest_integers
prompt: '//Create a function that returns a tuple (a, b), where ''a'' is

  // the largest of negative integers, and ''b'' is the smallest

  // of positive integers in a list.

  // If there is no negative or positive integers, return them as None.

  // Examples:

  // largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)

  // largest_smallest_integers([]) == (None, None)

  // largest_smallest_integers([0]) == (None, None)

  function largest_smallest_integers(lst: number[]): [number | undefined, number |
  undefined] {

  '
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2,\
  \ 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5,\
  \ 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2,\
  \ 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7,\
  \ 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined,\
  \ undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1,\
  \ -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6,\
  \ 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3,\
  \ 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\n\
  test();"
