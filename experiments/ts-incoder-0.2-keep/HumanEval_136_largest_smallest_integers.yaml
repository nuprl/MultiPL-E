name: HumanEval_136_largest_smallest_integers
language: humaneval_to_typescript.py
prompt: "//Create a function that returns a tuple (a, b), where 'a' is\n// the largest\
  \ of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n\
  // If there is no negative or positive integers, return them as None.\n// Examples:\n\
  // largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([])\
  \ == (None, None)\n// largest_smallest_integers([0]) == (None, None)\nfunction largest_smallest_integers(lst:\
  \ number[]): [number | undefined, number | undefined] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2,\
  \ 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5,\
  \ 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2,\
  \ 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7,\
  \ 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined,\
  \ undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1,\
  \ -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6,\
  \ 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3,\
  \ 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\n\
  test();"
completions: ["  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  let largest\
    \ = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
    \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n \
    \   }\n  }\n  return [largest, smallest];\n}\n", "  const positive = lst.filter(n\
    \ => n >= 0);\n  const negative = lst.filter(n => n < 0);\n  if (positive.length\
    \ > 0 && negative.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
    \  }\n  return [undefined, undefined];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const min: number = Number.MAX_SAFE_INTEGER;\n  const max:\
    \ number = Number.MIN_SAFE_INTEGER;\n  for (const num of lst) {\n    if (num <\
    \ min) {\n      min = num;\n    } else if (num > max) {\n      max = num;\n  \
    \  }\n  }\n  return [min, max];\n}\n", "  if (lst.length === 0) {\n    return\
    \ [undefined, undefined];\n  }\n  const [smallest, largest] = lst;\n  if (smallest\
    \ > largest) {\n    return [undefined, undefined];\n  }\n  if (smallest < 0) {\n\
    \    return [smallest, undefined];\n  }\n  return [smallest, largest];\n}\n",
  "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const positive = lst.filter(x => x > 0);\n  const negative\
    \ = lst.filter(x => x < 0);\n  if (positive.length > 0 && negative.length > 0)\
    \ {\n    return [Math.max(...negative), Math.min(...positive)];\n  }\n  if (positive.length\
    \ > 0) {\n    return [Math.max(...positive)];\n  }\n  if (negative.length > 0)\
    \ {\n    return [Math.min(...negative)];\n  }\n  return [undefined, undefined];\n\
    }\n", "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n\
    \ => n < 0);\n  if (positive.length > 0 && negative.length > 0) {\n    return\
    \ [Math.max(...negative), Math.min(...positive)];\n  }\n  if (positive.length\
    \ > 0) {\n    return [Math.max(...positive)];\n  }\n  if (negative.length > 0)\
    \ {\n    return [Math.min(...negative)];\n  }\n  return [undefined, undefined];\n\
    }\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  if (lst.length\
    \ === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest, largest]\
    \ = lst;\n  if (smallest > largest) {\n    return [undefined, undefined];\n  }\n\
    \  if (smallest === 0) {\n    return [undefined, smallest];\n  }\n  if (smallest\
    \ < 0) {\n    return [smallest, undefined];\n  }\n  return [smallest, largest];\n\
    }\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  let largest\
    \ = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num > largest)\
    \ {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest =\
    \ num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    }\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (const num of lst) {\n    if (num < smallest) {\n      smallest = num;\n\
    \    } else if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const largest = lst.sort((a, b) => b - a)[0];\n  const\
    \ smallest = lst.sort((a, b) => a - b)[0];\n  return [largest, smallest];\n}\n",
  "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  const [smallest, largest]\
    \ = lst.reduce(\n    (acc, [smallest, largest]) =>\n      smallest > largest ?\
    \ [smallest, largest] : [largest, smallest],\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n\
    \  );\n  return [smallest, largest];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
