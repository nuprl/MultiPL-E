name: HumanEval_119_match_parens
language: humaneval_to_typescript.py
prompt: "//You are given a list of two strings, both strings consist of open\n// parentheses\
  \ '(' or close parentheses ')' only.\n// Your job is to check if it is possible\
  \ to concatenate the two strings in\n// some order, that the resulting string will\
  \ be good.\n// A string S is considered to be good if and only if all parentheses\
  \ in S\n// are balanced. For example: the string '(())()' is good, while the string\n\
  // '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return\
  \ 'No' otherwise.\n// Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')',\
  \ ')']) == 'No'\nfunction match_parens(lst: string[]): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\"\
  , \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
  ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\");\n\
  \  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
  ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n\
  \  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
completions: ["  if (lst.length < 2) {\n    return 'No';\n  }\n  const stack = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n    if (char\
    \ === '(') {\n      stack.push(char);\n    } else if (char === ')') {\n      if\
    \ (stack.length === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n\
    \      if (top !== char) {\n        return 'No';\n      }\n    }\n  }\n  return\
    \ 'Yes';\n}\n", "  const stack: Stack<string> = new Stack<string>();\n  const\
    \ result: string[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ item = lst[i];\n    if (item === '(') {\n      stack.push(item);\n    } else\
    \ if (item === ')') {\n      if (stack.isEmpty()) {\n        result.push('No');\n\
    \      } else {\n        const top = stack.pop();\n        if (top !== item) {\n\
    \          result.push('No');\n        } else {\n          result.push('Yes');\n\
    \        }\n      }\n    } else {\n      result.push('No');\n    }\n  }\n  return\
    \ result.join('');\n}\n", "  const stack: Stack<string> = new Stack<string>();\n\
    \  const result: string[] = [];\n  for (let i = 0; i < lst.length; i++) {\n  \
    \  if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] ===\
    \ ')') {\n      if (stack.isEmpty()) {\n        result.push('No');\n        break;\n\
    \      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n      \
    \  result.push('No');\n        break;\n      }\n    }\n  }\n  if (stack.isEmpty())\
    \ {\n    result.push('Yes');\n  } else {\n    result.push('No');\n  }\n  return\
    \ result.join('');\n}\n", "  let stack = [];\n  let index = 0;\n  while (index\
    \ < lst.length) {\n    if (lst[index] === '(') {\n      stack.push(lst[index]);\n\
    \      index++;\n    } else if (lst[index] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      stack.pop();\n      index++;\n\
    \    } else {\n      index++;\n    }\n  }\n  return stack.length === 0 ? 'Yes'\
    \ : 'No';\n}\n", "  if (lst.length < 2) {\n    return \"No\";\n  }\n  let stack\
    \ = [];\n  let index = 0;\n  while (index < lst.length) {\n    if (lst[index]\
    \ === \"(\") {\n      stack.push(lst[index]);\n      index++;\n    } else {\n\
    \      if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top !== lst[index]) {\n        return \"No\";\n  \
    \    }\n      index++;\n    }\n  }\n  if (stack.length === 0) {\n    return \"\
    Yes\";\n  }\n  return \"No\";\n}\n", "  if (lst.length < 2) {\n    return 'No';\n\
    \  }\n  let stack: number[] = [];\n  let index = 0;\n  while (index < lst.length)\
    \ {\n    if (lst[index] === '(') {\n      stack.push(index);\n    }\n    if (lst[index]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    }\n    index++;\n  }\n  if (stack.length === 0) {\n \
    \   return 'Yes';\n  }\n  return 'No';\n}\n", "  const stack: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n", "  if (lst.length\
    \ < 2) {\n    return 'No';\n  }\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(i);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      const top = stack.pop();\n      if (top < i) {\n        return 'No';\n\
    \      }\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return\
    \ 'No';\n}\n", "  if (lst.length < 2) {\n    return 'No';\n  }\n  let open = 0;\n\
    \  let close = 0;\n  let i = 0;\n  let j = 0;\n  while (i < lst.length) {\n  \
    \  if (lst[i] === '(') {\n      open++;\n    } else if (lst[i] === ')') {\n  \
    \    close++;\n    } else {\n      if (open > close) {\n        return 'No';\n\
    \      }\n    }\n    i++;\n  }\n  if (open > close) {\n    return 'No';\n  }\n\
    \  return 'Yes';\n}\n", "  let stack: string[] = [];\n  let openCount = 0;\n \
    \ let closeCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === '(') {\n      openCount++;\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      closeCount++;\n      if (openCount > closeCount) {\n     \
    \   return 'No';\n      }\n      openCount--;\n      stack.pop();\n    }\n  }\n\
    \  return 'Yes';\n}\n", "  if (lst.length < 2) {\n    return 'No';\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === '(') {\n      stack.push(index);\n    } else if (lst[index]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      index -= stack.pop();\n    } else {\n      index++;\n    }\n  }\n  return\
    \ 'Yes';\n}\n", "  const stack: Stack<string> = new Stack<string>();\n  const\
    \ result: string[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n    } else\
    \ if (char === ')') {\n      if (stack.isEmpty()) {\n        result.push(char);\n\
    \      } else {\n        const top = stack.pop();\n        if (top !== char) {\n\
    \          result.push(char);\n        }\n      }\n    }\n  }\n  return result.length\
    \ === lst.length ? \"Yes\" : \"No\";\n}\n", "  const stack: string[] = [];\n \
    \ for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n      stack.push('(');\n\
    \    } else if (lst[i] == ')') {\n      if (stack.length == 0) {\n        return\
    \ 'No';\n      }\n      stack.pop();\n    } else {\n      if (stack.length !=\
    \ 0) {\n        return 'No';\n      }\n    }\n  }\n  return stack.length == 0;\n\
    }\n", "  let stack: string[] = [];\n  let result: string = 'No';\n  for (let i\
    \ = 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] == ')') {\n      if (stack.length == 0) {\n        result\
    \ = 'Yes';\n        break;\n      }\n      stack.pop();\n    }\n  }\n  return\
    \ result;\n}\n", "  const stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n", "  const stack\
    \ = [];\n  const res = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n  \
    \    if (stack.length === 0) {\n        res.push('No');\n      } else {\n    \
    \    res.push(stack.pop());\n      }\n    } else {\n      res.push(lst[i]);\n\
    \    }\n  }\n  return res.join('');\n}\n", "  if (lst.length < 2) {\n    return\
    \ 'No';\n  }\n  const stack: Stack<string> = new Stack<string>();\n  const stacks:\
    \ Stack<string>[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str\
    \ = lst[i];\n    if (str === '(') {\n      stack.push(str);\n    } else if (str\
    \ === ')') {\n      while (stack.length > 0 && stack[stack.length - 1] !== '(')\
    \ {\n        stack.pop();\n      }\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      stacks.push(stack);\n      stack.clear();\n    } else\
    \ if (str === ')(') {\n      while (stack.length > 0 && stack[stack.length - 1]\
    \ !== '(') {\n        stack.pop();\n      }\n      if (stack.length === 0) {\n\
    \        return 'No';\n      }\n      stacks.push(stack);\n      stack.clear();\n\
    \    } else {\n      stack.push(str);\n    }\n  }\n  if (stack.length > 0) {\n\
    \    return 'No';\n  }\n  for (let i = 0; i < stacks.length; i++) {\n    const\
    \ stack = stacks[i];\n    for (let j = 0; j < stack.length; j++) {\n      if (stack[j]\
    \ === '(') {\n        stack.splice(j, 1);\n        break;\n      }\n    }\n  }\n\
    \  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n}\n", " \
    \ const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str =\
    \ lst[i];\n    if (str === '(') {\n      stack.push(str);\n    } else if (str\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      const top = stack.pop();\n      if (top !== str) {\n        return 'No';\n\
    \      }\n    }\n  }\n  return 'Yes';\n}\n", "  const stack: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n", "  let stack:\
    \ string[] = [];\n  let result: string = '';\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        result += 'No';\n       \
    \ break;\n      }\n      stack.pop();\n    } else {\n      result += 'No';\n \
    \     break;\n    }\n  }\n  return result == 'Yes' ? 'Yes' : 'No';\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
