name: HumanEval_99_closest_integer
language: humaneval_to_typescript.py
prompt: "//Create a function that takes a value (string) representing a number\n//\
  \ and returns the closest integer to it. If the number is equidistant\n// from two\
  \ integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\"\
  )\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from\
  \ zero means that if the given number is equidistant\n// from two integers, the\
  \ one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunction closest_integer(value: string): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = closest_integer;\n  assert.deepEqual(candidate(\"\
  10\"),10);\n  assert.deepEqual(candidate(\"14.5\"),15);\n  assert.deepEqual(candidate(\"\
  -15.5\"),-16);\n  assert.deepEqual(candidate(\"15.3\"),15);\n  assert.deepEqual(candidate(\"\
  0\"),0);\n}\n\ntest();"
completions: ["  const [integer, decimal] = value.split(\".\");\n  const [integerPart,\
    \ decimalPart] = integer.split(\".\");\n  const [integerPart2, decimalPart2] =\
    \ decimal.split(\".\");\n  const [integerPart3, decimalPart3] = decimalPart2.split(\"\
    .\");\n  const [integerPart4, decimalPart4] = decimalPart3.split(\".\");\n  const\
    \ [integerPart5, decimalPart5] = decimalPart4.split(\".\");\n  const [integerPart6,\
    \ decimalPart6] = decimalPart5.split(\".\");\n  const [integerPart7, decimalPart7]\
    \ = decimalPart6.split(\".\");\n  const [integerPart8, decimalPart8] = decimalPart7.split(\"\
    .\");\n  const [integerPart9, decimalPart9] = decimalPart8.split(\".\");\n  const\
    \ [integerPart10, decimalPart10] = decimalPart9.split(\".\");\n\n  const integerParts\
    \ = [\n    integerPart,\n    integerPart2,\n    integerPart3,\n    integerPart4,\n\
    \    integerPart5,\n    integerPart6,\n    integerPart7,\n    integerPart8,\n\
    \    integerPart9,\n    integerPart10,\n  ];\n\n  const integerParts2 = [];\n\
    \  for (let i = 0; i < integerParts.length; i++) {\n    const integerPart = integerParts[i];\n\
    \    const integerPart2 = integerParts[i + 1];\n    const integerPart3 = integerParts[i\
    \ + 2];\n    const integerPart4 = integerParts[i + 3];\n    const integerPart5\
    \ = integerParts[i + 4];\n    const integerPart6 = integerParts[i + 5];\n    const\
    \ integerPart7 = integerParts[i + 6];\n    const integerPart8 = integerParts[i\
    \ + 7];\n    const integerPart9 = integerParts[i + 8];\n    const integerPart10\
    \ = integerParts[i + 9];\n\n    const integerParts2[i] = [\n      integerPart,\n\
    \      integerPart2,\n      integerPart3,\n      integerPart4,\n      integerPart5,\n\
    \      integerPart6,\n      integerPart7,\n      integerPart8,\n      integerPart9,\n\
    \      integerPart10,\n    ];\n  }\n\n  const integerParts3 = [];\n  for (let\
    \ i = 0; i < integerParts2.length; i++) {\n    const integerParts2[i] = integerParts2[i].sort((a,\
    \ b) => a - b);\n  }\n\n  const integerParts4 = [];\n  for (let i = 0; i < integerParts3.length;\
    \ i++) {\n    const integerParts3[i] = integerParts3[i].sort((a, b) => a - b);\n\
    \  }\n\n  const integerParts5 = [];\n  for (let i = 0; i < integerParts4.length;\
    \ i++) {\n    const integerParts4[i] = integerParts4[i].sort((a, b) => a - b);\n\
    \  }\n\n", "  const num = parseFloat(value);\n  const diff = Math.abs(num - Math.floor(num));\n\
    \  if (diff < 0.5) {\n    return Math.floor(num);\n  }\n  return Math.ceil(num);\n\
    }\n", "  const num = Number(value);\n  const diff = Math.abs(num - Math.floor(num));\n\
    \  if (diff < 1) {\n    return Math.floor(num);\n  }\n  if (diff > 1) {\n    return\
    \ Math.ceil(num);\n  }\n  return num;\n}\n", "  const num = parseFloat(value);\n\
    \  const isNegative = num < 0;\n  const closest = Math.abs(num);\n  const closestInteger\
    \ = Math.abs(closest);\n  if (closestInteger === closest) {\n    return isNegative\
    \ ? closest : -closest;\n  }\n  if (closestInteger < closest) {\n    return isNegative\
    \ ? closest : closest;\n  }\n  return isNegative ? -closest : closest;\n}\n",
  "  const num = parseFloat(value);\n  const diff = num - Math.floor(num);\n  if (diff\
    \ > 0) {\n    return Math.floor(num);\n  }\n  if (diff < 0) {\n    return Math.ceil(num);\n\
    \  }\n  return num;\n}\n", "  const num = parseFloat(value);\n  const diff = Math.abs(num\
    \ - Math.floor(num));\n  if (diff > 0.5) {\n    return Math.floor(num);\n  }\n\
    \  return Math.ceil(num);\n}\n", "  const num = parseFloat(value);\n  if (isNaN(num))\
    \ {\n    throw new Error(`Invalid number ${value}`);\n  }\n  const diff = num\
    \ - Math.floor(num);\n  if (diff < 0) {\n    return Math.floor(num);\n  }\n  if\
    \ (diff > 0) {\n    return Math.ceil(num);\n  }\n  return num;\n}\n", "  const\
    \ num = parseFloat(value);\n  const sign = num < 0 ? -1 : 1;\n  const absNum =\
    \ Math.abs(num);\n  const absNumFloor = Math.floor(absNum);\n  const absNumCeil\
    \ = Math.ceil(absNum);\n  const absNumFloorDiff = absNum - absNumFloor;\n  const\
    \ absNumCeilDiff = absNum - absNumCeil;\n  const diff = Math.abs(absNumFloorDiff\
    \ - absNumCeilDiff);\n  if (diff === 0) {\n    return absNum;\n  }\n  if (diff\
    \ > 0) {\n    return sign * Math.ceil(absNum);\n  }\n  return sign * Math.floor(absNum);\n\
    }\n", "  const [integer, decimal] = value.split(\".\");\n  const [integerPart,\
    \ decimalPart] = integer.split(\".\");\n\n  // If the decimal part is equidistant\
    \ from two integers, round it away\n  // from zero.\n  if (Math.abs(decimalPart\
    \ - integerPart) < 1) {\n    return Math.ceil(decimalPart);\n  }\n\n  return Math.floor(decimalPart);\n\
    }\n", "  const num = Number(value);\n  if (Number.isNaN(num)) {\n    throw new\
    \ Error(`Invalid number ${value}`);\n  }\n  const diff = Math.abs(num - Math.floor(num));\n\
    \  return num - diff > 0.1 ? Math.floor(num) : num;\n}\n", "  const [integer1,\
    \ integer2] = value.split(\".\");\n  const [integer1int, integer2int] = [parseInt(integer1),\
    \ parseInt(integer2)];\n  if (Math.abs(integer1int - integer2int) < 1) {\n   \
    \ return integer1int;\n  }\n  return integer2int;\n}\n", "  const [integerPart,\
    \ decimalPart] = value.split(\".\");\n  const integerPartNumber = parseInt(integerPart);\n\
    \  const decimalPartNumber = parseFloat(decimalPart);\n  if (decimalPartNumber\
    \ === 0) {\n    return integerPartNumber;\n  }\n  return integerPartNumber + (decimalPartNumber\
    \ < 0 ? 1 : -1);\n}\n", "  let closest: number = null;\n  let closestDiff: number\
    \ = null;\n  for (let i = 0; i < value.length; i++) {\n    const currentChar =\
    \ value[i];\n    const currentDiff = Math.abs(parseInt(currentChar) - parseInt(closest));\n\
    \    if (currentDiff < closestDiff) {\n      closest = currentChar;\n      closestDiff\
    \ = currentDiff;\n    }\n  }\n  return parseInt(closest);\n}\n", "  const num\
    \ = parseFloat(value);\n  if (isNaN(num)) {\n    throw new Error(`Cannot parse\
    \ ${value} as a number`);\n  }\n  if (num === 0) {\n    return 0;\n  }\n  if (num\
    \ > 0) {\n    return Math.floor(num);\n  }\n  if (num < 0) {\n    return Math.ceil(num);\n\
    \  }\n  return num;\n}\n", "  const num = parseFloat(value);\n  const diff = Math.abs(num\
    \ - Math.floor(num));\n  if (diff > 0.5) {\n    return Math.floor(num);\n  }\n\
    \  return Math.ceil(num);\n}\n", "  const num = Number(value);\n  const diff =\
    \ Math.abs(num - Math.floor(num));\n  if (diff < 0.5) {\n    return Math.floor(num);\n\
    \  }\n  return Math.ceil(num);\n}\n", "  const num = Number(value);\n  if (Number.isNaN(num))\
    \ {\n    throw new Error(`Invalid number ${value}`);\n  }\n  if (num === 0) {\n\
    \    return 0;\n  }\n  if (num > 0) {\n    return num;\n  }\n  const diff = num\
    \ - Math.floor(num);\n  if (Math.abs(diff) < Number.EPSILON) {\n    return Math.floor(num);\n\
    \  }\n  return Math.floor(num) + Math.sign(diff) * Number.EPSILON;\n}\n", "  const\
    \ num = Number(value);\n  const diff = num - Math.floor(num);\n  if (diff > 0)\
    \ {\n    return Math.floor(num);\n  }\n  if (diff < 0) {\n    return Math.ceil(num);\n\
    \  }\n  return num;\n}\n", "  const [integer1, integer2] = value.split(\".\");\n\
    \  const [integer1int, integer2int] = [parseInt(integer1), parseInt(integer2)];\n\
    \  if (integer1int < integer2int) {\n    return integer1int;\n  }\n  return integer2int;\n\
    }\n", "  const num = Number(value);\n  const isNegative = num < 0;\n  const absNum\
    \ = Math.abs(num);\n  let closestNum = absNum;\n  let closestDiff = absNum;\n\
    \  if (absNum < Number.MAX_SAFE_INTEGER) {\n    if (absNum < Number.MIN_SAFE_INTEGER)\
    \ {\n      // If `absNum` is less than the minimum safe integer,\n      // then\
    \ `closestNum` will be the minimum safe integer\n      // and `closestDiff` will\
    \ be zero.\n      closestNum = Number.MIN_SAFE_INTEGER;\n      closestDiff = 0;\n\
    \    } else {\n      // If `absNum` is greater than the maximum safe integer,\n\
    \      // then `closestNum` will be the maximum safe integer\n      // and `closestDiff`\
    \ will be zero.\n      closestNum = Number.MAX_SAFE_INTEGER;\n      closestDiff\
    \ = 0;\n    }\n  } else {\n    // If `absNum` is greater than the maximum safe\
    \ integer,\n    // then `closestNum` will be the maximum safe integer\n    //\
    \ and `closestDiff` will be zero.\n    closestNum = Number.MAX_SAFE_INTEGER;\n\
    \    closestDiff = 0;\n  }\n  if (isNegative) {\n    closestNum *= -1;\n    closestDiff\
    \ *= -1;\n  }\n  return closestNum + closestDiff;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
