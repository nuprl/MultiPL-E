completions:
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- "    const u: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n       \
  \ if (u.indexOf(l[i]) === -1) {\n            u.push(l[i]);\n        }\n    }\n \
  \   return u;\n}\n"
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- '  return l.filter((v, i, a) => a.indexOf(v) === i);

  }

  '
- "  const a: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (a.indexOf(l[i])\
  \ === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n}\n"
- "    const u: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n       \
  \ if (u.indexOf(l[i]) === -1) {\n            u.push(l[i]);\n        }\n    }\n \
  \   return u;\n}\n"
- "  const a: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (a.indexOf(l[i])\
  \ === -1) a.push(l[i]);\n  }\n  return a;\n}\n"
- "  const a: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (a.indexOf(l[i])\
  \ === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n}\n"
- '  return l.filter((v, i, a) => a.indexOf(v) === i);

  }

  '
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- "  const a: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (a.indexOf(l[i])\
  \ === -1) a.push(l[i]);\n  }\n  return a;\n}\n"
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
  \ === -1) {\n      u.push(l[i]);\n    }\n  }\n  return u;\n}\n"
- "\tconst u: number[] = [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\tif (u.indexOf(l[i])\
  \ === -1) {\n\t\t\tu.push(l[i]);\n\t\t}\n\t}\n\treturn u;\n}\n"
- "\tlet i: number;\n\tlet j: number;\n\tlet result: number[] = [];\n\tlet seen: number[]\
  \ = [];\n\tlet num: number;\n\tlet last: number;\n\n\tfor (i = 0; i < l.length;\
  \ i++) {\n\t\tnum = l[i];\n\t\tlast = i;\n\t\twhile (num) {\n\t\t\tj = i;\n\t\t\t\
  while (num) {\n\t\t\t\tif (num === l[j]) {\n\t\t\t\t\tresult.push(num);\n\t\t\t\t\
  \tseen[j] = num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t\tnum = seen[j];\n\
  \t\t\t}\n\t\t\ti = j;\n\t\t\tnum = seen[i];\n\t\t}\n\t}\n\treturn result;\n}\n"
- "\tconst u: number[] = [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\tif (u.indexOf(l[i])\
  \ === -1) {\n\t\t\tu.push(l[i]);\n\t\t}\n\t}\n\treturn u;\n}\n"
language: ts
name: HumanEval_34_unique
prompt: '//Return sorted unique elements in a list

  // >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])

  // [0, 2, 3, 5, 9, 123]

  function unique(l: number[]): number[] {

  '
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = unique;\n  assert.deepEqual(candidate([5, 3, 5, 2,\
  \ 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);\n}\n\ntest();"
