name: HumanEval_59_largest_prime_factor
language: humaneval_to_typescript.py
prompt: "//Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  // >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n//\
  \ 2\nfunction largest_prime_factor(n: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_prime_factor;\n  assert.deepEqual(candidate(15),5);\n\
  \  assert.deepEqual(candidate(27),3);\n  assert.deepEqual(candidate(63),7);\n  assert.deepEqual(candidate(330),11);\n\
  \  assert.deepEqual(candidate(13195),29);\n}\n\ntest();"
completions: ["  let factors: number[] = [];\n  let isPrime = true;\n  for (let i\
    \ = 2; i <= n; i++) {\n    if (isPrime) {\n      factors.push(i);\n    }\n   \
    \ for (let j = 2; j < i; j++) {\n      if (n % i == 0) {\n        isPrime = false;\n\
    \      }\n    }\n  }\n  return factors[factors.length - 1];\n}\n", "  let factors:\
    \ number[] = [];\n  let maxFactor: number = 1;\n  let i: number;\n  for (i = 2;\
    \ i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      if (i\
    \ > maxFactor) {\n        maxFactor = i;\n      }\n    }\n  }\n  if (factors.length\
    \ === 0) {\n    return 1;\n  }\n  if (factors.length === 1) {\n    return factors[0];\n\
    \  }\n  return factors[factors.length - 1];\n}\n", "  let factors: number[] =\
    \ [];\n  let maxFactor = n;\n  let maxFactorIndex = 0;\n  for (let i = 2; i <=\
    \ maxFactor; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      if\
    \ (i > maxFactor) {\n        maxFactor = i;\n        maxFactorIndex = factors.length\
    \ - 1;\n      }\n    }\n  }\n  return factors[maxFactorIndex];\n}\n", "  let factors:\
    \ number[] = [];\n  let maxFactor = n;\n  let maxFactorIndex = 0;\n  for (let\
    \ i = 2; i <= maxFactor; i++) {\n    while (n % i == 0) {\n      factors.push(i);\n\
    \      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push(n);\n  }\n  return\
    \ factors[factors.length - 1];\n}\n", "  let factors: number[] = [];\n  let isPrime\
    \ = true;\n  for (let i = 2; i <= n; i++) {\n    if (isPrime) {\n      factors.push(i);\n\
    \    }\n    for (let j = 2; j < i; j++) {\n      if (n % i == 0) {\n        isPrime\
    \ = false;\n        break;\n      }\n    }\n  }\n  return factors[factors.length\
    \ - 1];\n}\n", "  let i = 2;\n  while (i < n) {\n    if (n % i == 0) {\n     \
    \ n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  return i;\n}\n", " \
    \ let i = 2;\n  while (i < n) {\n    if (n % i == 0) {\n      n = n / i;\n   \
    \ } else {\n      i = i + 1;\n    }\n  }\n  return i;\n}\n", "  let i = 2;\n \
    \ while (i < n) {\n    if (n % i == 0) {\n      n = n / i;\n    } else {\n   \
    \   i = i + 1;\n    }\n  }\n  return i;\n}\n", "  let factors: number[] = [];\n\
    \  let isPrime = true;\n  for (let i = 2; i <= n; i++) {\n    if (isPrime) {\n\
    \      factors.push(i);\n    }\n    for (let j = i * i; j < n; j += i) {\n   \
    \   isPrime = false;\n    }\n  }\n  return factors[factors.length - 1];\n}\n",
  "  let factors: number[] = [];\n  let maxFactor: number = 0;\n  for (let i = 2;\
    \ i <= n; i++) {\n    while (n % i == 0) {\n      factors.push(i);\n      n /=\
    \ i;\n    }\n    if (n > 1) {\n      factors.push(n);\n      n = 1;\n    }\n \
    \ }\n  if (n > 1) {\n    factors.push(n);\n  }\n  while (factors.length != 0)\
    \ {\n    maxFactor = Math.max(maxFactor, factors[factors.length - 1]);\n    factors.pop();\n\
    \  }\n  return maxFactor;\n}\n", "  let factors: number[] = [];\n  for (let i\
    \ = 2; i <= n; i++) {\n    while (n % i === 0) {\n      factors.push(i);\n   \
    \   n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push(n);\n  }\n  return factors[factors.length\
    \ - 1];\n}\n", "  let factors: number[] = [];\n  let maxFactor = n;\n  let maxFactorIndex\
    \ = 0;\n  for (let i = 2; i <= maxFactor; i++) {\n    if (n % i === 0) {\n   \
    \   factors.push(i);\n      if (i > maxFactor) {\n        maxFactor = i;\n   \
    \     maxFactorIndex = factors.length - 1;\n      }\n    }\n  }\n  return factors[maxFactorIndex];\n\
    }\n", "  let i = 2;\n  while (i < n) {\n    if (n % i == 0) {\n      n = n / i;\n\
    \    } else {\n      i = i + 1;\n    }\n  }\n  return i;\n}\n", "    let i = 2;\n\
    \    let p = n;\n    while (p % i === 0) {\n        p /= i;\n        i++;\n  \
    \  }\n    return p;\n}\n", "  let factors: number[] = [];\n  for (let i = 2; i\
    \ <= n; i++) {\n    while (n % i === 0) {\n      factors.push(i);\n      n /=\
    \ i;\n    }\n  }\n  return factors.length ? factors[factors.length - 1] : 1;\n\
    }\n", "    let i = 2;\n    let p = 2;\n    let q = 3;\n    while (i <= n) {\n\
    \        if (n % i == 0) {\n            n = n / i;\n            p = i;\n     \
    \       q = i;\n        }\n        i++;\n    }\n    return p * q;\n}\n", "   \
    \ let i = 2;\n    let p = n;\n    while (i < p) {\n        if (n % i == 0) {\n\
    \            p /= i;\n        }\n        else {\n            i += 1;\n       \
    \ }\n    }\n    return p;\n}\n", "  let i = 2;\n  while (i < n) {\n    if (n %\
    \ i == 0) {\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  return\
    \ i;\n}\n", "  let i = 2;\n  while (i < n) {\n    if (n % i == 0) {\n      n =\
    \ n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  return i;\n}\n", "  let\
    \ i = 2;\n  while (i < n) {\n    if (n % i == 0) {\n      n = n / i;\n    } else\
    \ {\n      i = i + 1;\n    }\n  }\n  return i;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
