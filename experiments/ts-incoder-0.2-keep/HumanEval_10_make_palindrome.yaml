completions:
- "  const reverse = string\n    .split('')\n    .reverse()\n    .join('');\n  return\
  \ string + reverse;\n}\n"
- "  const reverse: string = string\n    .split('')\n    .reverse()\n    .join('');\n\
  \  const prefix: string = string.slice(0, string.length - reverse.length);\n  return\
  \ prefix + reverse;\n}\n"
- "  let longestPalindrome = longestPalindromeFrom(string);\n  let reversedString\
  \ = reverseString(longestPalindrome);\n  return reversedString + longestPalindrome;\n\
  }\n"
- "  const reversed_string = string\n    .toLowerCase()\n    .split('')\n    .reverse()\n\
  \    .join('');\n\n  const prefix_length = string.length - reversed_string.length;\n\
  \n  return string + reversed_string.substr(0, prefix_length);\n}\n"
- "  const reverse: string = string\n    .split('')\n    .reverse()\n    .join('');\n\
  \  return string + reverse;\n}\n"
- "  const reverse: string = string\n    .split('')\n    .reverse()\n    .join('');\n\
  \  const prefix: string = string.slice(0, reverse.length);\n  const suffix: string\
  \ = string.slice(reverse.length);\n  return prefix + reverse + suffix;\n}\n"
- "  let longestPalindrome: string = '';\n  let longestPalindromeLength: number =\
  \ 0;\n  for (let i = 0; i < string.length; i++) {\n    let currentChar: string =\
  \ string[i];\n    let currentPalindrome: string = currentChar + currentChar;\n \
  \   let currentPalindromeLength: number = currentPalindrome.length;\n    if (currentPalindromeLength\
  \ > longestPalindromeLength) {\n      longestPalindrome = currentPalindrome;\n \
  \     longestPalindromeLength = currentPalindromeLength;\n    }\n  }\n  let reversedString:\
  \ string = longestPalindrome.split('').reverse().join('');\n  return string + reversedString;\n\
  }\n"
- "  let longestPalindrome = string.substr(0, string.length - 1);\n  let reversedLongestPalindrome\
  \ = longestPalindrome.reverse();\n  return string + reversedLongestPalindrome;\n\
  }\n"
- "  let reverse: string = string\n  let prefix: string = ''\n  let suffix: string\
  \ = ''\n  let longestPalindrome: string = ''\n  for (let i = 0; i < string.length;\
  \ i++) {\n    if (string[i] === string[string.length - 1 - i]) {\n      reverse\
  \ = reverse.slice(0, -1) + string[i]\n      prefix = string.slice(0, i) + string[i]\n\
  \      suffix = string.slice(i + 1) + string[i]\n      longestPalindrome = prefix\
  \ + reverse + suffix\n    }\n  }\n  return longestPalindrome\n}\n"
- "    const prefix_length: number = string.length;\n    const suffix_length: number\
  \ = string.length - prefix_length;\n    const prefix_reverse: string = string.substr(prefix_length,\
  \ string.length - prefix_length);\n    const suffix_reverse: string = string.substr(0,\
  \ suffix_length);\n    const palindrome: string = prefix_reverse + suffix_reverse;\n\
  \    return palindrome;\n}\n"
- "  let reverse: string = string\n  let longest: string = string\n  let prefix: string\
  \ = ''\n  let suffix: string = ''\n  let palindrome: string = ''\n  let i: number\
  \ = 0\n  let j: number = 0\n  while (i < string.length) {\n    longest = longest.slice(0,\
  \ i)\n    suffix = string.slice(i)\n    prefix = prefix.slice(0, i)\n    palindrome\
  \ = prefix + longest.slice(-1) + suffix\n    if (palindrome === string) {\n    \
  \  break\n    }\n    i++\n  }\n  return palindrome\n}\n"
- "  let reverse: string = string\n  let prefix: string = ''\n  let suffix: string\
  \ = ''\n  let longest: number = 0\n  let i: number = 0\n  while (i < string.length)\
  \ {\n    const char = string[i]\n    const next = string[i + 1]\n    if (char ===\
  \ next) {\n      i++\n      continue\n    }\n    if (char === reverse[reverse.length\
  \ - longest]) {\n      longest++\n      reverse = reverse.slice(0, reverse.length\
  \ - longest) + char + reverse.slice(reverse.length - longest)\n      continue\n\
  \    }\n    if (next === reverse[reverse.length - longest]) {\n      longest++\n\
  \      reverse = reverse.slice(0, reverse.length - longest) + char + reverse.slice(reverse.length\
  \ - longest)\n      continue\n    }\n    if (next === reverse[reverse.length - longest])\
  \ {\n      longest++\n      reverse = reverse.slice(0, reverse.length - longest)\
  \ + char + reverse.slice(reverse.length - longest)\n      continue\n    }\n    if\
  \ (next === reverse[reverse.length - longest]) {\n      longest++\n      reverse\
  \ = reverse.slice(0, reverse.length - longest) + char + reverse.slice(reverse.length\
  \ - longest)\n      continue\n    }\n    if (next === reverse[reverse.length - longest])\
  \ {\n      longest++\n      reverse = reverse.slice(0, reverse.length - longest)\
  \ + char + reverse.slice(reverse.length - longest)\n      continue\n    }\n    if\
  \ (next === reverse[reverse.length - longest]) {\n      longest++\n      reverse\
  \ = reverse.slice(0, reverse.length - longest) + char + reverse.slice(reverse.length\
  \ - longest)\n      continue\n    }\n    if (next === reverse[reverse.length - longest])\
  \ {\n      longest++\n      reverse = reverse.slice(0, reverse.length - longest)\
  \ + char + reverse.slice(reverse.length - longest)\n      continue\n    }\n    if\
  \ (next === reverse[reverse.length - longest]) {\n      longest++\n      reverse\
  \ = reverse.slice(0, reverse.length - longest) + char + reverse.slice(reverse.length\
  \ - longest)\n      continue\n    }\n    if (next === reverse[reverse.length - longest])\
  \ {\n      longest++\n      reverse = reverse.slice(0, reverse.length - longest)\
  \ + char + reverse.slice(reverse.length - longest)\n      continue\n    }\n    if\
  \ (next === reverse[reverse.length - longest]) {\n      longest++\n      reverse\
  \ = reverse.slice(0, reverse.length - longest) + char + reverse.slice(reverse.length\
  \ - longest)\n      continue\n    }\n    if (next === reverse[reverse.length - longest])\
  \ {\n      longest++\n      reverse = reverse.slice(0, reverse.length - longest)\
  \ + char + reverse.slice(reverse.length - longest)\n      continue\n    }\n    if\
  \ (next === reverse[reverse.length - longest]) {\n      longest++\n      reverse\
  \ = reverse.slice(0, reverse.length - longest) + char + reverse"
- "  const reverse: string = string\n    .split('')\n    .reverse()\n    .join('');\n\
  \  return string + reverse;\n}\n"
- "  const reversed = string\n    .toLowerCase()\n    .split('')\n    .reverse()\n\
  \    .join('');\n  return string + reversed;\n}\n"
- "  let longestPalindrome = string.split('').reverse().join('');\n  let prefixToPalindrome\
  \ = longestPalindrome.split('');\n  let suffixToPalindrome = longestPalindrome.split('').reverse().join('');\n\
  \  let palindrome = longestPalindrome;\n  let i = 0;\n  while (i < longestPalindrome.length)\
  \ {\n    let char = longestPalindrome[i];\n    if (char === suffixToPalindrome[i])\
  \ {\n      palindrome += prefixToPalindrome[i];\n      i++;\n    } else {\n    \
  \  palindrome += char;\n    }\n  }\n  return palindrome;\n}\n"
- "  let longestPalindrome = find_longest_palindrome(string);\n  let reversedString\
  \ = reverseString(string, longestPalindrome);\n  return reversedString + longestPalindrome;\n\
  }\n"
- "  const reverse = string.replace(/^./g, (match) => match.split('').reverse().join(''));\n\
  \  return string + reverse;\n}\n"
- "  const reverse: string = string\n    .split('')\n    .reverse()\n    .join('');\n\
  \  const prefix: string = string.substr(0, reverse.length);\n  return prefix + reverse;\n\
  }\n"
- "  let longestPalindrome = string\n  let longestPalindromeLength = string.length\n\
  \  for (let i = 0; i < string.length; i++) {\n    let currentChar = string[i]\n\
  \    let currentPalindrome = string\n    let currentPalindromeLength = string.length\n\
  \    for (let j = i; j < string.length; j++) {\n      let nextChar = string[j]\n\
  \      let nextPalindrome = string\n      let nextPalindromeLength = string.length\n\
  \      if (currentChar === nextChar) {\n        currentPalindrome = currentPalindrome.substring(0,\
  \ j) + currentPalindrome.substring(j + 1, currentPalindromeLength)\n        currentPalindromeLength\
  \ += 1\n      } else {\n        break\n      }\n    }\n    if (currentPalindromeLength\
  \ > longestPalindromeLength) {\n      longestPalindrome = currentPalindrome\n  \
  \    longestPalindromeLength = currentPalindromeLength\n    }\n  }\n  return longestPalindrome\n\
  }\n"
- "  const reversed = string\n    .split('')\n    .reverse()\n    .join('');\n  return\
  \ `${string}${reversed}`;\n}\n"
language: ts
name: HumanEval_10_make_palindrome
prompt: '//Find the shortest palindrome that begins with a supplied string.

  // Algorithm idea is simple:

  // - Find the longest postfix of supplied string that is a palindrome.

  // - Append to the end of the string reverse of a string prefix that comes before
  the palindromic suffix.

  // >>> make_palindrome('''')

  // ''''

  // >>> make_palindrome(''cat'')

  // ''catac''

  // >>> make_palindrome(''cata'')

  // ''catac''

  function make_palindrome(string: string): string {

  '
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = make_palindrome;\n  assert.deepEqual(candidate(\"\"\
  ),\"\");\n  assert.deepEqual(candidate(\"x\"),\"x\");\n  assert.deepEqual(candidate(\"\
  xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"\
  jerry\"),\"jerryrrej\");\n}\n\ntest();"
