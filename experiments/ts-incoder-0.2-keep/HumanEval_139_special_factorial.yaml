completions:
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  if (n === 0) {\n    return 1;\n  }\n  return factorial(n) * special_factorial(n\
  \ - 1);\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  if (n < 1) {\n    return 1;\n  }\n  return n * special_factorial(n - 1);\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  if (n === 0) {\n    return 1;\n  }\n  return n * special_factorial(n - 1);\n\
  }\n"
- "  if (n === 0) {\n    return 1;\n  }\n  return factorial(n) * special_factorial(n\
  \ - 1);\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
- "  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n \
  \ }\n  return factorial;\n}\n"
language: ts
name: HumanEval_139_special_factorial
prompt: '//The Brazilian factorial is defined as:

  // brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!

  // where n > 0

  // For example:

  // >>> special_factorial(4)

  // 288

  // The function will receive an integer as input and should return the special

  // factorial of this integer.

  function special_factorial(n: number): number {

  '
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = special_factorial;\n  assert.deepEqual(candidate(4),288);\n\
  \  assert.deepEqual(candidate(5),34560);\n  assert.deepEqual(candidate(7),125411328000);\n\
  \  assert.deepEqual(candidate(1),1);\n}\n\ntest();"
