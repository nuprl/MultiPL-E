name: HumanEval_20_find_closest_elements
language: humaneval_to_typescript.py
prompt: "//From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  // (2.0, 2.2)\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n//\
  \ (2.0, 2.0)\nfunction find_closest_elements(numbers: number[]): [number, number]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = find_closest_elements;\n  assert.deepEqual(candidate([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);\n  assert.deepEqual(candidate([1.0, 2.0,\
  \ 5.9, 4.0, 5.0]),[5.0, 5.9]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]),[2.0, 2.2]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]),[2.0, 2.0]);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2,\
  \ 3.1]);\n}\n\ntest();"
completions: ["\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\t\
    for (let i = 1; i < numbers.length; i++) {\n\t\tmin = Math.min(min, numbers[i]);\n\
    \t\tmax = Math.max(max, numbers[i]);\n\t}\n\treturn [min, max];\n}\n", "\tlet\
    \ min: number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor (let i = 1;\
    \ i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\
    \t\t} else if (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn\
    \ [min, max];\n}\n", "  if (numbers.length < 2) {\n    throw new Error(\"find_closest_elements:\
    \ numbers.length < 2\");\n  }\n  const smallest = numbers[0];\n  const largest\
    \ = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i]\
    \ < smallest) {\n      smallest = numbers[i];\n    }\n    if (numbers[i] > largest)\
    \ {\n      largest = numbers[i];\n    }\n  }\n  return [smallest, largest];\n\
    }\n", "  if (numbers.length < 2) {\n    throw new Error(\"Must have at least two\
    \ numbers to compare\");\n  }\n  let smallest: number = numbers[0];\n  let largest:\
    \ number = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i]\
    \ < smallest) {\n      smallest = numbers[i];\n    }\n    if (numbers[i] > largest)\
    \ {\n      largest = numbers[i];\n    }\n  }\n  return [smallest, largest];\n\
    }\n", "  let min: number = numbers[0];\n  let max: number = numbers[0];\n  for\
    \ (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min\
    \ = numbers[i];\n    } else if (numbers[i] > max) {\n      max = numbers[i];\n\
    \    }\n  }\n  return [min, max];\n}\n", "  if (numbers.length < 2) {\n    throw\
    \ new Error(\"find_closest_elements expects at least two numbers to compare\"\
    );\n  }\n\n  let minDiff = Number.MAX_SAFE_INTEGER;\n  let minDiffIndex = 0;\n\
    \  let minDiffValue = numbers[0];\n\n  for (let i = 1; i < numbers.length; i++)\
    \ {\n    const diff = Math.abs(numbers[i] - minDiffValue);\n    if (diff < minDiff)\
    \ {\n      minDiff = diff;\n      minDiffIndex = i;\n    }\n  }\n\n  return [minDiffValue,\
    \ numbers[minDiffIndex]];\n}\n", "\tlet min: number = numbers[0];\n\tlet max:\
    \ number = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i]\
    \ < min) {\n\t\t\tmin = numbers[i];\n\t\t}\n\t\tif (numbers[i] > max) {\n\t\t\t\
    max = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n}\n", "  if (numbers.length\
    \ < 2) {\n    throw new Error(\"find_closest_elements: numbers.length must be\
    \ at least 2\");\n  }\n  const smallest = numbers[0];\n  const largest = numbers[0];\n\
    \  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < smallest)\
    \ {\n      smallest = numbers[i];\n    }\n    if (numbers[i] > largest) {\n  \
    \    largest = numbers[i];\n    }\n  }\n  return [smallest, largest];\n}\n", "\t\
    let min: number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor (let i =\
    \ 1; i < numbers.length; i++) {\n\t\tmin = Math.min(min, numbers[i]);\n\t\tmax\
    \ = Math.max(max, numbers[i]);\n\t}\n\treturn [min, max];\n}\n", "  let smallest:\
    \ number;\n  let largest: number;\n  let smallest_index: number;\n  let largest_index:\
    \ number;\n  for (let i = 0; i < numbers.length; i += 1) {\n    smallest = numbers[i];\n\
    \    largest = numbers[i];\n    smallest_index = i;\n    largest_index = i;\n\
    \    for (let j = i + 1; j < numbers.length; j += 1) {\n      if (numbers[j] <\
    \ smallest) {\n        smallest = numbers[j];\n        smallest_index = j;\n \
    \     }\n      if (numbers[j] > largest) {\n        largest = numbers[j];\n  \
    \      largest_index = j;\n      }\n    }\n    if (smallest_index !== largest_index)\
    \ {\n      numbers[smallest_index] = numbers[largest_index];\n      numbers[largest_index]\
    \ = smallest;\n    }\n  }\n  return [numbers[0], numbers[numbers.length - 1]];\n\
    }\n", "\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor\
    \ (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\t\
    min = numbers[i];\n\t\t}\n\t\tif (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\
    \t\t}\n\t}\n\treturn [min, max];\n}\n", "  const sortedNumbers = numbers.slice().sort((a,\
    \ b) => a - b);\n  const closestNumbers = sortedNumbers.slice(0, 2);\n  return\
    \ [closestNumbers[0], closestNumbers[1]];\n}\n", "\tlet min: number = numbers[0];\n\
    \tlet max: number = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\
    \t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\t\t}\n\t\tif (numbers[i]\
    \ > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n}\n", "\t\
    let smallest = numbers[0];\n\tlet largest = numbers[0];\n\tfor (let i = 1; i <\
    \ numbers.length; i++) {\n\t\tif (numbers[i] < smallest) {\n\t\t\tsmallest = numbers[i];\n\
    \t\t} else if (numbers[i] > largest) {\n\t\t\tlargest = numbers[i];\n\t\t}\n\t\
    }\n\treturn [smallest, largest];\n}\n", "  let smallest = numbers[0];\n  let largest\
    \ = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i]\
    \ < smallest) {\n      smallest = numbers[i];\n    }\n    if (numbers[i] > largest)\
    \ {\n      largest = numbers[i];\n    }\n  }\n  return [smallest, largest];\n\
    }\n", "\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor\
    \ (let i = 1; i < numbers.length; i++) {\n\t\tmin = Math.min(min, numbers[i]);\n\
    \t\tmax = Math.max(max, numbers[i]);\n\t}\n\treturn [min, max];\n}\n", "\tlet\
    \ min: number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor (let i = 1;\
    \ i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\
    \t\t} else if (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn\
    \ [min, max];\n}\n", "  const smallest = numbers[0];\n  const largest = numbers[0];\n\
    \  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < smallest)\
    \ {\n      smallest = numbers[i];\n    }\n    if (numbers[i] > largest) {\n  \
    \    largest = numbers[i];\n    }\n  }\n  return [smallest, largest];\n}\n", "\t\
    let min: number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor (let i =\
    \ 1; i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\
    \t\t} else if (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn\
    \ [min, max];\n}\n", "\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\
    \tfor (let i = 1; i < numbers.length; i++) {\n\t\tmin = Math.min(min, numbers[i]);\n\
    \t\tmax = Math.max(max, numbers[i]);\n\t}\n\treturn [min, max];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
