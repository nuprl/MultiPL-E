completions:
- "  const n = lst.length;\n  if (n < 1) return [];\n  if (x < 0 || x >= n) return\
  \ [];\n  const row = [x];\n  const result = [row];\n  for (let i = 2; i < n; i++)\
  \ {\n    const row2 = row.slice();\n    for (let j = 0; j < row2.length; j++) {\n\
  \      row2[j] += i;\n      if (row2[j] === n) row2[j] = -1;\n      if (row2[j]\
  \ === -1) row2[j] = i;\n      if (row2[j] === x) result.push(row2);\n    }\n  }\n\
  \  return result;\n}\n"
- "  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][]\
  \ = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const\
  \ rowCoords: number[] = [];\n    for (let j = 0; j < cols; j++) {\n      rowCoords.push([i,\
  \ j]);\n    }\n    coords.push(rowCoords);\n  }\n  coords.sort((a, b) => {\n   \
  \ const aRow = a[0][0];\n    const bRow = b[0][0];\n    if (aRow === bRow) {\n \
  \     return a[1] - b[1];\n    }\n    return aRow - bRow;\n  });\n  const rowCoords\
  \ = coords[coords.length - 1];\n  const rowIndex = rowCoords.findIndex((coord) =>\
  \ coord[0] === x);\n  const rowCoord = rowCoords[rowIndex];\n  const colIndex =\
  \ rowCoord[1] - x;\n  const colCoord = rowCoords[rowIndex][colIndex];\n  return\
  \ [\n    [rowCoord[0], colCoord[1]],\n    [rowCoord[0] + 1, colCoord[1]],\n    [rowCoord[0]\
  \ + 1, colCoord[1] + 1],\n    [rowCoord[0], colCoord[1] + 1],\n  ];\n}\n"
- "  const rows = lst.map(row => row.filter(val => val === x));\n  const rows = rows.map(row\
  \ => row.sort((a, b) => b - a));\n  const rows = rows.map(row => row.sort((a, b)\
  \ => b - a));\n  return rows.map(row => [row, row.map(col => col.length)]);\n}\n"
- "  const n = lst.length;\n  if (n < 1) return [];\n  const m = lst[0].length;\n\
  \  if (x < 0 || x >= m) return [];\n  const result = [];\n  for (let i = 0; i <\
  \ n; i++) {\n    const row = lst[i];\n    const rowx = row[x];\n    for (let j =\
  \ 0; j < m; j++) {\n      const col = row[j];\n      if (col === rowx) result.push([i,\
  \ j]);\n    }\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b)\
  \ => b[1] - a[1]);\n  return result;\n}\n"
- "  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n  \
  \  const row = lst[i];\n    const rowLength = row.length;\n    if (rowLength > x)\
  \ {\n      result.push([i, rowLength]);\n    }\n  }\n  result.sort((a, b) => {\n\
  \    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[0] > b[0]) {\n     \
  \ return 1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1]\
  \ < b[1]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n\
  \    }\n    return 0;\n  });\n  return result;\n}\n"
- "  const row = [0, 0];\n  const result = [];\n  for (let i = 0; i < lst.length;\
  \ i++) {\n    const row = lst[i];\n    if (row[x] === x) {\n      result.push([row[0],\
  \ row[x]]);\n    }\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a,\
  \ b) => b[1] - a[1]);\n  return result;\n}\n"
- "  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n \
  \ const [row, col] = get_row_col(rows, cols);\n  return get_row_col(row, col, x);\n\
  }\n"
- "  const n = lst.length;\n  const m = lst[0].length;\n  const coords: number[][]\
  \ = [];\n  for (let i = 0; i < n; i++) {\n    const row = lst[i];\n    const rowCoords\
  \ = coords[i] = [];\n    for (let j = 0; j < m; j++) {\n      rowCoords[j] = row[j];\n\
  \    }\n    rowCoords.sort((a, b) => a - b);\n    rowCoords.sort((a, b) => b - a);\n\
  \  }\n  const rowCoords = coords[coords.length - 1];\n  const rowIndex = rowCoords.indexOf(x);\n\
  \  const rowCoord = rowCoords[rowIndex];\n  const columnIndex = rowCoords.indexOf(rowCoord\
  \ - 1);\n  return [\n    [rowIndex, columnIndex],\n    [rowIndex + 1, columnIndex],\n\
  \    [rowIndex, columnIndex + 1],\n    [rowIndex + 1, columnIndex + 1],\n  ];\n\
  }\n"
- "  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n  \
  \  if (lst[i].includes(x)) {\n      result.push([i, lst[i].indexOf(x)]);\n    }\n\
  \  }\n  result.sort((a, b) => a[1] - b[1]);\n  result.sort((a, b) => b[0] - a[0]);\n\
  \  return result;\n}\n"
- "  const rows = lst.reduce((acc, row) => acc.concat(row), []);\n  const rowIndex\
  \ = rows.findIndex(row => row.includes(x));\n  const columnIndex = rows[rowIndex].findIndex(col\
  \ => col === x);\n  return [\n    [rowIndex + 1, columnIndex],\n    [rowIndex +\
  \ 1, columnIndex + 1],\n    [rowIndex + 1, columnIndex + 2],\n    [rowIndex, columnIndex\
  \ + 1],\n    [rowIndex, columnIndex + 2],\n    [rowIndex, columnIndex + 3],\n  ];\n\
  }\n"
- "  const rows = lst.reduce((acc, cur) => {\n    cur.forEach((y, i) => {\n      acc[i]\
  \ = acc[i] || [];\n      acc[i].push([x, y]);\n    });\n    return acc;\n  }, []);\n\
  \  const rows = rows.sort((a, b) => {\n    return a[0] > b[0] ? 1 : -1;\n  });\n\
  \  const cols = rows.reduce((acc, cur) => {\n    cur.forEach((y, i) => {\n     \
  \ acc[i] = acc[i] || [];\n      acc[i].push(y);\n    });\n    return acc;\n  },\
  \ []);\n  const cols = cols.sort((a, b) => {\n    return a[1] > b[1] ? 1 : -1;\n\
  \  });\n  return rows.map(x => [x, cols[x][1]]);\n}\n"
- "  const [rows, columns] = lst;\n  const [row, col] = get_row_and_col(rows, x);\n\
  \  return [\n    [row, col],\n    ...get_row(rows.slice(0, row), x),\n    ...get_row(rows.slice(row),\
  \ x),\n  ];\n}\n"
- "  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const result\
  \ = [row];\n  for (let i = 1; i < lst.length; i++) {\n    const row2 = row.slice();\n\
  \    for (let j = 0; j < row2.length; j++) {\n      row2[j] += lst[i][j];\n    }\n\
  \    result.push(row2);\n  }\n  return result.sort((a, b) => a[0] - b[0]).sort((a,\
  \ b) => b[1] - a[1]);\n}\n"
- "  const [rows, cols] = lst;\n  const [row, col] = get_row_col(x, rows);\n  return\
  \ [\n    [row, col],\n    ...get_row(rows.slice(row, row + 1), col),\n  ];\n}\n"
- "  const [rows, cols] = lst;\n  const [minRow, maxRow] = rows.map(row => row.map(x\
  \ => Math.min(x, x)));\n  const [minCol, maxCol] = cols.map(col => col.map(x =>\
  \ Math.min(x, x)));\n  const [minRow_, maxRow_] = [minRow, maxRow].map(row => row.map(x\
  \ => Math.min(x, x)));\n  const [minCol_, maxCol_] = [minCol, maxCol].map(col =>\
  \ col.map(x => Math.min(x, x)));\n  const [minRow__, maxRow_] = [minRow_, maxRow_].map(row\
  \ => row.map(x => Math.min(x, x)));\n  const [minCol_, maxCol_] = [minCol_, maxCol_].map(col\
  \ => col.map(x => Math.min(x, x)));\n  const [minRow_, maxRow_] = [minRow_, maxRow_].map(row\
  \ => row.map(x => Math.min(x, x)));\n  const [minCol_, maxCol_] = [minCol_, maxCol_].map(col\
  \ => col.map(x => Math.min(x, x)));\n  const [minRow_, maxRow_] = [minRow_, maxRow_].map(row\
  \ => row.map(x => Math.min(x, x)));\n  const [minCol_, maxCol_] = [minCol_, maxCol_].map(col\
  \ => col.map(x => Math.min(x, x)));\n  const [minRow_, maxRow_] = [minRow_, maxRow_].map(row\
  \ => row.map(x => Math.min(x, x)));\n  const [minCol_, maxCol_] = [minCol_, maxCol_].map(col\
  \ => col.map(x => Math.min(x, x)));\n  const [minRow_, maxRow_] = [minRow_, maxRow_].map(row\
  \ => row.map(x => Math.min(x, x)));\n  const [minCol_, maxCol_] = [minCol_, maxCol_].map(col\
  \ => col.map(x => Math.min(x, x)));\n  const [minRow_, maxRow_] = [minRow_, maxRow_].map(row\
  \ => row.map(x => Math.min(x, x)));\n  const [minCol_, maxCol_] = [minCol_, maxCol_].map(col\
  \ => col.map(x => Math.min(x, x)));\n  const [minRow_, maxRow_] = [minRow_, maxRow_].map(row\
  \ => row.map(x => Math.min(x, x)));\n  const [minCol_, maxCol_] = [minCol"
- "  const rows = lst.map(row => row.filter(x => x === x));\n  const sortedRows =\
  \ rows.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  const sortedRowsReversed = sortedRows.reverse();\n\
  \  const sortedColumns = sortedRowsReversed.map(row => row.reverse());\n  const\
  \ sortedColumnsReversed = sortedColumns.reverse();\n  return sortedColumnsReversed.map(column\
  \ => [column[0], column[x]]);\n}\n"
- "  const rows: number[][] = [];\n  const columns: number[] = [];\n  const result:\
  \ number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    rows.push(lst[i]);\n\
  \    columns.push(lst[i].slice());\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n \
  \ columns.sort((a, b) => b[1] - a[1]);\n  for (let i = 0; i < rows.length; i++)\
  \ {\n    const row = rows[i];\n    const column = columns[i];\n    for (let j =\
  \ 0; j < column.length; j++) {\n      if (column[j] === x) {\n        result.push([i,\
  \ j]);\n      }\n    }\n  }\n  return result;\n}\n"
- "  const rows: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const\
  \ row = lst[i];\n    if (row.indexOf(x) !== -1) {\n      rows.push([i, row.indexOf(x)]);\n\
  \    }\n  }\n  rows.sort((a, b) => a[1] - b[1]);\n  rows.sort((a, b) => b[0] - a[0]);\n\
  \  return rows;\n}\n"
- "  const rows = lst.map(row => row.map(x => [x]));\n  const rows = rows.map(row\
  \ => row.sort((a, b) => b[0] - a[0]));\n  const rows = rows.map(row => row.sort((a,\
  \ b) => b[1] - a[1]));\n  const rows = rows.map(row => row.map(x => [x[0], x[1]]));\n\
  \  return rows.filter(row => row[0] === x).map(row => row);\n}\n"
- "  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n\
  \  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult\
  \ = [];\n    for (let j = 0; j < cols; j++) {\n      const col = row[j];\n     \
  \ if (col === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n\
  \  }\n  result.sort((a, b) => {\n    const aRow = a[0][0];\n    const bRow = b[0][0];\n\
  \    if (aRow === bRow) {\n      return a[1] - b[1];\n    }\n    return aRow - bRow;\n\
  \  });\n  result.sort((a, b) => {\n    const aCol = a[0][1];\n    const bCol = b[0][1];\n\
  \    if (aCol === bCol) {\n      return a[1] - b[1];\n    }\n    return aCol - bCol;\n\
  \  });\n  return result;\n}\n"
language: ts
name: HumanEval_87_get_row
prompt: '//You are given a 2 dimensional data, as a nested lists,

  // which is similar to matrix, however, unlike matrices,

  // each row may contain a different number of columns.

  // Given lst, and integer x, find integers x in the list,

  // and return list of tuples, [(x1, y1), (x2, y2) ...] such that

  // each tuple is a coordinate - (row, columns), starting with 0.

  // Sort coordinates initially by rows in ascending order.

  // Also, sort coordinates of the row by columns in descending order.

  // Examples:

  // get_row([

  // [1,2,3,4,5,6],

  // [1,2,3,4,1,6],

  // [1,2,3,4,5,1]

  // ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]

  // get_row([], 1) == []

  // get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]

  function get_row(lst: number[][], x: number): [number, number][] {

  '
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3,\
  \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0],\
  \ [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
  \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
  \ 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1,\
  \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
  \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2,\
  \ 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n\
  \  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n\
  \  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();"
