completions:
- "\tlet sum = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tsum += array[i];\n\
  \t}\n\tif (sum % 2 === 0) {\n\t\tarray.sort((a, b) => a - b);\n\t} else {\n\t\t\
  array.sort((a, b) => b - a);\n\t}\n\treturn array;\n}\n"
- "  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n\
  \  }\n  if (sum % 2 === 0) {\n    array.sort((a, b) => a - b);\n  } else {\n   \
  \ array.sort((a, b) => b - a);\n  }\n  return array;\n}\n"
- "  const len = array.length;\n  if (len < 2) {\n    return array;\n  }\n  const\
  \ [firstIndex, lastIndex] = partition(array);\n  if (sumOfFirstAndLast(array, firstIndex,\
  \ lastIndex) % 2 === 0) {\n    return sort_array(array.slice(firstIndex, lastIndex\
  \ + 1));\n  } else {\n    return sort_array(array.slice(firstIndex, lastIndex -\
  \ 1));\n  }\n}\n"
- "\tlet result: number[] = [];\n\tlet sum: number = 0;\n\tfor (let i = 0; i < array.length;\
  \ i++) {\n\t\tsum += array[i];\n\t\tif (sum % 2 === 0) {\n\t\t\tresult.push(array[i]);\n\
  \t\t} else {\n\t\t\tresult.push(array[i]);\n\t\t\tresult.push(array.length - 1 -\
  \ i);\n\t\t}\n\t}\n\treturn result;\n}\n"
- "\tlet sum = 0;\n\tlet result = [];\n\tfor (let i = 0; i < array.length; i++) {\n\
  \t\tsum += array[i];\n\t\tresult.push(array[i]);\n\t}\n\tif (sum % 2 === 0) {\n\t\
  \tresult.sort((a, b) => a - b);\n\t} else {\n\t\tresult.sort((a, b) => b - a);\n\
  \t}\n\treturn result;\n}\n"
- "  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n\
  \  }\n  if (sum % 2 === 0) {\n    array.sort((a, b) => a - b);\n  } else {\n   \
  \ array.sort((a, b) => b - a);\n  }\n  return array;\n}\n"
- "  const len = array.length;\n  if (len === 0) {\n    return array;\n  }\n  const\
  \ mid = Math.floor(len / 2);\n  const left = array.slice(0, mid);\n  const right\
  \ = array.slice(mid);\n  const leftSum = left.reduce((acc, val) => acc + val, 0);\n\
  \  const rightSum = right.reduce((acc, val) => acc + val, 0);\n  if (leftSum % 2\
  \ === 1) {\n    return sort_array(left).concat(right);\n  }\n  if (rightSum % 2\
  \ === 0) {\n    return sort_array(right).concat(left);\n  }\n  return left.concat(right);\n\
  }\n"
- "\tlet result: number[] = [];\n\tlet sum = 0;\n\tfor (let i = 0; i < array.length;\
  \ i++) {\n\t\tsum += array[i];\n\t}\n\tlet odd = sum % 2 === 1;\n\tfor (let i =\
  \ 0; i < array.length; i++) {\n\t\tresult.push(array[i]);\n\t}\n\tif (odd) {\n\t\
  \tresult.sort((a, b) => a - b);\n\t} else {\n\t\tresult.sort((a, b) => b - a);\n\
  \t}\n\treturn result;\n}\n"
- "\tlet result: number[] = [];\n\tlet sum = 0;\n\tfor (let i = 0; i < array.length;\
  \ i++) {\n\t\tsum += array[i];\n\t}\n\tif (sum % 2 === 0) {\n\t\tresult = array.sort((a,\
  \ b) => a - b);\n\t} else {\n\t\tresult = array.sort((a, b) => b - a);\n\t}\n\t\
  return result;\n}\n"
- "  const len = array.length;\n  if (len === 0) {\n    return array;\n  }\n  const\
  \ [firstIndex, lastIndex] = partition(array);\n  if (lastIndex - firstIndex ===\
  \ 1) {\n    return array;\n  }\n  const midIndex = firstIndex + (lastIndex - firstIndex)\
  \ / 2;\n  const midValue = array[midIndex];\n  const isOdd = midValue % 2 === 1;\n\
  \  return isOdd ? sort_array(array.slice(0, midIndex)) : sort_array(array.slice(midIndex\
  \ + 1));\n}\n"
- "\tlet sum = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tsum += array[i];\n\
  \t}\n\tlet odd = sum % 2 === 1;\n\tlet even = sum % 2 === 0;\n\tif (odd) {\n\t\t\
  array.sort((a, b) => a - b);\n\t} else {\n\t\tarray.sort((a, b) => b - a);\n\t}\n\
  \treturn array;\n}\n"
- "  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n\
  \  }\n  if (sum % 2 === 0) {\n    array.sort((a, b) => a - b);\n  } else {\n   \
  \ array.sort((a, b) => b - a);\n  }\n  return array;\n}\n"
- "  const result: number[] = [];\n  for (let i = 0; i < array.length; i++) {\n  \
  \  const sum: number = array[i];\n    if (sum % 2 === 0) {\n      result.push(array[i]);\n\
  \    } else {\n      result.push(array[i]);\n      result.push(array.length - 1\
  \ - i);\n    }\n  }\n  return result;\n}\n"
- "\tlet sum = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tsum += array[i];\n\
  \t}\n\tif (sum % 2 === 0) {\n\t\tarray.sort((a, b) => a - b);\n\t} else {\n\t\t\
  array.sort((a, b) => b - a);\n\t}\n\treturn array;\n}\n"
- "\tlet sum = 0;\n\tlet result: number[] = [];\n\tfor (let i = 0; i < array.length;\
  \ i++) {\n\t\tsum += array[i];\n\t\tresult.push(array[i]);\n\t}\n\tif (sum % 2 ===\
  \ 0) {\n\t\tresult.sort((a, b) => a - b);\n\t} else {\n\t\tresult.sort((a, b) =>\
  \ b - a);\n\t}\n\treturn result;\n}\n"
- "\tlet sum = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tsum += array[i];\n\
  \t}\n\tif (sum % 2 === 0) {\n\t\tarray.sort((a, b) => a - b);\n\t} else {\n\t\t\
  array.sort((a, b) => b - a);\n\t}\n\treturn array;\n}\n"
- "\tlet sum = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tsum += array[i];\n\
  \t}\n\tlet odd = sum % 2 === 1;\n\tlet result: number[] = [];\n\tfor (let i = 0;\
  \ i < array.length; i++) {\n\t\tlet value = array[i];\n\t\tif (odd === (sum - value)\
  \ % 2 === 1) {\n\t\t\tresult.push(value);\n\t\t} else {\n\t\t\tresult.unshift(value);\n\
  \t\t}\n\t}\n\treturn result;\n}\n"
- "  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n\
  \  }\n  if (sum % 2 === 0) {\n    array.sort((a, b) => a - b);\n  } else {\n   \
  \ array.sort((a, b) => b - a);\n  }\n  return array;\n}\n"
- "\tlet sum = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tsum += array[i];\n\
  \t}\n\tif (sum % 2 === 0) {\n\t\tarray.sort((a, b) => a - b);\n\t} else {\n\t\t\
  array.sort((a, b) => b - a);\n\t}\n\treturn array;\n}\n"
- "\tlet sum = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tsum += array[i];\n\
  \t}\n\tif (sum % 2 === 0) {\n\t\tarray.sort((a, b) => a - b);\n\t} else {\n\t\t\
  array.sort((a, b) => b - a);\n\t}\n\treturn array;\n}\n"
language: ts
name: HumanEval_88_sort_array
prompt: '//Given an array of non-negative integers, return a copy of the given array
  after sorting,

  // you will sort the given array in ascending order if the sum( first index value,
  last index value) is odd,

  // or sort it in descending order if the sum( first index value, last index value)
  is even.

  // Note:

  // * don''t change the given array.

  // Examples:

  // * sort_array([]) => []

  // * sort_array([5]) => [5]

  // * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]

  // * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]

  function sort_array(array: number[]): number[] {

  '
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = sort_array;\n  assert.deepEqual(candidate([]),[]);\n\
  \  assert.deepEqual(candidate([5]),[5]);\n  assert.deepEqual(candidate([2, 4, 3,\
  \ 0, 1, 5]),[0, 1, 2, 3, 4, 5]);\n  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5,\
  \ 6]),[6, 5, 4, 3, 2, 1, 0]);\n  assert.deepEqual(candidate([2, 1]),[1, 2]);\n \
  \ assert.deepEqual(candidate([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87]);\n\
  \  assert.deepEqual(candidate([21, 14, 23, 11]),[23, 21, 14, 11]);\n}\n\ntest();"
