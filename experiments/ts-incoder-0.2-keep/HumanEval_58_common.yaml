name: HumanEval_58_common
language: humaneval_to_typescript.py
prompt: "//Return sorted unique common elements for two lists.\n// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n// [2, 3]\nfunction common(l1: number[], l2: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34,\
  \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5,\
  \ 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2,\
  \ 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"
completions: ["  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const result\
    \ = [];\n  for (const item of set1) {\n    if (set2.has(item)) {\n      result.push(item);\n\
    \    }\n  }\n  return result;\n}\n", "  const l1: number[] = l1.slice();\n  const\
    \ l2: number[] = l2.slice();\n  const result: number[] = [];\n  while (l1.length\
    \ > 0 && l2.length > 0) {\n    if (l1.shift() === l2.shift()) {\n      result.push(l1.shift());\n\
    \      l1.length--;\n      l2.length--;\n    } else {\n      result.push(l1.shift());\n\
    \      l2.length--;\n    }\n  }\n  return result;\n}\n", "  const l: number[]\
    \ = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) !==\
    \ -1) {\n      l.push(l1[i]);\n    }\n  }\n  return l;\n}\n", "  const l: number[]\
    \ = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) ===\
    \ -1) {\n      l.push(l1[i]);\n    }\n  }\n  return l;\n}\n", "  const l: number[]\
    \ = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) ===\
    \ -1) {\n      l.push(l1[i]);\n    }\n  }\n  return l;\n}\n", "  const l: number[]\
    \ = [];\n  let i: number;\n  let j: number;\n  let k: number;\n  let l1: number;\n\
    \  let l2: number;\n  let l3: number;\n  let l4: number;\n  let l5: number;\n\
    \  let l6: number;\n  let l7: number;\n  let l8: number;\n  let l9: number;\n\
    \  let l10: number;\n  let l11: number;\n  let l12: number;\n  let l13: number;\n\
    \  let l14: number;\n  let l15: number;\n  let l16: number;\n  let l17: number;\n\
    \  let l18: number;\n  let l19: number;\n  let l20: number;\n  let l21: number;\n\
    \  let l22: number;\n  let l23: number;\n  let l24: number;\n  let l25: number;\n\
    \  let l26: number;\n  let l27: number;\n  let l28: number;\n  let l29: number;\n\
    \  let l30: number;\n  let l31: number;\n  let l32: number;\n  let l33: number;\n\
    \  let l34: number;\n  let l35: number;\n  let l36: number;\n  let l37: number;\n\
    \  let l38: number;\n  let l39: number;\n  let l40: number;\n  let l41: number;\n\
    \  let l42: number;\n  let l43: number;\n  let l44: number;\n  let l45: number;\n\
    \  let l46: number;\n  let l47: number;\n  let l48: number;\n  let l49: number;\n\
    \  let l50: number;\n  let l51: number;\n  let l52: number;\n  let l53: number;\n\
    \  let l54: number;\n  let l55: number;\n  let l56: number;\n  let l57: number;\n\
    \  let l58: number;\n  let l59: number;\n  let l60: number;\n  let l61: number;\n\
    \  let l62: number;\n  let l63: number;\n  let l64: number;\n  let l65: number;\n\
    \  let l66: number;\n  let l67: number;\n  let l68: number;\n  let l69: number;\n\
    \  let l70: number;\n  let l71: number;\n  let l72: number;\n  let l73: number;\n\
    \  let l74: number;\n  let l75: number;\n  let l76: number;\n  let l77: number;\n\
    \  let l78: number;\n  let l79: number;\n  let l80: number;\n  let l81: number;\n\
    \  let l82: number;\n  let l83: number;\n  let l84: number;\n  let l85: number;\n\
    \  let l86: number;\n  let l87: number;\n  let l88: number;\n  let l89: number;\n\
    \  let l90: number;\n  let l91: number;\n  let l92: number;\n  let l93: number;\n\
    \  let l94: number;\n  let l95: number;\n  let l96: number;\n  let l97: number;\n\
    \  let l98: number;", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    if (l2.indexOf(l1[i]) === -1) {\n      l.push(l1[i]);\n    }\n \
    \ }\n  return l;\n}\n", "  const l: number[] = [];\n  let i = 0;\n  let j = 0;\n\
    \  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n    \
    \  l.push(l1[i]);\n      i++;\n      j++;\n    } else if (l1[i] < l2[j]) {\n \
    \     i++;\n    } else {\n      j++;\n    }\n  }\n  return l;\n}\n", "  const\
    \ set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const result = [];\n  for\
    \ (let i = 0; i < Math.min(set1.size, set2.size); i++) {\n    if (set1.has(i)\
    \ && set2.has(i)) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n",
  "  const l: number[] = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length)\
    \ {\n    if (l1[i] === l2[i]) {\n      l.push(l1[i]);\n      i++;\n    } else\
    \ {\n      break;\n    }\n  }\n  return l;\n}\n", "  const l: number[] = [];\n\
    \  const hash: number[] = [];\n  const hashMap = new Map<number, number[]>();\n\
    \  for (let i = 0; i < l1.length; i++) {\n    const val = l1[i];\n    if (hashMap.has(val))\
    \ {\n      hashMap.get(val).push(l1[i]);\n    } else {\n      hashMap.set(val,\
    \ [l1[i]]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const val\
    \ = l2[i];\n    if (hashMap.has(val)) {\n      hashMap.get(val).push(l2[i]);\n\
    \    } else {\n      hashMap.set(val, [l2[i]]);\n    }\n  }\n  for (let i = 0;\
    \ i < l1.length; i++) {\n    const val = l1[i];\n    const vals = hashMap.get(val);\n\
    \    for (let j = 0; j < vals.length; j++) {\n      l.push(val);\n    }\n  }\n\
    \  return l;\n}\n", "  const result = [];\n  for (let i = 0; i < l1.length; i++)\
    \ {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n\
    \        result.push(l1[i]);\n        break;\n      }\n    }\n  }\n  return result;\n\
    }\n", "  const l1 = l1 || [];\n  const l2 = l2 || [];\n  const result = [];\n\
    \  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i])\
    \ {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n\
    \  }\n  return result;\n}\n", "  const l: number[] = [];\n  let j = 0;\n  for\
    \ (let i = 0; i < l1.length; i++) {\n    while (j < l2.length && l2[j] === l1[i])\
    \ {\n      j++;\n    }\n    l.push(l1[i]);\n  }\n  return l;\n}\n", "  const l:\
    \ number[] = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i])\
    \ !== -1) {\n      l.push(l1[i]);\n    }\n  }\n  return l;\n}\n", "  const l:\
    \ number[] = [];\n  const hash: number[] = [];\n  const hashMap: Map<number, number>\
    \ = new Map();\n  for (let i = 0; i < l1.length; i++) {\n    const val = l1[i];\n\
    \    if (!hashMap.has(val)) {\n      hashMap.set(val, i);\n      l.push(val);\n\
    \    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const val = l2[i];\n\
    \    if (!hashMap.has(val)) {\n      hashMap.set(val, i);\n      l.push(val);\n\
    \    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    const val = l[i];\n \
    \   const index = hashMap.get(val);\n    l.splice(index, 1);\n    hashMap.delete(val);\n\
    \  }\n  return l;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    if (l2.indexOf(l1[i]) === -1) {\n      l.push(l1[i]);\n    }\n \
    \ }\n  return l;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    if (l2.indexOf(l1[i]) === -1) {\n      l.push(l1[i]);\n    }\n \
    \ }\n  return l;\n}\n", "  const result = [];\n  let i = 0;\n  while (i < l1.length\
    \ && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n\
    \      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n}\n", " \
    \ const l: number[] = [];\n  for (let i = 0; i < l1.length; i++) {\n    const\
    \ found = false;\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] ===\
    \ l2[j]) {\n        found = true;\n        break;\n      }\n    }\n    if (!found)\
    \ {\n      l.push(l1[i]);\n    }\n  }\n  return l;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
