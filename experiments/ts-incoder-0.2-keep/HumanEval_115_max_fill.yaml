completions:
- "    let rows: number[][] = [];\n    let cols: number[][] = [];\n    for (let i\
  \ = 0; i < grid.length; i++) {\n        rows.push(grid[i]);\n    }\n    for (let\
  \ j = 0; j < grid[0].length; j++) {\n        cols.push(grid[0][j]);\n    }\n   \
  \ let result = 0;\n    for (let i = 0; i < rows.length; i++) {\n        for (let\
  \ j = 0; j < cols.length; j++) {\n            if (rows[i][j] === 1) {\n        \
  \        let bucket = cols[j];\n                let count = 0;\n               \
  \ while (bucket > 0) {\n                    if (bucket > capacity) {\n         \
  \               bucket -= capacity;\n                        count++;\n        \
  \            } else {\n                        bucket--;\n                    }\n\
  \                }\n                result += count;\n            }\n        }\n\
  \    }\n    return result;\n}\n"
- "    const n = grid.length;\n    const m = grid[0].length;\n    const buckets =\
  \ new Array(n * m).fill(0).map(() => new Array(capacity).fill(0));\n    for (let\
  \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                buckets[i][j] = 1;\n            }\n        }\n    }\n\
  \    let count = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
  \ j < m; j++) {\n            if (buckets[i][j] === 0) {\n                count++;\n\
  \                buckets[i][j] = 1;\n            }\n        }\n    }\n    return\
  \ count;\n}\n"
- "    const n = grid.length;\n    const m = grid[0].length;\n    const buckets =\
  \ new Array(n * m).fill(0);\n    for (let i = 0; i < n; i++) {\n        for (let\
  \ j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                buckets[(i\
  \ * m) + j] += capacity;\n            }\n        }\n    }\n    let count = 0;\n\
  \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n    \
  \        if (buckets[(i * m) + j] > 0) {\n                buckets[(i * m) + j] -=\
  \ 1;\n                count++;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let buckets: number[][] = [];\n    for (let i = 0; i < grid.length; i++) {\n\
  \        let bucket: number[] = [];\n        for (let j = 0; j < grid[i].length;\
  \ j++) {\n            bucket.push(0);\n        }\n        buckets.push(bucket);\n\
  \    }\n    \n    for (let i = 0; i < grid.length; i++) {\n        for (let j =\
  \ 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n         \
  \       buckets[i][j] += 1;\n            }\n        }\n    }\n    \n    let result\
  \ = 0;\n    for (let i = 0; i < buckets.length; i++) {\n        for (let j = 0;\
  \ j < buckets[i].length; j++) {\n            result += Math.max(buckets[i][j] -\
  \ capacity, 0);\n        }\n    }\n    \n    return result;\n}\n"
- "    let buckets: number[][] = [];\n    for (let i = 0; i < grid.length; i++) {\n\
  \        let bucket: number[] = [];\n        for (let j = 0; j < grid[i].length;\
  \ j++) {\n            bucket.push(grid[i][j]);\n        }\n        buckets.push(bucket);\n\
  \    }\n    let count = 0;\n    for (let i = 0; i < buckets.length; i++) {\n   \
  \     let bucket = buckets[i];\n        let max = 0;\n        for (let j = 0; j\
  \ < bucket.length; j++) {\n            if (bucket[j] > max) {\n                max\
  \ = bucket[j];\n            }\n        }\n        if (max > capacity) {\n      \
  \      count += 1;\n        }\n    }\n    return count;\n}\n"
- "    let n = grid.length;\n    let m = grid[0].length;\n    let buckets = new Array(n);\n\
  \    for (let i = 0; i < n; i++) {\n        buckets[i] = new Array(m);\n    }\n\
  \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n    \
  \        if (grid[i][j] === 1) {\n                buckets[i][j].push(j);\n     \
  \       }\n        }\n    }\n    let count = 0;\n    for (let i = 0; i < n; i++)\
  \ {\n        for (let j = 0; j < m; j++) {\n            if (buckets[i][j].length\
  \ === 0) {\n                buckets[i][j].push(j);\n                count++;\n \
  \           }\n        }\n    }\n    return count;\n}\n"
- "    const n = grid.length;\n    const m = grid[0].length;\n    const buckets =\
  \ new Array(capacity).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n      \
  \  for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n        \
  \        buckets[grid[i][j]] += 1;\n            }\n        }\n    }\n    \n    let\
  \ count = 0;\n    for (let i = 0; i < buckets.length; i++) {\n        if (buckets[i]\
  \ === 0) {\n            count += 1;\n        }\n    }\n    \n    return count;\n\
  }\n"
- "    let n = grid.length;\n    let m = grid[0].length;\n    let bucket = new Array(capacity).fill(0);\n\
  \    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n\
  \            if (grid[i][j] === 1) {\n                bucket[grid[i][j]] += 1;\n\
  \            }\n        }\n    }\n    \n    let ans = 0;\n    for (let i = 0; i\
  \ < bucket.length; i++) {\n        if (bucket[i] > 0) {\n            ans += bucket[i];\n\
  \            bucket[i] = 0;\n        }\n    }\n    \n    return ans;\n}\n"
- "    let buckets = grid.map((row, index) => {\n        let bucket = new Array(capacity).fill(0);\n\
  \        bucket[index] = 1;\n        return bucket;\n    });\n    let count = 0;\n\
  \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
  \ j++) {\n            if (grid[i][j] === 1) {\n                let bucket = buckets[i][j];\n\
  \                for (let k = 0; k < bucket; k++) {\n                    buckets[i][j]\
  \ = 0;\n                }\n                count++;\n            }\n        }\n\
  \    }\n    return count;\n}\n"
- "    const n = grid.length;\n    const m = grid[0].length;\n    const buckets =\
  \ new Array(n * m).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for\
  \ (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n             \
  \   buckets[(i * m) + j] += capacity;\n            }\n        }\n    }\n    \n \
  \   let count = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
  \ < m; j++) {\n            if (buckets[(i * m) + j] > 0) {\n                buckets[(i\
  \ * m) + j] -= 1;\n                count++;\n            }\n        }\n    }\n \
  \   \n    return count;\n}\n"
- "    let buckets: number[][] = [];\n    for (let i = 0; i < grid.length; i++) {\n\
  \        let bucket = new Array(capacity).fill(0);\n        buckets.push(bucket);\n\
  \    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
  \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                buckets[grid[i][j]\
  \ - 1][capacity--] = 1;\n            }\n        }\n    }\n    let count = 0;\n \
  \   for (let i = 0; i < buckets.length; i++) {\n        for (let j = 0; j < buckets[i].length;\
  \ j++) {\n            if (buckets[i][j] === 0) {\n                count++;\n   \
  \         }\n        }\n    }\n    return count;\n}\n"
- "    let n = grid.length;\n    let m = grid[0].length;\n    let bucket = new Array(capacity).fill(0);\n\
  \    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n\
  \            if (grid[i][j] === 1) {\n                bucket[grid[i][j]] += 1;\n\
  \            }\n        }\n    }\n    \n    let count = 0;\n    for (let i = 0;\
  \ i < bucket.length; i++) {\n        if (bucket[i] > 0) {\n            count +=\
  \ bucket[i];\n        }\n    }\n    return count;\n}\n"
- "    const n = grid.length;\n    const m = grid[0].length;\n    const buckets =\
  \ new Array(n * m).fill(0);\n    for (let i = 0; i < n; i++) {\n        for (let\
  \ j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                buckets[(i\
  \ * m) + j] += capacity;\n            }\n        }\n    }\n    let count = 0;\n\
  \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n    \
  \        if (buckets[(i * m) + j] > 0) {\n                buckets[(i * m) + j] -=\
  \ 1;\n                count++;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let n = grid.length;\n    let m = grid[0].length;\n    let buckets = new Array(n\
  \ * m).fill(0);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j <\
  \ m; j++) {\n            let bucket = grid[i][j];\n            if (bucket === 1)\
  \ {\n                buckets[(i * m) + j] += 1;\n            }\n        }\n    }\n\
  \    let count = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
  \ j < m; j++) {\n            let bucket = buckets[(i * m) + j];\n            if\
  \ (bucket > capacity) {\n                buckets[(i * m) + j] = capacity;\n    \
  \            count += 1;\n            }\n        }\n    }\n    return count;\n}"
- "    let row = 0;\n    let col = 0;\n    let count = 0;\n    while (row < grid.length)\
  \ {\n        while (col < grid[row].length) {\n            if (grid[row][col] ===\
  \ 1) {\n                grid[row][col] = 0;\n                count++;\n        \
  \    }\n            col++;\n        }\n        col = 0;\n        row++;\n    }\n\
  \    return count;\n}\n"
- "    let n = grid.length;\n    let m = grid[0].length;\n    let buckets: number[][]\
  \ = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    for (let i = 0; i\
  \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                buckets[i][j] = buckets[i][j] + 1;\n            }\n\
  \        }\n    }\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n    \
  \    for (let j = 0; j < m; j++) {\n            if (buckets[i][j] <= capacity) {\n\
  \                buckets[i][j] = buckets[i][j] - 1;\n                result = Math.max(result,\
  \ buckets[i][j]);\n            }\n        }\n    }\n    return result;\n}\n"
- "    let buckets = Array(capacity).fill(0);\n    for (let row of grid) {\n     \
  \   for (let i = 0; i < row.length; i++) {\n            buckets[row[i]]++;\n   \
  \     }\n    }\n    let result = 0;\n    for (let i = 0; i < buckets.length; i++)\
  \ {\n        if (buckets[i] > 0) result++;\n    }\n    return result;\n}"
- "    const n = grid.length;\n    if (n < 1) {\n        return 0;\n    }\n    const\
  \ buckets = new Array(capacity).fill(0);\n    for (let i = 0; i < n; i++) {\n  \
  \      for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
  \ 1) {\n                buckets[grid[i][j]] += 1;\n            }\n        }\n  \
  \  }\n    let count = 0;\n    for (let i = 0; i < buckets.length; i++) {\n     \
  \   if (buckets[i] > 0) {\n            count += buckets[i];\n        }\n    }\n\
  \    return count;\n}\n"
- "    const n = grid.length;\n    const m = grid[0].length;\n    const bucket = new\
  \ Array(capacity).fill(0);\n    for (let i = 0; i < n; i++) {\n        for (let\
  \ j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                bucket[grid[i][j]]\
  \ += 1;\n            }\n        }\n    }\n    let ans = 0;\n    for (let i = 0;\
  \ i < bucket.length; i++) {\n        if (bucket[i] > 0) {\n            ans += bucket[i];\n\
  \            bucket[i] = 0;\n        }\n    }\n    return ans;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           let bucket = grid[i][j];\n                let count = 0;\n         \
  \       while (bucket > 0) {\n                    count += bucket;\n           \
  \         bucket -= 1;\n                }\n                result += count;\n  \
  \          }\n        }\n    }\n    return result;\n}\n"
language: ts
name: HumanEval_115_max_fill
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// Input: \n// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity\
  \ : 1\n// Output: 6\n// Example 2:\n// Input: \n// grid : [[0,0,1,1], [0,0,0,0],\
  \ [1,1,1,1], [0,1,1,1]]\n// bucket_capacity : 2\n// Output: 5\n// Example 3:\n//\
  \ Input: \n// grid : [[0,0,0], [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n\
  // Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
