name: HumanEval_61_correct_bracketing
language: humaneval_to_typescript.py
prompt: "//brackets is a string of \"(\" and \")\".\n// return True if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
  )\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"\
  (()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nfunction correct_bracketing(brackets:\
  \ string): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"\
  ()\"),true);\n  assert.deepEqual(candidate(\"(()())\"),true);\n  assert.deepEqual(candidate(\"\
  ()()(()())()\"),true);\n  assert.deepEqual(candidate(\"()()((()()())())(()()(()))\"\
  ),true);\n  assert.deepEqual(candidate(\"((()())))\"),false);\n  assert.deepEqual(candidate(\"\
  )(()\"),false);\n  assert.deepEqual(candidate(\"(\"),false);\n  assert.deepEqual(candidate(\"\
  ((((\"),false);\n  assert.deepEqual(candidate(\")\"),false);\n  assert.deepEqual(candidate(\"\
  (()\"),false);\n  assert.deepEqual(candidate(\"()()(()())())(()\"),false);\n  assert.deepEqual(candidate(\"\
  ()()(()())()))()\"),false);\n}\n\ntest();"
completions: ["\tlet opening_brackets = brackets.split(\"\");\n\tlet closing_brackets\
    \ = brackets.split(\"\").reverse();\n\tlet opening_brackets_set = opening_brackets.reduce((set,\
    \ char) => set.add(char), new Set<string>());\n\tlet closing_brackets_set = closing_brackets.reduce((set,\
    \ char) => set.add(char), new Set<string>());\n\treturn opening_brackets_set.size\
    \ == closing_brackets_set.size;\n}\n", "\tlet opening_brackets: string[] = brackets.split(\"\
    \");\n\tlet closing_brackets: string[] = brackets.split(\"\");\n\tfor (let i =\
    \ 0; i < opening_brackets.length; i++) {\n\t\tif (opening_brackets[i] === \"(\"\
    ) {\n\t\t\tclosing_brackets[i] = \")\";\n\t\t}\n\t\tif (opening_brackets[i] ===\
    \ \"[\") {\n\t\t\tclosing_brackets[i] = \"]\";\n\t\t}\n\t\tif (opening_brackets[i]\
    \ === \"{\") {\n\t\t\tclosing_brackets[i] = \"}\";\n\t\t}\n\t}\n\treturn opening_brackets.length\
    \ === closing_brackets.length;\n}\n", "\tlet opening_brackets = brackets.split(\"\
    \");\n\tlet closing_brackets = brackets.split(\"\").reverse();\n\tlet opening_brackets_set\
    \ = opening_brackets.reduce((set, char) => {\n\t\tset.add(char);\n\t\treturn set;\n\
    \t}, new Set<string>());\n\tlet closing_brackets_set = closing_brackets.reduce((set,\
    \ char) => {\n\t\tset.add(char);\n\t\treturn set;\n\t}, new Set<string>());\n\t\
    return opening_brackets_set.size == closing_brackets_set.size;\n}\n", "\tlet opening\
    \ = brackets.substr(0, 1);\n\tlet closing = brackets.substr(brackets.length -\
    \ 1, 1);\n\treturn opening === closing;\n}\n", "\tlet opening_brackets = brackets.split(\"\
    (\");\n\tlet closing_brackets = brackets.split(\")\");\n\tlet opening_brackets_length\
    \ = opening_brackets.length;\n\tlet closing_brackets_length = closing_brackets.length;\n\
    \tlet opening_brackets_index = 0;\n\tlet closing_brackets_index = 0;\n\twhile\
    \ (opening_brackets_index < opening_brackets_length && closing_brackets_index\
    \ < closing_brackets_length) {\n\t\tlet opening_bracket = opening_brackets[opening_brackets_index];\n\
    \t\tlet closing_bracket = closing_brackets[closing_brackets_index];\n\t\tif (opening_bracket\
    \ == closing_bracket) {\n\t\t\topening_brackets_index++;\n\t\t\tclosing_brackets_index++;\n\
    \t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn (opening_brackets_index\
    \ == opening_brackets_length) && (closing_brackets_index == closing_brackets_length);\n\
    }\n", "  const stack: string[] = [];\n  for (let i = 0; i < brackets.length; i\
    \ += 1) {\n    const bracket = brackets[i];\n    if (bracket === \"(\") {\n  \
    \    stack.push(bracket);\n    } else if (bracket === \")\") {\n      if (stack.length\
    \ === 0) {\n        return false;\n      }\n      const opening = stack.pop();\n\
    \      if (opening !== bracket) {\n        return false;\n      }\n    }\n  }\n\
    \  if (stack.length > 0) {\n    return false;\n  }\n  return true;\n}\n", "  let\
    \ stack: string[] = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if\
    \ (brackets[i] == '(') {\n      stack.push(brackets[i]);\n    } else if (brackets[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return false;\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length == 0) {\n        return\
    \ false;\n      }\n      if (brackets[i] != stack[stack.length - 1]) {\n     \
    \   return false;\n      }\n    }\n  }\n  return stack.length == 0;\n}\n", "\t\
    let open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet\
    \ open_brackets_length: number = 0;\n\tlet close_brackets_length: number = 0;\n\
    \tfor (let i = 0; i < brackets.length; ++i) {\n\t\tlet bracket = brackets[i];\n\
    \t\tif (bracket == \"(\") {\n\t\t\topen_brackets[open_brackets_length++] = i;\n\
    \t\t} else if (bracket == \")\") {\n\t\t\tclose_brackets[close_brackets_length++]\
    \ = i;\n\t\t}\n\t}\n\tif (open_brackets.length != close_brackets.length) {\n\t\
    \treturn false;\n\t}\n\tfor (let i = 0; i < open_brackets.length; ++i) {\n\t\t\
    let open_bracket = open_brackets[i];\n\t\tlet close_bracket = close_brackets[i];\n\
    \t\tif (open_bracket > close_bracket) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;\n}\n", "  const opening_brackets = brackets.split('(');\n  const closing_brackets\
    \ = brackets.split(')');\n  for (let i = 0; i < opening_brackets.length; i++)\
    \ {\n    if (closing_brackets.length < opening_brackets[i]) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "\tlet stack: string[] = [];\n\tlet opening_brackets:\
    \ number[] = [];\n\tlet closing_brackets: number[] = [];\n\tfor (let i = 0; i\
    \ < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket ===\
    \ \"(\") {\n\t\t\topening_brackets.push(i);\n\t\t} else if (bracket === \")\"\
    ) {\n\t\t\tclosing_brackets.push(i);\n\t\t}\n\t}\n\tfor (let i = 0; i < opening_brackets.length;\
    \ i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket\
    \ = closing_brackets[i];\n\t\tif (opening_bracket === closing_bracket) {\n\t\t\
    \treturn false;\n\t\t}\n\t\tlet stack_size = stack.length;\n\t\twhile (stack_size\
    \ > 0) {\n\t\t\tlet top = stack[stack_size-1];\n\t\t\tif (top === opening_bracket)\
    \ {\n\t\t\t\tstack.pop();\n\t\t\t\topening_brackets.splice(opening_bracket, 1);\n\
    \t\t\t\tclosing_brackets.splice(closing_bracket, 1);\n\t\t\t\tbreak;\n\t\t\t}\
    \ else if (top === closing_bracket) {\n\t\t\t\tstack.pop();\n\t\t\t\topening_brackets.splice(opening_bracket,\
    \ 1);\n\t\t\t\tclosing_brackets.splice(closing_bracket, 1);\n\t\t\t\tbreak;\n\t\
    \t\t} else {\n\t\t\t\tstack_size--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n",
  "  if (brackets.length === 0) {\n    return false;\n  }\n  const stack: string[]\
    \ = [];\n  for (let i = 0; i < brackets.length; i++) {\n    const bracket = brackets[i];\n\
    \    if (bracket === '(') {\n      stack.push(bracket);\n    } else if (bracket\
    \ === ')') {\n      if (stack.length === 0) {\n        return false;\n      }\n\
    \      const openingBracket = stack.pop();\n      if (openingBracket !== bracket)\
    \ {\n        return false;\n      }\n    }\n  }\n  if (stack.length > 0) {\n \
    \   return false;\n  }\n  return true;\n}\n", "\tlet stack: string[] = [];\n\t\
    for (let i = 0; i < brackets.length; ++i) {\n\t\tlet c = brackets[i];\n\t\tif\
    \ (c === \"(\") {\n\t\t\tstack.push(c);\n\t\t} else if (c === \")\") {\n\t\t\t\
    if (stack.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet opening =\
    \ stack.pop();\n\t\t\tif (opening !== c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\
    \t}\n\t}\n\tif (stack.length > 0) {\n\t\treturn false;\n\t}\n\treturn true;\n\
    }\n", "  let stack: string[] = [];\n  for (let i = 0; i < brackets.length; ++i)\
    \ {\n    let bracket = brackets[i];\n    if (bracket == \"(\") {\n      stack.push(bracket);\n\
    \    } else if (bracket == \")\") {\n      if (stack.length == 0) {\n        return\
    \ false;\n      }\n      let opening = stack.pop();\n      if (opening != bracket)\
    \ {\n        return false;\n      }\n    }\n  }\n  if (stack.length != 0) {\n\
    \    return false;\n  }\n  return true;\n}\n", "  let stack: string[] = [];\n\
    \  for (let i = 0; i < brackets.length; ++i) {\n    if (brackets[i] == '(') {\n\
    \      stack.push(brackets[i]);\n    } else if (brackets[i] == ')') {\n      if\
    \ (stack.length == 0) {\n        return false;\n      }\n      stack.pop();\n\
    \    } else {\n      if (stack.length != 0) {\n        return false;\n      }\n\
    \    }\n  }\n  return stack.length == 0;\n}\n", "\tlet opening_brackets = brackets.split(\"\
    \");\n\tlet closing_brackets = brackets.split(\"\").reverse();\n\tlet opening_brackets_set\
    \ = opening_brackets.reduce((acc, cur) => acc && cur !== \",\", true);\n\tlet\
    \ closing_brackets_set = closing_brackets.reduce((acc, cur) => acc && cur !==\
    \ \",\", true);\n\treturn opening_brackets_set && closing_brackets_set;\n}\n",
  "\tlet opening_brackets = brackets.split(\"\");\n\tlet closing_brackets = brackets.split(\"\
    \").reverse();\n\tlet opening_brackets_set = opening_brackets.reduce((set, char)\
    \ => set.add(char), new Set<string>());\n\tlet closing_brackets_set = closing_brackets.reduce((set,\
    \ char) => set.add(char), new Set<string>());\n\treturn opening_brackets_set.size\
    \ == closing_brackets_set.size;\n}\n", "\tlet opening_brackets = brackets.split(\"\
    (\");\n\tlet closing_brackets = brackets.split(\")\");\n\tlet opening_brackets_length\
    \ = opening_brackets.length;\n\tlet closing_brackets_length = closing_brackets.length;\n\
    \tfor (let i = 0; i < opening_brackets_length; i++) {\n\t\tlet opening_bracket\
    \ = opening_brackets[i];\n\t\tlet closing_bracket = closing_brackets[i];\n\t\t\
    if (opening_bracket.includes(\"(\")) {\n\t\t\tif (closing_bracket.includes(\"\
    )\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (opening_bracket.includes(\"\
    )\")) {\n\t\t\tif (closing_bracket.includes(\"(\")) {\n\t\t\t\treturn true;\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn false;\n}\n", "  const opening_brackets = brackets.split(\"\
    \");\n  const closing_brackets = brackets.split(\"\").reverse();\n  for (let i\
    \ = 0; i < opening_brackets.length; i++) {\n    if (opening_brackets[i] !== closing_brackets[i])\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n", "  if (brackets.length\
    \ < 2) return false;\n  const stack: string[] = [];\n  for (let i = 0; i < brackets.length;\
    \ ++i) {\n    const bracket = brackets[i];\n    if (bracket === \"(\") {\n   \
    \   stack.push(bracket);\n    } else if (bracket === \")\") {\n      if (stack.length\
    \ !== 0) return false;\n      stack.pop();\n    } else {\n      if (stack.length\
    \ !== 0) return false;\n    }\n  }\n  if (stack.length !== 0) return false;\n\
    \  return true;\n}\n", "\tlet opening_brackets = brackets.split(\"\");\n\tlet\
    \ closing_brackets = brackets.split(\"\").reverse();\n\tlet opening_brackets_count\
    \ = opening_brackets.length;\n\tlet closing_brackets_count = closing_brackets.length;\n\
    \n\tfor (let i = 0; i < opening_brackets_count; i++) {\n\t\tlet opening_bracket\
    \ = opening_brackets[i];\n\t\tlet closing_bracket = closing_brackets[i];\n\n\t\
    \tif (opening_bracket !== closing_bracket) {\n\t\t\treturn false;\n\t\t}\n\t}\n\
    \n\treturn true;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
