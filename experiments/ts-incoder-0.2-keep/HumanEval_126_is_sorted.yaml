completions:
- "  if (lst.length < 2) return true;\n  const map = new Map();\n  for (let i = 0;\
  \ i < lst.length; i++) {\n    const key = lst[i];\n    if (map.has(key)) {\n   \
  \   return false;\n    }\n    map.set(key, true);\n  }\n  return true;\n}\n"
- "  let seen = new Set<number>();\n  for (let i = 0; i < lst.length; i++) {\n   \
  \ if (seen.has(lst[i])) {\n      return false;\n    }\n    seen.add(lst[i]);\n \
  \ }\n  return true;\n}\n"
- "  if (lst.length <= 1) return true;\n  let hashmap = new Map<number, number>();\n\
  \  for (let i = 0; i < lst.length; i++) {\n    let key = lst[i];\n    if (hashmap.has(key))\
  \ {\n      if (hashmap.get(key) !== i) {\n        return false;\n      }\n    }\
  \ else {\n      hashmap.set(key, i);\n    }\n  }\n  return true;\n}\n"
- "  if (lst.length <= 1) return true;\n  for (let i = 0; i < lst.length - 1; i++)\
  \ {\n    if (lst[i] > lst[i + 1]) return false;\n  }\n  return true;\n}\n"
- "  if (lst.length < 2) {\n    return true;\n  }\n  const map = new Map<number, number>();\n\
  \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (map.has(num))\
  \ {\n      return false;\n    }\n    map.set(num, num);\n  }\n  return true;\n}\n"
- "  if (lst.length <= 1) return true;\n  for (let i = 0; i < lst.length - 1; i++)\
  \ {\n    if (lst[i] > lst[i + 1]) return false;\n  }\n  return true;\n}\n"
- "  if (lst.length < 2) return true;\n  for (let i = 0; i < lst.length - 1; i++)\
  \ {\n    if (lst[i] > lst[i + 1]) return false;\n  }\n  return true;\n}\n"
- "  if (lst.length <= 1) {\n    return true;\n  }\n  const hashMap = new Map<number,\
  \ number>();\n  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n\
  \    if (hashMap.has(num)) {\n      return false;\n    }\n    hashMap.set(num, i);\n\
  \  }\n  return true;\n}\n"
- "  if (lst.length <= 1) return true;\n  const map = new Map();\n  for (let i = 0;\
  \ i < lst.length; i++) {\n    const key = lst[i];\n    if (map.has(key)) {\n   \
  \   if (map.get(key) === i) {\n        return false;\n      }\n    } else {\n  \
  \    map.set(key, i);\n    }\n  }\n  return true;\n}\n"
- "  let last: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
  \ === lst[last[i]]) {\n      return false;\n    }\n    last[i] = lst[i];\n  }\n\
  \  return true;\n}\n"
- "  if (lst.length <= 1) return true;\n  const map = new Map();\n  for (const num\
  \ of lst) {\n    const key = num.toString();\n    if (!map.has(key)) {\n      map.set(key,\
  \ true);\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n"
- "  if (lst.length <= 1) return true;\n  let seen = new Set<number>();\n  for (let\
  \ i = 0; i < lst.length; i++) {\n    if (seen.has(lst[i])) return false;\n    seen.add(lst[i]);\n\
  \  }\n  return true;\n}\n"
- "  if (lst.length <= 1) {\n    return true;\n  }\n  for (let i = 0; i < lst.length\
  \ - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n\
  \  return true;\n}\n"
- "  if (lst.length <= 1) {\n    return true;\n  }\n  for (let i = 0; i < lst.length\
  \ - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n\
  \  return true;\n}\n"
- "  if (lst.length < 2) return true;\n  for (let i = 0; i < lst.length - 1; i++)\
  \ {\n    if (lst[i] > lst[i + 1]) return false;\n  }\n  return true;\n}\n"
- "  if (lst.length < 2) return true;\n  for (let i = 0; i < lst.length - 1; i++)\
  \ {\n    if (lst[i] > lst[i + 1]) return false;\n  }\n  return true;\n}\n"
- "  if (lst.length < 2) {\n    return true;\n  }\n  const hashMap = new Map<number,\
  \ boolean>();\n  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n\
  \    if (hashMap.has(num)) {\n      return false;\n    }\n    hashMap.set(num, true);\n\
  \  }\n  return true;\n}\n"
- "  if (lst.length < 2) return true;\n  if (lst.length == 2) return lst[0] < lst[1];\n\
  \  let hashmap = new Map<number, boolean>();\n  for (let i = 0; i < lst.length;\
  \ i++) {\n    let val = lst[i];\n    if (hashmap.has(val)) {\n      return false;\n\
  \    }\n    hashmap.set(val, true);\n  }\n  return true;\n}\n"
- "  let hashMap = new Map<number, boolean>()\n  for (let i = 0; i < lst.length; i++)\
  \ {\n    let key = lst[i]\n    if (hashMap.has(key)) {\n      return false\n   \
  \ } else {\n      hashMap.set(key, true)\n    }\n  }\n  return true\n}\n"
- "  if (lst.length <= 1) {\n    return lst[0] === lst[1];\n  }\n  const set = new\
  \ Set<number>();\n  for (let i = 0; i < lst.length; i++) {\n    if (set.has(lst[i]))\
  \ {\n      return false;\n    }\n    set.add(lst[i]);\n  }\n  return true;\n}\n"
language: ts
name: HumanEval_126_is_sorted
prompt: "//Given a list of numbers, return whether or not they are sorted\n// in ascending\
  \ order. If list has more than 1 duplicate of the same\n// number, return False.\
  \ Assume no negative numbers and only integers.\n// Examples\n// is_sorted([5])\
  \ \u279E True\n// is_sorted([1, 2, 3, 4, 5]) \u279E True\n// is_sorted([1, 3, 2,\
  \ 4, 5]) \u279E False\n// is_sorted([1, 2, 3, 4, 5, 6]) \u279E True\n// is_sorted([1,\
  \ 2, 3, 4, 5, 6, 7]) \u279E True\n// is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279E False\n\
  // is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n// is_sorted([1, 2, 2, 2, 3, 4]) \u279E\
  \ False\nfunction is_sorted(lst: number[]): boolean {\n"
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = is_sorted;\n  assert.deepEqual(candidate([5]),true);\n\
  \  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);\n  assert.deepEqual(candidate([1,\
  \ 3, 2, 4, 5]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);\n\
  \  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);\n  assert.deepEqual(candidate([1,\
  \ 3, 2, 4, 5, 6, 7]),false);\n  assert.deepEqual(candidate([]),true);\n  assert.deepEqual(candidate([1]),true);\n\
  \  assert.deepEqual(candidate([3, 2, 1]),false);\n  assert.deepEqual(candidate([1,\
  \ 2, 2, 2, 3, 4]),false);\n  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);\n\
  \  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 4]),true);\n}\n\ntest();"
