name: HumanEval_110_exchange
language: lua
prompt: "-- In this problem, you will implement a function that takes two tables of\
  \ numbers,\n-- and determines whether it is possible to perform an exchange of elements\n\
  -- between them to make lst1 a table of only even numbers.\n-- There is no limit\
  \ on the number of exchanged elements between lst1 and lst2.\n-- If it is possible\
  \ to exchange elements between the lst1 and lst2 to make\n-- all the elements of\
  \ lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n\
  -- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})\n-- 'YES'\n-- >>> exchange({1, 2, 3,\
  \ 4}, {1, 5, 3, 4})\n-- 'NO'\n-- It is assumed that the input tables will be non-empty.\n\
  local function exchange(lst1, lst2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = exchange\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 4}, {1, 5, 3, 4}), 'NO')\n    lu.assertEquals(candidate({1, 2, 3, 4}, {2,\
  \ 1, 4, 3}), 'YES')\n    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')\n\
  \    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')\n    lu.assertEquals(candidate({3,\
  \ 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')\n    lu.assertEquals(candidate({100,\
  \ 200}, {200, 200}), 'YES')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if type(lst1) ~= 'table' or type(lst2) ~= 'table' then\n      \
    \  return 'Error: please provide two table arguments.'\n    end\n    local found_odd\
    \ = false\n    for i, v in ipairs(lst1) do\n        if v % 2 ~= 0 then\n     \
    \       for k, w in ipairs(lst2) do\n                if w % 2 == 0 then\n    \
    \                lst1[i] = w\n                    lst2[k] = v\n              \
    \      found_odd = true\n                    break\n                end\n    \
    \        end\n        end\n        if not found_odd then\n            return 'NO'\n\
    \        end\n    end\n    return 'YES'\nend", end, "\tlocal evens = 0\n\tlocal\
    \ odds = 0\n\tfor _, v in ipairs(lst1) do\n\t\tif v % 2 == 0 then\n\t\t\tevens\
    \ = evens + 1\n\t\telse\n\t\t\todds = odds + 1\n\t\tend\n\tend\n\tif evens ==\
    \ #lst1 then\n\t\treturn 'YES'\n\tend\n\tfor _, v in ipairs(lst2) do\n\t\tif v\
    \ % 2 == 0 then\n\t\t\tevens = evens + 1\n\t\telse\n\t\t\todds = odds + 1\n\t\t\
    end\n\tend\n\tif evens == #lst1 then\n\t\treturn 'YES'\n\tend\n\treturn 'NO'\n\
    end", "\tfor _, val in ipairs(lst1) do\n\t\tif val % 2 == 1 then\n\t\t\tfor k,\
    \ v in ipairs(lst2) do\n\t\t\t\tif v % 2 == 0 then\n\t\t\t\t\tlst1[k], lst2[k]\
    \ = lst2[k], lst1[k]\n\t\t\t\t\treturn 'YES'\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn\
    \ 'NO'\n\t\tend\n\tend\n\treturn 'YES'\nend", "  for i = 1, #lst1 do\n    if lst1[i]\
    \ % 2 == 1 then\n      for j = 1, #lst2 do\n        if lst2[j] % 2 == 1 then\n\
    \          lst1[i], lst2[j] = lst2[j], lst1[i]\n          break\n        end\n\
    \      end\n    end\n  end\n  for i = 1, #lst1 do\n    if lst1[i] % 2 == 1 then\n\
    \      return 'NO'\n    end\n  end\n  return 'YES'\nend", "  local function is_even(n)\n\
    \    return n % 2 == 0\n  end\n  local function contains_odd(lst)\n    return\
    \ linq.from(lst):any(function(n) return not is_even(n) end)\n  end\n  if contains_odd(lst1)\
    \ and contains_odd(lst2) then\n    return 'NO'\n  end\n  return 'YES'\nend", " \
    \   local res = false\n    local odd  = {}\n    local even = {}\n    for i = 1,\
    \ #lst1 do\n        if (lst1[i] % 2 == 0) then\n            even[#even + 1] =\
    \ lst1[i]\n        else\n            odd[#odd + 1] = lst1[i]\n        end\n  \
    \  end\n    for i = 1, #lst2 do\n        if (lst2[i] % 2 == 0) then\n        \
    \    even[#even + 1] = lst2[i]\n        else\n            odd[#odd + 1] = lst2[i]\n\
    \        end\n    end\n    if (#even == #lst1) then\n        res = true\n    end\n\
    \    return res and \"YES\" or \"NO\"\nend", "    -- If all of the elements of\
    \ lst1 are even, we don't need to do any\n    -- exchanges. We return \"YES\"\
    \ right away.\n    if all_even(lst1) then\n        return \"YES\"\n    end", " \
    \ -- YOUR CODE HERE\n  if not lst1 or not lst2 then\n    return nil\n  end\n \
    \ local odd_values = {}\n  local even_values = {}\n  for _, val in ipairs(lst1)\
    \ do\n    if val % 2 == 0 then\n      table.insert(even_values, val)\n    else\n\
    \      table.insert(odd_values, val)\n    end\n  end\n  for _, val in ipairs(lst2)\
    \ do\n    if val % 2 == 0 then\n      table.insert(even_values, val)\n    else\n\
    \      table.insert(odd_values, val)\n    end\n  end\n  if #odd_values == 0 then\n\
    \    return 'YES'\n  elseif #even_values == 0 then\n    return 'NO'\n  else\n\
    \    return 'YES'\n  end\nend", "    for i = 1, #lst1 do\n        if (lst1[i]\
    \ % 2 == 1) then\n            for j = 1, #lst2 do\n                if (lst2[j]\
    \ % 2 == 0) then\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n  \
    \                  return exchange(lst1, lst2)\n                end\n        \
    \    end\n            return \"NO\"\n        end\n    end\n    return \"YES\"\n\
    end", "    for i = 1, #lst1 do\n        if lst1[i] % 2 == 1 then\n           \
    \ local _, pos = isPresent(lst2, 'even')\n            if pos ~= -1 then\n    \
    \            lst1[i], lst2[pos] = lst2[pos], lst1[i]\n            else\n     \
    \           return 'NO'\n            end\n        end\n    end\n    return 'YES'\n\
    end", "  for _, v in ipairs(lst1) do\n    if v % 2 == 1 then\n      for _, w in\
    \ ipairs(lst2) do\n        if w % 2 == 0 then\n          return 'YES'\n      \
    \  end\n      end\n      return 'NO'\n    end\n  end\n  return 'YES'\nend", " \
    \   return false\nend", "    -- TODO: implement me!\nend", "  local function is_even(n)\n\
    \    return n % 2 == 0\n  end\n  local function swap(a, i, j)\n    a[i], a[j]\
    \ = a[j], a[i]\n  end\n  local function bubble_sort(a)\n    local swap_counter\
    \ = 0\n    for i = 1, #a do\n      for j = 1, #a - i do\n        if a[j] > a[j\
    \ + 1] then\n          swap(a, j, j + 1)\n          swap_counter = swap_counter\
    \ + 1\n        end\n      end\n    end\n    return swap_counter\n  end\n  local\
    \ lst1_even_count = 0\n  local lst2_even_count = 0\n  for i = 1, #lst1 do\n  \
    \  if is_even(lst1[i]) then\n      lst1_even_count = lst1_even_count + 1\n   \
    \ end\n  end\n  for i = 1, #lst2 do\n    if is_even(lst2[i]) then\n      lst2_even_count\
    \ = lst2_even_count + 1\n    end\n  end\n  if lst1_even_count == #lst1 or lst2_even_count\
    \ == #lst2 then\n    return 'YES'\n  end\n  if lst1_even_count < lst2_even_count\
    \ then\n    bubble_sort(lst1)\n    bubble_sort(lst2)\n    if lst1[1] > lst2[1]\
    \ then\n      swap(lst1, 1, 2)\n    end\n    return 'YES'\n  else\n    if lst1_even_count\
    \ > lst2_even_count then\n      bubble_sort(lst1)\n      bubble_sort(lst2)\n \
    \     if lst1[1] > lst2[1] then\n        swap(lst1, 1, 2)\n      end\n      return\
    \ 'YES'\n    else\n      return 'NO'\n    end\n  end\nend", "  local total_len\
    \ = #lst1 + #lst2\n  for i = 1, total_len do\n    if lst1[i] and lst1[i] % 2 ==\
    \ 1 then\n      local j = 1\n      while j <= total_len do\n        if lst2[j]\
    \ and lst2[j] % 2 == 0 then\n          lst1[i], lst2[j] = lst2[j], lst1[i]\n \
    \         break\n        end\n        j = j + 1\n      end\n      if lst1[i] %\
    \ 2 == 1 then\n        return 'NO'\n      end\n    end\n  end\n  return 'YES'\n\
    end", "  local even_nums = {}\n  local odd_nums = {}\n  for _,v in ipairs(lst1)\
    \ do\n    if v % 2 == 0 then\n      table.insert(even_nums, v)\n    else\n   \
    \   table.insert(odd_nums, v)\n    end\n  end\n  for _,v in ipairs(lst2) do\n\
    \    if v % 2 == 0 then\n      table.insert(even_nums, v)\n    else\n      table.insert(odd_nums,\
    \ v)\n    end\n  end\n  return (#even_nums >= #lst1) and \"YES\" or \"NO\"\nend",
  "    local res = \"NO\"\n    for k, v in ipairs(lst1) do\n        if v % 2 == 1\
    \ then\n            for k1, v1 in ipairs(lst2) do\n                if v1 % 2 ==\
    \ 0 then\n                    lst1[k] = v1\n                    lst2[k1] = v\n\
    \                    res = \"YES\"\n                    break\n              \
    \  end\n            end\n        end\n    end\n    return res\nend", "    -- Implement\
    \ this function.\nend", "  local ok = true\n  for i = 1, #lst1 do\n    if lst1[i]\
    \ % 2 == 1 then\n      ok = false\n      for j = 1, #lst2 do\n        if lst2[j]\
    \ % 2 == 1 then\n          lst1[i], lst2[j] = lst2[j], lst1[i]\n          ok =\
    \ true\n          break\n        end\n      end\n    end\n    if not ok then break\
    \ end\n  end\n  return ok and \"YES\" or \"NO\"\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
