name: HumanEval_86_anti_shuffle
language: lua
prompt: "-- Write a function that takes a string and returns an ordered version of\
  \ it.\n-- Ordered version of string, is a string where all words (separated by space)\n\
  -- are replaced by a new word where all the characters arranged in\n-- ascending\
  \ order based on ascii value.\n-- Note: You should keep the order of words and blank\
  \ spaces in the sentence.\n-- For example:\n-- >>> anti_shuffle('Hi')\n-- 'Hi'\n\
  -- >>> anti_shuffle('hello')\n-- 'ehllo'\n-- >>> anti_shuffle('Hello World!!!')\n\
  -- 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = anti_shuffle\n\
  \    lu.assertEquals(candidate('Hi'), 'Hi')\n    lu.assertEquals(candidate('hello'),\
  \ 'ehllo')\n    lu.assertEquals(candidate('number'), 'bemnru')\n    lu.assertEquals(candidate('abcd'),\
  \ 'abcd')\n    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')\n\
  \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hi. My name\
  \ is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: [end, "  local tbl = {}\n  for word in s:gmatch(\"%S+\") do\n    tbl[#tbl+1]\
    \ = word\n  end\n  for i,v in ipairs(tbl) do\n    tbl[i] = v:lower():gsub(\".\"\
    , function(c) return \"%\" .. c end)\n  end\n  table.sort(tbl)\n  for i,v in ipairs(tbl)\
    \ do\n    tbl[i] = v:gsub(\"%(.)\", function(c) return c:lower() end)\n  end\n\
    \  return table.concat(tbl)\nend", "  -- Your code here\nend", "    local words\
    \ = {}\n    local chars = {}\n    local new_word = ''\n    for word in s:gmatch('%S+')\
    \ do\n        table.insert(words, word)\n    end\n    for i, word in ipairs(words)\
    \ do\n        for c in word:gmatch('.') do\n            table.insert(chars, c)\n\
    \        end\n        table.sort(chars)\n        for j, c in ipairs(chars) do\n\
    \            new_word = new_word .. c\n        end\n        chars = {}\n     \
    \   words[i] = new_word\n        new_word = ''\n    end\n    return table.concat(words,\
    \ ' ')\nend", "  -- wirte your code here\nend", "\t-- DONE\n\tlocal ret = ''\n\
    \tfor w in s:gmatch('[^%s]+') do\n\t\tlocal t = {}\n\t\tfor c in w:gmatch('.')\
    \ do\n\t\t\ttable.insert(t, c)\n\t\tend\n\t\ttable.sort(t)\n\t\tret = ret .. table.concat(t)\
    \ .. ' '\n\tend\n\treturn ret:sub(1, -2)\nend", "  -- TODO: Implement this function\n\
    end", "\tlocal res = {}\n\tlocal ascii = {}\n\tlocal sorted = {}\n\tlocal c =\
    \ ''\n\tlocal w = ''\n\tfor i=1,#s do\n\t\tascii[s:sub(i,i)] = s:byte(i)\n\tend\n\
    \tfor k, v in pairs(ascii) do\n\t\ttable.insert(sorted, {key=k, value=v})\n\t\
    end\n\ttable.sort(sorted, function(a, b) return a.value < b.value end)\n\tfor\
    \ i=1,#sorted do\n\t\tc = sorted[i].key\n\t\tif c == ' ' then\n\t\t\tres[i] =\
    \ c\n\t\telse\n\t\t\tw = w .. c\n\t\t\tif i == #sorted then\n\t\t\t\tres[i] =\
    \ w\n\t\t\tend\n\t\tend\n\tend\n\treturn table.concat(res)\nend", "    -- Unimplemented\n\
    end", "    local function is_delimiter(c)\n        return c == ' ' or c == '\\\
    n' or c == '\\t'\n    end", "  local t = {}\n  for w in s:gmatch('%S+') do\n \
    \   local v = w:gsub('%a', function(c) return string.char(string.byte(c) - 32)\
    \ end)\n    table.insert(t, v .. w)\n  end\n  return table.concat(t)\nend", end,
  "    -- put your code here\nend", "    -- TODO\nend", "    local res = {}\n    for\
    \ w in s:gmatch(\"%S+\") do\n        table.insert(res, table.concat(w:gmatch(\"\
    .\"), \"\",\n            function(a, b) return a:byte() < b:byte() end))\n   \
    \ end\n    return table.concat(res, \" \")\nend", "    local words = {}\n    for\
    \ word in s:gmatch('%S+') do\n        table.insert(words, word)\n    end\n   \
    \ local new_words = {}\n    for _, word in ipairs(words) do\n        table.insert(new_words,\
    \ word:gsub('.', function(c)\n            return string.char(string.byte(c))\n\
    \        end))\n    end\n    return table.concat(new_words, ' ')\nend", "    --\
    \ TODO: Implement me\nend", "  local res = {}\n  for word in s:gmatch('%S+') do\n\
    \    table.insert(res, table.concat(table.sort(word:split('')), ''))\n  end\n\
    \  return table.concat(res, ' ')\nend", "  if s:len() < 2 then\n    return s\n\
    \  end\n  local result = {}\n  for k, v in pairs(s:split(' ')) do\n    table.insert(result,\
    \ string.char(v:byte()))\n  end\n  table.sort(result)\n  return table.concat(result)\n\
    end", "  local words = str_split(s, ' ')\n  local new_words = {}\n  for i, v in\
    \ ipairs(words) do\n    local letters = {}\n    for i2, v2 in ipairs(str_split(v,\
    \ '')) do\n      table.insert(letters, v2)\n    end\n    table.sort(letters)\n\
    \    table.insert(new_words, table.concat(letters, ''))\n  end\n  return table.concat(new_words,\
    \ ' ')\nend", "  assert(type(s) == 'string')\n  return s\nend", "  local result\
    \ = ''\n  for word in s:gmatch('%S+') do\n    local chars = {}\n    for c in word:gmatch('.')\
    \ do\n      table.insert(chars, c)\n    end\n    table.sort(chars)\n    result\
    \ = result .. table.concat(chars) .. ' '\n  end\n  return result:sub(1, -2)\n\
    end", "    if s == \"\" then\n        return \"\"\n    end\n    local s = s:gsub(\"\
    %s\",\"\")\n    local table = {}\n    for i = 1, #s do\n        table[i] = s:sub(i,i)\n\
    \    end\n    table.sort(table)\n    local sentence = \"\"\n    for i = 1, #table\
    \ do\n        sentence = sentence .. table[i]\n    end\n    return sentence\n\
    end", "  local r = {}\n  local e = {}\n  local ss = s\n  while string.find(ss,\
    \ ' ') do\n    local i, j = string.find(ss, ' ')\n    table.insert(r, string.sub(ss,\
    \ 1, i - 1))\n    table.insert(e, string.sub(ss, i, j))\n    ss = string.sub(ss,\
    \ j + 1)\n  end\n  table.insert(r, ss)\n  local res = {}\n  for i = 1, #r do\n\
    \    local s = r[i]\n    local t = {}\n    for k = 1, #s do\n      table.insert(t,\
    \ string.sub(s, k, k))\n    end\n    table.sort(t)\n    for k = 1, #t do\n   \
    \   table.insert(res, t[k])\n    end\n    table.insert(res, e[i])\n  end\n  return\
    \ table.concat(res)\nend", "    --TODO\nend", "    local function sort_word(word)\n\
    \        local letter_table = {}\n        for c in word:gmatch('.') do\n     \
    \       table.insert(letter_table, c)\n        end\n        table.sort(letter_table)\n\
    \        return table.concat(letter_table)\n    end", "    local new_s = \"\"\n\
    \    local word = \"\"\n    local word_list = {}\n    for i = 1, #s do\n     \
    \   if s:sub(i, i) == \" \" then\n            table.insert(word_list, word)\n\
    \            table.insert(word_list, \" \")\n            word = \"\"\n       \
    \ else\n            word = word .. s:sub(i, i)\n        end\n    end\n    table.insert(word_list,\
    \ word)\n    for i = 1, #word_list do\n        local sorted_word = \"\"\n    \
    \    if type(word_list[i]) == \"string\" then\n            local chars = {}\n\
    \            for j = 1, #word_list[i] do\n                table.insert(chars,\
    \ word_list[i]:sub(j, j))\n            end\n            table.sort(chars)\n  \
    \          for j = 1, #chars do\n                sorted_word = sorted_word ..\
    \ chars[j]\n            end\n        else\n            sorted_word = word_list[i]\n\
    \        end\n        new_s = new_s .. sorted_word\n    end\n    return new_s\n\
    end", "  return s\nend", "\t-- TODO\nend", "    local words = {}\n    for word\
    \ in s:gmatch('%S+') do\n        table.insert(words, word)\n    end\n    local\
    \ new_s = ''\n    for i = 1, #words do\n        local word = words[i]\n      \
    \  local chars = {}\n        for c in word:gmatch('.') do\n            table.insert(chars,\
    \ c)\n        end\n        table.sort(chars)\n        for j = 1, #chars do\n \
    \           local c = chars[j]\n            new_s = new_s .. c\n        end\n\
    \        new_s = new_s .. ' '\n    end\n    return new_s\nend", "  local words\
    \ = {}\n  local counter = 1\n  for w in s:gmatch('%S+') do\n    words[counter]\
    \ = w\n    counter = counter + 1\n  end\n  for k, v in pairs(words) do\n    local\
    \ new_word = {}\n    for c in v:gmatch('.') do\n      new_word[#new_word + 1]\
    \ = c\n    end\n    table.sort(new_word)\n    words[k] = table.concat(new_word)\n\
    \  end\n  return table.concat(words, ' ')\nend", "  local t = {}\n  for i in s:gmatch('%S+')\
    \ do\n    local chars = {}\n    for j in i:gmatch('.') do\n      table.insert(chars,\
    \ j)\n    end\n    table.sort(chars)\n    local sorted = table.concat(chars)\n\
    \    table.insert(t, sorted)\n  end\n  return table.concat(t, ' ')\nend", "  --\
    \ YOUR CODE GOES HERE\nend", "    local words = {}\n    for word in s:gmatch('%S+')\
    \ do\n        words[#words + 1] = word\n    end\n    for i = 1, #words do\n  \
    \      words[i] = table.concat(\n            table.sort(\n                utils.to_table(words[i]),\n\
    \                function(a, b)\n                    return a:byte() < b:byte()\n\
    \                end\n            )\n        )\n    end\n    return table.concat(words,\
    \ ' ')\nend", "  local words = s:split(' ')\n  local ordered = {}\n  for _, word\
    \ in ipairs(words) do\n    local chars = {}\n    for c in word:gmatch('.') do\n\
    \      table.insert(chars, c)\n    end\n    table.sort(chars)\n    table.insert(ordered,\
    \ table.concat(chars))\n  end\n  return table.concat(ordered, ' ')\nend", "  local\
    \ t = {}\n  for w in s:gmatch('%S+') do\n    local tt = {}\n    for c in w:gmatch('.')\
    \ do\n      table.insert(tt, c)\n    end\n    table.sort(tt)\n    table.insert(t,\
    \ table.concat(tt))\n  end\n  return table.concat(t, ' ')\nend", "  local tbl\
    \ = {}\n  local str = ''\n  local i = 1\n  local j = 0\n  local k = 0\n  -- split\
    \ string using string.gmatch\n  for w in string.gmatch(s, \"%S+\") do\n    j =\
    \ i + string.len(w)\n    table.insert(tbl, w)\n    tbl[i] = {}\n    tbl[i] = tbl[i]\
    \ .. w\n    table.insert(tbl, j)\n    tbl[j] = {}\n    tbl[j] = tbl[j] .. ' '\n\
    \    i = j + 1\n  end\n  for i, v in ipairs(tbl) do\n    for j, w in ipairs(v)\
    \ do\n      tbl[i][j] = string.byte(w)\n    end\n  end\n  for i, v in ipairs(tbl)\
    \ do\n    for j, w in ipairs(v) do\n      for k, u in ipairs(v) do\n        if\
    \ k == 1 then\n          if w < u then\n            tbl[i][j] = u\n          \
    \  tbl[i][k] = w\n          end\n        else\n          if w < u then\n     \
    \       tbl[i][j] = u\n            tbl[i][k] = w\n          end\n        end\n\
    \      end\n    end\n  end\n  for i, v in ipairs(tbl) do\n    for j, w in ipairs(v)\
    \ do\n      tbl[i][j] = string.char(w)\n    end\n  end\n  for i, v in ipairs(tbl)\
    \ do\n    str = str .. v\n  end\n  return str\nend", "  local words = {}\n  local\
    \ prev = 1\n  for w in s:gmatch('%w+') do\n    table.insert(words, w)\n    prev\
    \ = prev + #w\n  end\n  local words2 = {}\n  for i, w in ipairs(words) do\n  \
    \  table.insert(words2, w:sort())\n  end\n  local start = 1\n  local result =\
    \ {}\n  for i, w in ipairs(words) do\n    table.insert(result, s:sub(start, start\
    \ + #w - 1))\n    start = start + #w\n  end\n  return table.concat(result)\nend",
  "    local words = {}\n    local spaces = {}\n    local s_ = {}\n    local prev\
    \ = ''\n    local function append(w)\n        if #w > 0 then\n            table.insert(words,\
    \ w)\n        end\n    end\n    for w in s:gmatch('%S+') do\n        append(prev)\n\
    \        prev = w\n    end\n    append(prev)\n    for i, w in ipairs(words) do\n\
    \        local letters = {}\n        for l in w:gmatch('.') do\n            table.insert(letters,\
    \ l)\n        end\n        table.sort(letters)\n        table.insert(s_, table.concat(letters))\n\
    \    end\n    return table.concat(s_)\nend", "  -- TODO: your code here\nend",
  end, "    local words = {}\n    local word = \"\"\n    for char in s:gmatch(\"%S\"\
    ) do\n        if char ~= \" \" then\n            word = word .. char\n       \
    \ else\n            table.insert(words, word)\n            word = \"\"\n     \
    \   end\n    end\n    table.insert(words, word)\n    for i, word in ipairs(words)\
    \ do\n        words[i] = table.concat(sort_string(word))\n    end\n    return\
    \ table.concat(words, \" \")\nend", end, "    local res = {}\n    for word in\
    \ s:gmatch('%S+') do\n        local chars = {}\n        for char in word:gmatch('.')\
    \ do\n            table.insert(chars, char)\n        end\n        table.sort(chars)\n\
    \        table.insert(res, table.concat(chars))\n    end\n    return table.concat(res,\
    \ ' ')\nend", "  local function f(w)\n    local t = {}\n    for i=1,#w do t[i]\
    \ = w:sub(i,i) end\n    table.sort(t)\n    return table.concat(t)\n  end\n  return\
    \ (s:gsub('(%w+)', f))\nend", "  local words = {}\n  for word in s:gmatch('%w+')\
    \ do\n    local l = {}\n    for char in word:gmatch('.') do\n      table.insert(l,\
    \ char)\n    end\n    table.sort(l)\n    table.insert(words, table.concat(l))\n\
    \  end\n  return table.concat(words, ' ')\nend", end, "    -- write your code\
    \ here\nend", "    -- your implementation here\n    return nil\nend", "    --\
    \ YOUR CODE HERE\nend", "  -- TODO\nend", "  local word_table = {}\n  for word\
    \ in s:gmatch(\"%w+\") do\n    local sorted_word = \"\"\n    for ch in word:gmatch(\"\
    .\") do\n      local n = string.byte(ch)\n      local inserted = false\n     \
    \ local new_word = \"\"\n      for i, ch2 in ipairs(sorted_word) do\n        if\
    \ not inserted and string.byte(ch2) > n then\n          new_word = new_word ..\
    \ ch\n          inserted = true\n        end\n        new_word = new_word .. ch2\n\
    \      end\n      if not inserted then\n        new_word = new_word .. ch\n  \
    \    end\n      sorted_word = new_word\n    end\n    table.insert(word_table,\
    \ sorted_word)\n  end\n  local result = \"\"\n  local i = 1\n  for ch in s:gmatch(\"\
    .\") do\n    if ch:match(\"%w\") then\n      result = result .. word_table[i]\n\
    \      i = i + 1\n    else\n      result = result .. ch\n    end\n  end\n  return\
    \ result\nend", "\tlocal words = {}\n\tfor i in s:gmatch(\"%S+\") do\n\t\ttable.insert(words,\
    \ i)\n\tend\n\tfor i = 1, #words do\n\t\tlocal chars = {}\n\t\tfor j in words[i]:gmatch(\"\
    .\") do\n\t\t\ttable.insert(chars, j)\n\t\tend\n\t\ttable.sort(chars)\n\t\twords[i]\
    \ = table.concat(chars)\n\tend\n\treturn table.concat(words, \" \")\nend", " \
    \ -- TODO(student): remove this line and replace the function with the body\n\
    \  -- of the function to make the tests pass\n  -- HINT: You can use `string.char`\
    \ and `string.byte` to convert between\n  -- a character and its ascii code. To\
    \ sort characters, use table.sort.\n  local answer = {}\n  local previous = 0\n\
    \  local words = s:split(\" \")\n  for _, word in ipairs(words) do\n    local\
    \ characters = {}\n    for i = 1, #word do\n      table.insert(characters, string.char(word:byte(i)))\n\
    \    end\n    table.sort(characters)\n    for i = 1, #characters do\n      table.insert(answer,\
    \ characters[i])\n    end\n    table.insert(answer, \" \")\n  end\n  return table.concat(answer)\n\
    end", "  local sorted = table.sort(string.split(s, ' '))\n  return table.concat(sorted,\
    \ ' ')\nend", "  local tab = {}\n  for word in s:gmatch('%w+') do\n    table.insert(tab,\
    \ word:gsub('.', function(x) return string.char(x:byte() % 128) end))\n  end\n\
    \  return table.concat(tab, ' ')\nend", "\tlocal str = ''\n\tfor word in s:gmatch('%w+')\
    \ do\n\t\tstr = str .. ' ' .. word:gsub('.', function(char)\n\t\t\treturn char\
    \ .. ' ' .. string.byte(char)\n\t\tend):gsub('^%s', ''):gsub('%s+', ' '):gsub('%s+$',\
    \ ''):gsub('(%s+)(%d+)(%s+)', function(a, b, c)\n\t\t\treturn c .. b .. a\n\t\t\
    end):gsub('(%d+)%s+(%S+)', function(a, b)\n\t\t\treturn b\n\t\tend)\n\tend\n\t\
    return str:gsub('^%s', ''):gsub('%s+', ' '):gsub('%s+$', '')\nend", "    -- your\
    \ code here\nend", "    local words = {}\n    local w = ''\n    for i = 1, #s\
    \ do\n        local c = s:sub(i, i)\n        if c ~= ' ' then\n            w =\
    \ w .. c\n        else\n            table.insert(words, w)\n            w = ''\n\
    \        end\n    end\n    table.insert(words, w)\n    for i = 1, #words do\n\
    \        local word = words[i]\n        local chars = {}\n        for j = 1, #word\
    \ do\n            local c = word:sub(j, j)\n            table.insert(chars, c)\n\
    \        end\n        table.sort(chars)\n        words[i] = table.concat(chars)\n\
    \    end\n    return table.concat(words, ' ')\nend", "    -- insert your code\
    \ here\nend", "    local words = {}\n    for w in s:gmatch('%S+') do\n       \
    \ table.insert(words, table.concat(sort(chars(w))))\n    end\n    return table.concat(words,\
    \ ' ')\nend", "  local result = {}\n  local index = 1\n  for word in s:gmatch('%S+')\
    \ do\n    local char_list = {}\n    for c in word:gmatch('.') do\n      table.insert(char_list,\
    \ c)\n    end\n    table.sort(char_list)\n    result[index] = table.concat(char_list)\n\
    \    index = index + 1\n  end\n  return table.concat(result, ' ')\nend", "   \
    \ return s:gsub('%w+', function(w)\n        return string.gsub(w, '.', function(c)\n\
    \            return table.concat(table.sort(string.explode(c)))\n        end)\n\
    \    end)\nend", "\t-- TODO: implement\nend", "  local words = {}\n  for word\
    \ in s:gmatch('%S+') do\n    table.insert(words, word)\n  end\n  local sorted_words\
    \ = {}\n  for i, word in ipairs(words) do\n    local word_chars = {}\n    for\
    \ c in word:gmatch('.') do\n      table.insert(word_chars, c)\n    end\n    table.sort(word_chars)\n\
    \    local sorted_word = table.concat(word_chars)\n    table.insert(sorted_words,\
    \ sorted_word)\n  end\n  return table.concat(sorted_words, ' ')\nend", "    local\
    \ table = {}\n    local answer = ''\n    for word in string.gmatch(s, '[^%s]+')\
    \ do\n        local part = ''\n        for character in string.gmatch(word, '.')\
    \ do\n            part = part .. character\n        end\n        table[#table\
    \ + 1] = part\n    end\n    for _, v in ipairs(table) do\n        table[_] = {}\n\
    \        for i = 1, #v do\n            table[_][i] = v:sub(i, i)\n        end\n\
    \        table[_] = table[_]:sort()\n        for i = 1, #table[_] do\n       \
    \     answer = answer .. table[_][i]\n        end\n        answer = answer ..\
    \ ' '\n    end\n    return answer:sub(1, #answer - 1)\nend", "    local res =\
    \ {}\n    for word in s:gmatch('%S+') do\n        table.insert(res, word:gsub('.',\
    \ function(c)\n            return string.char(string.byte(c))\n        end))\n\
    \    end\n    return table.concat(res, ' ')\nend", "    -- your code goes here\n\
    end", "  -- YOUR CODE GOES HERE\nend", "\tlocal l = {}\n\tlocal w = ''\n\tlocal\
    \ r = ''\n\tfor c in s:gmatch('.') do\n\t\tif c ~= ' ' then\n\t\t\tw = w .. c\n\
    \t\telse\n\t\t\tr = r .. ' '\n\t\t\tl[#l + 1] = w\n\t\t\tw = ''\n\t\tend\n\tend\n\
    \tfor _, v in ipairs(l) do\n\t\tlocal chars = {}\n\t\tfor ch in v:gmatch('.')\
    \ do\n\t\t\tchars[#chars + 1] = ch\n\t\tend\n\t\ttable.sort(chars)\n\t\tfor _,\
    \ l in ipairs(chars) do\n\t\t\tr = r .. l\n\t\tend\n\tend\n\treturn r\nend", " \
    \ -- your code here\nend", "    return s\nend", "    return (s:gsub(\"%w+\", function(word)\n\
    \        return word:gsub(\".\", function(char)\n            return char .. '\
    \ '\n        end):sub(1, -2):gsub(\" \", function(chars)\n            return chars:gsub(\"\
    .\", function(char)\n                return table.sort(chars, function(a, b)\n\
    \                    return a:byte() < b:byte()\n                end)[1]\n   \
    \         end)\n        end)\n    end))\nend", "  -- Write your code here\nend",
  "    -- YOUR CODE HERE\nend", end, "    local function anti_shuffle_word(word)\n\
    \        local chars = {}\n        for char in word:gmatch(\".\") do\n       \
    \     table.insert(chars, char)\n        end\n        table.sort(chars)\n    \
    \    return table.concat(chars)\n    end", "  local t = {}\n  for w in s:gmatch('%S+')\
    \ do\n    table.insert(t, table.concat(c(w):sort()))\n  end\n  return table.concat(t,\
    \ ' ')\nend", "  local function new_word(s)\n    local result = ''\n    local\
    \ t = {}\n    for i = 1, #s do\n      table.insert(t, s:sub(i, i))\n    end\n\
    \    table.sort(t)\n    for i = 1, #t do\n      result = result .. t[i]\n    end\n\
    \    return result\n  end\n  local words = {}\n  local result = ''\n  for word\
    \ in s:gmatch('%w+') do\n    table.insert(words, word)\n  end\n  local i = 1\n\
    \  while i <= #s do\n    local tmp = string.match(s, '%w+', i)\n    if tmp then\n\
    \      result = result .. new_word(tmp)\n      i = i + #tmp\n    else\n      result\
    \ = result .. s:sub(i, i)\n      i = i + 1\n    end\n  end\n  return result\n\
    end", "    local words = {}\n    for w in s:gmatch('%S+') do\n        local chars\
    \ = {}\n        for c in w:gmatch('.') do\n            table.insert(chars, c)\n\
    \        end\n        table.sort(chars)\n        table.insert(words, table.concat(chars))\n\
    \    end\n    return table.concat(words, ' ')\nend", "\tlocal t={}\n\tlocal j=1\n\
    \tlocal  i=1\n\tlocal n=#s\n\twhile i<=n do\n\t\tif s:sub(i,i)==\" \" then\n\t\
    \t\tt[j]={key=s:sub(i,i),index=i}\n\t\t\tj=j+1\n\t\t\ti=i+1\n\t\telse\n\t\t\t\
    local k=i\n\t\t\twhile s:sub(k,k)~=\" \" and k<=n do\n\t\t\t\tk=k+1\n\t\t\tend\n\
    \t\t\tt[j]={key=s:sub(i,k-1),index=i}\n\t\t\tj=j+1\n\t\t\ti=k\n\t\tend\n\tend\n\
    \tlocal function compare(a,b)\n\t\treturn a.key:lower()<b.key:lower()\n\tend\n\
    \ttable.sort(t,compare)\n\tlocal str=\"\"\n\tfor i=1,#t do\n\t\tstr=str..t[i].key\n\
    \tend\n\tlocal res=\"\"\n\tlocal m=1\n\tfor i=1,#t do\n\t\twhile m<t[i].index\
    \ do\n\t\t\tres=res..s:sub(m,m)\n\t\t\tm=m+1\n\t\tend\n\t\tres=res..str:sub(i,i)\n\
    \t\tm=m+1\n\tend\n\treturn res\nend", "    local words = {}\n    local new_words\
    \ = {}\n    local str = \"\"\n    for word in string.gmatch(s, \"%S+\") do\n \
    \       table.insert(words, word)\n    end\n    for i, w in ipairs(words) do\n\
    \        local new_word = \"\"\n        for c in string.gmatch(w, \".\") do\n\
    \            table.insert(new_words, c)\n        end\n        table.sort(new_words)\n\
    \        for j, nw in ipairs(new_words) do\n            new_word = new_word ..\
    \ nw\n        end\n        str = str .. new_word .. \" \"\n        new_words =\
    \ {}\n    end\n    return str\nend", "  -- Your code here\nend", end, "  local\
    \ wl = {}\n  for w in s:gmatch(\"%S+\") do\n    table.insert(wl, w)\n  end\n \
    \ for i, v in ipairs(wl) do\n    local sw = {}\n    for l in v:gmatch(\".\") do\n\
    \      table.insert(sw, l)\n    end\n    table.sort(sw)\n    wl[i] = table.concat(sw)\n\
    \  end\n  return table.concat(wl, \" \")\nend", "    local function order(w)\n\
    \        local res = \"\"\n        local order = {}\n        for i = 1, #w do\n\
    \            table.insert(order, w:sub(i, i))\n        end\n        table.sort(order)\n\
    \        for _, c in ipairs(order) do\n            res = res .. c\n        end\n\
    \        return res\n    end\n    local res = \"\"\n    local current_word = \"\
    \"\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if c ~= \" \"\
    \ then\n            current_word = current_word .. c\n        else\n         \
    \   res = res .. order(current_word) .. \" \"\n            current_word = \"\"\
    \n        end\n    end\n    res = res .. order(current_word)\n    return res\n\
    end", "    -- TODO: Implement the function\nend", "    -- your code here\nend",
  "    -- write your code here\nend", "    -- TODO: Add your implementation here\n\
    end", "  local words = {}\n  local temp = \"\"\n  for i = 1, string.len(s) do\n\
    \    if (string.sub(s, i, i) == \" \") then\n      table.insert(words, temp)\n\
    \      temp = \"\"\n    else\n      temp = temp .. string.sub(s, i, i)\n    end\n\
    \  end\n  table.insert(words, temp)\n  for i = 1, #words do\n    words[i] = table.concat(table.sort(split(words[i],\
    \ \"\")))\n  end\n  return table.concat(words, \" \")\nend", "    -- TODO: implement\
    \ this function\nend", "    --[[\n        >>> anti_shuffle('Hello World!!!')\n\
    \        'Hello !!!Wdlor'\n    ]]\n    local tokens = {}\n    local token = \"\
    \"\n    for c in s:gmatch(\".\") do\n        if c == \" \" then\n            table.insert(tokens,\
    \ token)\n            token = \"\"\n        else\n            token = token ..\
    \ c\n        end\n    end\n    table.insert(tokens, token)\n    for _, t in ipairs(tokens)\
    \ do\n        tokens[_] = table.concat(table.sort(split(t)))\n    end\n    return\
    \ table.concat(tokens, \" \")\nend", "  -- TODO: Write me\nend", "    -- your\
    \ code here\nend", "    if type(s) ~= 'string' then\n        return nil\n    end\n\
    \    local str = ''\n    for word in s:gmatch('%S+') do\n        local new_word\
    \ = ''\n        for char in word:gmatch('.') do\n            new_word = new_word\
    \ .. char\n        end\n        table.sort(new_word)\n        str = str .. new_word\n\
    \    end\n    return str\nend", "    -- Place your code here\nend", "    s = string.gsub(s,\
    \ \" +\", \" \")\n    local r = \"\"\n    local t = {}\n    local l = 0\n    for\
    \ w in string.gmatch(s, \"%S+\") do\n        local c = w:sub(1, 1)\n        local\
    \ o = c\n        l = l + 1\n        for i = 2, #w do\n            c = w:sub(i,\
    \ i)\n            if c < o then\n                t[l] = \" \" .. t[l]\n      \
    \          t[l] = c .. t[l]\n            else\n                t[l] = t[l] ..\
    \ c\n            end\n            o = c\n        end\n    end\n    for _, w in\
    \ ipairs(t) do\n        r = r .. w\n    end\n    return r\nend", "    -- your\
    \ code here\nend", "\t-- TODO: Implement this function\nend", "    local output\
    \ = ''\n    local current_word = ''\n    local in_word = false\n    for i = 1,\
    \ #s do\n        local char = s:sub(i, i)\n        if in_word then\n         \
    \   if char == ' ' then\n                table.insert(output, current_word)\n\
    \                table.insert(output, ' ')\n                current_word = ''\n\
    \                in_word = false\n            else\n                table.insert(current_word,\
    \ char)\n            end\n        else\n            if char ~= ' ' then\n    \
    \            table.insert(current_word, char)\n                in_word = true\n\
    \            else\n                table.insert(output, ' ')\n            end\n\
    \        end\n    end\n    table.insert(output, current_word)\n    local function\
    \ compare(a, b)\n        if #a == 0 or #b == 0 then\n            return false\n\
    \        end\n        return a:sub(1, 1) < b:sub(1, 1)\n    end\n    table.sort(output,\
    \ compare)\n    return table.concat(output)\nend", "    if type(s) ~= 'string'\
    \ then\n        error(\"expected argument of type string\", 2)\n    end\n    return\
    \ s:gsub(\"%S+\", function(w)\n        local t = {}\n        for i = 1, #w do\n\
    \            t[#t + 1] = w:sub(i, i)\n        end\n        table.sort(t)\n   \
    \     return table.concat(t)\n    end)\nend", "  -- Write your code here\nend",
  "    local function char_sort(s)\n        local t = {}\n        for i = 1, #s do\n\
    \            table.insert(t, s:sub(i, i))\n        end\n        table.sort(t)\n\
    \        return table.concat(t)\n    end\n    local t = {}\n    for w in s:gmatch('%S+')\
    \ do\n        table.insert(t, char_sort(w))\n    end\n    return table.concat(t,\
    \ ' ')\nend", "    local words = {}\n    for word in s:gmatch('%S+') do\n    \
    \    local letters = {}\n        for char in word:gmatch('.') do\n           \
    \ table.insert(letters, char)\n        end\n        table.sort(letters)\n    \
    \    table.insert(words, table.concat(letters))\n    end\n    return table.concat(words,\
    \ ' ')\nend", end, "    -- Replace all non alpha characters with space\n    local\
    \ s = s:gsub('%P', ' ')\n    -- Replace all consecutive spaces with just one space\n\
    \    s = s:gsub('%s+', ' ')\n    -- Split string into array of words\n    local\
    \ words = s:split(' ')\n    -- Reorder characters within each word based on ascii\
    \ value\n    for i = 1, #words do\n        local chars = words[i]:split('')\n\
    \        table.sort(chars)\n        words[i] = table.concat(chars)\n    end\n\
    \    -- Return string of reordered words joined with a space\n    return table.concat(words,\
    \ ' ')\nend", "  local function anti_sort(w)\n    local function anti_cmp(c1,\
    \ c2)\n      return c1:byte() < c2:byte()\n    end\n    local t = {}\n    for\
    \ c in w:gmatch'.' do table.insert(t, c) end\n    table.sort(t, anti_cmp)\n  \
    \  return table.concat(t)\n  end\n  local t = {}\n  for w in s:gmatch'%S+' do\
    \ table.insert(t, anti_sort(w)) end\n  return table.concat(t, ' ')\nend", "  local\
    \ o = ''\n  for word in s:gmatch('%w+') do\n    local t = {}\n    for char in\
    \ word:gmatch('.') do\n      table.insert(t, char)\n    end\n    table.sort(t)\n\
    \    for i, char in ipairs(t) do\n      o = o .. char\n    end\n    o = o .. '\
    \ '\n  end\n  return o:sub(1, -2)\nend", "  local ret = ''\n  for w in s:gmatch('[^%s]+')\
    \ do\n    w = w:gsub('(.)', function(c) return c .. '\\0' end)\n    table.sort(w)\n\
    \    ret = ret .. w\n  end\n  return ret\nend", "    local result = {}\n    for\
    \ word in s:gmatch('%S+') do\n        table.insert(result, table.concat(table.sort(word)))\n\
    \    end\n    return table.concat(result, ' ')\nend", "  -- YOUR CODE HERE\nend",
  end, "  local buffer = {\"\"}\n  local i = 1\n  for word in s:gmatch(\"%S+\") do\n\
    \    local chars = {}\n    for char in word:gmatch(\".\") do\n      chars[#chars\
    \ + 1] = char\n    end\n    table.sort(chars)\n    local anti_shuffled_word =\
    \ table.concat(chars)\n    buffer[i] = anti_shuffled_word\n    i = i + 1\n  end\n\
    \  return table.concat(buffer, \" \")\nend", "  -- TODO: implement this function\n\
    end", "  error('Not implementted')\nend", "    return s\nend", "    local out\
    \ = {}\n    for word in s:gmatch(\"%S+\") do\n        table.insert(out, word:gsub(\"\
    .\", function(c) return c..'+' end):sub(1, -2))\n    end\n    return table.concat(out,\
    \ ' ')\nend", "    local words = split(s, ' ')\n    local result = {}\n    for\
    \ _,word in ipairs(words) do\n        local chars = split(word, '')\n        table.sort(chars)\n\
    \        table.insert(result, table.concat(chars))\n    end\n    return table.concat(result,\
    \ ' ')\nend", "    if not s then return '' end\n    local t = {}\n    for w in\
    \ s:gmatch('%S+') do\n        t[#t+1] = w:gsub('.', function(c) return c:rep(c:byte())\
    \ end)\n    end\n    return table.concat(t, ' ')\nend", "  --write your code here\n\
    end", "  assert(type(s) == 'string')\n  -- YOUR CODE HERE\nend", "    -- insert\
    \ your code here\nend", "    local t = {}\n    for word in s:gmatch('%S+') do\n\
    \        local t2 = {}\n        for char in word:gmatch('.') do\n            table.insert(t2,\
    \ char)\n        end\n        table.sort(t2)\n        table.insert(t, table.concat(t2))\n\
    \    end\n    return table.concat(t, ' ')\nend", "  local new_sentence = ''\n\
    \  local current_word = ''\n  local splitted_text = split(s, ' ')\n  for i = 1,\
    \ #splitted_text do\n    if splitted_text[i] == '' then\n      new_sentence =\
    \ new_sentence .. splitted_text[i]\n    else\n      current_word = splitted_text[i]\n\
    \      local chars = split(current_word, '')\n      table.sort(chars)\n      for\
    \ j = 1, #chars do\n        new_sentence = new_sentence .. chars[j]\n      end\n\
    \    end\n    if i ~= #splitted_text then\n      new_sentence = new_sentence ..\
    \ ' '\n    end\n  end\n  return new_sentence\nend", "    local words = {}\n  \
    \  for m in s:gmatch('%S+') do\n        table.insert(words, m)\n    end\n    for\
    \ i, v in ipairs(words) do\n        words[i] = table.concat(split(v))\n    end\n\
    \    return table.concat(words, ' ')\nend", "  -- TODO: fill in this function.\n\
    \  -- Use this function to swap characters in a string:\n  --     'a'..'b' ==\
    \ 'ab'\n  --     'ab'..'c' == 'abc'\n  --     'abc'..'d' == 'abcd'\n  --     'abcd'..'a'\
    \ == 'adbc'\n  local function swap(s, p1, p2)\n    return s:sub(1, p1-1) .. s:sub(p2,\
    \ p2) .. s:sub(p1+1, p2-1) .. s:sub(p1, p1) .. s:sub(p2+1)\n  end\n  for i = 1,\
    \ #s do\n    for j = i+1, #s do\n      if s:sub(i, i) > s:sub(j, j) then\n   \
    \     s = swap(s, i, j)\n      end\n    end\n  end\n  return s\nend", "  -- YOUR\
    \ CODE HERE\nend", "    local tmp, t = {}, {}\n    for word in s:gmatch('%S+')\
    \ do\n        table.insert(tmp, word)\n    end\n    for i = 1, #tmp do\n     \
    \   if #tmp[i] > 1 then\n            table.insert(t, tmp[i]:gsub('(.)', function(c)\
    \ return string.format('%02d', string.byte(c)) end))\n        else\n         \
    \   table.insert(t, tmp[i])\n        end\n    end\n    for i = 1, #t do\n    \
    \    if #t[i] > 1 then\n            t[i] = t[i]:gsub('%d%d', function(c) return\
    \ string.char(tonumber(c)) end)\n        end\n    end\n    return table.concat(t,\
    \ ' ')\nend", "    if s:match('^%s*$') then\n        return s\n    end\n    local\
    \ sorted_chars = {}\n    for char in s:gmatch('.') do\n        table.insert(sorted_chars,\
    \ char)\n    end\n    table.sort(sorted_chars)\n    local anti_shuffled_s = sorted_chars[1]\n\
    \    for i = 2, #sorted_chars do\n        anti_shuffled_s = anti_shuffled_s ..\
    \ sorted_chars[i]\n    end\n    local shuffled_s = \"\"\n    local count = 0\n\
    \    for char in s:gmatch('.') do\n        if char == ' ' then\n            shuffled_s\
    \ = shuffled_s .. ' '\n        else\n            count = count + 1\n         \
    \   shuffled_s = shuffled_s .. anti_shuffled_s:sub(count, count)\n        end\n\
    \    end\n    return shuffled_s\nend", "    if s == nil then\n        return nil\n\
    \    end\n    local t = {}\n    for word in s:gmatch(\"%S+\") do\n        local\
    \ antishuffled = {}\n        for ch in word:gmatch(\".\") do\n            antishuffled[#antishuffled\
    \ + 1] = ch\n        end\n        table.sort(antishuffled)\n        t[#t + 1]\
    \ = table.concat(antishuffled)\n    end\n    return table.concat(t, \" \")\nend",
  "    return s:gsub('%S+', function(w)\n        local t = {}\n        for c in w:gmatch('.')\
    \ do\n            table.insert(t, c)\n        end\n        table.sort(t)\n   \
    \     return table.concat(t)\n    end)\nend", "    return s\nend", "  -- your\
    \ code here\nend", "    -- TODO: Implement this function.\nend", "  -- TODO: Fill\
    \ this in\nend", "  -- body\nend", "  -- just a hint: you may use string.gmatch\n\
    \  return s\nend", "    local t = {}\n    local index = 1\n    for word in string.gmatch(s,\
    \ '%w+') do\n        local word = word\n        local letters = {}\n        local\
    \ word_index = 1\n        for letter in string.gmatch(word, '.') do\n        \
    \    letters[word_index] = letter\n            word_index = word_index + 1\n \
    \       end\n        local sorted_letters = table.sort(letters)\n        t[index]\
    \ = table.concat(sorted_letters)\n        index = index + 1\n    end\n    local\
    \ result = table.concat(t, ' ')\n    return result\nend", "    local ret = ''\n\
    \    local function cmp(a, b)\n        return a:byte() < b:byte()\n    end\n \
    \   for i in s:gmatch('%w+') do\n        ret = ret .. table.concat(i:gmatch('.'),\
    \ '', cmp) .. ' '\n    end\n    return ret:sub(1, -2)\nend", "    -- TODO: implement\
    \ the function.\nend", "  local function f(s)\n    local t = {}\n    for i = 1,\
    \ #s do\n      t[i] = s:sub(i, i)\n    end\n    table.sort(t)\n    return table.concat(t)\n\
    \  end\n  local t = {}\n  for w in s:gmatch('%S+') do\n    table.insert(t, f(w))\n\
    \  end\n  return table.concat(t, ' ')\nend", "    local lower_s = s:lower()\n\
    \    local words = {}\n    local new_s = ''\n    local i = 1\n    while i <= #lower_s\
    \ do\n        local space = string.find(lower_s, ' ', i)\n        if space then\n\
    \            words[#words + 1] = lower_s:sub(i, space - 1)\n            new_s\
    \ = new_s .. s:sub(i, space - 1)\n            i = space + 1\n        else\n  \
    \          words[#words + 1] = lower_s:sub(i)\n            new_s = new_s .. s:sub(i)\n\
    \            i = #lower_s + 1\n        end\n    end\n    for i = 1, #words do\n\
    \        local word = words[i]\n        table.sort(word:gmatch('.'))\n       \
    \ for j = 1, #word do\n            new_s = new_s:gsub(word:sub(j, j), word:sub(j,\
    \ j):upper(), 1)\n        end\n    end\n    return new_s\nend", "    local count\
    \ = 0\n    local function _count(s)\n        count = count + 1\n        return\
    \ string.sub(s, -1)\n    end\n    local function _sort(s)\n        return table.concat(table.sort(string.to_array(s)),\
    \ '')\n    end\n    s = string.gsub(s, '%a+', _count)\n    s = string.gsub(s,\
    \ '%a+', _sort)\n    return s\nend", "    function anti_shuffle_word(w)\n    \
    \    return w:gsub('.', function(c) return string.char(string.byte(c)) end)\n\
    \    end\n    return string.gsub(s, '%w+', anti_shuffle_word)\nend", "\tlocal\
    \ words = {}\n\tfor w in s:gmatch('%w+') do\n\t\ttable.insert(words, w)\n\tend\n\
    \tfor i, w in ipairs(words) do\n\t\tlocal chars = {}\n\t\tfor c in w:gmatch('.')\
    \ do\n\t\t\ttable.insert(chars, c)\n\t\tend\n\t\ttable.sort(chars)\n\t\twords[i]\
    \ = table.concat(chars)\n\tend\n\treturn table.concat(words, ' ')\nend", "  return\
    \ s:gsub('%w+', function(w) return w:gsub('.', function(c) return c .. '.' end):gsub('%.',\
    \ ''):gsub('%.', '') end)\nend", "  local words = {}\n  local prev = 1\n  for\
    \ i = 1, #s do\n    if s:sub(i, i) == ' ' then\n      words[#words + 1] = s:sub(prev,\
    \ i - 1)\n      prev = i + 1\n    end\n  end\n  words[#words + 1] = s:sub(prev,\
    \ #s)\n  for i = 1, #words do\n    words[i] = sort_chars(words[i])\n  end\n  return\
    \ table.concat(words, ' ')\nend", "    -- Implement this function!\nend", "  local\
    \ r = {}\n  for word in s:gmatch(\"%S+\") do\n    table.insert(r, word:gsub(\"\
    .\", function(c) return string.format(\"%c%02d\", c, c:byte()) end))\n  end\n\
    \  table.sort(r)\n  for i, word in ipairs(r) do\n    r[i] = word:gsub(\".\", function(c)\
    \ return string.char(tonumber(c:sub(2))) end)\n  end\n  return table.concat(r,\
    \ \" \")\nend", "\tlocal words = {}\n\tfor word in s:gmatch('%S+') do\n\t\ttable.insert(words,\
    \ word)\n\tend\n\tlocal new_sentence = {}\n\tfor i = 1, #words do\n\t\tlocal new_word\
    \ = words[i]:gsub('.', function(char)\n\t\t\treturn char .. '+'\n\t\tend)\n\t\t\
    new_word = new_word:gsub('(.)%+', function(char)\n\t\t\treturn '%%' .. string.byte(char)\n\
    \t\tend)\n\t\tnew_word = string.gsub(new_word, '%%%%+', function(str)\n\t\t\t\
    return string.char(tonumber(str:sub(2)))\n\t\tend)\n\t\ttable.insert(new_sentence,\
    \ new_word)\n\tend\n\treturn table.concat(new_sentence, ' ')\nend", "    -- TODO\n\
    end", "  -- Implement your code here\nend", "    local result = ''\n    for word\
    \ in s:gmatch('%S+') do\n        local sorted_word = table.concat(table.sort(word:split()))\n\
    \        result = result .. sorted_word .. ' '\n    end\n    return result:strip()\n\
    end", "    -- TODO: Your code here.\nend", "    local words = {}\n    for word\
    \ in s:gmatch('%S+') do\n        local chars = {}\n        for char in word:gmatch('.')\
    \ do\n            chars[#chars + 1] = char\n        end\n        table.sort(chars)\n\
    \        words[#words + 1] = table.concat(chars)\n    end\n    return table.concat(words,\
    \ ' ')\nend", "    -- TODO: implement this function\nend", "    local w = s:split('\
    \ ')\n    local ss = ''\n    for i, v in ipairs(w) do\n        ss = ss .. v:sort()\n\
    \        if i ~= #w then\n            ss = ss .. ' '\n        end\n    end\n \
    \   return ss\nend", "    local s = s\n    local i = 1\n    local j = 1\n    local\
    \ new = \"\"\n    local word = {}\n    local ind = {}\n    local indWord = 1\n\
    \    while i <= #s do\n        j = i\n        while j <= #s and s:sub(j, j) ~=\
    \ \" \" do\n            j = j + 1\n        end\n        word[indWord] = s:sub(i,\
    \ j - 1)\n        ind[indWord] = i\n        indWord = indWord + 1\n        i =\
    \ j + 1\n    end\n    for i = 1, #word do\n        new = new .. word[i]:gsub(\"\
    .\", function(c)\n            return c .. \",\"\n        end):gsub(\",\", function(c)\n\
    \            return table.concat(table.sort(c:split(\",\")))\n        end)\n \
    \       if s:sub(ind[i] + #word[i], ind[i] + #word[i]) == \" \" then\n       \
    \     new = new .. \" \"\n        end\n    end\n    return new\nend", "    return\
    \ s\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local f = {}\n\
    \    for i in alphabet:gmatch('.') do\n        f[i] = ''\n    end\n    for i in\
    \ s:gmatch('%a') do\n        f[i] = f[i] .. i\n    end\n    for i in s:gmatch('%A')\
    \ do\n        f[i] = f[i] .. i\n    end\n    local result = ''\n    for i in s:gmatch('%a')\
    \ do\n        result = result .. f[i]\n    end\n    for i in s:gmatch('%A') do\n\
    \        result = result .. f[i]\n    end\n    return result\nend", "    -- Implement\
    \ me!\nend", end, "    local result = ''\n    for word in s:gmatch('%S+') do\n\
    \        result = result .. table.concat(table.sort(word:split(''))) .. ' '\n\
    \    end\n    return result:sub(1, -2)\nend", "    --  Type your code here\n \
    \   local str = \"\"\n    for i in string.gmatch(s, '%S+') do\n        local str2\
    \ = \"\"\n        for j in string.gmatch(i, '.') do\n            str2 = str2 ..\
    \ string.char(string.byte(j))\n        end\n        str = str .. table.concat(string.split(str2,\
    \ ''), '') .. \" \"\n    end\n    return str\nend", "    local words = {}\n  \
    \  local new_s = ''\n    local current_word = ''\n    local s_len = string.len(s)\n\
    \    for i = 1, s_len do\n        local char = string.sub(s, i, i)\n        if\
    \ char == ' ' then\n            if current_word ~= '' then\n                table.insert(words,\
    \ current_word)\n                current_word = ''\n            end\n        \
    \    table.insert(words, ' ')\n        else\n            current_word = current_word\
    \ .. char\n        end\n    end\n    if current_word ~= '' then\n        table.insert(words,\
    \ current_word)\n    end\n    for _, word in ipairs(words) do\n        if word\
    \ == ' ' then\n            new_s = new_s .. ' '\n        else\n            local\
    \ word_len = string.len(word)\n            local chars = {}\n            for i\
    \ = 1, word_len do\n                local char = string.sub(word, i, i)\n    \
    \            table.insert(chars, char)\n            end\n            table.sort(chars)\n\
    \            for _, char in ipairs(chars) do\n                new_s = new_s ..\
    \ char\n            end\n        end\n    end\n    return new_s\nend", "  local\
    \ words = {}\n  for word in s:gmatch('%S+') do\n    table.insert(words, word)\n\
    \  end\n  for i, word in ipairs(words) do\n    local chars = {}\n    for char\
    \ in word:gmatch('.') do\n      table.insert(chars, char)\n    end\n    table.sort(chars)\n\
    \    words[i] = table.concat(chars)\n  end\n  return table.concat(words, ' ')\n\
    end", "    -- insert your code here\nend", "    -- your code goes here\nend",
  "    local result = ''\n    local words = explode(s, ' ')\n    for _, w in ipairs(words)\
    \ do\n        local chars = explode(w, '')\n        table.sort(chars)\n      \
    \  result = result .. table.concat(chars) .. ' '\n    end\n    return result:sub(1,\
    \ -2)\nend", "    -- ADD YOUR CODE HERE\n    return s\nend", "  -- Body\nend",
  "\treturn s\nend", "  local function compare(a, b)\n    return a < b\n  end\n  local\
    \ result = {}\n  for word in s:gmatch('[%w%p%s]+') do\n    table.insert(result,\
    \ word:gsub('%w+', function(s)\n      return table.concat(table.pack(s:byte(1,\
    \ -1)):sort(compare))\n    end))\n  end\n  return table.concat(result)\nend",
  "  -- 1. split string into words separated by spaces\n  -- 2. sort all characters\
    \ in each word, then combine them back into one word\n  -- 3. combine all the\
    \ words with space between each word\n  return table.concat(table.map(s:split(),\
    \ function(w)\n    return table.concat(table.sort(w:split()))\n  end), ' ')\n\
    end", "    -- TODO: Implement this function.\nend", "  s = s:gsub('%a+', function(w)\n\
    \    return w:gsub('.', function(ch)\n      return ch:byte()\n    end)\n  end)\n\
    \  return s\nend", "  -- TODO: implement me!\nend", "  -- write your code here\n\
    end", "    -- If the string is empty, return an empty string.\n    if not s then\n\
    \        return ''\n    end", "    local words = {}\n    for i in string.gmatch(s,\
    \ '%S+') do\n        table.insert(words, i)\n    end\n    local ascii = {}\n \
    \   for i = 1, #words do\n        local word = words[i]\n        ascii[i] = {}\n\
    \        for j = 1, #word do\n            table.insert(ascii[i], word:sub(j, j))\n\
    \        end\n        table.sort(ascii[i])\n    end\n    local result = ''\n \
    \   for i = 1, #words do\n        result = result .. table.concat(ascii[i]) ..\
    \ ' '\n    end\n    return result:sub(1, -2)\nend", "    -- your code here\nend",
  "    local function cmp(c1, c2)\n        return c1:byte() < c2:byte()\n    end\n\
    \    local result = {}\n    for word in s:gmatch('%S+') do\n        local letter\
    \ = {}\n        for c in word:gmatch('.') do\n            table.insert(letter,\
    \ c)\n        end\n        table.sort(letter, cmp)\n        table.insert(result,\
    \ table.concat(letter))\n    end\n    return table.concat(result, ' ')\nend",
  "    local words = {}\n    local len = string.len(s)\n    local i = 1\n    local\
    \ word_start = 1\n    while i <= len do\n        if s:sub(i, i) == ' ' then\n\
    \            table.insert(words, s:sub(word_start, i - 1))\n            word_start\
    \ = i + 1\n        end\n        i = i + 1\n    end\n    table.insert(words, s:sub(word_start,\
    \ len))\n    local s = ''\n    for _, word in ipairs(words) do\n        local\
    \ chars = {}\n        for c in word:gmatch('.') do\n            table.insert(chars,\
    \ c)\n        end\n        table.sort(chars)\n        s = s .. table.concat(chars)\
    \ .. ' '\n    end\n    return s:sub(1, -2)\nend", "    -- return s\n    -- When\
    \ we're trying to solve algorithmic problems, it's good\n    -- to first check\
    \ what are the parts of the input that we need to\n    -- consider. For example,\
    \ if the input is a sentence, we need to\n    -- deal with words and spaces.\n\
    \    --\n    -- See if you can break the problem down into smaller problems.\n\
    \    -- For example, do you need to deal with punctuation?\n    --\n    -- See\
    \ if you can devise a solution for just one word.\n    --\n    -- See if you can\
    \ devise a solution for one word, where the word\n    -- itself is already ordered.\n\
    \    --\n    -- See if you can devise a solution for any word.\n    --\n    --\
    \ Then see if you can combine these solutions to solve the whole problem.\n  \
    \  --\n    -- Remember that if you're stuck, you can always ask others for help.\n\
    \    --\n    -- P.S. If you're doing it right, the \"return s\" line above should\
    \ be\n    -- replaced by the complete solution.\nend", "  local r = ''\n  for\
    \ w in s:gmatch(\"%S+\") do\n    table.sort(w:gmatch(\".\"))\n    r = r .. w\n\
    \  end\n  return r\nend", end, "  -- your code here\nend", "  -- TODO\nend", " \
    \   -- your code goes here!\nend", "    local r = {}\n    for m in string.gmatch(s,\
    \ '%S+') do\n        table.insert(r, m:gsub('.', function(c) return string.format('%03d%s',\
    \ string.byte(c), c) end))\n    end\n    return table.concat(r, ' '):gsub('%d+',\
    \ '')\nend", "    -- your code here\nend", "  local words = {}\n  local blank_count\
    \ = 0\n  local blank_indexes = {}\n  local index = 1\n  local word = {}\n  local\
    \ s_len = #s\n  while index <= s_len do\n    local c = s:sub(index, index)\n \
    \   if c == ' ' then\n      blank_count = blank_count + 1\n      blank_indexes[blank_count]\
    \ = index\n      index = index + 1\n    else\n      while index <= s_len and s:sub(index,\
    \ index) ~= ' ' do\n        word[#word + 1] = s:sub(index, index)\n        index\
    \ = index + 1\n      end\n      table.sort(word)\n      words[#words + 1] = table.concat(word)\n\
    \      word = {}\n    end\n  end\n  table.sort(words)\n  local result = table.concat(words)\n\
    \  if blank_count > 0 then\n    for i = blank_count, 1, -1 do\n      local blank_index\
    \ = blank_indexes[i]\n      local left = result:sub(1, blank_index - 1)\n    \
    \  local right = result:sub(blank_index, #result)\n      result = left .. ' '\
    \ .. right\n    end\n  end\n  return result\nend", "    local t = {}\n    for\
    \ i in s:gmatch('%S+') do\n        table.insert(t, i)\n    end\n    local res\
    \ = ''\n    for i = 1, #t do\n        res = res .. table.concat(split_string(t[i]))\n\
    \        if i ~= #t then\n            res = res .. ' '\n        end\n    end\n\
    \    return res\nend", "\tlocal s = s:gsub(\"%s*\", \"\")\n\tlocal word = \"\"\
    \n\tfor i = 1, #s do\n\t\tword = word .. s:sub(i, i)\n\tend\n\tlocal function\
    \ compare(a, b)\n\t\treturn a < b\n\tend\n\ttable.sort(word, compare)\n\tfor i\
    \ = 1, #s do\n\t\ts = s:gsub(s:sub(i, i), word:sub(i, i), 1)\n\tend\n\treturn\
    \ s\nend", "  local tab = s:split(' ')\n  for i, w in ipairs(tab) do\n    tab[i]\
    \ = w:gsub(\"(.)\", function(a) return a end):lower():gsub(\"(.)\", function(a)\
    \ return a end):lower():sort()\n  end\n  return table.concat(tab, ' ')\nend",
  "  -- TODO\nend", "  local result = {}\n  local array_of_words = string_split(s,\
    \ ' ')\n  for _, value in ipairs(array_of_words) do\n    table.insert(result,\
    \ string_sort(value))\n  end\n  return table_concat(result, ' ')\nend", "    --\
    \ In order to keep the order of the words we replace each single word one\n  \
    \  -- by one.\n    return string.gsub(s, '%S+', function(word)\n        -- The\
    \ replace rule is to replace each word with the sorted string.\n        -- Therefore\
    \ we sort the characters of each word and return the\n        -- ordered string.\n\
    \        local t = {}\n        for i = 1, #word do\n            t[i] = word:sub(i,\
    \ i)\n        end\n        table.sort(t)\n        return table.concat(t)\n   \
    \ end)\nend", "    -- Implement your solution here\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
