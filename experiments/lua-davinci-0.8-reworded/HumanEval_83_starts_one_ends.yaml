name: HumanEval_83_starts_one_ends
language: lua
prompt: "-- Given a positive integer n, return the count of the numbers of n-digit\n\
  -- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = starts_one_ends\n\
  \    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(2), 18)\n \
  \   lu.assertEquals(candidate(3), 180)\n    lu.assertEquals(candidate(4), 1800)\n\
  \    lu.assertEquals(candidate(5), 18000)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local one_cnt = 0\n    local number = 1\n    local exp = 0\n  \
    \  while exp < n do\n        exp = exp + 1\n        number = number * 10\n   \
    \     one_cnt = one_cnt + number - 1\n    end\n    return one_cnt\nend", "  if\
    \ n == 1 then\n    return 2\n  end\n  local count = 10 * starts_one_ends(n - 1)\
    \ - starts_one_ends(n - 2)\n  assert(count >= 0)\n  return count\nend", "   if\
    \ n == 1 then\n      return 2\n   else\n      return starts_one_ends(n-1) + starts_one_ends(n-2)\n\
    \   end\nend", "    local count = 0\n    -- Here we could create a for-loop to\
    \ go through all of the\n    -- combinations, but let's try to find a pattern\n\
    \    if n == 1 then\n        return 10\n    elseif n == 2 then\n        return\
    \ 10 * 9\n    else\n        return 10 * 9 * 8 ^ (n - 2)\n    end\nend", "   if\
    \ n == 1 then\n      return 1\n   elseif n == 2 then\n      return 3\n   else\n\
    \      local last = 3\n      local current = 5\n      for i = 3, n do\n      \
    \   local tmp = current\n         current = current + last\n         last = tmp\n\
    \      end\n      return current\n   end\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    return 9 * math.pow(10, n - 2)\nend", "  local count = 0\n \
    \ local new_ones = 1\n  local old_ones = 0\n  local temp", "    if n == 1 then\n\
    \        return 2\n    end\n    local count = 0\n    for d = 0, 9 do\n       \
    \ count = count + starts_one_ends(n - 1)\n    end\n    if n > 2 then\n       \
    \ count = count + starts_one_ends(n - 2)\n    end\n    return count\nend", " \
    \ if n == 1 then\n    return 1\n  end\n  local c = 9\n  for i = 2, n - 1 do\n\
    \    c = c * 10\n  end\n  return c * 2\nend", "    if n < 2 then\n        return\
    \ n\n    end\n    -- For a n-digit number, the first digit can be any of the 10,\
    \ the last\n    -- digit can be any of the 10, but both the first and last digit\
    \ cannot be\n    -- 1 at the same time.\n    -- Using a recurrence relation:\n\
    \    --   f(n) = 10f(n-1) - 9f(n-2)\n    local a, b = 2, 10\n    for i = 2, n\
    \ - 1 do\n        local c = 10 * b - 9 * a\n        a, b = b, c\n    end\n   \
    \ return b\nend", "  local dp = setmetatable({0, 9, 9}, {__index = function(t,\
    \ k)\n    if k < 0 then\n      return 0\n    end\n    local v = t[k - 1] * 9 +\
    \ (t[k - 2] or 0)\n    t[k] = v\n    return v\n  end})\n  return dp[n]\nend",
  "   local start_ones = 9*10^(n-1)\n   local end_ones = 9*10^(n-1)\n   return start_ones\
    \ + end_ones\nend", "    return 9 * 10 ^ (n - 1)\nend", "  local start_one = n\
    \ - 1\n  local end_one = n - 1\n  return start_one + end_one\nend", "    if n\
    \ == 1 then\n        return 2\n    end\n    local dp = {2, 1}\n    for i = 2,\
    \ n do\n        dp[i] = dp[i - 1] * 9 + dp[i - 2]\n    end\n    return dp[n]\n\
    end", "  if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 6\n\
    \  end\n  if n == 3 then\n    return 10\n  end\n  local a = {2, 6, 10}\n  for\
    \ i = 4, n do\n    a[i] = a[i - 1] + a[i - 2]\n  end\n  return a[n]\nend", " \
    \ if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 10\n  end\n\
    \  return (n-1) * 9 * math.pow(10, n-2)\nend", "   local function ends_one(n)\n\
    \      if n == 1 then\n         return 2\n      elseif n == 2 then\n         return\
    \ 3\n      else\n         local f = math.floor(n / 2)\n         local x = ends_one(f)\n\
    \         local y = math.pow(10, f) - 1\n         local z = math.pow(10, n - 1)\n\
    \         return x * y + z\n      end\n   end\n   local f = math.floor(n / 2)\n\
    \   local x = ends_one(f)\n   local y = math.pow(10, f) - 1\n   local z = math.pow(10,\
    \ n - 1)\n   return x * y + z\nend", "  -- n-digit positive integers have n-1\
    \ digits after the leading 1.\n  -- Counting the leading 1, that's 1 + D_n-1(1),\
    \ where D_n(1) is\n  -- the count of n-digit positive integers that start with\
    \ 1.\n  -- Similarly, the count of n-digit positive integers that end with 1\n\
    \  -- is D_n-1(1).\n  if n == 1 then\n    return 2\n  else\n    return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 1)\n  end\nend", "  local sum = 0\n  local inc =\
    \ n\n  local dec = n\n  while inc > 0 do\n    sum = sum + inc\n    inc = inc -\
    \ 1\n  end\n  while dec > 1 do\n    sum = sum + dec\n    dec = dec - 1\n  end\n\
    \  return sum\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
