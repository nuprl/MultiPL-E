name: HumanEval_83_starts_one_ends
language: lua
prompt: "-- Given a positive integer n, return the count of the numbers of n-digit\n\
  -- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = starts_one_ends\n\
  \    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(2), 18)\n \
  \   lu.assertEquals(candidate(3), 180)\n    lu.assertEquals(candidate(4), 1800)\n\
  \    lu.assertEquals(candidate(5), 18000)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local one_cnt = 0\n    local number = 1\n    local exp = 0\n  \
    \  while exp < n do\n        exp = exp + 1\n        number = number * 10\n   \
    \     one_cnt = one_cnt + number - 1\n    end\n    return one_cnt\nend", "  if\
    \ n == 1 then\n    return 2\n  end\n  local count = 10 * starts_one_ends(n - 1)\
    \ - starts_one_ends(n - 2)\n  assert(count >= 0)\n  return count\nend", "   if\
    \ n == 1 then\n      return 2\n   else\n      return starts_one_ends(n-1) + starts_one_ends(n-2)\n\
    \   end\nend", "    local count = 0\n    -- Here we could create a for-loop to\
    \ go through all of the\n    -- combinations, but let's try to find a pattern\n\
    \    if n == 1 then\n        return 10\n    elseif n == 2 then\n        return\
    \ 10 * 9\n    else\n        return 10 * 9 * 8 ^ (n - 2)\n    end\nend", "   if\
    \ n == 1 then\n      return 1\n   elseif n == 2 then\n      return 3\n   else\n\
    \      local last = 3\n      local current = 5\n      for i = 3, n do\n      \
    \   local tmp = current\n         current = current + last\n         last = tmp\n\
    \      end\n      return current\n   end\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    return 9 * math.pow(10, n - 2)\nend", "  local count = 0\n \
    \ local new_ones = 1\n  local old_ones = 0\n  local temp", "    if n == 1 then\n\
    \        return 2\n    end\n    local count = 0\n    for d = 0, 9 do\n       \
    \ count = count + starts_one_ends(n - 1)\n    end\n    if n > 2 then\n       \
    \ count = count + starts_one_ends(n - 2)\n    end\n    return count\nend", " \
    \ if n == 1 then\n    return 1\n  end\n  local c = 9\n  for i = 2, n - 1 do\n\
    \    c = c * 10\n  end\n  return c * 2\nend", "    if n < 2 then\n        return\
    \ n\n    end\n    -- For a n-digit number, the first digit can be any of the 10,\
    \ the last\n    -- digit can be any of the 10, but both the first and last digit\
    \ cannot be\n    -- 1 at the same time.\n    -- Using a recurrence relation:\n\
    \    --   f(n) = 10f(n-1) - 9f(n-2)\n    local a, b = 2, 10\n    for i = 2, n\
    \ - 1 do\n        local c = 10 * b - 9 * a\n        a, b = b, c\n    end\n   \
    \ return b\nend", "  local dp = setmetatable({0, 9, 9}, {__index = function(t,\
    \ k)\n    if k < 0 then\n      return 0\n    end\n    local v = t[k - 1] * 9 +\
    \ (t[k - 2] or 0)\n    t[k] = v\n    return v\n  end})\n  return dp[n]\nend",
  "   local start_ones = 9*10^(n-1)\n   local end_ones = 9*10^(n-1)\n   return start_ones\
    \ + end_ones\nend", "    return 9 * 10 ^ (n - 1)\nend", "  local start_one = n\
    \ - 1\n  local end_one = n - 1\n  return start_one + end_one\nend", "    if n\
    \ == 1 then\n        return 2\n    end\n    local dp = {2, 1}\n    for i = 2,\
    \ n do\n        dp[i] = dp[i - 1] * 9 + dp[i - 2]\n    end\n    return dp[n]\n\
    end", "  if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 6\n\
    \  end\n  if n == 3 then\n    return 10\n  end\n  local a = {2, 6, 10}\n  for\
    \ i = 4, n do\n    a[i] = a[i - 1] + a[i - 2]\n  end\n  return a[n]\nend", " \
    \ if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 10\n  end\n\
    \  return (n-1) * 9 * math.pow(10, n-2)\nend", "   local function ends_one(n)\n\
    \      if n == 1 then\n         return 2\n      elseif n == 2 then\n         return\
    \ 3\n      else\n         local f = math.floor(n / 2)\n         local x = ends_one(f)\n\
    \         local y = math.pow(10, f) - 1\n         local z = math.pow(10, n - 1)\n\
    \         return x * y + z\n      end\n   end\n   local f = math.floor(n / 2)\n\
    \   local x = ends_one(f)\n   local y = math.pow(10, f) - 1\n   local z = math.pow(10,\
    \ n - 1)\n   return x * y + z\nend", "  -- n-digit positive integers have n-1\
    \ digits after the leading 1.\n  -- Counting the leading 1, that's 1 + D_n-1(1),\
    \ where D_n(1) is\n  -- the count of n-digit positive integers that start with\
    \ 1.\n  -- Similarly, the count of n-digit positive integers that end with 1\n\
    \  -- is D_n-1(1).\n  if n == 1 then\n    return 2\n  else\n    return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 1)\n  end\nend", "  local sum = 0\n  local inc =\
    \ n\n  local dec = n\n  while inc > 0 do\n    sum = sum + inc\n    inc = inc -\
    \ 1\n  end\n  while dec > 1 do\n    sum = sum + dec\n    dec = dec - 1\n  end\n\
    \  return sum\nend", "  if n == 1 then\n    return 2\n  end\n  return (9 * (9^(n-2))\
    \ + 1) * 2\nend", "    if n < 1 then\n        return 0\n    end\n    if n == 1\
    \ then\n        return 1\n    end\n    local d = digits(n)\n    local last = d[d.n]\n\
    \    d.n = d.n - 1\n    if last == 1 then\n        return count_integer_digit_permutations(d)\n\
    \    else\n        d[d.n + 1] = 0\n        local m = count_integer_digit_permutations(d)\n\
    \        d[d.n + 1] = 1\n        return m + count_integer_digit_permutations(d)\n\
    \    end\nend", "  return (n - 1) * 9 ^ (n - 1)\nend", "    local count = 0\n\
    \    for i = 1, n do\n        count = count + 9 * 10 ^ (i - 1)\n    end\n    count\
    \ = count + 9 * 10 ^ (n - 1)\n    return count\nend", "    if n == 1 then\n  \
    \      return 2\n    end\n    local n2 = n - 1\n    local c1 = 1\n    local c2\
    \ = 1\n    local c3 = 0\n    for i = 1, n2 do\n        c3 = c1 + c2\n        c1\
    \ = c2\n        c2 = c3\n    end\n    return c1 + c2\nend", "  if n == 1 then\n\
    \    return 2\n  end\n  if n == 2 then\n    return 10\n  end\n  return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2) * 9\nend", "  local count = 0\n  local f = 1\n\
    \  for i = 1, n do\n    f = f * 10\n    count = count + (f - 1)\n  end\n  count\
    \ = count * 2\n  count = count - n\n  return count\nend", "  local cache = {}\n\
    \  local function _starts_one_ends(n)\n    if n == 1 then\n      return 2\n  \
    \  elseif n == 2 then\n      return 3\n    elseif cache[n] then\n      return\
    \ cache[n]\n    else\n      cache[n] = starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)\n      return cache[n]\n    end\n  end\n  return _starts_one_ends(n)\n\
    end", "    if n == 1 then\n        return 10\n    end\n    return n * 9 * 9 ^\
    \ (n - 2)\nend", "  if n == 1 then\n    return 3\n  end\n  local a, b = starts_one_ends(n\
    \ - 1), 1\n  for i = 1, n - 2 do\n    a, b = a + b, a\n  end\n  return 2 * a +\
    \ b\nend", "    if n == 1 then\n        return 2\n    end\n    local start_ends\
    \ = 0\n    for i = 1, n do\n        start_ends = start_ends + math.pow(10, i-1)\n\
    \    end\n    return 2 * start_ends\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    if n == 2 then\n        return 6\n    end\n    return 2 * starts_one_ends(n\
    \ - 1) + (n - 2) * starts_one_ends(n - 2)\nend", "   local r = 0\n   local start\
    \ = 0\n   local ten = 10\n   while n > 0 do\n      r = r + ten - 1\n      ten\
    \ = ten * 10\n      n = n - 1\n   end\n   return r\nend", "   local sum = 9\n\
    \   local dec = 10\n   local inc = 1\n   while n > 1 do\n      sum = sum * 10\
    \ + dec * inc\n      dec = dec * 10\n      inc = inc * 10\n      n = n - 1\n \
    \  end\n   return sum\nend", "  local total = 0\n  for _ = 1, n - 1 do\n    total\
    \ = total + 9 * 10 ^ (_ - 1)\n  end\n  return 10 * total + 2\nend", "  local sum\
    \ = 0\n  local n1 = 9*(10^(n-1))\n  local n2 = 9*(10^(n-2))\n  for i = 1, n do\n\
    \    sum = sum + n1 + n2\n    n1 = n1 / 10\n    n2 = n2 / 10\n  end\n  return\
    \ sum\nend", "    return n * 9 * 8\nend", "  if n <= 1 then\n    return 0\n  end\n\
    \  local digits = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n  digits[1] = 2\n  for i = 2,\
    \ n do\n    digits[i] = 0\n    for j = 0, 9 do\n      if j ~= 1 then\n       \
    \ digits[i] = digits[i] + digits[i - 1]\n      end\n    end\n    digits[i] = digits[i]\
    \ + 1\n  end\n  return digits[n]\nend", "  if n == 1 then\n    return 2\n  end\n\
    \  local M = math.modf(n / 2)\n  local res = 1 + 9\n  for i = 2, M do\n    res\
    \ = res * 10\n  end\n  if M == 0 then\n    return res\n  end\n  local L = n -\
    \ M * 2\n  if L == 0 then\n    return res + 9\n  end\n  for i = 1, L do\n    res\
    \ = res * 10\n  end\n  return res + 9\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    local sum = 2\n    for _ = 1, n - 1 do\n        sum = 2 * sum\
    \ + 2\n    end\n    return sum\nend", "    local one = n - 1\n    local nine =\
    \ n - 1\n    local res = 0\n    while one > 0 do\n        res = res + power_of_10(one)\
    \ + power_of_10(nine)\n        one = one - 1\n        nine = nine - 1\n    end\n\
    \    return res\nend", "  local count = 0\n  if n == 1 then\n    count = 10\n\
    \  elseif n == 2 then\n    count = 28\n  else\n    count = 10 * (starts_one_ends(n\
    \ - 1) + ends_one_ends(n - 1))\n    count = count + 20 * (n - 2) * ends_one_ends(n\
    \ - 2)\n  end\n  return count\nend", "  if n < 1 then\n    return 0\n  end\n \
    \ local dp = {}\n  for i = 1, 9 do\n    dp[i] = 1\n  end\n  for _ = 2, n do\n\
    \    local tmp = {}\n    for i = 1, 9 do\n      tmp[i] = 0\n      if i == 1 then\n\
    \        tmp[i] = dp[i] + 1\n      else\n        tmp[i] = dp[i] + tmp[i - 1]\n\
    \      end\n    end\n    dp = tmp\n  end\n  return dp[9]\nend", "    if n <= 0\
    \ then\n        return 0\n    end\n    local f = 2\n    local t = 3\n    local\
    \ i = 2\n    while i < n do\n        local tmp = t\n        t = f + t\n      \
    \  f = tmp\n        i = i + 1\n    end\n    return t + f\nend", "    local n =\
    \ n - 1\n    local numbers = n\n    while n > 0 do\n        numbers = numbers\
    \ + n\n        n = n - 1\n    end\n    return numbers\nend", "   assert(n > 0)\n\
    \   if n == 1 then\n      return 2\n   end\n   return 1 + math.pow(10, n - 1)\
    \ + 9 * starts_one_ends(n - 1)\nend", "    local m = \"1\" .. string.rep(\"0\"\
    , n - 1)\n    local a = tonumber(m)\n    local b = tonumber(string.reverse(m))\n\
    \    local c = string.format(\"%d\", b - a + 1)\n    return c\nend", "  local\
    \ p = 2 -- the number of n-digit positive integers that start with 1\n  local\
    \ q = 9 -- the number of n-digit positive integers that end with 1\n  for k =\
    \ 1, n - 1 do\n    p = 2 * p\n    q = 10 * q + 9\n  end\n  return p + q\nend",
  "  return (n == 1) and 1 or\n    ((n-1)*(2^(n-2)) + (n-1)*(2^(n-2)-1))\nend", " \
    \ if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 12\n  end\n\
    \  local res = 2 * starts_one_ends(n - 1)\n  res = res + 8 * starts_one_ends(n\
    \ - 2)\n  return res\nend", "    if n == 1 then\n        return 2\n    end\n \
    \   local m = 10 ^ (n - 1)\n    local d = 10 ^ (n - 2)\n    local c = 0\n    for\
    \ i = m, 9 * m do\n        local j = i / d\n        if math.floor(j) % 10 == 1\
    \ then\n            c = c + 1\n        end\n    end\n    return c * 10 + 2\nend",
  "  return 9*10^(n-2) + 10^(n-1)\nend", "  if n == 1 then\n    return 2\n  end\n\
    \  local val = starts_one_ends(n - 1)\n  return val + 10 * val\nend", "  local\
    \ n10, n100 = n * 10, n * 100\n  local max = n10 - 1\n  local total = 0\n  for\
    \ i = n100, max do\n    local s = tostring(i)\n    local first, last = s:sub(1,\
    \ 1), s:sub(-1)\n    if first == '1' or last == '1' then\n      total = total\
    \ + 1\n    end\n  end\n  return total\nend", "    if n == 1 then\n        return\
    \ 1\n    end\n    local c = 1\n    local x = math.floor(math.pow(10, n-1))\n \
    \   local y = math.floor(math.pow(10, n))\n    while x < y do\n        x = x +\
    \ 1\n        if math.floor(x/10) == 1 or math.fmod(x, 10) == 1 then\n        \
    \    c = c + 1\n        end\n    end\n    return c\nend", "  if n == 1 then\n\
    \    return 1\n  end\n  local dp = {1, 1}\n  for i = 2, n do\n    dp[i] = dp[i\
    \ - 1] + 9 * 10 ^ (i - 2)\n  end\n  return dp[n] * 2\nend", "  if n == 1 then\n\
    \    return 2\n  end\n  local starts_one_ends_cache = {}\n  return auxiliary.starts_one_ends(n,starts_one_ends_cache)\n\
    end", "    if n == 1 then\n        return 2\n    end\n    local count = 2\n  \
    \  for i = 1, n - 1 do\n        count = count + math.pow(10, i)\n    end\n   \
    \ return count\nend", "    -- One digit numbers:\n    if n == 1 then\n       \
    \ return 1\n    end", "    if n == 1 then\n        return 10\n    end\n    local\
    \ sum = 0\n    for i = 1, 10 ^ (n - 1) do\n        sum = sum + (i + 1)\n    end\n\
    \    return sum\nend", "    local start = n - 1\n    local ends = 0\n    local\
    \ count = 0\n    while start > 0 do\n        ends = ends + count * start * 9\n\
    \        count = count + 1\n        start = start - 1\n    end\n    return ends\n\
    end", "  -- We have a choice for the first digit, either 0 or 1. If we choose\
    \ 0,\n  -- then the last digit can be any one of 10. If we choose 1, then the\
    \ last\n  -- digit can be any one of 9.\n  return (10^(n-1)) + (9*(10^(n-2)))\n\
    end", "    local count = 0\n    local pow = 10\n    while n > 0 do\n        local\
    \ m = n - 1\n        count = count + pow + m * pow / 10\n        pow = pow * 10\n\
    \        n = n - 1\n    end\n    return count\nend", "  if n == 1 then\n    return\
    \ 2\n  end\n  if n == 2 then\n    return 3\n  end\n  if n == 3 then\n    return\
    \ 7\n  end\n  local ways = math.pow(10, n - 1)\n  -- suffix_without_one: number\
    \ of way for suffixes of length (n - 2) that\n  --                     do not\
    \ contain 1\n  local suffix_without_one = starts_one_ends(n - 2)\n  -- suffix_with_one:\
    \ number of way for suffixes of length (n - 2) that\n  --                  do\
    \ contain 1\n  local suffix_with_one = starts_one_ends(n - 1)\n  return ways +\
    \ suffix_without_one + suffix_with_one\nend", "    if n == 1 then\n        return\
    \ 10\n    end\n    local ends = 9\n    local total = ends\n    for i = 2, n -\
    \ 1 do\n        ends = ends * 9\n        total = total + ends\n    end\n    return\
    \ total + ends\nend", "  if n == 1 then\n    return 2\n  end\n  return starts_one_ends(n\
    \ - 1) + 8 * starts_one_ends(n - 2)\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    if n == 2 then\n        return 4\n    end\n    local dp = {[0]\
    \ = 2, [1] = 4}\n    for i = 2, n - 1 do\n        dp[i] = dp[i - 1] + dp[i - 2]\n\
    \    end\n    return dp[n - 1] * 2\nend", "  local function _starts_one_ends(n,\
    \ last)\n    if n == 0 then\n      return 1\n    elseif n == 1 then\n      return\
    \ last and 0 or 1\n    else\n      local r = _starts_one_ends(n - 1, false)\n\
    \      if last then\n        r = r + _starts_one_ends(n - 1, true)\n      end\n\
    \      return r\n    end\n  end\n  return _starts_one_ends(n, false)\nend", " \
    \   local result = 0\n    local res = {0, 1}\n    local i = 0\n    while i < n\
    \ do\n        i = i + 1\n        local new = res[2] * 9 + res[1]\n        res[1]\
    \ = res[2]\n        res[2] = new\n    end\n    return res[2] + res[1]\nend", " \
    \ local starts_w_one = 0\n  local ends_w_one = 0\n  for i = 1, n do\n    starts_w_one\
    \ = starts_w_one + 1\n    ends_w_one = ends_w_one + 10 ^ (i - 1)\n  end\n  return\
    \ starts_w_one + ends_w_one\nend", "  if n == 1 then\n    return 2\n  end\n  local\
    \ m = 10^(n-1)\n  return (9 * m) + (m-1)\nend", "  local memo = {}\n  memo[0]\
    \ = 1\n  memo[1] = 2\n  for i = 2, n do\n    memo[i] = memo[i - 1] + memo[i -\
    \ 2]\n  end\n  return memo[n]\nend", "  local a = {0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0}\n  a[1] = 1\n  for i = 2, n do\n    for j = 0, 9 do\n      if j == 1 then\n\
    \        a[j] = a[j] + 1\n      else\n        a[j] = a[j] + a[1]\n      end\n\
    \    end\n  end\n  return a[1]\nend", "  local count = 0\n  for i = 1, 9 do\n\
    \    count = count + one_ends(n - 1)\n  end\n  return count\nend", "    local\
    \ function ends_one(n)\n        if n == 1 then\n            return 1\n       \
    \ else\n            return 9 * math.pow(10, n - 2)\n        end\n    end", " \
    \   if n == 1 then\n        return 1\n    end\n    return 2 * (10 ^ (n - 1)) +\
    \ starts_one_ends(n - 1)\nend", "  if n == 1 then\n    return 2\n  end\n  local\
    \ count = 0\n  local first = 1 * (10 ^ (n - 1))\n  local last = (10 ^ n) - 1\n\
    \  count = count + (last - first + 1)\n  count = count + starts_one_ends(n - 1)\n\
    \  return count\nend", "  local function _starts_one_ends(m)\n    if m <= 1 then\n\
    \      return 1\n    end\n    local count = 1\n    for i = 1, m - 1 do\n     \
    \ count = count + _starts_one_ends(i)\n    end\n    return count\n  end\n  return\
    \ _starts_one_ends(n)\nend", "   if n == 1 then\n      return 2\n   else\n   \
    \   return 9*starts_one_ends(n-1) + 10^(n-1)\n   end\nend", "   if n == 1 then\n\
    \      return 2\n   else\n      return math.pow(10, n - 1) + starts_one_ends(n\
    \ - 1)\n   end\nend", "  if n == 1 then\n    return 1\n  end\n  local num, dec\
    \ = math.modf(n/2)\n  num = math.floor(num)\n  local first, last\n  if dec ==\
    \ 0 then\n    first = 11\n    last = 12\n  else\n    first = 0\n    last = 1\n\
    \  end\n  return math.pow(2, num - 1) * first + math.pow(2, num) * last\nend",
  "    if n == 1 then\n        return 2\n    end\n    return 10 ^ (n - 1) + starts_one_ends(n\
    \ - 1)\nend", "    if n == 1 then\n        return 2\n    end\n    if n == 2 then\n\
    \        return 10\n    end\n    local ending_one = starts_one_ends(n - 1)\n \
    \   local starting_one = math.pow(10, n - 1) - math.pow(10, n - 2)\n    return\
    \ starting_one + ending_one\nend", "  local one_ends = 0\n  local not_one_ends\
    \ = 0\n  if n == 1 then\n    return 1\n  end\n  for k = 1, n - 1 do\n    not_one_ends\
    \ = one_ends\n    one_ends = not_one_ends * 10 + 9 ^ k\n  end\n  return one_ends\
    \ + not_one_ends + 1\nend", "    if n == 1 then\n        return 2\n    end\n \
    \   if n == 2 then\n        return 9\n    end\n    return starts_one_ends(n -\
    \ 1) + 9 * A066295.a(n - 1)\nend", "  if n == 1 then\n    return 1\n  end\n  return\
    \ (10^(n-1) - 10^(n-2)) * 9 + 10^(n-2)\nend", "  local ends = ends_one(n)\n  local\
    \ starts = starts_one(n)\n  if n == 1 then\n    return ends\n  else\n    return\
    \ ends + starts\n  end\nend", "    -- For example, with n=4:\n    -- 1xxx and\
    \ xx1x are OK.\n    -- 11xx, x11x, and xx11 are not OK.\n    -- 111x, x111, and\
    \ xx11 are OK.\n    -- 1111 is not OK.\n    -- So we can construct the sequence:\n\
    \    -- _[0] = 1\n    -- _[1] = 1\n    -- _[2] = 2\n    -- _[3] = 4\n    -- _[4]\
    \ = 7\n    -- So the sequence forms a binary tree.\n    -- If a node is a leaf,\
    \ we count it.\n    -- If a node is not a leaf, we count the left and right children\
    \ as\n    -- separate branches.\n    local count = 0\n    local root = {\n   \
    \     children = { nil, nil }\n    }\n    local queue = Queue.new()\n    Queue.push(queue,\
    \ root)\n    for _ = 1, n do\n        local size = Queue.size(queue)\n       \
    \ for _ = 1, size do\n            local node = Queue.pop(queue)\n            if\
    \ #node.children < 2 then\n                local left = {\n                  \
    \  children = { nil, nil }\n                }\n                local right = {\n\
    \                    children = { nil, nil }\n                }\n            \
    \    node.children[1] = left\n                node.children[2] = right\n     \
    \           Queue.push(queue, left)\n                Queue.push(queue, right)\n\
    \            else\n                count = count + 1\n            end\n      \
    \  end\n    end\n    return count\nend", "   if n == 1 then\n      return 2\n\
    \   else\n      return 9 * 9 * (n - 1)\n   end\nend", "    if n == 1 then\n  \
    \      return 2\n    end\n    local start = 1\n    local mid = 9\n    local end\
    \ = 10\n    local s = 0\n    for i = 2, n - 1 do\n        s = (start + mid + end)\
    \ % 1000000007\n        start = mid\n        mid = end\n        end = s\n    end\n\
    \    return (start + end) % 1000000007\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    return starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend",
  "   if n == 1 then\n      return 1\n   elseif n == 2 then\n      return 10\n   else\n\
    \      return starts_one_ends(n-1) + 9*n\n   end\nend", "    if n == 1 then\n\
    \        return 2\n    end\n    if n == 2 then\n        return 4\n    end\n  \
    \  return starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend", "    local total\
    \ = 0\n    local one = 1\n    local ten = 1\n    local digit = 1\n    for _ =\
    \ 1, n - 1 do\n        digit = (digit * 10) + 1\n        ten = ten * 10\n    \
    \    one = one + digit\n    end\n    total = one + ten\n    return total\nend",
  "   if n == 1 then\n      return 1\n   elseif n == 2 then\n      return 10\n   else\n\
    \      return 10 * starts_one_ends(n - 1) + 9\n   end\nend", "  local dp = {}\n\
    \  -- dp[i][j] is the count of i-digit numbers that start (j = 0) or end\n  --\
    \ (j = 1) with 1.\n  for i = 1, n do\n    dp[i] = {}\n    for j = 0, 1 do\n  \
    \    dp[i][j] = 0\n    end\n  end\n  dp[1][0] = 1\n  dp[1][1] = 1\n  for i = 2,\
    \ n do\n    dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n    dp[i][1] = dp[i - 1][0]\n\
    \  end\n  return dp[n][0] + dp[n][1]\nend", "   -- n = n - 1\n   -- return (math.floor(10\
    \ ^ n / 9) - math.floor(10 ^ (n-1) / 9))\n   --    + math.floor(10 ^ n / 9)\n\
    \   return math.floor(10 ^ (n-1) / 9) * 2 + 1\nend", "    if n == 1 then\n   \
    \     return 2\n    end\n    return (fib_last_digit(n + 1) - 1) % 10\nend", " \
    \ return (10^(n-1))\nend", "  if n == 1 then\n    return 1\n  end\n  return math.pow(2,\
    \ n - 1) + starts_one_ends(n - 1)\nend", "  if n == 1 then\n    return 2\n  end\n\
    \  local res = 0\n  for i = 1, n do\n    res = res + 9*10^(i-1)\n  end\n  return\
    \ res + 1\nend", "    --[[\n    # 0 - 9 are 1 digit numbers that begin with 1.\
    \ These contribute 1 to\n    # the number of numbers whose units digit is 1.\n\
    \    #\n    # 10 - 99 are 2 digit numbers that end with 1. These contribute 10\
    \ to\n    # the number of numbers whose units digit is 1.\n    #\n    # 100 -\
    \ 999 are 3 digit numbers that start with 1. These contribute 100\n    # to the\
    \ number of numbers whose units digit is 1.\n    #\n    # 1000 - 9999 are 4 digit\
    \ numbers that end with 1. These contribute 1000\n    # to the number of numbers\
    \ whose units digit is 1.\n    #\n    # 10000 - 99999 are 5 digit numbers that\
    \ start with 1. These contribute\n    # 10000 to the number of numbers whose units\
    \ digit is 1.\n    #\n    # and so on ...\n    #\n    # The formulas for n-digit\
    \ numbers whose first digit is 1 and whose\n    # last digit is 1 are\n    #\n\
    \    #   a(n) = 1 + 10*a(n-2) = 1 + 10*(1 + 10*a(n-4)) = ...\n    #\n    # and\n\
    \    #\n    #   b(n) = 10^(n-1) + 10*b(n-2) = 10^(n-1) + 10*(10^(n-3) + 10*b(n-4))\
    \ = ...\n    #\n    # respectively.\n    #\n    # Now, the required number is\
    \ b(n) - a(n) = (10^n - 1) + 10*(b(n-2) - a(n-2))\n    --]]\n    if n <= 1 then\n\
    \        return 0\n    elseif n == 2 then\n        return 10\n    elseif n ==\
    \ 3 then\n        return 90\n    else\n        return 99 + 10 * (starts_one_ends(n\
    \ - 2) - starts_one_ends(n - 4))\n    end\nend", "  if n == 1 then\n    return\
    \ 10\n  end\n  if n == 2 then\n    return 9\n  end\n  local q, r = divmod(n -\
    \ 2, 3)\n  return (q + 1) * 10 + r * 3\nend", "  local r = 1 -- 1..9\n  local\
    \ p = 9 -- 10..99\n  local q = 8 -- 00..99, 10..19\n  local s = 9 -- 10..19, 90..99\n\
    \  local m = 10^(n-1)\n  local ret = r + p + s\n  while m > 1 do\n    r = r +\
    \ 10*p + 9*q\n    p = 10*p + 8*q\n    q = 9*q\n    s = 10*s + 9*q\n    m = m/10\n\
    \    ret = ret + r + p + s\n  end\n  return ret\nend", "    local sum = 1\n  \
    \  local last_sum = 0\n    for i = 1, n do\n        local tmp = last_sum\n   \
    \     last_sum = sum\n        sum = (9 * sum + 9 * tmp)\n    end\n    return sum\n\
    end", "    local count = 0\n    if n == 1 then\n        count = 2\n    elseif\
    \ n == 2 then\n        count = 20\n    else\n        count = 9 * 10 ^ (n - 2)\n\
    \    end\n    return count\nend", "  if n == 1 then\n    return 10\n  end\n  local\
    \ num = starts_one_ends(n - 1) * 9\n  return num + 2 * (10 ^ (n - 1))\nend", " \
    \   if n <= 1 then\n        return 0\n    end\n    return (9 * 10 ^ (n - 2)) +\
    \ starts_one_ends(n - 1)\nend", "   local count = 0\n   for i = 0, 9 do\n    \
    \  count = count + pow(10, n - 1)\n   end\n   return count\nend", "  local count\
    \ = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n  for i = 2, n do\n    local new_count = {0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    for d = 0, 9 do\n      local total = 0\n   \
    \   for i = 0, d do\n        total = total + count[i + 1]\n      end\n      new_count[d\
    \ + 1] = total\n    end\n    count = new_count\n  end\n  return count[1]\nend",
  "  local values = {}\n  local count = 0\n  local i = 1\n  while i <= n do\n    count\
    \ = count + 1\n    values[i] = count\n    i = i + 1\n  end\n  while i <= n * 2\
    \ do\n    count = count + values[n * 2 - i + 1]\n    values[i] = count\n    i\
    \ = i + 1\n  end\n  return count\nend", "  if n == 1 then\n    return 2\n  end\n\
    \  if n == 2 then\n    return 9\n  end\n  if n == 3 then\n    return 45\n  end\n\
    \  local prev = 9\n  local next = 45\n  for _ = 4, n do\n    local tmp = next\n\
    \    next = 9 * next + prev\n    prev = tmp\n  end\n  return next\nend", "   local\
    \ count = 0\n   local count_digs = { }\n   local max_digs = { }\n   max_digs[0]\
    \ = 1\n   count_digs[0] = 1\n   max_digs[1] = 10\n   count_digs[1] = 9\n   for\
    \ i = 2, n do\n      local max_dig_count = count_digs[i - 1] * 10\n      local\
    \ max_dig_digits = max_digs[i - 1] * 10\n      local min_dig_count = max_digs[i\
    \ - 2]\n      local min_dig_digits = count_digs[i - 2]\n      local max_last_dig_count\
    \ = 9 * max_dig_count\n      local max_last_dig_digits = max_dig_digits + max_last_dig_count\n\
    \      local min_last_dig_count = max_dig_count\n      local min_last_dig_digits\
    \ = max_dig_digits + min_last_dig_count\n      local min_first_dig_count = min_dig_count\n\
    \      local min_first_dig_digits = min_dig_digits + min_first_dig_count\n   \
    \   local max_first_dig_count = 9 * min_dig_count\n      local max_first_dig_digits\
    \ = min_dig_digits + max_first_dig_count\n      local min_first_max_last_count\
    \ = min_first_dig_count + max_last_dig_count\n      local min_first_max_last_digits\
    \ = min_first_dig_digits + max_last_dig_digits\n      local max_first_min_last_count\
    \ = max_first_dig_count + min_last_dig_count\n      local max_first_min_last_digits\
    \ = max_first_dig_digits + min_last_dig_digits\n      max_digs[i] = min_first_max_last_digits\n\
    \      count_digs[i] = min_first_max_last_count\n      if max_first_min_last_digits\
    \ <= max_digs[i] then\n         max_", "    local total = 0\n    local powers_of_ten\
    \ = 1\n    for i = 2, n do\n        powers_of_ten = powers_of_ten * 10\n    end\n\
    \    for i = 1, n do\n        if i == 1 then\n            total = total + 10\n\
    \        elseif i == n then\n            total = total + powers_of_ten\n     \
    \   else\n            total = total + 9 * powers_of_ten\n        end\n       \
    \ powers_of_ten = powers_of_ten / 10\n    end\n    return total\nend", "  if n\
    \ == 1 then\n    return 2\n  end\n  local res = 9 * starts_one_ends(n - 1)\n \
    \ res = res + 10 * starts_one_ends(n - 2)\n  return res\nend", "    if n == 1\
    \ then\n        return 2\n    end\n    local last = 1\n    local cur = 9\n   \
    \ for i = 2, n do\n        local next = cur + 9 * last\n        last = cur\n \
    \       cur = next\n    end\n    return last + cur\nend", "  if n == 1 then\n\
    \    return 2\n  end\n  local start_ends = 9\n  local other_ends = 9\n  for i\
    \ = 2, n do\n    start_ends = start_ends + 1 + other_ends\n    other_ends = other_ends\
    \ + 1\n  end\n  return start_ends\nend", "   assert(n > 0)\n   local s = {0, 1}\n\
    \   for i = 2, n do\n      local s_i = 0\n      for j = 1, i do\n         s_i\
    \ = s_i + s[j]\n      end\n      s[i] = s_i + s[i - 1]\n   end\n   return s[n]\n\
    end", "  if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 3\n\
    \  end\n  return (n - 1) * (starts_one_ends(n - 1) + starts_one_ends(n - 2))\n\
    end", "    local t = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n    for i = 2, n do\n   \
    \     local t_ = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n        for j = 0, 9 do\n   \
    \         for k = 0, 9 do\n                t_[j] = t_[j] + t[k]\n            end\n\
    \        end\n        t = t_\n    end\n    local ans = 0\n    for i = 1, 9 do\n\
    \        ans = ans + t[i]\n    end\n    return ans\nend", "  if n == 1 then\n\
    \    return 2\n  end\n  local r = 1\n  for i = 1, n - 1 do\n    r = r * 9\n  end\n\
    \  return 2 * r\nend", "  if n == 1 then\n    return 2\n  end\n  if n == 2 then\n\
    \    return 7\n  end\n  if n == 3 then\n    return 18\n  end\n  if n == 4 then\n\
    \    return 41\n  end\n  if n == 5 then\n    return 84\n  end\n  if n == 6 then\n\
    \    return 162\n  end\n  if n == 7 then\n    return 289\n  end\n  if n == 8 then\n\
    \    return 504\n  end\n  if n == 9 then\n    return 836\n  end\n  if n == 10\
    \ then\n    return 1324\n  end\n  if n == 11 then\n    return 2031\n  end\n  if\
    \ n == 12 then\n    return 3008\n  end\n  if n == 13 then\n    return 4272\n \
    \ end\n  if n == 14 then\n    return 5984\n  end\n  if n == 15 then\n    return\
    \ 8134\n  end\n  if n == 16 then\n    return 10878\n  end\n  if n == 17 then\n\
    \    return 14342\n  end\n  if n == 18 then\n    return 18579\n  end\n  if n ==\
    \ 19 then\n    return 23714\n  end\n  if n == 20 then\n    return 29881\n  end\n\
    \  if n == 21 then\n    return 37205\n  end\n  if n == 22 then\n    return 45772\n\
    \  end\n  if n == 23 then\n    return 55629\n  end\n  if n == 24 then\n    return\
    \ 66936\n  end\n  if n == 25 then\n    return 79747\n  end\n  if n == 26 then\n\
    \    return 94236\n  end\n  if n == 27 then\n    return 110459\n  end\n  if n\
    \ == 28 then\n    return 128502\n  end\n  if n == 29 then\n    return 148454\n\
    \  end\n  if n == 30 then\n    return 170354\n  end\n  if n == 31 then\n    return\
    \ 194251\n  end\n  if n == 32 then\n    return 220203\n  end\n  if n == 33 then\n\
    \    return 248246\n  end\n  if n == 34 then\n    return 278407\n  end\n  if n\
    \ ==", '   local s = 0', "    if n == 1 then\n        return 2\n    end\n    local\
    \ count = 9\n    local base = 1\n    for i = 2, n - 1 do\n        base = base\
    \ * 10\n        count = count + 9 * base\n    end\n    return count * 2\nend",
  "   if n == 1 then\n      return 2\n   else\n      local total = starts_one_ends(n-1)\
    \ * 3\n      if n >= 3 then\n         total = total + starts_one_ends(n-2)\n \
    \     end\n      return total\n   end\nend", "    local f = function(m)\n    \
    \    return (n - 1) * 9 * 10 ^ (m - 1)\n    end\n    local r = f(n)\n    for m\
    \ = 1, n - 1 do\n        r = r + f(m)\n    end\n    return r\nend", "    if n\
    \ == 1 then\n        return 1\n    end\n    local f = {1,1}\n    for i = 3, n\
    \ do\n        f[i] = f[i-1] + f[i-2]\n    end\n    return f[n] * 2\nend", "  if\
    \ n == 1 then\n    return 1\n  end\n  local last = starts_one_ends(n - 1)\n  local\
    \ all = 9 * (4 ^ (n - 2))\n  return last + all\nend", "  local r = 1\n  for i\
    \ = 1, n - 1 do\n    r = r * 10\n  end\n  return n * r\nend", "    if n == 1 then\n\
    \        return 2\n    end\n    if n == 2 then\n        return 4\n    end\n  \
    \  local count = 8\n    for i = 1, n - 3 do\n        count = count * 5\n    end\n\
    \    return count\nend", "  if n == 1 then\n    return 2\n  end\n  local sum =\
    \ 0\n  for i = 1, n - 1 do\n    sum = sum + starts_one_ends(i) * one_digit_numbers(n\
    \ - i)\n  end\n  return sum\nend", "    local cache = {}\n    local function count(k)\n\
    \        if k == 1 then\n            return 2\n        elseif k == 0 then\n  \
    \          return 1\n        elseif cache[k] then\n            return cache[k]\n\
    \        else\n            cache[k] = count(k - 1) + count(k - 2)\n          \
    \  return cache[k]\n        end\n    end\n    return count(n - 1) + count(n -\
    \ 2)\nend", "    local function combs(n)\n        local function fact(n)\n   \
    \         if n == 0 then\n                return 1\n            else\n       \
    \         return n * fact(n - 1)\n            end\n        end\n        return\
    \ fact(n) / (fact(n / 2) * fact(n / 2))\n    end\n    return (9 ^ (n - 1)) * combs(n)\n\
    end", "    if n == 1 then\n        return 2\n    end\n    if n == 2 then\n   \
    \     return 4\n    end\n    local total = 6\n    local prev = 4\n    local next\
    \ = 6\n    for i = 3, n do\n        total = total + next\n        prev, next =\
    \ next, next + prev\n    end\n    return total\nend", "  local f = {}\n  local\
    \ g = {}\n  for i = 1, n - 1 do\n    f[i] = 1\n    g[i] = 1\n  end\n  f[n] = 2\n\
    \  g[n] = 2\n  for i = n + 1, 2 * n - 1 do\n    f[i] = f[i - 1] + f[i - n]\n \
    \   g[i] = g[i - 1] + g[i - n]\n  end\n  return g[2 * n - 1]\nend", "    if n\
    \ == 1 then\n        return 10\n    end\n    local start_one = 1\n    local end_one\
    \ = 1\n    for i = 2, n do\n        local tmp = (9 * start_one + 9 * end_one)\n\
    \        start_one = end_one\n        end_one = tmp\n    end\n    return (start_one\
    \ + end_one)\nend", "   return 10^(n-1)\nend", "   if n == 1 then\n      return\
    \ 2\n   else\n      return starts_one_ends(n-1) + 8 * count_non_one(n-1)\n   end\n\
    end", "   local result = 0\n   for i = 1, 9 do\n      result = result + 9 * 10^(n\
    \ - 2)\n   end\n   return result\nend", "    -- The recursive solution is messy\
    \ for two reasons:\n    --\n    --   1. The 1-digit base case, where 1 <= n <=\
    \ 9.\n    --   2. When n > 1, there are 9 ending digits and 10 starting digits.\n\
    \    --\n    -- For the first issue, count manually. For the second, consider\
    \ that we\n    -- can drop 1 from the total and add 10, because 10 is a starting\
    \ digit and\n    -- 1 is an ending digit.", "    local res = fibs(n + 2)\n   \
    \ return res[n + 1] - 1\nend", "  if n == 1 then\n    return 10\n  end\n  return\
    \ \n    (9 * comb(n - 1, 1)) + -- 1XXX...\n    (10 * (n - 1)) -- X1XX...\nend",
  "   if n == 1 then\n      return 1\n   elseif n == 2 then\n      return 2\n   else\n\
    \      return 10^(n-1) + 10^(n-2)\n   end\nend", "    -- n == 0\n    if n == 0\
    \ then\n        return 0\n    end", "  local _, v = strings.split(utils.to_binary(n),\
    \ '1')\n  return utils.from_binary(v or \"\")\nend", "  local t = {}\n  local\
    \ function count(digits, ones, prev)\n    if digits == 0 then\n      table.insert(t,\
    \ ones)\n      return\n    end\n    count(digits - 1, ones + 1, 1)\n    count(digits\
    \ - 1, ones, 0)\n  end\n  count(n, 0, 0)\n  return t\nend", "    if n == 1 then\n\
    \        return 3\n    elseif n == 2 then\n        return 4\n    else\n      \
    \  return starts_one_ends(n - 1) + starts_one_ends(n - 2)\n    end\nend", "  local\
    \ dp = { {}, {1, 1} }\n  for d = 3, n do\n    dp[d] = {1}\n    for i = 2, 9 do\n\
    \      dp[d][i] = (dp[d][i - 1] or 0) + (dp[d - 1][i] or 0)\n    end\n  end\n\
    \  return (dp[n][9] or 0) + 1\nend", "    local function starts_ends(count, digit)\n\
    \        if count == 0 then\n            return 1\n        elseif count == 1 then\n\
    \            return 0\n        else\n            return (count - 1) * 9\n    \
    \    end\n    end\n    return sum(starts_ends, range(n))\nend", "    return n\
    \ * 10^(n-1)\nend", "    if n == 1 then\n        return 2\n    end\n    local\
    \ start = math.pow(10, n - 1)\n    local ends = math.pow(10, n - 2) * 9\n    return\
    \ start + ends\nend", "  local function starts_ends(n)\n    if n == 1 then\n \
    \     return 1\n    else\n      return sum_diffs(starts_ends(n - 1), ends_starts(n\
    \ - 1))\n    end\n  end\n  return starts_ends(n)\nend", "  local count = 0\n \
    \ for b = 2, 9 do\n    count = count + nb_digits_start_num(n, b)\n  end\n  return\
    \ count\nend", "    if n == 1 then\n        return 2\n    end\n    if n == 2 then\n\
    \        return 6\n    end\n    return 9 * ends_one_starts(n - 1)\nend", "   \
    \ local c = (base ^ (n - 1)) - 1\n    local d = base - 1\n    return c + d\nend",
  "    local table1 = {}\n    local table2 = {}\n    for i = 1, n do\n        table1[i]\
    \ = 0\n        table2[i] = 0\n    end\n    table1[1] = 2\n    table2[1] = 1\n\
    \    for i = 2, n do\n        table1[i] = table1[i - 1] + table2[i - 1]\n    \
    \    table2[i] = table1[i - 1]\n    end\n    return table1[n] + table2[n]\nend",
  "  if n == 1 then\n    return 10\n  end\n  local d = 9\n  local res = 10\n  for\
    \ i = 2, n do\n    res = res + d\n    d = d * 10\n  end\n  return res\nend", " \
    \   local count = 0\n    for k=n,1,-1 do\n        count = count + 9 * 10^(k-1)\n\
    \    end\n    count = count + (n - 1) * 9\n    return count\nend", "  if n ==\
    \ 1 then\n    return 2\n  end\n  if n == 2 then\n    return 3\n  end\n  return\
    \ starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend", "    local count = 0\n\
    \    local begin = 10^(n-1)\n    local end = 10^n - 1\n    local digits = {}\n\
    \    for i = begin, end do\n        digits = {}\n        for d in string.gmatch(tostring(i),\
    \ \"%d\") do\n            table.insert(digits, d)\n        end\n        if digits[1]\
    \ == '1' or digits[#digits] == '1' then\n            count = count + 1\n     \
    \   end\n    end\n    return count\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    return starts_one_ends(n - 1) + 99 * 9^(n - 2)\nend", "   return\
    \ n\nend", "   return n\nend", "  if n == 1 then\n    return 10\n  end\n  local\
    \ dp = {10, 100}\n  for i = 3, n do\n    dp[i] = dp[i - 1] + dp[i - 2] * 9\n \
    \ end\n  return dp[n]\nend", "    -- Let's use the same approach as in `count_of_n_digit_one_ends`.\n\
    \    --\n    -- First we count the number of n-digit numbers that end with 1.\n\
    \    --\n    -- We can pick the first n-1 digits in 9^(n-1) ways. The last digit\
    \ has to\n    -- be 1.\n    --\n    -- The number of n-digit numbers that start\
    \ with 1 is the same.\n    return 2 * 9^(n-1)\nend", "   local start = 1\n   local\
    \ end = 1\n   local middle = math.floor(n/2) - 1\n   for i = 0, middle do\n  \
    \    start = start + (n - i - 1) * (9 * 10^i)\n      end = end + (n - i - 1) *\
    \ (9 * 10^i)\n   end\n   if n % 2 == 1 then\n      middle = middle + 1\n     \
    \ start = start + 10^middle\n      end = end + 10^middle\n   end\n   return start\
    \ + end\nend", "    if n == 1 then\n        return 2\n    end\n    local count\
    \ = 0\n    local m = 1\n    while m <= n do\n        count = count + math.pow(8,\
    \ m - 1)\n        m = m + 1\n    end\n    return count * 2\nend", "  if n == 1\
    \ then\n    return 2\n  end\n  local c = 0\n  if n % 2 == 0 then\n    c = c +\
    \ 1\n  end\n  c = c + 9 * (10 ^ (n // 2 - 1))\n  return c\nend", "    local cache\
    \ = {}\n    local function one_digit()\n        return 1\n    end\n    local function\
    \ two_digits()\n        return 10\n    end\n    local function three_digits()\n\
    \        return 100 - 10 + 1\n    end\n    local function four_digits()\n    \
    \    return 1000 - 100 + 1\n    end\n    local function five_digits()\n      \
    \  return 10000 - 1000 + 1\n    end\n    local function six_digits()\n       \
    \ return 100000 - 10000 + 1\n    end\n    local function seven_digits()\n    \
    \    return 1000000 - 100000 + 1\n    end\n    local function eight_digits()\n\
    \        return 10000000 - 1000000 + 1\n    end\n    local function nine_digits()\n\
    \        return 100000000 - 10000000 + 1\n    end\n    local function ten_digits()\n\
    \        return 1000000000 - 100000000 + 1\n    end\n    cache[1] = one_digit\n\
    \    cache[2] = two_digits\n    cache[3] = three_digits\n    cache[4] = four_digits\n\
    \    cache[5] = five_digits\n    cache[6] = six_digits\n    cache[7] = seven_digits\n\
    \    cache[8] = eight_digits\n    cache[9] = nine_digits\n    cache[10] = ten_digits\n\
    \    local function recursion(n)\n        if cache[n] then\n            return\
    \ cache[n]()\n        end\n        local counts = 0\n        for i = 2, n - 1\
    \ do\n            counts = counts + recursion(i) * nine_digits()\n        end\n\
    \        counts = counts + recursion(n - 1) * 10\n        counts = counts + ten_digits()\n\
    \        cache[n] = function()\n            return counts\n        end\n     \
    \   return counts\n    end\n    return recursion(n)\nend", "  -- If a number is\
    \ odd and ends with 1, then it ends with a 1.\n  -- If a number is even and ends\
    \ with 1, then it starts with a 1.\n  -- So, if the number of odd numbers with\
    \ 1 as the last digit is odd_ones and\n  -- the number of even numbers with 1\
    \ as the last digit is even_ones, then the\n  -- number of numbers that start\
    \ with a 1 or end with a 1 is odd_ones +\n  -- even_ones.\n  --\n  -- The number\
    \ of odd numbers with 1 as the last digit is equal to the number\n  -- of odd\
    \ numbers with any digit as the last digit, which is the number of\n  -- odd numbers\
    \ with 1 digit minus the number of odd numbers with 0 as the last\n  -- digit.\
    \ The number of odd numbers with 1 digit is 10^(n-1), and the number\n  -- of\
    \ odd numbers with 0 as the last digit is 5^(n-1). The number of odd\n  -- numbers\
    \ with 1 as the last digit is 10^(n-1) - 5^(n-1).\n  --\n  -- The number of even\
    \ numbers with 1 as the last digit is equal to the number\n  -- of even numbers\
    \ with any digit as the last digit, which is the number of\n  -- even numbers\
    \ with 1 digit minus the number of even numbers with 0 as the\n  -- last digit.\
    \ The number of even numbers with 1 digit is 10^(n-1), and the\n  -- number of\
    \ even numbers with 0 as the last digit is 5^(n-1). The number of\n  -- even numbers\
    \ with 1 as the last digit is 10^(n-1) - 5^(n-1).\n  --\n  -- Therefore, the total\
    \ number of numbers that start with a 1 or end with a 1\n  -- is 2*(10^(n-1) -\
    \ 5^(n-1)).\n  return 2 * (10^(n-1) - 5^(n-1))\nend", "   if n == 1 then\n   \
    \   return 3\n   elseif n == 2 then\n      return 11\n   else\n      return 2\
    \ * starts_one_ends(n - 1) + starts_one_ends(n - 2)\n   end\nend", "    local\
    \ count = 0\n    local zero_count = n - 1\n    while zero_count > 0 do\n     \
    \   count = count + 9\n        zero_count = zero_count - 1\n    end\n    return\
    \ count\nend", "    if n == 1 then\n        return 2\n    end\n    if n == 2 then\n\
    \        return 9\n    end\n    local d = n - 2\n    return 9 * (10 ^ d - 1) +\
    \ starts_one_ends(n - 1)\nend", "    local function make_string(acc, count)\n\
    \        if count == 0 then\n            return acc\n        else\n          \
    \  return make_string(\"9\" .. acc, count - 1)\n        end\n    end", "    if\
    \ n == 1 then\n        return 2\n    end\n    if n == 2 then\n        return 3\n\
    \    end\n    return n * 9 + 1\nend", "  local start = 1\n  local ends = 1\n \
    \ local both = 0\n  local none = 0\n  for _ = 2, n do\n    start, ends, both,\
    \ none = ends, 10 * (start + ends + both + none), start, 9 * (start + ends + both\
    \ + none)\n  end\n  return start + ends + both + none\nend", "  if n == 1 then\n\
    \    return 2\n  end\n  if n == 2 then\n    return 9\n  end\n  return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2)\nend", "  local f = fib()\n  local count = 0\n\
    \  for _ = 1, n do\n    count = count + f()\n  end\n  return count\nend", "  \
    \  if n < 1 then\n        return 0\n    end\n    if n == 1 then\n        return\
    \ 1\n    end\n    return n * 9 * 9 ^ (n - 2)\nend", "    -- Base case\n    if\
    \ n == 1 then\n        return 2\n    end", "  local count_for_n = {}\n  local\
    \ results = {}\n  local function count(n)\n    if n == 0 then\n      return 1\n\
    \    end\n    if count_for_n[n] then\n      return count_for_n[n]\n    end\n \
    \   local sum = 0\n    for i = 1, 9 do\n      sum = sum + count(n - 1)\n    end\n\
    \    count_for_n[n] = sum\n    return sum\n  end\n  for i = 1, n do\n    results[i]\
    \ = count(i)\n  end\n  return results\nend", "  local result = 0\n  local d =\
    \ 1\n  while d < n do\n    result = result + 2 * (10 ^ (d - 1))\n    d = d + 1\n\
    \  end\n  result = result + 1\n  return result\nend", "   if n == 1 then\n   \
    \   return 10\n   elseif n == 2 then\n      return 90\n   else\n      return math.floor(10*(math.pow(9,\
    \ n-1) - math.pow(8, n-1)))\n   end\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    return starts_one_ends(n - 1) + 9 * (10 ^ (n - 2))\nend", " \
    \   if n == 1 then\n        return 1\n    end\n    local last_digit = starts_one_ends(n\
    \ - 1)\n    local other_digits = starts_one_ends(n - 2)\n    return 9 * other_digits\
    \ + last_digit\nend", "   if n == 1 then\n      return 2\n   else\n      return\
    \ 9*(10^(n-2))\n   end\nend", "    if n == 1 then\n        return 2\n    end\n\
    \    local a = 1\n    local b = 1\n    for i = 1, n - 1 do\n        a, b = b,\
    \ a + b\n    end\n    return a + b\nend", "    local memo = {}\n    local function\
    \ count(m)\n        if memo[m] then\n            return memo[m]\n        end\n\
    \        if m == 1 then\n            return 3\n        end\n        local s =\
    \ count(m - 1) * 10\n        for i = 2, m do\n            s = s + count(i - 1)\
    \ * 10 ^ (m - i)\n        end\n        memo[m] = s\n        return s\n    end\n\
    \    return count(n)\nend", "   if n == 1 then\n      return 1\n   elseif n ==\
    \ 2 then\n      return 11\n   else\n      local sum = 1\n      local cur = 0\n\
    \      local rem = 1\n      local base = 10\n      local i = 1\n      while i\
    \ < n do\n         cur = rem + cur\n         rem = cur\n         sum = sum + cur\n\
    \         i = i + 1\n      end\n      return sum\n   end\nend", "    if n == 1\
    \ then\n        return 1\n    end\n    if n == 2 then\n        return 10\n   \
    \ end\n    if n == 3 then\n        return 19\n    end\n    return 2 * (9 ^ (n\
    \ - 1)) + starts_one_ends(n - 1)\nend", "  local sum = 1\n  local p = 1\n  local\
    \ limit = 10\n  for i = 1, n - 1 do\n    p = p * 10\n    limit = limit * 10\n\
    \    sum = sum + p * 9 + p * (limit - 1) * i\n  end\n  return sum\nend", "  --\
    \   n-1 places (skipping the first/last)\n  -- * n options for each one\n  --\
    \ + 1 if we started with 1, so 0-9 can go in the last place\n  -- * 1 if we ended\
    \ with 1, so 0-9 can go in the first place\n  return (n - 1) * n + (n ~= 1 and\
    \ 1 or 0) + (n == 1 and 1 or 0)\nend", "  if n == 1 then\n    return 10\n  end\n\
    \  local res = 0\n  local first = 10^(n-1)\n  res = res + 9*first\n  local ends\
    \ = ends_one(n-1)\n  res = res + ends\n  local starts = starts_one(n-1)\n  res\
    \ = res + starts\n  local start_ends = starts_one_ends(n-1)\n  res = res + start_ends\n\
    \  return res\nend", "    if n == 1 then\n        return 2\n    end\n    local\
    \ memo = {}\n    memo[1] = 2\n    memo[2] = 3\n    for i = 3, n do\n        memo[i]\
    \ = memo[i - 1] + memo[i - 2]\n    end\n    return memo[n]\nend", "  return 1\n\
    end", "    return 10^(n-1) - 2 * 9^(n-1) + 9^(n-2)\nend", "    local dp = {}\n\
    \    dp[0] = 0\n    dp[1] = 1\n    for i = 2, n do\n        dp[i] = dp[i - 1]\
    \ * 9 + 10 ^ (i - 1)\n    end\n    return dp[n]\nend", "  local dp = {[0] = 1,\
    \ [1] = 1}\n  local pow = 1\n  for i = 2, n do\n    pow = pow * 10\n    dp[i]\
    \ = dp[i - 1] * 10 + dp[i - 2] * pow\n  end\n  return dp[n]\nend", "   local function\
    \ binary_representation(n)\n      local r = {}\n      while n > 0 do\n       \
    \  r[#r+1] = n % 2\n         n = (n - n % 2) / 2\n      end\n      return r\n\
    \   end", "    if n == 1 then\n        return 1\n    end\n    local count = 0\n\
    \    for d=2,n-1 do\n        count = count + 10^(d-1)\n    end\n    -- last digit\
    \ is 1\n    count = count + 9\n    return count\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
