name: HumanEval_134_check_if_last_char_is_a_letter
language: lua
prompt: "-- Create a function that returns true if the last character\n-- of a given\
  \ string is an alphabetical character and is not\n-- a part of a word, and false\
  \ otherwise.\n-- Note: \"word\" is a group of characters separated by space.\n--\
  \ Examples:\n-- >>> check_if_last_char_is_a_letter('apple pie')\n-- false\n-- >>>\
  \ check_if_last_char_is_a_letter('apple pi e')\n-- true\n-- >>> check_if_last_char_is_a_letter('apple\
  \ pi e ')\n-- false\n-- >>> check_if_last_char_is_a_letter('')\n-- false\nlocal\
  \ function check_if_last_char_is_a_letter(txt)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_if_last_char_is_a_letter\n\
  \    lu.assertEquals(candidate('apple'), false)\n    lu.assertEquals(candidate('apple\
  \ pi e'), true)\n    lu.assertEquals(candidate('eeeee'), false)\n    lu.assertEquals(candidate('A'),\
  \ true)\n    lu.assertEquals(candidate('Pumpkin pie '), false)\n    lu.assertEquals(candidate('Pumpkin\
  \ pie 1'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('eeeee\
  \ e '), false)\n    lu.assertEquals(candidate('apple pie'), false)\n    lu.assertEquals(candidate('apple\
  \ pi e '), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- Check if the last character is not a space and is alphabetical.\n\
    \treturn txt:sub(-1):find(\"%a\") ~= nil and txt:sub(-1):find(\"%S\") ~= nil\n\
    end", "  local len = string.len(txt)\n  if len < 1 then\n    return false\n  end\n\
    \  local last_char = string.sub(txt, len, len)\n  local last_char_is_alpha = last_char:match('[a-zA-Z]')\n\
    \  local last_char_not_part_of_word = last_char:match('[^a-zA-Z]')\n  if last_char_is_alpha\
    \ and last_char_not_part_of_word then\n    return true\n  end\n  return false\n\
    end", "    if #txt <= 0 then\n        return false\n    end\n    if txt:find(\"\
    %w$\") then\n        return false\n    end\n    return true\nend", "    -- Insert\
    \ code here\nend", "  return nil\nend", "    -- Write your code here\nend", "\t\
    if txt:match('%a$') then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend",
  "    if #txt > 0 then\n        if string.sub(txt, -1, -1) == ' ' then\n        \
    \    return false\n        else\n            return not string.find(txt, '%w%s$')\n\
    \        end\n    else\n        return false\n    end\nend", "    return true\n\
    end", "  -- Your code here\nend", end, "    if string.match(txt, '%a$') and not\
    \ string.match(txt, '%w$') then\n        return true\n    else\n        return\
    \ false\n    end\nend", "    -- code here\nend", "  if txt == '' then\n    return\
    \ false\n  end\n  local len = txt:len()\n  local last = txt:sub(len, len)\n  if\
    \ last:match('%w') and last:match('%s') then\n    return true\n  end\n  return\
    \ false\nend", "    local last_char = txt:sub(-1)\n    return last_char:match('%a')\
    \ and not txt:sub(-2, -2):match('%a')\nend", "  local last = txt:sub(-1, -1)\n\
    \  if last:find('%a') and not last:find('%w') then\n    return true\n  else\n\
    \    return false\n  end\nend", "\t-- your code here\nend", "  if (txt == '')\
    \ then\n    return false\n  end\n  -- if the last character is an alphabetical\
    \ character\n  if (string.find(txt, '%a$')) then\n    -- check if that alphabetical\
    \ character is not a part of a word.\n    local start, finish = string.find(txt,\
    \ '%a$')\n    if (start > 1) then\n      if (not (string.find(txt, '%a%a$')))\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  return false\nend", "    -- write your code here\nend", "    return false\nend",
  "    local len = txt:len()\n    -- If the string is empty, return false.\n    if\
    \ len == 0 then\n        return false\n    -- If the last character is a space,\
    \ return false.\n    elseif txt:sub(len, len) == ' ' then\n        return false\n\
    \    end\n    -- Loop from the last character to the first one.\n    for i = len,\
    \ 1, -1 do\n        -- If a space is encountered, return true.\n        if txt:sub(i,\
    \ i) == ' ' then\n            return true\n        end\n    end\n    -- If there\
    \ was no space, return false.\n    return false\nend", "    --\n    -- write your\
    \ code here\n    --\nend", "  -- Implement this function.\nend", "    -- Length\
    \ of the string\n    local length = string.len(txt)\n    -- If the string is empty\
    \ return false\n    if length == 0 then\n        return false\n    end\n    --\
    \ Find the last letter and trim it (remove white spaces after it)\n    local last_letter\
    \ = string.sub(txt, length, length)\n    last_letter = last_letter:gsub(\"%s+$\"\
    , \"\")\n    -- Get the last letter code in the Ascii table\n    local char_code\
    \ = string.byte(last_letter)\n    -- Check if the code is between 97 (a) and 122\
    \ (z) or between 65 (A) and 90 (Z)\n    if char_code >= 97 and char_code <= 122\
    \ or char_code >= 65 and char_code <= 90 then\n        return true\n    end\n\
    \    return false\nend", "    local last = txt:sub(-1)\n    local last_letter\
    \ = string.match(last, \"%a\")\n    local last_letter_with_space = string.match(last,\
    \ \"%a%s\")\n    if last_letter == last and last_letter_with_space == nil then\n\
    \        return true\n    else\n        return false\n    end\nend", end, "  \
    \  local last_index = #txt\n    local last_char = txt:sub(last_index, last_index)\n\
    \    local letter = last_char:match('%a')\n    if letter and last_char ~= ' '\
    \ then\n        return true\n    else\n        return false\n    end\nend", " \
    \ -- your code here\nend", "  -- TODO: replace this line with your code\n  return\
    \ false\nend", "    -- your code here\nend", "  return false\nend", "  local s\
    \ = txt:gsub('%s+', '')\n  local l = s:len()\n  if l < 1 then\n    return false\n\
    \  end\n  local c = s:sub(l, l)\n  if c:match('[%a]') then\n    return true\n\
    \  end\n  return false\nend", "    -- TODO(Mohit):\n    return false\nend", " \
    \ if txt == '' then\n    return false\n  end\n  local last_char = string.sub(txt,\
    \ -1)\n  local second_last_char = string.sub(txt, -2, -2)\n  return string.match(last_char,\
    \ '[a-zA-Z]') and\n         not string.match(second_last_char, '[a-zA-Z]')\nend",
  "    return false\nend", "  -- Your code here\nend", "  if not txt or txt == ''\
    \ then\n    return false\n  end\n  local last_char = txt:sub(-1)\n  local last_char_next_to_last\
    \ = txt:sub(-2, -2)\n  if last_char_next_to_last == ' ' and last_char:match('%a')\
    \ then\n    return true\n  end\n  return false\nend", "\treturn string.find(txt,\
    \ \"^.*%s%p$\")\nend", "    -- type checking\n    assert(type(txt) == 'string',\
    \ 'input must be a string')", "  if not (type(txt) == 'string') then return false\
    \ end\n  return txt:match('%a%s*$') ~= nil\nend", "    return nil\nend", "  local\
    \ k = string.sub(txt, -1)\n  if k == ' ' then return false end\n  for i = string.len(txt)\
    \ - 1, 1, -1 do\n    local c = string.sub(txt, i, i)\n    if c == ' ' then break\
    \ end\n    if not string.match(c, '%a') then return false end\n  end\n  return\
    \ true\nend", "  local last_char = string.sub(txt, -1)\n  return string.find(last_char,\
    \ '%a') and not string.find(last_char, '%s')\nend", "  -- Write your code here\n\
    end", "  -- TODO: implement this function\nend", "  local txt = txt or ' '\n \
    \ local len = #txt\n  local last_char = txt:sub(len, len)\n  local check_previous_char\
    \ = txt:sub(len - 1, len - 1)\n  if last_char:match('%a') and check_previous_char\
    \ ~= ' ' then\n    return true\n  else\n    return false\n  end\nend", "    --\
    \ YOUR CODE HERE\n    return false\nend", "  local last_char = string.sub(txt,\
    \ string.len(txt))\n  if last_char ~= nil and last_char ~= '' and string.match(last_char,\
    \ '[a-zA-Z]') then\n    return true\n  end\n  return false\nend", "\tif txt:len()\
    \ == 0 then\n\t\treturn false\n\tend\n\treturn txt:sub(-1):match(\"%a\") and not\
    \ txt:sub(-1):match(\"%s\")\nend", "  if string.len(txt) == 0 then\n    return\
    \ false\n  end\n  for i = 1, string.len(txt) do\n    local ch = string.sub(txt,\
    \ i, i)\n    if ch == ' ' then\n      if i == string.len(txt) then\n        return\
    \ false\n      end\n      local tmp_ch = string.sub(txt, i + 1, i + 1)\n     \
    \ if (tmp_ch >= 'a' and tmp_ch <= 'z') or (tmp_ch >= 'A' and tmp_ch <= 'Z') then\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "\tlocal\
    \ last_char = txt:sub(-1)\n\tlocal not_alphabetical = last_char:find('%a') ==\
    \ nil\n\tlocal last_char_is_a_letter = not not_alphabetical", "\t-- Implement\
    \ this function.\n\t-- See section: https://en.wikipedia.org/wiki/ASCII#Printable_characters\n\
    \t-- See section: https://en.wikipedia.org/wiki/Letter_and_digit\n\t-- See section:\
    \ https://en.wikipedia.org/wiki/Number_Forms\n\t-- See section: https://en.wikipedia.org/wiki/Ideographic_Space\n\
    \t-- See section: https://en.wikipedia.org/wiki/Hangul_Jamo_(Unicode_block)\n\t\
    -- See section: https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)\n\
    \t-- See section: https://en.wikipedia.org/wiki/Letterlike_Symbols\n\t-- See section:\
    \ https://en.wikipedia.org/wiki/Mathematical_Operators\n\t-- See section: https://en.wikipedia.org/wiki/Miscellaneous_Mathematical_Symbols-A\n\
    \t-- See section: https://en.wikipedia.org/wiki/Miscellaneous_Mathematical_Symbols-B\n\
    \t-- See section: https://en.wikipedia.org/wiki/Miscellaneous_Symbols_and_Arrows\n\
    \t-- See section: https://en.wikipedia.org/wiki/Miscellaneous_Symbols_(Unicode_block)\n\
    \t-- See section: https://en.wikipedia.org/wiki/Modifier_Letters\n\t-- See section:\
    \ https://en.wikipedia.org/wiki/Phonetic_Extensions\n\t-- See section: https://en.wikipedia.org/wiki/Phonetic_Extensions_Supplement\n\
    \t-- See section: https://en.wikipedia.org/wiki/Private_Use_Area\n\t-- See section:\
    \ https://en.wikipedia.org/wiki/Spacing_Modifier_Letters\n\t-- See section: https://en.wikipedia.org/wiki/Superscripts_and_Subscripts\n\
    \t-- See section: https://en.wikipedia.org/wiki/Unified_Canadian_Aboriginal_Syllabics\n\
    \t-- See section: https://en.wikipedia.org/wiki/Unified_Canadian_Aboriginal_Syllabics_Extended\n\
    \t-- See section: https", "    local last_char = string.sub(txt, -1)\n    if last_char:match(\"\
    %a\") then\n        local second_last_char = string.sub(txt, -2, -2)\n       \
    \ if second_last_char:match(\"%s\") then\n            return true\n        end\n\
    \    end\n    return false\nend", "  -- #txt gives the length of the string; Remember:\
    \ Lua is 1-indexed.\n  if #txt == 0 then\n    return false\n  end\n  local char\
    \ = txt:sub(#txt, #txt) -- Gets the last character from the string.\n  if char:match('%a')\
    \ and txt:sub(#txt - 1, #txt - 1) == ' ' then\n    return true\n  end\n  return\
    \ false\nend", "    local len = string.len(txt)\n    local char = string.sub(txt,\
    \ len, len)\n    if char == \" \" then\n        return false\n    else\n     \
    \   return true\n    end\nend", "  return nil\nend", "  return nil\nend", end,
  "    -- TODO: Your code here\nend", "  return false\nend", "  -- TODO: Implement\
    \ this function.\nend", "\treturn txt:match('.*%s*(%a)$') ~= nil\nend", "    --\
    \ write your code here\nend", "    local last = txt:sub(-1)\n    local penultimate\
    \ = txt:sub(-2, -2)\n    return (last:find(\"%a\") and penultimate ~= \" \")\n\
    end", "    -- TODO: Write your code here.\nend", "  -- TODO: your code here\n\
    end", "  local len = #txt\n  local letter = txt:sub(len, len)\n  return txt:sub(len\
    \ - 1, len - 1) == ' ' and letter:match('%a')\nend", "    -- TODO: Implement this\
    \ function.\n    return false\nend", "  return txt:match('%a$')\nend", "  -- YOUR\
    \ CODE HERE\n  return\nend", end, "  -- your code here\nend", "    if string.len(txt)\
    \ == 0 then\n        return false\n    end\n    local last = string.sub(txt, string.len(txt),\
    \ string.len(txt))\n    local new_txt = string.sub(txt, 1, string.len(txt) - 1)\n\
    \    local last_space = string.find(new_txt, ' ')\n    if not last_space then\n\
    \        return false\n    end\n    local space_char = string.sub(new_txt, last_space\
    \ + 1, last_space + 1)\n    if last_space == string.len(new_txt) then\n      \
    \  return false\n    end\n    return not string.find(space_char, '[A-Za-z]')\n\
    end", "\tif type(txt) ~= 'string' then\n\t\treturn false\n\tend\n\tlocal last_char\
    \ = txt:sub(-1)\n\tif last_char:find('%a') then\n\t\treturn not txt:find('[%s]+'\
    \ .. last_char .. '[%s]+')\n\tend\n\treturn false\nend\nassert(check_if_last_char_is_a_letter('apple\
    \ pie') == false)\nassert(check_if_last_char_is_a_letter('apple pi e') == true)\n\
    assert(check_if_last_char_is_a_letter('apple pi e ') == false)\nassert(check_if_last_char_is_a_letter('')\
    \ == false)\nassert(check_if_last_char_is_a_letter(nil) == false)\nassert(check_if_last_char_is_a_letter(123)\
    \ == false)\nassert(check_if_last_char_is_a_letter({}) == false)", "    local\
    \ len = txt:len()\n    if len == 0 then\n        return false\n    end\n    local\
    \ last_char = txt:sub(len, len)\n    local prev_char = txt:sub(len - 1, len -\
    \ 1)\n    return (last_char:match('%a') and prev_char:match('%s'))\nend", "  \
    \  if txt:len() == 0 then\n        return false\n    end\n    return txt:sub(-1):match(\"\
    %w\") == nil\nend", "  -- TODO: Implement function here\nend", "    return true\n\
    end", "    -- REPLACE THE CODE WITH YOUR OWN\n    return false\nend", "    --\
    \ fill in your code here\nend", "  -- write your code here\nend", "    if txt\
    \ == \"\" then\n        return false\n    end\n    local txt_len = string.len(txt)\n\
    \    local result = false\n    if txt_len >= 2 then\n        --  check if second\
    \ last char is space\n        if txt:sub(txt_len - 1, txt_len - 1) == \" \" then\n\
    \            -- if yes, then check if last char is alphabetical\n            if\
    \ txt:sub(txt_len, txt_len):match(\"%a\") then\n                result = true\n\
    \            end\n        end\n    end\n    return result\nend", "    local last_char\
    \ = get_last_char(txt)\n    if type(last_char) == 'string' then\n        return\
    \ is_alphabetical(last_char) and is_separator(txt:sub(-2, -2))\n    else\n   \
    \     return false\n    end\nend", "  local lastChar = string.sub(txt, -1)\n \
    \ return string.find(lastChar, \"[%a]\")\nend", "    -- Return true if the last\
    \ character is a letter,\n    -- and false otherwise.\n    --\n    -- Your code\
    \ goes here.\nend", "  local chars = txt:split(' ')\n  local last_char = chars[#chars]:sub(-1)\n\
    \  return last_char:match('%a') ~= nil\nend", "  if type(txt) == 'string' then\n\
    \    return false\n  end\nend", "\t-- Write your code here\n\treturn false\nend",
  "    -- <your code goes here>\nend", "    local last_letter = txt:sub(-1):gsub('%s+',\
    \ '')\n    if last_letter == '' then\n        return false\n    else\n       \
    \ return last_letter:match('[a-zA-Z]') and true or false\n    end\nend", "  txt\
    \ = txt:gsub('%s', '')\n  return #txt > 0 and txt:sub(-1):match('%a') and not\
    \ txt:sub(-2):match('%a')\nend", "  -- ...\nend", end, "    -- TODO: Implement\
    \ this function!\nend", "  local last = txt:sub(-1)\n  if last == '' then\n  \
    \  return false\n  end\n  return last:match('%a') ~= nil and not last:match('%w')\n\
    end", "  local len = #txt\n  local last_char = string.sub(txt, len, len)\n  local\
    \ before_last_char = string.sub(txt, len - 1, len - 1)\n  return (string.match(last_char,\
    \ '%a') and\n          not string.match(before_last_char, '%a'))\nend", "  if\
    \ not txt then return false end\n  local last_char = txt:sub(-1)\n  if not last_char:match('%a')\
    \ then return false end\n  local next_last_char = txt:sub(-2, -2)\n  if next_last_char:match('%a')\
    \ then return false end\n  return true\nend", "    if txt == '' then\n       \
    \ return false\n    end\n    -- TODO: implement the function here\n    local found\
    \ = false\n    local space = false\n    local len = string.len(txt)\n    for i\
    \ = len, 1, -1 do\n        local char = string.sub(txt, i, i)\n        if char\
    \ == ' ' then\n            space = true\n        elseif char:match('%a') then\n\
    \            if space then\n                found = true\n            end\n  \
    \          break\n        end\n    end\n    return found\nend", "\tlocal new_txt\
    \ = txt:gsub(\"^%s*(.-)%s*$\", \"%1\")\n\treturn string.match(new_txt, \"[a-zA-Z]$\"\
    ) ~= nil and string.match(new_txt, \"[a-zA-Z]%s$\") == nil\nend", "    if txt\
    \ == '' then\n        return false\n    end\n    local txt_len = txt:len()\n \
    \   local last_char = txt:sub(txt_len, txt_len)\n    local len_last_char = last_char:len()\n\
    \    if len_last_char > 1 then\n        return false\n    end\n    if not last_char:match('%a')\
    \ then\n        return false\n    end\n    local txt_without_last_char = txt:sub(1,\
    \ txt_len - 1)\n    if txt_without_last_char:match(' ' .. last_char .. '$') then\n\
    \        return false\n    end\n    return true\nend", "    if not txt or txt\
    \ == '' then\n        return false\n    end\n    local last = txt:sub(-1)\n  \
    \  if last:match('%a') and not last:match('%w') then\n        return true\n  \
    \  end\n    return false\nend", "    local last_char = txt:sub(-1)\n    return\
    \ last_char:match('%a') and not last_char:match('%w')\nend", "  return\nend",
  "    -- your code goes here\nend", "  return txt:sub(-1):match(\"%a\") and not txt:sub(-1):match(\"\
    %w\")\nend", "\treturn false\nend", end, "    -- ...\nend", "  return false\n\
    end", "    local txt_length = string.len(txt)\n    local txt_last_char = string.sub(txt,\
    \ -1)\n    local txt_second_last_char = string.sub(txt, -2, -2)\n    if txt_last_char\
    \ == ' ' and string.match(txt_second_last_char, '%a') then\n        return true\n\
    \    else\n        return false\n    end\nend", "    return false\nend", end,
  "  if string.match(txt, \"%a$\") ~= nil then\n    return true\n  else\n    return\
    \ false\n  end\nend", "    return false\nend", "  -- YOUR CODE GOES HERE\n  txt_len\
    \ = string.len(txt)\n  if txt_len > 0 then\n    last_char = string.sub(txt, txt_len,\
    \ txt_len)\n    if not string.find(last_char, '%a') then\n      return false\n\
    \    end\n    before_last_char = string.sub(txt, txt_len - 1, txt_len - 1)\n \
    \   if not string.find(before_last_char, '%a') then\n      return true\n    end\n\
    \  end\n  return false\nend", "  -- TODO\nend", "  local c = string.sub(txt, -1)\n\
    \  if string.find(c, \"%w\") then\n    return false\n  else\n    return true\n\
    \  end\nend", "    if type(txt) ~= 'string' then\n        error('Expected a string')\n\
    \    end\n    local len = string.len(txt)\n    if len == 0 then\n        return\
    \ false\n    end\n    local last = string.sub(txt, len, len)\n    local is_letter\
    \ = string.match(last, '%a')\n    if not is_letter then\n        return false\n\
    \    end\n    local before_last = string.sub(txt, len - 1, len - 1)\n    local\
    \ is_before_letter = string.match(before_last, '%a')\n    if is_before_letter\
    \ then\n        return false\n    end\n    return true\nend", "\tlocal _, c =\
    \ txt:reverse():find(\"^%s*(%w)\")\n\treturn not (c == nil)\nend", "    -- your\
    \ code here\nend", "    local len = string.len(txt)\n    if len == 0 then\n  \
    \      return false\n    end\n    local last_char = string.sub(txt, len, len)\n\
    \    if last_char == ' ' then\n        return false\n    end\n    return not string.find(txt,\
    \ last_char .. ' ')\nend", "  --[[\n    TODO: Write a function\n  ]]\nend", " \
    \   -- write your code here\nend", "  -- your code here\nend", "    if (txt:match('%a%s$'))\
    \ then\n        return false\n    elseif (txt:match('%s%a$')) then\n        return\
    \ true\n    else\n        return false\n    end\nend", end, "    -- write your\
    \ code here\nend", "    if not txt then return false end\n    -- TODO: Your code\
    \ here\nend", "    -- TODO: Implement this\nend", "    -- insert your code here\n\
    end", "  -- Ignore non-alphabetic characters\n  local letter = txt:gsub('%A',\
    \ ''):sub(-1)\n  return letter and letter:match('[a-zA-Z]')\nend", "    if type(txt)\
    \ ~= 'string' then\n        error('txt should be a string')\n    end\n    local\
    \ function is_letter(char)\n        return char:match('%a') ~= nil\n    end\n\
    \    local function is_last_char_part_of_word(txt)\n        local last_char =\
    \ txt:sub(-1)\n        local rest_of_the_string = txt:sub(1, -2)\n        if rest_of_the_string:find(last_char)\
    \ then\n            return true\n        else\n            return false\n    \
    \    end\n    end\n    local function is_last_char_a_letter(txt)\n        local\
    \ last_char = txt:sub(-1)\n        if is_letter(last_char) then\n            return\
    \ true\n        else\n            return false\n        end\n    end\n    local\
    \ is_last_char_letter = is_last_char_a_letter(txt)\n    local is_last_char_part_of_word\
    \ = is_last_char_part_of_word(txt)\n    if is_last_char_letter and not is_last_char_part_of_word\
    \ then\n        return true\n    else\n        return false\n    end\nend", " \
    \   local last_char = string.sub(txt, string.len(txt))\n    if string.find(last_char,\
    \ \"%a\") then\n        local last_word = txt:match(\".* (%S+)$\")\n        if\
    \ last_word == last_char then\n            return false\n        else\n      \
    \      return true\n        end\n    else\n        return false\n    end\nend",
  "    local str = txt:reverse()\n    local char = str:sub(1,1)\n    if char:match(\"\
    %a\") then\n        local prev_char = str:sub(2,2)\n        if prev_char:match(\"\
    %a\") or prev_char:match(\"%s\") then\n            return false\n        else\n\
    \            return true\n        end\n    else\n        return false\n    end\n\
    end", "    local last_char = string.sub(txt, string.len(txt))\n    return not\
    \ string.find(last_char, '%a') and not string.find(last_char, '%s')\nend", " \
    \   -- ...\nend", "    -- TODO\nend", '    local last_char = txt:sub(-1)', " \
    \   local res = false\n    if txt:match('%w') then\n        res = true\n    end\n\
    \    return res\nend", "    return string.find(txt, '[^%s]$') ~= nil\nend", " \
    \   return false\nend", "  if #txt == 0 then\n    return false\n  end\n  if txt:sub(-1):match('%a')\
    \ and (txt:sub(-2, -2) == ' ' or txt:sub(-1) == ' ') then\n    return true\n \
    \ end\n  return false\nend", "\tlocal last_word = txt:match('%a+[^%s]*$')\n\t\
    if last_word == nil then\n\t\treturn false\n\tend\n\tif last_word:match('%a$')\
    \ then\n\t\treturn true\n\tend\n\treturn false\nend", "  return false\nend", " \
    \ local last_char = txt:sub(-1)\n  if #txt == 0 then\n    return false\n  elseif\
    \ last_char:match('%u') or last_char:match('%l') then\n    local word_count =\
    \ txt:gsub('[^%s]+', '')\n    if word_count == txt:sub(1, -2) then\n      return\
    \ true\n    else\n      return false\n    end\n  else\n    return false\n  end\n\
    end", "  -- your code here\nend", "  return true\nend", "    --return (txt:match(\"\
    %l$\") ~= nil)\n    return txt:find(\".%l$\") ~= nil\nend", "\t-- Implement here\n\
    \treturn false\nend", "    return txt:match(\"[a-zA-Z]$\") and not txt:match(\"\
    [a-zA-Z] $\")\nend", "    -- Your code goes here\nend", "\t-- YOUR CODE GOES HERE\n\
    end", end, "    -- Write your code here\nend", "    if string.len(txt) == 0 then\n\
    \        return false\n    end\n    local last_char = string.sub(txt, -1)\n  \
    \  local next_to_last_char = string.sub(txt, -2, -2)\n    return next_to_last_char\
    \ == ' ' and last_char:match('%a')\nend", "  -- your code here\nend", "  if txt:sub(-1):match('%a')\
    \ then\n    if txt:sub(-2, -2):match('%a') then\n      return false\n    else\n\
    \      return true\n    end\n  else\n    return false\n  end\nend", "    return\
    \ txt:match('[a-zA-Z]')\nend", "\t-- Fill in your code here\nend", end, "    --\
    \ Insert your code here\nend", "  -- Insert your code here\nend", "    if string.match(txt,\
    \ '%w$') then\n        return false\n    elseif string.match(txt, '[%a]$') then\n\
    \        return true\n    else\n        return false\n    end\nend", "\treturn\
    \ txt:sub(-1):match(\"%a\") ~= nil and txt:sub(-1):match(\"%s\") == nil\nend",
  "  return txt:match('%S+%s+([a-zA-Z])$') == txt:sub(-1)\nend", "    -- YOUR CODE\
    \ HERE\n    -- use string.find(txt, '%a')\n    -- use string.len(txt)\n    --\
    \ use string.sub(txt, i, i)\n    -- use string.find(txt, '%s')\nend", "  -- TODO\n\
    end", "    return false\nend", "  -- TODO: Implement this function.\nend", " \
    \   -- TODO: Implement this function\nend", "    -- Read about patterns in the\
    \ following URL:\n    -- https://www.lua.org/pil/20.2.html\n    -- Hint: you will\
    \ need to use a pattern such as %d, %s, %l,\n    -- etc.\n    -- Hint: you will\
    \ need to understand the difference between\n    -- %d and %D. For example, %d\
    \ matches any digit character\n    -- while %D matches any non-digit character.\n\
    \    return false\nend", "    if txt == \"\" then\n        return false\n    end\n\
    \    local len = #txt\n    local last_char = txt:sub(len, len)\n    local char_before_last\
    \ = txt:sub(len - 1, len - 1)\n    if (char_before_last == \" \") and (last_char:match(\"\
    [a-z]\") or last_char:match(\"[A-Z]\")) then\n        return true\n    end\n \
    \   return false\nend", "    -- This function returns true if the last character\n\
    \    -- of a given string is an alphabetical character and is not\n    -- a part\
    \ of a word, and false otherwise.\n    -- For example:\n    --     check_if_last_char_is_a_letter('apple\
    \ pie')\n    --     check_if_last_char_is_a_letter('apple pi e')\n    --     check_if_last_char_is_a_letter('apple\
    \ pi e ')\n    --     check_if_last_char_is_a_letter('')\n    -- NOTE:\n    --\
    \   The order of the arguments is important.\n    --   Use the following pattern\
    \ to check the length of a\n    --   string.\n    --      if #string == 0 then\n\
    \    --          -- string is empty\n    --      else\n    --          -- string\
    \ is not empty\n    --      end\n    --   To find out if the last character is\
    \ a letter, use\n    --   the following pattern. Note that string[#string]\n \
    \   --   refers to the last character of the string.\n    --      if string[#string]\
    \ == 'a' then\n    --          -- character is 'a'\n    --      elseif string[#string]\
    \ == 'b' then\n    --          -- character is 'b'\n    --      else\n    -- \
    \         -- it is not 'a' or 'b'\n    --      end\n    --   Finally, use isalpha()\
    \ to check if the last character\n    --   is an alphabetical character.\n   \
    \ --      if string[#string]:isalpha() then\n    --          -- character is an\
    \ alphabetical character\n    --      else\n    --          -- character is not\
    \ an alphabetical character\n    --      end\n    --   Use the following pattern\
    \ to check if the last character\n    --   is a part of a word.\n    --      if\
    \ string[#string-1] and string[#string-1]:isalpha() then\n    --          -- character\
    \ is part of a word\n    --      else\n    --          -- character is not part\
    \ of a word\n    --      end\n    -- NOTE:\n    --   We will learn about 'and'\
    \ operator in the lecture.\n    --   In the meantime, 'and'", "    -- TODO: implement\
    \ this function.\n    -- HINT: use string.match(txt, '%w') to check if a\n   \
    \ -- character is a letter.\n    return false\nend", "    local last_char = string.sub(txt,\
    \ -1)\n    if last_char:match(\"%a\") and not string.match(txt, last_char .. \"\
    %s\") then\n        return true\n    else\n        return false\n    end\nend",
  end, "    return false\nend", "  local i = txt:find(\"[a-zA-Z]$\")\n  if i then\n\
    \    return i > txt:find(\" \", i)\n  end\n  return false\nend", "    local len\
    \ = txt:len()\n    local last = txt:sub(len, len)\n    if string.match(last, \"\
    %a\") and not string.match(last, \"%w\") then\n        return true\n    else\n\
    \        return false\n    end\nend", "  if txt == '' then\n    return false\n\
    \  end\n  local is_last_char_alphabetical = is_alphabetical(txt:sub(-1))\n  if\
    \ is_last_char_alphabetical then\n    local all_chars_but_last = txt:sub(1, -2)\n\
    \    local last_word = all_chars_but_last:sub(all_chars_but_last:find('%s+%w+$'))\n\
    \    return not last_word or last_word:sub(-1) ~= txt:sub(-1)\n  end\n  return\
    \ false\nend", "    --[[\n    Write your code here.\n    --]]\nend", '    local
    last_char = txt:sub(-1)', "    -- Function definition goes here.\nend", "  --\
    \ Insert your code here\nend", "  local len = #txt\n  if len == 0 then\n    return\
    \ false\n  end\n  local last_char = txt:sub(len, len)\n  return not txt:sub(len-1,\
    \ len-1):match('%w') and\n         last_char:match('%a')\nend", "  -- Write your\
    \ code here\nend", "    if txt == '' then\n        return false\n    end\n   \
    \ local str_len = string.len(txt)\n    local ch = string.sub(txt, str_len, str_len)\n\
    \    if ch == ' ' then\n        return false\n    end\n    local str_len = string.len(txt)\n\
    \    local ch = string.sub(txt, str_len - 1, str_len - 1)\n    if ch == ' ' then\n\
    \        return true\n    end\n    return false\nend", "  -- type checking\n \
    \ if type(txt) ~= 'string' then\n    error(\"expected a string but got a \" ..\
    \ type(txt), 2)\n  end", "  -- TODO: Write your code here\n  return false\nend",
  "  txt = txt:gsub('%s', '')\n  return txt:len() == 0 or txt:sub(-1):match('%a')\
    \ and\n    not txt:sub(-2):match('%a')\nend", "    -- YOUR CODE HERE\nend", " \
    \   -- Your code here\nend", end, "    if txt == '' then\n        return false\n\
    \    end\n    if txt[-1] ~= ' ' then\n        return true\n    end\n    return\
    \ false\nend", "    return false\nend", "  return not txt:match('.%s') and txt:match('%l$')\n\
    end", "  -- write your solution here\nend", "    local last = txt:sub(-1)\n  \
    \  if last == ' ' then\n        return false\n    end\n    return txt:len() ==\
    \ 0 or txt:match(\"[%z]\") ~= last\nend", "  return txt:sub(-1):find('%l') ~=\
    \ nil and not txt:sub(-1):find('%w')\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
