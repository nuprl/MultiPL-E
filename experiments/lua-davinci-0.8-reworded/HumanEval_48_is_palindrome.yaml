name: HumanEval_48_is_palindrome
language: lua
prompt: "-- Checks if given string is a palindrome\n-- >>> is_palindrome('')\n-- true\n\
  -- >>> is_palindrome('aba')\n-- true\n-- >>> is_palindrome('aaaaa')\n-- true\n--\
  \ >>> is_palindrome('zbcd')\n-- false\nlocal function is_palindrome(text)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_palindrome\n\
  \    lu.assertEquals(candidate(''), true)\n    lu.assertEquals(candidate('aba'),\
  \ true)\n    lu.assertEquals(candidate('aaaaa'), true)\n    lu.assertEquals(candidate('zbcd'),\
  \ false)\n    lu.assertEquals(candidate('xywyx'), true)\n    lu.assertEquals(candidate('xywyz'),\
  \ false)\n    lu.assertEquals(candidate('xywzx'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #text < 2 then\n    return true\n  end\n  local a, b = text:sub(1,\
    \ 1), text:sub(-1, -1)\n  if a ~= b then\n    return false\n  end\n  return is_palindrome(text:sub(2,\
    \ -2))\nend", "    local last_index = string.len(text)\n    local half_index =\
    \ math.floor(last_index / 2)\n    local first_index = 1\n    while first_index\
    \ <= half_index do\n        if text:sub(first_index, first_index) ~= text:sub(last_index,\
    \ last_index) then\n            return false\n        end\n        first_index\
    \ = first_index + 1\n        last_index = last_index - 1\n    end\n    return\
    \ true\nend", "  local len = #text\n  local mid = math.floor(len / 2)", "    return\
    \ (text == text:reverse())\nend", "    return text == string.reverse(text)\nend",
  "    if string.len(text) <= 1 then\n        return true\n    elseif text:sub(1,\
    \ 1) == text:sub(-1, -1) then\n        return is_palindrome(text:sub(2, -2))\n\
    \    else\n        return false\n    end\nend", "  local text_length = #text\n\
    \  local half_length = math.floor(text_length / 2)\n  local text_first = text:sub(1,\
    \ half_length)\n  local text_last = text:sub(text_length - half_length + 1, text_length)\n\
    \  return text_first == text_last:reverse()\nend", "  if text == '' then\n   \
    \ return true\n  end\n  for i = 1, math.floor(#text / 2) do\n    if text:sub(i,\
    \ i) ~= text:sub(#text - i + 1, #text - i + 1) then\n      return false\n    end\n\
    \  end\n  return true\nend", "    text = string.lower(text)\n    len = string.len(text)\n\
    \    half = math.floor(len / 2)\n    for i = 1, half do\n        local front =\
    \ string.sub(text, i, i)\n        local back = string.sub(text, len - i + 1, len\
    \ - i + 1)\n        if front ~= back then\n            return false\n        end\n\
    \    end\n    return true\nend", "    text = string.lower(text)\n    local text_len\
    \ = string.len(text)\n    for i = 1, math.floor(text_len / 2) do\n        if string.sub(text,\
    \ i, i) ~= string.sub(text, text_len - i + 1, text_len - i + 1) then\n       \
    \     return false\n        end\n    end\n    return true\nend", "  if type(text)\
    \ ~= 'string' then return false end\n  if #text < 2 then return true end\n  return\
    \ text:sub(1, 1) == text:sub(-1, -1) and is_palindrome(text:sub(2, -2))\nend",
  "    return text == string.reverse(text)\nend", "  if string.len(text) <= 1 then\n\
    \    return true\n  elseif string.sub(text, 1, 1) == string.sub(text, -1, -1)\
    \ then\n    return is_palindrome(string.sub(text, 2, -2))\n  else\n    return\
    \ false\n  end\nend", "  if text:len() == 0 then\n    return true\n  end\n  for\
    \ i = 1, text:len() // 2 do\n    if text:sub(i, i) ~= text:sub(text:len() - i\
    \ + 1, text:len() - i + 1) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "  if text:len() <= 1 then\n    return true\n  elseif text:sub(1,\
    \ 1) == text:sub(-1, -1) then\n    return is_palindrome(text:sub(2, -2))\n  else\n\
    \    return false\n  end\nend", "    local rev = string.reverse(text)\n    if\
    \ text == rev then\n        return true\n    else\n        return false\n    end\n\
    end", "    local length = #text\n    local mid = math.floor(length / 2)", "  \
    \  local n = text:len()\n    for i = 1, n/2 do\n        if text:sub(i, i) ~= text:sub(n\
    \ - i + 1, n - i + 1) then\n            return false\n        end\n    end\n \
    \   return true\nend", "  if #text < 2 then\n    return true\n  end\n  if string.sub(text,\
    \ 1, 1) == string.sub(text, -1, -1) then\n    return is_palindrome(string.sub(text,\
    \ 2, -2))\n  end\n  return false\nend", "  return text == text:reverse()\nend",
  "    local i, j = 1, text:len()\n    while i < j do\n        if text:sub(i, i) ~=\
    \ text:sub(j, j) then\n            return false\n        end\n        i = i +\
    \ 1\n        j = j - 1\n    end\n    return true\nend", "  local half_len = math.floor(#text\
    \ / 2)\n  for i = 1, half_len do\n    if text:sub(i, i) ~= text:sub(#text - i\
    \ + 1, #text - i + 1) then\n      return false\n    end\n  end\n  return true\n\
    end", "    local text_len = string.len(text)\n    local index = 0\n    for i =\
    \ 1, text_len / 2 do\n        index = index + 1\n        if text:sub(i, i) ~=\
    \ text:sub(text_len - i + 1, text_len - i + 1) then\n            return false\n\
    \        end\n    end\n    return true\nend", "  -- This counts the length of\
    \ the string\n  local len = text:len()\n  -- This loops half of the string and\
    \ checks if the string is palindrome or not\n  for i = 1, len/2 do\n    if text:sub(i,\
    \ i) ~= text:sub(len-i+1, len-i+1) then\n      return false\n    end\n  end\n\
    \  return true\nend", "  local left, right = 1, #text\n  while left < right do\n\
    \    if text:sub(left, left) ~= text:sub(right, right) then\n      return false\n\
    \    end\n    left = left + 1\n    right = right - 1\n  end\n  return true\nend",
  "    local n = #text\n    for i = 1, n/2 do\n        if text:sub(i, i) ~= text:sub(n-i+1,\
    \ n-i+1) then\n            return false\n        end\n    end\n    return true\n\
    end", "  for i = 1, #text / 2 do\n    if text:sub(i, i) ~= text:sub(#text - i\
    \ + 1, #text - i + 1) then\n      return false\n    end\n  end\n  return true\n\
    end", "  local table = unicode.utf8.to_table(text)\n  local reverse = {}\n  for\
    \ i, j in ipairs(table) do\n    reverse[#table-i+1] = j\n  end\n  return table\
    \ == reverse\nend", "    local palindrome = string.reverse(text)\n    return text\
    \ == palindrome\nend", "  local len = text:len()\n  for i = 1, len/2 do\n    if\
    \ text:sub(i, i) ~= text:sub(len-i+1, len-i+1) then\n      return false\n    end\n\
    \  end\n  return true\nend", "    local text_len = #text\n    for i = 1, text_len/2\
    \ do\n        if text:sub(i, i) ~= text:sub(text_len - i + 1, text_len - i + 1)\
    \ then\n            return false\n        end\n    end\n    return true\nend",
  "    if string.len(text) == 0 then\n        return true\n    end\n    local s =\
    \ 0\n    local e = string.len(text) - 1\n    while s < e do\n        if string.lower(string.sub(text,\
    \ s, s)) ~= string.lower(string.sub(text, e, e)) then\n            return false\n\
    \        end\n        s = s + 1\n        e = e - 1\n    end\n    return true\n\
    end", "  return text == string.reverse(text)\nend", "  return text == text:reverse()\n\
    end", "    if text:len() <= 1 then\n        return true\n    elseif text:sub(1,\
    \ 1) == text:sub(-1, -1) then\n        return is_palindrome(text:sub(2, -2))\n\
    \    else\n        return false\n    end\nend", '  -- your code goes here', " \
    \   local len = #text\n    for i = 1, len/2 do\n        if text:sub(i, i) ~= text:sub(len-i+1,\
    \ len-i+1) then\n            return false\n        end\n    end\n    return true\n\
    end", "    local textlen = #text\n    for i = 1, textlen/2 do\n        if text:sub(i,\
    \ i) ~= text:sub(textlen - i + 1, textlen - i + 1) then\n            return false\n\
    \        end\n    end\n    return true\nend", "  local len = text:len()\n  local\
    \ half_len = math.floor(len / 2)", "    local len = #text\n    if len == 0 then\n\
    \        return true\n    end\n    local last = len - 1\n    local first = 0\n\
    \    while first < last do\n        if text:sub(first, first) ~= text:sub(last,\
    \ last) then\n            return false\n        end\n        first = first + 1\n\
    \        last = last - 1\n    end\n    return true\nend", "    local text_len\
    \ = string.len(text)\n    for i = 1, text_len / 2 do\n        if string.sub(text,\
    \ i, i) ~= string.sub(text, text_len - i + 1, text_len - i + 1) then\n       \
    \     return false\n        end\n    end\n    return true\nend", "  -- create\
    \ a reverse of the text\n  local reversed = string.reverse(text)\n  -- check if\
    \ it's the same\n  return text == reversed\nend", "  -- TODO: implement this\n\
    \  return true\nend", "    local low = 1\n    local high = #text\n    while (low\
    \ < high) do\n        if text:sub(low, low) ~= text:sub(high, high) then\n   \
    \         return false\n        end\n        low = low + 1\n        high = high\
    \ - 1\n    end\n    return true\nend", "    local len = #text\n    if len < 2\
    \ then\n        return true\n    end\n    if text:sub(1, 1) ~= text:sub(len, len)\
    \ then\n        return false\n    end\n    return is_palindrome(text:sub(2, len\
    \ - 1))\nend", "  if string.len(text) == 0 then\n    return true\n  end\n  return\
    \ (string.sub(text, 1, 1) == string.sub(text, -1)) and is_palindrome(string.sub(text,\
    \ 2, -2))\nend", "    -- remove whitespace and punctuation\n    local text = text:gsub('%s',\
    \ ''):gsub('%p', '')\n    local text_len = text:len()\n    local half_len = math.floor(text_len\
    \ / 2)\n    local i, j = 1, text_len\n    while i <= half_len do\n        if text:sub(i,\
    \ i) ~= text:sub(j, j) then\n            return false\n        end\n        i\
    \ = i + 1\n        j = j - 1\n    end\n    return true\nend", "  local reverse\
    \ = text:reverse()\n  return reverse == text\nend", "    if #text <= 1 then\n\
    \        return true\n    end\n    if utf8.sub(text, 1, 1) == utf8.sub(text, -1,\
    \ -1) then\n        return is_palindrome(utf8.sub(text, 2, -2))\n    end\n   \
    \ return false\nend", "    local len = string.len(text)\n    for i = 1, len do\n\
    \        if text:sub(i, i) ~= text:sub(len + 1 - i, len + 1 - i) then\n      \
    \      return false\n        end\n    end\n    return true\nend", "    return\
    \ text == utils.reverse(text)\nend", "    local letters = string.lower(text)\n\
    \    letters = string.gsub(letters, '%W', '')\n    return letters == string.reverse(letters)\n\
    end", "    if string.len(text) == 0 then\n        return true\n    end\n    local\
    \ left, right = 1, string.len(text)\n    while string.sub(text, left, left) ==\
    \ string.sub(text, right, right) do\n        left = left + 1\n        right =\
    \ right - 1\n        if left > right then\n            return true\n        end\n\
    \    end\n    return false\nend", "    if (string.len(text) <= 1) then\n     \
    \   return true\n    end\n    local first = string.sub(text, 1, 1)\n    local\
    \ last = string.sub(text, -1, -1)\n    if (first ~= last) then\n        return\
    \ false\n    end\n    return is_palindrome(string.sub(text, 2, -2))\nend", " \
    \   local start = 1\n    local finish = #text\n    while start < finish do\n \
    \       if text:sub(start, start) ~= text:sub(finish, finish) then\n         \
    \   return false\n        end\n        start = start + 1\n        finish = finish\
    \ - 1\n    end\n    return true\nend", "    local char\n    local length = #text\n\
    \    for i = 1, math.floor(length / 2) do\n        if text:sub(i, i) ~= text:sub(length\
    \ - i + 1, length - i + 1) then\n            return false\n        end\n    end\n\
    \    return true\nend", "    if (not text) or (text == '') then\n        return\
    \ true\n    end", "    local text_len = string.len(text)\n    for i = 1, math.floor(text_len\
    \ / 2) do\n        if string.sub(text, i, i) ~= string.sub(text, text_len - i\
    \ + 1, text_len - i + 1) then\n            return false\n        end\n    end\n\
    \    return true\nend", "  local i = 1\n  local len = #text\n  local j = len",
  "    if #text < 2 then\n        return true\n    end\n    local n = #text\n    for\
    \ i = 1, math.floor(n / 2) do\n        if text:sub(i, i) ~= text:sub(n - i + 1,\
    \ n - i + 1) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "  local n = string.len(text)\n  for i = 1, math.floor(n / 2) do\n\
    \    if string.sub(text, i, i) ~= string.sub(text, n - i + 1, n - i + 1) then\n\
    \      return false\n    end\n  end\n  return true\nend", "  if text == nil then\n\
    \    return true\n  end\n  return text == string.reverse(text)\nend", "    local\
    \ reverse = string.reverse(text)\n    return text == reverse\nend", "  -- Your\
    \ code here\nend", "    local first = 1\n    local last = #text\n    local is_palindrome\
    \ = true\n    while first < last do\n        if text:sub(first, first) ~= text:sub(last,\
    \ last) then\n            is_palindrome = false\n            break\n        end\n\
    \        first = first + 1\n        last = last - 1\n    end\n    return is_palindrome\n\
    end", "  local len = utf8.len(text)\n  for i = 1, len/2 do\n    if utf8.sub(text,\
    \ i, i) ~= utf8.sub(text, len - i + 1, len - i + 1) then\n      return false\n\
    \    end\n  end\n  return true\nend", "  if not text then return true end\n  if\
    \ utf8.len(text) == 1 then return true end\n  return text == string.reverse(text)\n\
    end", "    -- Reverse the text and check if it's the same as original\n    local\
    \ rev_text = string.reverse(text)\n    return text == rev_text\nend", "    local\
    \ i, j = 1, #text\n    while i < j do\n        if text:sub(i, i) ~= text:sub(j,\
    \ j) then\n            return false\n        end\n        i = i + 1\n        j\
    \ = j - 1\n    end\n    return true\nend", "  local len = text:len()\n  for i\
    \ = 1, len / 2 do\n    if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1)\
    \ then\n      return false\n    end\n  end\n  return true\nend", "    local len\
    \ = text:len()\n    local middle = math.floor(len / 2)\n    local s1 = text:sub(1,\
    \ middle)\n    local s2 = text:sub(len % 2 == 0 and (middle + 1) or middle, len)\n\
    \    return s1 == s2:reverse()\nend", "    local text = text:lower()\n    return\
    \ is_palindrome_iter(text, 1, text:len())\nend", "    local len = string.len(text)\n\
    \    for i = 1, len / 2 do\n        if string.sub(text, i, i) ~= string.sub(text,\
    \ len - i + 1, len - i + 1) then\n            return false\n        end\n    end\n\
    \    return true\nend", "  local i = 1\n  local length = #text\n  local last =\
    \ length\n  local step = 1\n  local is_even = (length % 2 == 0)\n  if is_even\
    \ then\n    step = 2\n  end\n  while i <= length do\n    if text:sub(i, i) ~=\
    \ text:sub(last, last) then\n      return false\n    end\n    i = i + step\n \
    \   last = last - step\n  end\n  return true\nend", "    local text_len = string.len(text)\n\
    \    local first_index = 1\n    local last_index = text_len\n    while first_index\
    \ < last_index do\n        if text:sub(first_index, first_index) ~= text:sub(last_index,\
    \ last_index) then\n            return false\n        end\n        first_index\
    \ = first_index + 1\n        last_index = last_index - 1\n    end\n    return\
    \ true\nend", "    local first = 1\n    local last = #text\n    for i = 1, #text\
    \ do\n        if text:sub(first, first) ~= text:sub(last, last) then\n       \
    \     return false\n        end\n        first = first + 1\n        last = last\
    \ - 1\n    end\n    return true\nend", "  return text == reverse(text)\nend",
  "    local len = #text\n    for i = 1, len / 2 do\n        if text:sub(i, i) ~=\
    \ text:sub(len - i + 1, len - i + 1) then\n            return false\n        end\n\
    \    end\n    return true\nend", "    local first_char = 1\n    local last_char\
    \ = utf8.len(text)\n    while first_char < last_char do\n        local first_char_is_equal\
    \ = utf8.sub(text, first_char, first_char) == utf8.sub(text, last_char, last_char)\n\
    \        if not first_char_is_equal then\n            return false\n        end\n\
    \        first_char = first_char + 1\n        last_char = last_char - 1\n    end\n\
    \    return true\nend", "    local len = #text\n    if len == 0 then\n       \
    \ return true\n    end\n    local l = 1\n    local r = len\n    while l < r do\n\
    \        if text:sub(l, l) ~= text:sub(r, r) then\n            return false\n\
    \        end\n        l = l + 1\n        r = r - 1\n    end\n    return true\n\
    end", "    if text == nil then return false end\n    local chars = string.split(text,\
    \ '')\n    local reversed = {}\n    for i, c in ipairs(chars) do\n        reversed[#chars\
    \ - i + 1] = c\n    end\n    return table.concat(chars) == table.concat(reversed)\n\
    end", "    if (type(text) ~= 'string') then\n        error('Bad argument #1: expected\
    \ string, got ' .. type(text), 2)\n    end", "  local len = #text\n  for i = 1,\
    \ len / 2 do\n    if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n\
    \      return false\n    end\n  end\n  return true\nend", "    if #text < 2 then\n\
    \        return true\n    end\n    if text:sub(1, 1) ~= text:sub(-1, -1) then\n\
    \        return false\n    end\n    return is_palindrome(text:sub(2, -2))\nend",
  "  local len = #text\n  for i = 1, len/2 do\n    if text:sub(i, i) ~= text:sub(len-i+1,\
    \ len-i+1) then\n      return false\n    end\n  end\n  return true\nend", "  \
    \  -- uses a single pass to check whether a string is a palindrome\n    local\
    \ iter = function(last, first)\n        if first >= last then\n            return\
    \ true\n        elseif text:sub(first, first) ~= text:sub(last, last) then\n \
    \           return false\n        else\n            return iter(last - 1, first\
    \ + 1)\n        end\n    end\n    return iter(text:len(), 1)\nend", "  for i =\
    \ 1, math.floor(#text / 2) do\n    if text:sub(i, i) ~= text:sub(#text - i + 1,\
    \ #text - i + 1) then\n      return false\n    end\n  end\n  return true\nend",
  "    local len = #text\n    for i = 1, len do\n        if text:sub(i, i) ~= text:sub(len-i+1,\
    \ len-i+1) then\n            return false\n        end\n    end\n    return true\n\
    end", "    if string.len(text) <= 1 then\n        return true\n    elseif string.sub(text,\
    \ 1, 1) == string.sub(text, -1, -1) then\n        return is_palindrome(string.sub(text,\
    \ 2, -2))\n    else\n        return false\n    end\nend", "    -- Standardize\
    \ String\n    text = string.lower(text)\n    text = string.gsub(text, \"[^a-z]\"\
    , \"\")", "    local len = string.len(text)\n    for i = 1, math.floor(len / 2)\
    \ do\n        if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n \
    \           return false\n        end\n    end\n    return true\nend", "    return\
    \ text == string.reverse(text)\nend", "  local len = #text\n  for i = 1, len/2\
    \ do\n    if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n     \
    \ return false\n    end\n  end\n  return true\nend", "    text = preprocess(text)\n\
    \    if #text == 0 then\n        return true\n    end\n    if #text == 1 then\n\
    \        return true\n    end\n    local len = #text\n    for i = 1, math.floor(len\
    \ / 2) do\n        if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n\
    \            return false\n        end\n    end\n    return true\nend", "  local\
    \ reversed = text:reverse()\n  return text == reversed\nend", "  return text ==\
    \ text:reverse()\nend", "  local n = #text\n  for i = 1, n / 2 do\n    if text:sub(i,\
    \ i) ~= text:sub(n - i + 1, n - i + 1) then\n      return false\n    end\n  end\n\
    \  return true\nend", "    return text == string.reverse(text)\nend", "  -- Ensure\
    \ the text is lowercase\n  text = string.lower(text)\n  -- Now, to check if the\
    \ string is a palindrome, we check if the first and\n  -- last letter is the same,\
    \ then check the second and second-to-last letter\n  -- and so on. To get a letter\
    \ at a given index, we can use string.sub\n  -- syntax string.sub(text, position,\
    \ position)\n  local len = string.len(text)\n  for i = 1, math.floor(len / 2)\
    \ do\n    if string.sub(text, i, i) ~= string.sub(text, len - i + 1, len - i +\
    \ 1) then\n      return false\n    end\n  end\n  return true\nend", "    local\
    \ i, j = 1, #text\n    while i < j do\n        if text:sub(i, i) ~= text:sub(j,\
    \ j) then\n            return false\n        end\n        i = i + 1\n        j\
    \ = j - 1\n    end\n    return true\nend", "  -- text: string\n  -- Returns: boolean\n\
    \  local first_char = 1\n  local last_char = string.len(text)\n  while first_char\
    \ < last_char do\n    if string.sub(text, first_char, first_char) ~= string.sub(text,\
    \ last_char, last_char) then\n      return false\n    end\n    first_char = first_char\
    \ + 1\n    last_char = last_char - 1\n  end\n  return true\nend", "    return\
    \ text == string.reverse(text)\nend", "    return string.reverse(text) == text\n\
    end", "  if text == '' then\n    return true\n  end\n  local st = 1\n  local end_\
    \ = text:len()\n  while st < end_ do\n    if text:sub(st, st) ~= text:sub(end_,\
    \ end_) then\n      return false\n    end\n    st = st + 1\n    end_ = end_ -\
    \ 1\n  end\n  return true\nend", "    text = string.lower(text)\n    local text_len\
    \ = string.len(text)\n    local text_rev = string.reverse(text)\n    if text ==\
    \ text_rev then\n        return true\n    else\n        return false\n    end\n\
    end", "    -- TODO - complete this function\nend", "  local strlen = string.len(text)\n\
    \  for i = 1, strlen do\n    if string.sub(text, i, i) ~= string.sub(text, strlen\
    \ - i + 1, strlen - i + 1) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "    return text == string.reverse(text)\nend", "    local s = string.reverse(text)\n\
    \    if s == text then\n        return true\n    else\n        return false\n\
    \    end\nend", "  for i = 1, #text/2 do\n    if text:sub(i, i) ~= text:sub(#text-i+1,\
    \ #text-i+1) then\n      return false\n    end\n  end\n  return true\nend", " \
    \   if #text <= 1 then\n        return true\n    end\n    if string.sub(text,\
    \ 1, 1) == string.sub(text, -1, -1) then\n        return is_palindrome(string.sub(text,\
    \ 2, -2))\n    else\n        return false\n    end\nend", "    local left = 1\n\
    \    local right = #text\n    while left < right do\n        if text:sub(left,\
    \ left) ~= text:sub(right, right) then\n            return false\n        end\n\
    \        left = left + 1\n        right = right - 1\n    end\n    return true\n\
    end", "    local ret = true\n    for i = 1, #text/2 do\n        if text:sub(i,\
    \ i) ~= text:sub(#text - i + 1, #text - i + 1) then\n            ret = false\n\
    \            break\n        end\n    end\n    return ret\nend", "    return text\
    \ == string.reverse(text)\nend", "    if type(text) ~= 'string' then\n       \
    \ return false\n    end\n    return text == text:reverse()\nend", "  -- reverse\
    \ the text and compare it with original\n  local reversed = string.reverse(text)\n\
    \  return reversed == text\nend", "    local i, j = 1, text:len()\n    while i\
    \ < j do\n        if text:sub(i, i) ~= text:sub(j, j) then\n            return\
    \ false\n        end\n        i = i + 1\n        j = j - 1\n    end\n    return\
    \ true\nend", "    -- TODO: return true if text is a palindrome, false otherwise\n\
    \    -- HINT: remember about string.sub(text, i, j) to extract a substring\n \
    \   -- HINT: can you define the base case?\n    -- HINT: can you define a recursive\
    \ case?\n    local len = #text\n    if len == 0 then\n        return true\n  \
    \  elseif text:sub(1, 1) == text:sub(len, len) then\n        return is_palindrome(text:sub(2,\
    \ len - 1))\n    else\n        return false\n    end\nend", "    local s = #text\n\
    \    local half = math.floor(s / 2)", "  return text == string.reverse(text)\n\
    end", "    return text == string.reverse(text)\nend", "    local len = string.len(text)\n\
    \    local half = math.floor(len / 2)", "    return string.reverse(text) == text\n\
    end", "  local n = #text\n  local half = math.floor(n / 2)\n  for i = 1, half\
    \ do\n    if text:sub(i, i) ~= text:sub(n - i + 1, n - i + 1) then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  if not text then return false\
    \ end\n  local len = string.len(text)\n  if len < 2 then return true end\n  if\
    \ len == 2 then return string.sub(text, 1, 1) == string.sub(text, 2, 2) end\n\
    \  if len == 3 then return (string.sub(text, 1, 1) == string.sub(text, 3, 3))\
    \ and (string.sub(text, 2, 2) == string.sub(text, 2, 2)) end\n  for i = 1, len\
    \ / 2 do\n    if string.sub(text, i, i) ~= string.sub(text, len - i + 1, len -\
    \ i + 1) then\n      return false\n    end\n  end\n  return true\nend", "    local\
    \ len = #text\n    for i = 1, len / 2 do\n        if text:sub(i, i) ~= text:sub(len\
    \ - i + 1, len - i + 1) then\n            return false\n        end\n    end\n\
    \    return true\nend", "  if text == '' then\n    return true\n  end\n  local\
    \ first = text:sub(1, 1)\n  local last = text:sub(-1, -1)\n  if first ~= last\
    \ then\n    return false\n  end\n  return is_palindrome(text:sub(2, -2))\nend",
  "    local text_reverse = string.reverse(text)\n    return string.lower(text) ==\
    \ string.lower(text_reverse)\nend", "    if #text < 2 then\n        return true\n\
    \    end\n    if string.sub(text, 1, 1) == string.sub(text, -1, -1) then\n   \
    \     return is_palindrome(string.sub(text, 2, -2))\n    else\n        return\
    \ false\n    end\nend", "    local length = #text\n    for i = 1, length do\n\
    \        if text:sub(i, i) ~= text:sub(length-i+1, length-i+1) then\n        \
    \    return false\n        end\n    end\n    return true\nend", "    return text\
    \ == string.reverse(text)\nend", "    return text == string.reverse(text)\nend",
  "    text = text:lower()\n    return text == string.reverse(text)\nend", "    return\
    \ text == text:reverse()\nend", "    return text == reverse(text)\nend", "   \
    \ return #text == 0 or (\n        #text == 1 or (\n            text:sub(1, 1)\
    \ == text:sub(-1, -1) and is_palindrome(text:sub(2, -2))\n        )\n    )\nend",
  "  local text_len = string.len(text)\n  local half_len = math.floor(text_len / 2)\n\
    \  for i = 1, half_len do\n    if string.sub(text, i, i) ~= string.sub(text, text_len\
    \ - i + 1, text_len - i + 1) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "    if text == nil then return false end\n    if #text == 0 then\
    \ return true end\n    for i = 1, math.floor(#text / 2) do\n        if text:sub(i,\
    \ i) ~= text:sub(#text - i + 1, #text - i + 1) then\n            return false\n\
    \        end\n    end\n    return true\nend", "  return text == text:reverse()\n\
    end", "    local l = text:len()\n    for i = 1, l do\n        if not text:sub(i,\
    \ i) == text:sub(l - i + 1, l - i + 1) then\n            return false\n      \
    \  end\n    end\n    return true\nend", "  for i = 1, #text do\n    if text:sub(i,\
    \ i) ~= text:sub(#text + 1 - i, #text + 1 - i) then\n      return false\n    end\n\
    \  end\n  return true\nend", "  if text == '' then\n    return true\n  end\n \
    \ -- TODO add your code here\n  local prefix = string.sub(text,1,1)\n  local suffix\
    \ = string.sub(text,-1)\n  if prefix == suffix then\n    local sub_text = string.sub(text,2,-2)\n\
    \    return is_palindrome(sub_text)\n  else\n    return false\n  end\nend", " \
    \ return text == text:reverse()\nend", "    local reversed = text:reverse()\n\
    \    return text == reversed\nend", "  if text == \"\" then\n    return true\n\
    \  end\n  if text:sub(1, 1) == text:sub(-1, -1) then\n    return is_palindrome(text:sub(2,\
    \ -2))\n  end\n  return false\nend", "    local len = #text\n    for i = 1, len\
    \ / 2 do\n        if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n\
    \            return false\n        end\n    end\n    return true\nend", "  return\
    \ text == string.reverse(text)\nend", "    return text == string.reverse(text)\n\
    end", "  if #text < 2 then\n    return true\n  end\n  if text:sub(1, 1) == text:sub(-1,\
    \ -1) then\n    return is_palindrome(text:sub(2, -2))\n  end\n  return false\n\
    end", "  if not text or text == '' then\n    return true\n  end\n  if #text ==\
    \ 1 then\n    return true\n  end\n  for i = 1, #text do\n    if text:sub(i, i)\
    \ ~= text:sub(#text - i + 1, #text - i + 1) then\n      return false\n    end\n\
    \  end\n  return true\nend", "  if #text < 2 then\n    return true\n  end\n  if\
    \ text:sub(1, 1) == text:sub(-1, -1) then\n    return is_palindrome(text:sub(2,\
    \ -2))\n  end\n  return false\nend", "    return text == string.reverse(text)\n\
    end", "  if text:len() <= 1 then\n    return true\n  elseif text:sub(1, 1) ==\
    \ text:sub(-1, -1) then\n    return is_palindrome(text:sub(2, -2))\n  else\n \
    \   return false\n  end\nend", "    text = text:lower()\n    local length = text:len()\n\
    \    local halflength = length // 2", "    local i, j = 1, text:len()\n    local\
    \ is_palindrome = true\n    while i < j do\n        if text:sub(i, i) ~= text:sub(j,\
    \ j) then\n            is_palindrome = false\n            break\n        end\n\
    \        i = i + 1\n        j = j - 1\n    end\n    return is_palindrome\nend",
  "    return text == reverse(text)\nend", "  local length = #text\n  for i = 1, length\
    \ / 2 do\n    if text:sub(i, i) ~= text:sub(length - i + 1, length - i + 1) then\n\
    \      return false\n    end\n  end\n  return true\nend", "    local len = #text\n\
    \    if len == 0 then\n        return true\n    end\n    for i = 1, len / 2 do\n\
    \        if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n      \
    \      return false\n        end\n    end\n    return true\nend", "  local text_length\
    \ = string.len(text)\n  for i = 1, math.floor(text_length / 2) do\n    if text:sub(i,\
    \ i) ~= text:sub(text_length - i + 1, text_length - i + 1) then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  local len = string.len(text)\n\
    \  for i = 1, len / 2 do\n    if text:sub(i, i) ~= text:sub(len - i + 1, len -\
    \ i + 1) then\n      return false\n    end\n  end\n  return true\nend", "    --[[\n\
    \        checks if given string is a palindrome\n        input:\n            text\
    \ : string\n        output:\n            bool\n    ]]\n    local rev_str = \"\"\
    \n    for i in string.gmatch(text, \".\") do\n        rev_str = i .. rev_str\n\
    \    end\n    if rev_str == text then\n        return true\n    else\n       \
    \ return false\n    end\nend", "    return text == string.reverse(text)\nend",
  "  local len = text:len()\n  for i = 1, len do\n    if text:sub(i, i) ~= text:sub(len\
    \ + 1 - i, len + 1 - i) then\n      return false\n    end\n  end\n  return true\n\
    end", "    if not text then\n        return false\n    end\n    local len = string.len(text)\n\
    \    if len == 0 then\n        return true\n    end\n    if len == 1 then\n  \
    \      return true\n    end\n    if len == 2 then\n        return text[1] == text[2]\n\
    \    end\n    local left = 1\n    local right = len\n    while left < right do\n\
    \        if text[left] ~= text[right] then\n            return false\n       \
    \ end\n        left = left + 1\n        right = right - 1\n    end\n    return\
    \ true\nend", "  -- check arguments\n  if type(text) ~= 'string' then\n    error('bad\
    \ argument #1 to is_palindrome (expected string, got ' .. type(text) .. ')', 2)\n\
    \  end", "  for i = 1, #text / 2 do\n    if text:sub(i, i) ~= text:sub(#text -\
    \ i + 1, #text - i + 1) then\n      return false\n    end\n  end\n  return true\n\
    end", "    local len = string.len(text)\n    for i = 1, len / 2 do\n        if\
    \ text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    -- Check for empty\
    \ string or one-char strings\n    if text == '' or #text == 1 then\n        return\
    \ true\n    end", "  return text == string.reverse(text)\nend", "    local len\
    \ = #text\n    for i = 1, math.floor(len / 2) do\n        if text:sub(i, i) ~=\
    \ text:sub(len - i + 1, len - i + 1) then\n            return false\n        end\n\
    \    end\n    return true\nend", "    local text_length = #text\n    local last_index\
    \ = text_length - 1\n    for i = 0, last_index, 1 do\n        if text:sub(i, i)\
    \ ~= text:sub(last_index - i, last_index - i) then\n            return false\n\
    \        end\n    end\n    return true\nend", "    local text_len = string.len(text)\n\
    \    for i = 1, text_len/2 do\n        if string.sub(text, i, i) ~= string.sub(text,\
    \ text_len - i + 1, text_len - i + 1) then\n            return false\n       \
    \ end\n    end\n    return true\nend", "  if #text <= 1 then\n    return true\n\
    \  elseif text:sub(1, 1) == text:sub(-1, -1) then\n    return is_palindrome(text:sub(2,\
    \ -2))\n  else\n    return false\n  end\nend", "  local char_count = #text\n \
    \ local count = char_count // 2\n  for i = 1, count do\n    if text:sub(i, i)\
    \ ~= text:sub(char_count-i+1, char_count-i+1) then\n      return false\n    end\n\
    \  end\n  return true\nend", "  local len = string.len(text)\n  local half = math.floor(len\
    \ / 2)", "    return string.reverse(text) == text\nend", "    return text == string.reverse(text)\n\
    end", "    if #text <= 1 then\n        return true\n    end\n    local f_char\
    \ = string.sub(text, 1, 1)\n    local l_char = string.sub(text, #text, #text)\n\
    \    if f_char ~= l_char then\n        return false\n    end\n    return is_palindrome(string.sub(text,\
    \ 2, #text - 1))\nend", "    local len = string.len(text)\n    for i = 1, len/2\
    \ do\n        if string.sub(text, i, i) ~= string.sub(text, len - i + 1, len -\
    \ i + 1) then\n            return false\n        end\n    end\n    return true\n\
    end", "    text = text:lower()\n    local function is_palindrome_recursive(left,\
    \ right)\n        if left == right then\n            return true\n        elseif\
    \ left > right then\n            return true\n        elseif left < right then\n\
    \            if not is_lowercase(text:sub(left, left)) then\n                return\
    \ is_palindrome_recursive(left + 1, right)\n            elseif not is_lowercase(text:sub(right,\
    \ right)) then\n                return is_palindrome_recursive(left, right - 1)\n\
    \            elseif text:sub(left, left) ~= text:sub(right, right) then\n    \
    \            return false\n            else\n                return is_palindrome_recursive(left\
    \ + 1, right - 1)\n            end\n        end\n    end\n    return is_palindrome_recursive(1,\
    \ text:len())\nend", "    local len = string.len(text)\n    for i = 1, len //\
    \ 2 do\n        if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n\
    \            return false\n        end\n    end\n    return true\nend", "  for\
    \ i = 1, math.floor(#text / 2) do\n    if text:sub(i, i) ~= text:sub(#text - i\
    \ + 1, #text - i + 1) then\n      return false\n    end\n  end\n  return true\n\
    end", "  for i = 1, string.len(text) // 2 do\n    if string.sub(text, i, i) ~=\
    \ string.sub(text, -i, -i) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "  -- remove spaces, convert to lowercase, remove diacritics\n \
    \ local text = unicode.to_lower(unicode.nfkd(text))\n  -- remove non-alphanumeric\
    \ characters\n  local text = unicode.gsub(text, '[^%w]', '')\n  -- convert to\
    \ list\n  local list = unicode.utf8.codepoint(text)\n  -- remove whitespace\n\
    \  local list = tablex.compact(list)\n  -- check that list is not empty\n  if\
    \ #list == 0 then\n    return true\n  end\n  -- check for palindrome\n  local\
    \ i = 1\n  local j = #list\n  while i < j do\n    if list[i] ~= list[j] then\n\
    \      return false\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return true\n\
    end", "    local n = text:len()\n    for i = 1, n / 2 do\n        if text:sub(i,\
    \ i) ~= text:sub(n - i + 1, n - i + 1) then\n            return false\n      \
    \  end\n    end\n    return true\nend", "    local length = string.len(text)\n\
    \    local palindrome = true\n    for i = 1, length / 2 do\n        if text:sub(i,\
    \ i) ~= text:sub(length - i + 1, length - i + 1) then\n            palindrome\
    \ = false\n            break\n        end\n    end\n    return palindrome\nend",
  "  -- TODO: implement this\n  local count = 0\n  local i = 1\n  local j = #text\n\
    \  while i <= #text and j >= 1 do\n    if text:sub(i,i) == text:sub(j,j) then\n\
    \      count = count + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  if count\
    \ == #text then\n    return true\n  else\n    return false\n  end\nend", "  local\
    \ text_len = string.len(text)\n  local half_len = math.floor(text_len / 2)\n \
    \ local match = true\n  for i = 1, half_len do\n    if string.sub(text, i, i)\
    \ ~= string.sub(text, text_len - i + 1, text_len - i + 1) then\n      match =\
    \ false\n      break\n    end\n  end\n  return match\nend", "    local text_length\
    \ = #text\n    for i = 1, math.floor(text_length / 2) do\n        if text:sub(i,\
    \ i) ~= text:sub(text_length - i + 1, text_length - i + 1) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "  local input_length =\
    \ string.len(text)\n  local _, max_iterations = math.modf(input_length / 2)\n\
    \  local is_palindrome = true\n  for i = 1, max_iterations do\n    local left\
    \ = string.sub(text, i, i)\n    local right = string.sub(text, input_length -\
    \ i + 1, input_length - i + 1)\n    if left ~= right then\n      is_palindrome\
    \ = false\n      break\n    end\n  end\n  return is_palindrome\nend", "    local\
    \ text_len = #text\n    for i = 1, math.floor(text_len / 2) do\n        if text:sub(i,\
    \ i) ~= text:sub(text_len + 1 - i, text_len + 1 - i) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    local min, max = 1,\
    \ #text\n    while min < max do\n        if text:sub(min, min) ~= text:sub(max,\
    \ max) then\n            return false\n        end\n        min = min + 1\n  \
    \      max = max - 1\n    end\n    return true\nend", "  local len = #text\n \
    \ local half = math.floor(len / 2)", "  -- Implement your is_palindrome\n  --\
    \ function using the table\n  -- reverse function that you\n  -- will define in\
    \ the next step\n  -- You will have to define the\n  -- table_reverse function\
    \ before\n  -- using it\n  return (text == table_reverse(text))\nend", "  return\
    \ text == text:reverse()\nend", "  return string.reverse(text) == text\nend",
  "    if #text < 2 then\n        return true\n    end\n    if string.sub(text, 1,\
    \ 1) == string.sub(text, -1, -1) then\n        return is_palindrome(string.sub(text,\
    \ 2, -2))\n    else\n        return false\n    end\nend", "  -- If string length\
    \ is 1, it's a palindrome\n  if #text == 1 then\n    return true\n  end", "  \
    \  local len = string.len(text)\n    local loop_length = math.floor(len / 2)\n\
    \    for i = 1, loop_length do\n        if text:sub(i, i) ~= text:sub(len - i\
    \ + 1, len - i + 1) then\n            return false\n        end\n    end\n   \
    \ return true\nend", "    -- use the is_palindrome function that was given to\
    \ us\n    local text_reverse = string.reverse(text)\n    return text == text_reverse\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
