name: HumanEval_33_sort_third
language: lua
prompt: "-- This function takes a table l and returns a table l' such that\n-- l'\
  \ is identical to l in the indicies that are not divisible by three, while its values\
  \ at the indicies that are divisible by three are equal\n-- to the values of the\
  \ corresponding indicies of l, but sorted.\n-- >>> sort_third({1, 2, 3})\n-- {1,\
  \ 2, 3}\n-- >>> sort_third({5, 6, 3, 4, 8, 9, 2})\n-- {2, 6, 3, 4, 8, 9, 5}\nlocal\
  \ function sort_third(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_third\n\
  \    lu.assertEquals(candidate({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5})\n\
  \    lu.assertEquals(candidate({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5})\n\
  \    lu.assertEquals(candidate({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5})\n\
  \    lu.assertEquals(candidate({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5,\
  \ 1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal n = #l\n\tlocal ret = {}\n\tfor i = 1, n do\n\t\tif i % 3 ==\
    \ 0 then\n\t\t\tlocal t = {}\n\t\t\tfor j = i - 2, i do\n\t\t\t\ttable.insert(t,\
    \ l[j])\n\t\t\tend\n\t\t\ttable.sort(t)\n\t\t\tfor k = 1, 3 do\n\t\t\t\tret[#ret\
    \ + 1] = t[k]\n\t\t\tend\n\t\telse\n\t\t\tret[#ret + 1] = l[i]\n\t\tend\n\tend\n\
    \treturn ret\nend", "\tfor i = 3, #l, 3 do\n\t\ttable.sort(l, i - 2, i)\n\tend\n\
    \treturn l\nend", "  local sorted_list = {}\n  for i,v in ipairs(l) do\n    if\
    \ i % 3 == 0 then\n      local sort_table = {table.unpack(l, i-2, i)}\n      table.sort(sort_table)\n\
    \      sorted_list[i-2] = sort_table[1]\n      sorted_list[i-1] = sort_table[2]\n\
    \      sorted_list[i] = sort_table[3]\n    else\n      sorted_list[i] = v\n  \
    \  end\n  end\n  return sorted_list\nend", "    local ret = {}\n    for i, v in\
    \ ipairs(l) do\n        if i % 3 == 0 then\n            table.insert(ret, i, table.sort(v))\n\
    \        else\n            table.insert(ret, i, v)\n        end\n    end\n   \
    \ return ret\nend", "    local sorted = {}\n    for index, value in ipairs(l)\
    \ do\n        if (index - 1) % 3 == 0 then\n            table.insert(sorted, index,\
    \ value)\n        else\n            table.insert(sorted, index, value)\n     \
    \   end\n    end\n    return sorted\nend", "    local o = {}\n    for i, v in\
    \ ipairs(l) do\n        if i % 3 == 0 then\n            o[i] = table.sort(v)\n\
    \        else\n            o[i] = v\n        end\n    end\n    return o\nend",
  "    local even = {}\n    local odd = {}\n    for i = 1, #l do\n        if math.fmod(i,\
    \ 2) == 0 then\n            table.insert(even, l[i])\n        else\n         \
    \   table.insert(odd, l[i])\n        end\n    end\n    table.sort(odd)\n    for\
    \ i = 1, #even do\n        odd[i] = even[i]\n    end\n    return odd\nend", " \
    \ local new_list = {}\n  for i, v in ipairs(l) do\n    if i % 3 == 0 then\n  \
    \    table.insert(new_list, sort(v))\n    else\n      table.insert(new_list, v)\n\
    \    end\n  end\n  return new_list\nend", "  if l == nil then\n    return nil\n\
    \  end\n  local res = {}\n  for i = 1, #l do\n    if i % 3 == 0 then\n      local\
    \ tmp = {}\n      for j = i - 2, i do\n        table.insert(tmp, l[j])\n     \
    \ end\n      table.sort(tmp)\n      res[i - 2] = tmp[1]\n      res[i - 1] = tmp[2]\n\
    \      res[i] = tmp[3]\n    else\n      res[i] = l[i]\n    end\n  end\n  return\
    \ res\nend", "    local function sort(a, b)\n        if a < b then\n         \
    \   return a, b\n        else\n            return b, a\n        end\n    end\n\
    \    local ret = {}\n    for i, v in ipairs(l) do\n        if i % 3 == 0 then\n\
    \            local a, b = sort(v, l[i - 1])\n            table.insert(ret, a)\n\
    \            table.insert(ret, b)\n        else\n            table.insert(ret,\
    \ v)\n        end\n    end\n    return ret\nend", "    local lp = {}\n    for\
    \ i = 1, #l do\n        if i % 3 == 0 then\n            table.insert(lp, table.sort(l[i]))\n\
    \        else\n            table.insert(lp, l[i])\n        end\n    end\n    return\
    \ lp\nend", "\tlocal function less(a, b)\n\t\treturn a < b\n\tend\n\tlocal function\
    \ swap(a, b)\n\t\tlocal temp = l[a]\n\t\tl[a] = l[b]\n\t\tl[b] = temp\n\tend\n\
    \tlocal function sort(start, stop)\n\t\tif start == stop then\n\t\t\treturn\n\t\
    \tend\n\t\tlocal pivot = start\n\t\tlocal pivot_element = l[pivot]\n\t\tfor i\
    \ = start + 1, stop do\n\t\t\tif less(l[i], pivot_element) then\n\t\t\t\tpivot\
    \ = pivot + 1\n\t\t\t\tswap(pivot, i)\n\t\t\tend\n\t\tend\n\t\tswap(start, pivot)\n\
    \t\tif pivot > start + 1 then\n\t\t\tsort(start, pivot - 1)\n\t\tend\n\t\tif pivot\
    \ < stop then\n\t\t\tsort(pivot + 1, stop)\n\t\tend\n\tend\n\tfor i = 3, #l, 3\
    \ do\n\t\tsort(i, i + 2)\n\tend\n\treturn l\nend", "    local l_prime = {}\n \
    \   for i = 1, #l do\n        if i % 3 == 0 then\n            local new_list =\
    \ {table.unpack(l, i - 2, i)}\n            table.sort(new_list)\n            l_prime[i\
    \ - 2] = new_list[1]\n            l_prime[i - 1] = new_list[2]\n            l_prime[i]\
    \ = new_list[3]\n        else\n            l_prime[i] = l[i]\n        end\n  \
    \  end\n    return l_prime\nend", "\tlocal l_new = {}\n\tfor i = 1, #l do\n\t\t\
    if (i % 3) == 0 then\n\t\t\ttable.insert(l_new, ipairs(table.sort(l[i])))\n\t\t\
    else\n\t\t\ttable.insert(l_new, l[i])\n\t\tend\n\tend\n\treturn l_new\nend", "\t\
    local f = function(l)\n\t\treturn l[3] <= l[2]\n\tend\n\tlocal e = function(l)\n\
    \t\treturn f(l) and f(l.__pairs)\n\tend\n\tlocal g = function(a, b)\n\t\treturn\
    \ a < b\n\tend\n\tlocal h = function(a, b)\n\t\treturn a[1] < b[1]\n\tend\n\t\
    return list.sort(l, g, f, e, h)\nend", "    if #l <= 3 then\n        return l\n\
    \    end\n    local l_final = {}\n    local l_sub = {}\n    for i, e in ipairs(l)\
    \ do\n        if i % 3 == 0 then\n            table.insert(l_sub, e)\n       \
    \     table.sort(l_sub)\n            table.insert(l_final, l_sub[1])\n       \
    \     table.insert(l_final, l_sub[2])\n            table.insert(l_final, l_sub[3])\n\
    \            l_sub = {}\n        else\n            table.insert(l_final, e)\n\
    \        end\n    end\n    return l_final\nend", "\treturn sort_third_internal(l,\
    \ #l)\nend", "  local result = {}\n  for i = 1, #l do\n    if i % 3 == 0 then\n\
    \      result[i] = sort(copy(l[i]))\n    else\n      result[i] = l[i]\n    end\n\
    \  end\n  return result\nend", "    local function less_than(left, right)\n  \
    \      return left < right\n    end\n    local sorted = {}\n    for i, v in ipairs(l)\
    \ do\n        if i % 3 == 0 then\n            local copy = {}\n            for\
    \ j, v in ipairs(l) do\n                copy[j] = v\n            end\n       \
    \     table.sort(copy, less_than)\n            sorted[i] = copy[i]\n        else\n\
    \            sorted[i] = v\n        end\n    end\n    return sorted\nend", "\t\
    local new_table = {}\n\tfor i, v in ipairs(l) do\n\t\tif i % 3 == 0 then\n\t\t\
    \tlocal list = {}\n\t\t\tfor j, v in ipairs(l) do\n\t\t\t\tif j >= i - 2 and j\
    \ <= i then\n\t\t\t\t\ttable.insert(list, v)\n\t\t\t\tend\n\t\t\tend\n\t\t\ttable.sort(list)\n\
    \t\t\tfor j, v in ipairs(list) do\n\t\t\t\ttable.insert(new_table, v)\n\t\t\t\
    end\n\t\telse\n\t\t\ttable.insert(new_table, v)\n\t\tend\n\tend\n\treturn new_table\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
