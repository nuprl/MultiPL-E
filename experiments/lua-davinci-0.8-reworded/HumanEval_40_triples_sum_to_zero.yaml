name: HumanEval_40_triples_sum_to_zero
language: lua
prompt: "-- triples_sum_to_zero takes a table of integers as an input.\n-- it returns\
  \ true if there are three distinct elements in the table that\n-- sum to zero, and\
  \ false otherwise.\n-- >>> triples_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> triples_sum_to_zero({1,\
  \ 3, -2, 1})\n-- true\n-- >>> triples_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>>\
  \ triples_sum_to_zero({2, 4, -5, 3, 9, 7})\n-- true\n-- >>> triples_sum_to_zero({1})\n\
  -- false\nlocal function triples_sum_to_zero(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triples_sum_to_zero\n\
  \    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1,\
  \ 3, 5, -1}), false)\n    lu.assertEquals(candidate({1, 3, -2, 1}), true)\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 7}), false)\n    lu.assertEquals(candidate({1, 2, 5, 7}), false)\n    lu.assertEquals(candidate({2,\
  \ 4, -5, 3, 9, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({1,\
  \ 3, 5, -100}), false)\n    lu.assertEquals(candidate({100, 3, 5, -100}), false)\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal tab = {}\n\tfor k, v in pairs(l) do\n\t\ttab[v] = k\n\tend\n\
    \tfor k, v in pairs(l) do\n\t\tfor m, n in pairs(l) do\n\t\t\tif (m ~= k) and\
    \ (tab[-v-n] ~= nil) then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    return false\nend", "\t-- check for single element list\n\tif #l == 1 then\n\t\
    \treturn false\n\tend\n\t-- check for two element list\n\tif #l == 2 then\n\t\t\
    return false\n\tend\n\t-- check for empty list\n\tif #l == 0 then\n\t\treturn\
    \ false\n\tend\n\t-- loop through the list of length n\n\tfor i = 1, #l do\n\t\
    \t-- loop through the list of length n - 1\n\t\tfor j = 1, #l - 1 do\n\t\t\t--\
    \ loop through the list of length n - 2\n\t\t\tfor k = 1, #l - 2 do\n\t\t\t\t\
    -- check for distinct elements in the list and sum to zero\n\t\t\t\tif l[i] ~=\
    \ l[j] and l[i] ~= l[k] and l[j] ~= l[k] and l[i] + l[j] + l[k] == 0 then\n\t\t\
    \t\t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend",
  "  -- l is a table of integers, for example:\n  --   l = {1, 3, 5, 0}\n  -- The\
    \ goal is to determine if there are three distinct elements in l that\n  -- sum\
    \ to zero.", "  -- Since Lua has no built-in hash tables, we use an array to implement\n\
    \  -- the hash table.  The boolean values are stored at indices\n  -- \n  -- abs(x)\
    \ * 1000 + x,\n  --\n  -- where x is an integer.\n  --\n  -- This is a bit space-inefficient,\
    \ but it is extremely fast.\n  --\n  -- (If you are familiar with C++ or Java,\
    \ this is the \"map\" data structure.\n  -- In other programming languages, the\
    \ \"dictionary\" or \"hash map\" data\n  -- structure.)\n  local hash = {}\n \
    \ for _,x in ipairs(l) do\n    local hash_key = math.abs(x) * 1000 + x\n    hash[hash_key]\
    \ = true\n  end\n  for _,x in ipairs(l) do\n    for _,y in ipairs(l) do\n    \
    \  if x ~= y then\n        -- The variable \"hash_key\" is used as an index for\
    \ the \"hash\" table.\n        -- The table is used to store information about\
    \ the numbers that are\n        -- present in the list \"l\".\n        local hash_key\
    \ = math.abs(x+y) * 1000 + x+y\n        if hash[hash_key] then\n          return\
    \ true\n        end\n      end\n    end\n  end\n  return false\nend", "    local\
    \ i, j, k\n    for i=1,#l do\n        for j=i+1,#l do\n            for k=j+1,#l\
    \ do\n                if l[i] + l[j] + l[k] == 0 then\n                    return\
    \ true\n                end\n            end\n        end\n    end\n    return\
    \ false\nend", "  -- return false if the list has fewer than 3 elements.\n  if\
    \ #l < 3 then\n    return false\n  end", "    local hash = {}\n    for i, v in\
    \ ipairs(l) do\n        hash[v] = v\n    end\n    for i, v in ipairs(l) do\n \
    \       for j, w in ipairs(l) do\n            if i ~= j then\n               \
    \ local x = -1 * (v + w)\n                if hash[x] then\n                  \
    \  return true\n                end\n            end\n        end\n    end\n \
    \   return false\nend", "\tif #l < 3 then return false end", "  local i = 0\n\
    \  local j = 0\n  local k = 0\n  local sum = 0\n  for i = 1, #l do\n    for j\
    \ = i + 1, #l do\n      for k = j + 1, #l do\n        sum = l[i] + l[j] + l[k]\n\
    \        if sum == 0 then\n          return true\n        end\n      end\n   \
    \ end\n  end\n  return false\nend", "  if #l < 3 then\n    return false\n  end\n\
    \  for i, v in ipairs(l) do\n    for j, v1 in ipairs(l) do\n      for k, v2 in\
    \ ipairs(l) do\n        if v1 ~= v and v2 ~= v and v1 + v2 + v == 0 then\n   \
    \       return true\n        end\n      end\n    end\n  end\n  return false\n\
    end", "    if #l < 3 then\n        return false\n    end\n    -- If a triplet\
    \ sums to zero, then so does (-a, -b, -c)\n    -- So we can negate all elements\
    \ and check for a triplet summing to zero\n    for i, v in ipairs(l) do\n    \
    \    l[i] = -v\n    end\n    -- O(n^2) algorithm:\n    -- sort the list\n    local\
    \ function comp(a, b)\n        return a < b\n    end\n    table.sort(l, comp)\n\
    \    -- loop through the list\n    -- for each element, use a two-pointer approach\
    \ to find the remaining two elements\n    -- that sum to it\n    local left =\
    \ 1\n    local right = #l\n    while left < right - 1 do\n        while left <\
    \ right - 1 and l[left] + l[right] < l[left + 1] do\n            left = left +\
    \ 1\n        end\n        if left < right - 1 and l[left] + l[right] == l[left\
    \ + 1] then\n            return true\n        end\n        right = right - 1\n\
    \    end\n    return false\nend", "\tlocal function is_solution(l, i, j, k)\n\t\
    \treturn l[i] + l[j] + l[k] == 0\n\tend\n\tlocal function is_new_solution(l, i,\
    \ j, k)\n\t\treturn i ~= j and j ~= k and i ~= k\n\tend\n\tlocal function valid_subproblem(l,\
    \ i, j, k)\n\t\treturn i < #l and j < #l and k < #l\n\tend\n\tlocal function triples_sum_to_zero_helper(l,\
    \ i, j, k)\n\t\tif valid_subproblem(l, i, j, k) then\n\t\t\tif is_solution(l,\
    \ i, j, k) and is_new_solution(l, i, j, k) then\n\t\t\t\treturn true\n\t\t\telse\n\
    \t\t\t\tif k < #l - 1 then\n\t\t\t\t\tif triples_sum_to_zero_helper(l, i, j, k\
    \ + 1) then\n\t\t\t\t\t\treturn true\n\t\t\t\t\telse\n\t\t\t\t\t\tif j < #l -\
    \ 1 then\n\t\t\t\t\t\t\tif triples_sum_to_zero_helper(l, i, j + 1, j + 2) then\n\
    \t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tif i < #l - 2\
    \ then\n\t\t\t\t\t\t\t\t\tif triples_sum_to_zero_helper(l, i + 1, i + 2, i + 3)\
    \ then\n\t\t\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\
    \t\t\treturn false\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\
    \t\treturn false\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\telse\n\t\
    \t\t\t\t\t\treturn false\n\t\t\t\t\t\tend\n\t\t\t\t\tend", "    local found =\
    \ false\n    for i = 1, #l do\n        for j = i + 1, #l do\n            for k\
    \ = j + 1, #l do\n                if l[i] + l[j] + l[k] == 0 then\n          \
    \          found = true\n                end\n            end\n        end\n \
    \   end\n    return found\nend", "    local ret = false\n    local list = l\n\
    \    for k, _ in pairs(list) do\n        for l, _ in pairs(list) do\n        \
    \    for m, _ in pairs(list) do\n                if k ~= l and k ~= m and l ~=\
    \ m then\n                    if list[k] + list[l] + list[m] == 0 then\n     \
    \                   ret = true\n                    end\n                end\n\
    \            end\n        end\n    end\n    return ret\nend", "    for i = 1,\
    \ #l - 2 do\n        for j = i + 1, #l - 1 do\n            for k = j + 1, #l do\n\
    \                if l[i] + l[j] + l[k] == 0 then\n                    return true\n\
    \                end\n            end\n        end\n    end\n    return false\n\
    end", "    return false\nend", "    local t = {}\n    for _, v in ipairs(l) do\n\
    \        t[v] = (t[v] or 0) + 1\n    end\n    for _, v in ipairs(l) do\n     \
    \   t[v] = t[v] - 1\n        if t[-v] then\n            if t[-v] > 0 then\n  \
    \              return true\n            end\n        end\n        for _, w in\
    \ ipairs(l) do\n            if w ~= v and t[w] > 0 then\n                if t[0\
    \ - v - w] then\n                    if t[0 - v - w] > 0 then\n              \
    \          return true\n                    end\n                end\n       \
    \     end\n        end\n        t[v] = t[v] + 1\n    end\n    return false\nend",
  "    local map = {}\n    for _, v in ipairs(l) do\n        if not map[v] then\n\
    \            map[v] = 0\n        end\n        map[v] = map[v] + 1\n    end\n \
    \   for _, v in ipairs(l) do\n        for _, w in ipairs(l) do\n            if\
    \ (v == -w) then\n                if (map[v] > 1 or map[w] > 1) then\n       \
    \             return true\n                end\n            else\n           \
    \     if (map[-v-w]) then\n                    return true\n                end\n\
    \            end\n        end\n    end\n    return false\nend", "  local len =\
    \ #l\n  if len < 3 then\n    return false\n  end\n  for i = 1, len - 2 do\n  \
    \  for j = i + 1, len - 1 do\n      for k = j + 1, len do\n        if l[i] + l[j]\
    \ + l[k] == 0 then\n          return true\n        end\n      end\n    end\n \
    \ end\n  return false\nend", "\t-- sort the table\n\ttable.sort(l)\n\t-- find\
    \ the leftmost index that is greater than zero\n\tlocal i = 1\n\twhile l[i] <\
    \ 0 do\n\t\ti = i + 1\n\tend\n\t-- find the rightmost index that is less than\
    \ zero\n\tlocal j = #l\n\twhile l[j] > 0 do\n\t\tj = j - 1\n\tend\n\t-- for each\
    \ positive element, find a pair of negative elements that sum to\n\t-- the negative\
    \ of the positive element\n\tfor k = i, #l do\n\t\tlocal t = sum_to_zero_finder(l,\
    \ 1, j, k)\n\t\tif t ~= nil then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn\
    \ false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
