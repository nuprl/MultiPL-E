name: HumanEval_49_modp
language: lua
prompt: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n\
  -- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n--\
  \ 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
  \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
  \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
  \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
  \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return n % p\nend", "  if n == 0 then return 1 end\n  if n % 2 ==\
    \ 0 then\n    local tmp = modp(n/2, p)\n    return tmp * tmp % p\n  else\n   \
    \ return n * modp(n-1, p) % p\n  end\nend", "\tlocal b = to_binary(n)\n\tlocal\
    \ r = 1\n\tfor i = #b, 1, -1 do\n\t\tr = (r * r) % p\n\t\tif b[i] == 1 then\n\t\
    \t\tr = (r * 2) % p\n\t\tend\n\tend\n\treturn r\nend", "  assert(n >= 0, \"expected\
    \ n >= 0\")\n  if n == 0 then return 1 end\n  if n < 1024 then\n    -- efficient\
    \ for small n\n    return 2^n % p\n  else\n    -- beware of the numerics for large\
    \ n\n    local N = 2^(n % (intlog2(p)-1))\n    return (N * 2^(n - n % (intlog2(p)-1)))\
    \ % p\n  end\nend", "    local t = 1\n    local r = 1\n    for i = 0, p-1 do\n\
    \        if n & t > 0 then\n            r = (r * 2) % p\n        end\n       \
    \ t = t * 2\n    end\n    return r\nend", "\tassert(p > 1, \"prime number p must\
    \ be > 1\")\n\tassert(type(n) == \"number\", \"n must be a number\")\n\tassert(type(p)\
    \ == \"number\", \"p must be a number\")\n\tlocal ret = 1\n\tfor i = 1, n do\n\
    \t\tret = ret * 2 % p\n\tend\n\treturn ret\nend", "    if n == 0 then\n      \
    \  return 1\n    elseif n == 1 then\n        return n\n    elseif n % 2 == 0 then\n\
    \        local e = modp(n / 2, p)\n        return (e * e) % p\n    else\n    \
    \    return (n * modp(n - 1, p)) % p\n    end\nend", "  if n == 0 then return\
    \ 1 end\n  local u = 2^math.mod(n, p-1)\n  local res = math.mod(u * 2^math.floor(n/(p-1)),\
    \ p)\n  return res\nend", "\tif p <= 0 then error('p must be > 0', 2) end\n\t\
    if n < 0 then error('n must be >= 0', 2) end\n\tif n == 0 then return 1 end\n\t\
    if n % 2 == 0 then\n\t\treturn (modp(n/2, p)^2) % p\n\telse\n\t\treturn (2 * modp(n-1,\
    \ p)) % p\n\tend\nend", "  local res = 1\n  local x = n\n  while n > 0 do\n  \
    \  if n % 2 == 1 then\n      res = (res * x) % p\n    end\n    x = (x * x) % p\n\
    \    n = math.floor(n / 2)\n  end\n  return res\nend", "    return floor(p * (n\
    \ - floor(n / p) * p))\nend", "    local res = 1\n    for i = 1, n do\n      \
    \  res = res * 2 % p\n    end\n    return res\nend", "    if p == 1 then\n   \
    \     return 0\n    end\n    if n == 0 then\n        return 1\n    end\n    local\
    \ x = modp(n//2, p)\n    local x = (x * x) % p\n    if n % 2 == 1 then\n     \
    \   x = (x * 2) % p\n    end\n    return x\nend", "  local r = 1\n  local x =\
    \ n\n  while n > 0 do\n    if n % 2 == 1 then\n      r = (r * x) % p\n    end\n\
    \    x = (x * x) % p\n    n = math.floor(n / 2)\n  end\n  return r\nend", "  local\
    \ r = 1\n  for i = 1, #n do\n    local d = n:sub(i, i)\n    r = (r * 2^d) % p\n\
    \  end\n  return r\nend", "  local val = 1\n  for i = 1, n do\n    val = (val\
    \ * 2) % p\n  end\n  return val\nend", "    local r = 1\n    while n > 0 do\n\
    \        if n % 2 == 1 then\n            r = (r * 2) % p\n        end\n      \
    \  n = math.floor(n / 2)\n    end\n    return r\nend", "    local n = n % p\n\
    \    if n == 0 then\n        return 1\n    else\n        return n\n    end\nend",
  "  if n == 0 then return 1 end\n  local nn = modp(n>>1, p)^2 % p\n  if n & 1 ==\
    \ 1 then\n    return nn * 2 % p\n  else\n    return nn\n  end\nend", "    if (n\
    \ == 0) then\n        return 1\n    elseif (n % 2 == 0) then\n        return (modp(n\
    \ / 2, p) ^ 2) % p\n    else\n        return (modp(n - 1, p) * 2) % p\n    end\n\
    end", "  return (2^n) % p\nend", "  local s = 1\n  while n ~= 0 do\n    if n %\
    \ 2 == 1 then\n      s = (s * 10) % p\n    end\n    n = math.floor(n / 2)\n  \
    \  local t = (10 * 10) % p\n    if t == 0 then\n      error(\"failed to compute\
    \ 2^n modulo p\")\n    end\n    10 = t\n  end\n  return s\nend", "    local r\
    \ = 1\n    local a = 2 % p\n    while n > 0 do\n        if n % 2 == 1 then\n \
    \           r = (r * a) % p\n        end\n        n = math.floor(n / 2)\n    \
    \    a = (a * a) % p\n    end\n    return r\nend", "    local r = 1\n    local\
    \ x = n % p\n    while n > 0 do\n        if n % 2 == 1 then\n            r = (r\
    \ * x) % p\n        end\n        n = math.floor(n / 2)\n        x = (x * x) %\
    \ p\n    end\n    return r\nend", "    local r = 1\n    local t = n\n    while\
    \ t > 0 do\n        if bit32.band(t, 1) == 1 then\n            r = bit32.band(r\
    \ * n, p)\n        end\n        t = bit32.rshift(t, 1)\n        n = bit32.band(n\
    \ * n, p)\n    end\n    return r\nend", "  -- a^n mod p\n  local function modp_a(a,\
    \ n, p)\n    if n == 0 then\n      return 1\n    elseif n % 2 == 0 then\n    \
    \  local b = modp_a(a, n / 2, p)\n      return b * b % p\n    else\n      return\
    \ a * modp_a(a, n - 1, p) % p\n    end\n  end\n  if n < 0 then\n    return modp_a(1\
    \ / 2, -n, p)\n  else\n    return modp_a(2, n, p)\n  end\nend", "  local x = 1\n\
    \  local y = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      x = (x * y) %\
    \ p\n    end\n    y = (y * y) % p\n    n = math.floor(n / 2)\n  end\n  return\
    \ x\nend", "  -- Use recursion to calculate [2^n mod p].\n  -- The first case\
    \ is trivial, in the second we\n  -- use the two-squares formula for powers of\
    \ two.\n  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 2\n \
    \ elseif n % 2 == 0 then\n    local t = modp(n/2, p)\n    return (t * t) % p\n\
    \  else\n    return (2 * modp(n-1, p)) % p\n  end\nend", "    if n < 0 then n\
    \ = n % p + p end\n    local res = 1\n    while n > 0 do\n        if n % 2 ==\
    \ 1 then res = (res * 2) % p end\n        n = n // 2\n    end\n    return res\n\
    end", "  -- This is a binary exponentiation algorithm\n  local m = 1\n  local\
    \ base = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      m = (m * base) % p\n\
    \    end\n    base = (base * base) % p\n    n = math.floor(n / 2)\n  end\n  return\
    \ m\nend", "    -- Numerical problems arise in the following line: p^(n+1) is\n\
    \    -- evaluated in arbitrary precision, then converted to a float;\n    -- then\
    \ the next integer, and the next integer is no longer\n    -- accurate.\n    local\
    \ f = math.floor((p^(n+1) - 1) / p)\n    return (f % p) + 1\nend", "    local\
    \ m = 1\n    while n > 0 do\n        if n % 2 == 1 then\n            m = (m *\
    \ 2) % p\n        end\n        n = math.floor(n / 2)\n    end\n    return m\n\
    end", "  local h = 1\n  for i = 1, n do\n    h = (h * 2) % p\n  end\n  return\
    \ h\nend", "  local a = 1\n  local d = 2\n  if n == 0 then\n    return 1\n  end\n\
    \  while n > 0 do\n    if n % 2 == 1 then\n      a = (a * d) % p\n    end\n  \
    \  d = (d * d) % p\n    n = math.floor(n / 2)\n  end\n  return a\nend", "  local\
    \ function pow(b, e)\n    if e < 0 then return 1 end\n    if e == 0 then return\
    \ b end\n    local tmp = pow(b, math.floor(e/2))\n    if e % 2 == 0 then\n   \
    \   return tmp * tmp % p\n    else\n      return b * tmp * tmp % p\n    end\n\
    \  end\n  return pow(2, n)\nend", "    if n == 0 then\n        return 1\n    elseif\
    \ n % 2 == 0 then\n        return (modp(n/2, p)^2) % p\n    else\n        return\
    \ (modp(n/2, p)^2 * 2) % p\n    end\nend", "    local n = n % p\n    if n < 0\
    \ then\n        n = n + p\n    end\n    return n\nend", "    local r = 1\n   \
    \ while n > 0 do\n        if n % 2 == 1 then\n            r = (r * 2) % p\n  \
    \      end\n        n = math.floor(n / 2)\n    end\n    return r\nend", "\tlocal\
    \ nn = mod(n, p)\n\tif nn == 0 then\n\t\treturn 1\n\telse\n\t\treturn nn\n\tend\n\
    end", "    local res = 1\n    local p2 = p", "\tlocal r = 1\n\tn = mod(n, 2^32)\n\
    \tfor i = 1, 32 do\n\t\tif n % 2 == 1 then\n\t\t\tr = mod(r * 2, p)\n\t\tend\n\
    \t\tn = n / 2\n\tend\n\treturn r\nend", "    local r = 1\n    while n > 0 do\n\
    \        if bit.band(n, 1) == 1 then\n            r = (r * 2) % p\n        end\n\
    \        n = bit.rshift(n, 1)\n    end\n    return r\nend", "  if n == 0 then\n\
    \    return 1\n  elseif n % 2 == 0 then\n    local m = modp(n/2, p)\n    return\
    \ (m*m) % p\n  else\n    return (2 * modp(n-1, p)) % p\n  end\nend", "    if n\
    \ == 0 then\n        return 1\n    elseif n % 2 == 0 then\n        return (modp(n/2,\
    \ p) ^ 2) % p\n    else\n        return (2 * modp(n - 1, p)) % p\n    end\nend",
  "    local res = 1\n    for i = 1, n do\n        res = res * 2 % p\n    end\n  \
    \  return res\nend", "  if p <= 0 then\n    error('Second argument to modp must\
    \ be positive')\n  end\n  if n <= p then\n    return n\n  end\n  -- The modular\
    \ inverse of 2 modulo p is 1 if p is odd and 2 if p is even.\n  local n2 = n &\
    \ 1\n  n = n2 + (n2 - 1) * (n2 + 1) * p\n  n = n // 2\n  if n >= p then\n    n\
    \ = n - p\n  end\n  return n\nend", "\tlocal a = 1\n\tlocal two = 2\n\twhile n\
    \ > 0 do\n\t\tif n % 2 == 1 then\n\t\t\ta = (a * two) % p\n\t\tend\n\t\ttwo =\
    \ (two * two) % p\n\t\tn = math.floor(n / 2)\n\tend\n\treturn a\nend", "  if n\
    \ < p or n == p then\n    return n\n  end\n  -- n = 2^a * n' where a + lg(n')\
    \ < lg(p).\n  local k = floor(lg(n)/lg(2))\n  local a = 2^k\n  local n_ = n /\
    \ a\n  -- Invariant: n = 2^a * n' where n' mod p is the result of the computation\n\
    \  -- so far, and a + lg(n') < lg(p).\n  while a > 0 do\n    -- Compute 2^(2*a)\
    \ mod p.\n    -- sq(n', p) = (n'^2) mod p\n    local sq_n_ = sq(n_, p)\n    --\
    \ Use the identity (2*n')^2 = 4*n'^2 to reduce the exponentiation\n    -- modulo\
    \ p.\n    local b = 2 * a\n    while b > 0 do\n      -- sq_n_^2 = (n'^2)^2 = n'^4\
    \ mod p\n      sq_n_ = sq(sq_n_, p)\n      b = b - 1\n    end\n    -- A result\
    \ of 1 would mean that 2^(2*a) = 1 mod p, and since gcd(p, 2) = 1,\n    -- that\
    \ would mean that a = 0 (mod p-1), which is impossible since a < p-1.\n    if\
    \ sq_n_ ~= 1 then\n      -- If a is odd, we can just multiply the result by 2.\n\
    \      if a % 2 == 1 then\n        -- n' * 2^(a + 1) = n' * (2 * 2^a) = n' * 2^a\
    \ * 2 = n * 2 mod p\n        n_ = (n_ * 2) % p\n      else\n        -- If a is\
    \ even, we have to square the result, since 2^(2*a) = 2^(a/2)^2.\n        -- (n'\
    \ * 2^(a/2))^2 = n'^2 * 2^a = 2^a * n'^2 = 2^a * n' mod p\n        n_ = sq_",
  "\tlocal n = n % p\n\tif n < 0 then\n\t\tn = n + p\n\tend\n\treturn n\nend", " \
    \   local res = 1\n    for _ = 1, n do\n        res = res * 2 % p\n    end\n \
    \   return res\nend", "  if p == 2 then\n    return 1\n  end\n  local x = 1\n\
    \  for i = 1, n do\n    x = (x * 2) % p\n  end\n  return x\nend", "  return ((2^n)\
    \ % p)\nend", "    local x = 1\n    while n > 0 do\n        if n % 2 == 1 then\n\
    \            x = (x * 2) % p\n        end\n        n = math.floor(n / 2)\n   \
    \ end\n    return x\nend", "  if n == 0 then\n    return 1\n  elseif n == 1 then\n\
    \    return 2\n  elseif n == 2 then\n    return 4\n  elseif n == 3 then\n    return\
    \ 8\n  elseif n == 4 then\n    return 16\n  elseif n == 5 then\n    return 32\n\
    \  elseif n == 6 then\n    return 64\n  elseif n == 7 then\n    return 128\n \
    \ elseif n == 8 then\n    return 29\n  elseif n == 9 then\n    return 58\n  elseif\
    \ n == 10 then\n    return 116\n  elseif n == 11 then\n    return 232\n  elseif\
    \ n == 12 then\n    return 205\n  elseif n == 13 then\n    return 135\n  elseif\
    \ n == 14 then\n    return 19\n  elseif n == 15 then\n    return 38\n  elseif\
    \ n == 16 then\n    return 76\n  elseif n == 17 then\n    return 152\n  elseif\
    \ n == 18 then\n    return 45\n  elseif n == 19 then\n    return 90\n  elseif\
    \ n == 20 then\n    return 180\n  elseif n == 21 then\n    return 117\n  elseif\
    \ n == 22 then\n    return 234\n  elseif n == 23 then\n    return 201\n  elseif\
    \ n == 24 then\n    return 143\n  elseif n == 25 then\n    return 3\n  elseif\
    \ n == 26 then\n    return 6\n  elseif n == 27 then\n    return 12\n  elseif n\
    \ == 28 then\n    return 24\n  elseif n == 29 then\n    return 48\n  elseif n\
    \ == 30 then\n    return 96\n  elseif n == 31 then\n    return 192\n  elseif n\
    \ == 32 then\n    return 157\n  elseif n == 33 then\n    return 39\n  elseif n\
    \ == 34 then\n    return 78\n  elseif n == 35 then\n    return 156\n  elseif n\
    \ == 36 then\n    return 37\n  elseif n == 37 then\n    return 74\n  elseif n\
    \ == 38 then\n    return 148\n  elseif n == 39 then\n    return 53\n  elseif n\
    \ == 40 then\n    return 106\n  elseif n == 41 then\n    return 212\n  elseif\
    \ n == 42 then\n", "  local a = 1\n  local b = 2\n  while true do\n    if n ==\
    \ 0 then\n      return a\n    elseif n % 2 == 1 then\n      n = n - 1\n      a\
    \ = (a * b) % p\n    end\n    n = n / 2\n    b = (b * b) % p\n  end\nend", "\t\
    local r = 1\n\tlocal d = 2 % p\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\
    \tr = (r * d) % p\n\t\tend\n\t\tn = n / 2\n\t\td = (d * d) % p\n\tend\n\treturn\
    \ r\nend", "  local res = 1\n  while n > 0 do\n    if n % 2 == 1 then\n      res\
    \ = (res * 2) % p\n    end\n    n = math.floor(n / 2)\n  end\n  return res\nend",
  "  -- The implementation takes into account that exponents grow quickly\n  -- and\
    \ may overflow the integer size; it does not suffer from the\n  -- the same problem\
    \ itself because the modulus is prime.\n  local y = 1\n  local z = n\n  while\
    \ z > 0 do\n    if z % 2 == 1 then\n      y = (y * n) % p\n    end\n    n = (n\
    \ * n) % p\n    z = z // 2\n  end\n  return y\nend", "    local k = 0\n    while\
    \ n >= p do\n        n = n - p\n        k = k + 1\n    end\n    while k > 0 do\n\
    \        n = n + p\n        k = k - 1\n    end\n    return n\nend", "    local\
    \ n1 = n % p\n    if n1 < 0 then\n        n1 = n1 + p\n    end\n    return n1\n\
    end", "    local x = 1\n    while n > 0 do\n        if (n % 2) == 1 then\n   \
    \         x = (x * 2) % p\n        end\n        n = n / 2\n    end\n    return\
    \ x\nend", "  local r, a = 0, 1\n  while n > 0 do\n    if n % 2 == 1 then\n  \
    \    r = (r + a) % p\n    end\n    a = (a * 2) % p\n    n = math.floor(n / 2)\n\
    \  end\n  return r\nend", "\tif p == 1 then\n\t\treturn 0\n\tend\n\tlocal res\
    \ = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * 2) % p\n\t\
    \tend\n\t\tn = n / 2\n\tend\n\treturn res\nend", "    return (2^n) % p\nend",
  "\tif n == 0 then\n\t\treturn 1\n\telseif n % 2 == 0 then\n\t\treturn modp(n / 2,\
    \ p) ^ 2 % p\n\telse\n\t\treturn n * modp(n - 1, p) % p\n\tend\nend", "    return\
    \ n % p\nend", "    assert(p > 0, \"modulo must be a positive integer\")\n   \
    \ assert(n >= 0, \"n must be a non-negative integer\")\n    local function pow(x,\
    \ n)\n        if n == 0 then return 1 end\n        if n == 1 then return x end\n\
    \        if n % 2 == 0 then\n            local y = pow(x, n / 2)\n           \
    \ return y * y % p\n        else\n            return x * pow(x, n - 1) % p\n \
    \       end\n    end\n    return pow(2, n) % p\nend", "    -- note: negative numbers\
    \ can occur here\n    local z = 0\n    local prod = 1\n    local res = 1\n   \
    \ while prod <= n do\n        prod = prod * 2\n        z = z + 1\n    end\n  \
    \  -- start at the top, so we don't need to square 1 all the time\n    for i =\
    \ z, 0, -1 do\n        res = (res * res) % p\n        if 2^i <= n then\n     \
    \       res = (res * 2) % p\n        end\n    end\n    return res\nend", "\tlocal\
    \ res = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * 2) % p\n\
    \t\tend\n\t\tn = n / 2\n\tend\n\treturn res\nend", "  local base, res = 2, 1\n\
    \  for i = 1, n do\n    res = (res * base) % p\n  end\n  return res\nend", " \
    \ return math.floor(math.fmod(math.pow(2, n), p))\nend", "    local x = n\n  \
    \  local y = 1\n    local t = 0\n    while x ~= 0 do\n        if bit.band(x, 1)\
    \ == 1 then\n            t = p - t\n            y = (p - y) * t % p\n        else\n\
    \            y = y * t % p\n        end\n        t = (t * t) % p\n        x =\
    \ bit.rshift(x, 1)\n    end\n    return y\nend", "    if n == 0 then\n       \
    \ return 1\n    elseif p == 2 then\n        return n % 2\n    else\n        local\
    \ res = modp(2 * (n % p), p) % p\n        if n % 2 == 0 then\n            return\
    \ res\n        else\n            return (res * 2) % p\n        end\n    end\n\
    end", "    local m = 1\n    for i = 1, n do\n        m = m * 2 % p\n    end\n\
    \    return m\nend", "    return mod(2^n, p)\nend", "    local res = 1\n    local\
    \ two = 2 % p\n    for i = 1, n do\n        res = (res * two) % p\n    end\n \
    \   return res\nend", "    if n == 0 then\n        return 1\n    elseif n == 1\
    \ then\n        return 0\n    elseif n == 2 then\n        return 1\n    elseif\
    \ n > 2 then\n        local k = n % 2\n        if k == 0 then\n            return\
    \ modp(n/2, p) * (1 - modp(2, p)) % p\n        else\n            return (1 - modp(n-1,\
    \ p)) % p\n        end\n    end\nend", "  local z = 0\n  while n > 0 do\n    local\
    \ t = bit.band(n, 1)\n    if t == 1 then\n      z = (z + 1) % p\n    end\n   \
    \ n = bit.rshift(n, 1)\n    if n > 0 then\n      z = bit.lshift(z, 1) % p\n  \
    \  end\n  end\n  return z\nend", "  local function rec(n, p, s)\n    if n == 0\
    \ then return 1 end\n    if n == 1 then return s end\n    if n % 2 == 0 then\n\
    \      return rec(n / 2, p * p, s)\n    else\n      return rec(n - 1, p * p, s\
    \ * p)\n    end\n  end\n  return rec(n, p, p) % p\nend", "  local result = 1\n\
    \  for i = 1, n do\n    result = (result * 2) % p\n  end\n  return result\nend",
  "  if n == 0 then\n    return 1\n  elseif n % 2 == 0 then\n    local m = modp(n/2,\
    \ p)\n    return (m*m) % p\n  else\n    return (2 * modp(n-1, p)) % p\n  end\n\
    end", "    local result = 1\n    local base = 2\n    local sq = base*base", " \
    \ local r = 1\n  local m = n\n  while m > 0 do\n    if (m % 2) == 1 then\n   \
    \   r = (r * n) % p\n    end\n    n = (n * n) % p\n    m = math.floor(m / 2)\n\
    \  end\n  return r\nend", "\tlocal ap = math.abs(p)\n\tif n == 0 then\n\t\treturn\
    \ 1\n\telseif n % 2 == 0 then\n\t\treturn modp(2 * n, p) % ap\n\telse\n\t\treturn\
    \ (2 * modp(n, p)) % ap\n\tend\nend", "    -- p can't be even!\n    assert(p %\
    \ 2 == 1)\n    if n == 0 then\n        return 1\n    elseif n == 1 then\n    \
    \    return 2\n    else\n        -- We need the base case because the modulo inside\
    \ the loop\n        -- can overflow (doesn't fit in a C double).\n        local\
    \ r = modp(n-1, p) * 2\n        while r > p do\n            r = r - p\n      \
    \  end\n        return r\n    end\nend", "    if n > p then\n        n = n % p\n\
    \    end\n    if n == 0 then\n        return 1\n    end\n    local rems = {}\n\
    \    repeat\n        local rem = n % 2\n        rems[#rems + 1] = rem\n      \
    \  n = (n - rem) / 2\n    until n == 0\n    local res = 1\n    for i = #rems,\
    \ 1, -1 do\n        res = (res * res) % p\n        if rems[i] == 1 then\n    \
    \        res = (res * 2) % p\n        end\n    end\n    return res\nend", "  \
    \  local x = 1\n    local y = 2\n    while n > 0 do\n        if n % 2 == 1 then\n\
    \            x = (x * y) % p\n        end\n        y = (y * y) % p\n        n\
    \ = n // 2\n    end\n    return x\nend", "  if n == 0 then\n    return 1\n  elseif\
    \ n % 2 == 0 then\n    local d = modp(n / 2, p)\n    return (d * d) % p\n  else\n\
    \    return (modp(n - 1, p) * n) % p\n  end\nend", "    local r = 1\n    while\
    \ n > 0 do\n        if n % 2 == 1 then\n            r = (r * 2) % p\n        end\n\
    \        n = n / 2\n    end\n    return r\nend", "  local k, result = 1, 1\n \
    \ while k <= n do\n    result = (result * 2) % p\n    k = k + 1\n  end\n  return\
    \ result\nend", "    return lf.reduce(lf.mulmod, 1, lf.take(n, lf.iterate(lf.mulmod,\
    \ 2, p)))\nend", "    -- http://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method\n\
    \    -- http://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    local r =\
    \ 1\n    local b = n\n    local pw = p - 2\n    while pw > 0 do\n        if pw\
    \ % 2 == 1 then\n            r = (r * b) % p\n        end\n        b = (b * b)\
    \ % p\n        pw = math.floor(pw / 2)\n    end\n    return r\nend", "    local\
    \ res = 1\n    while n > 0 do\n        if (n % 2) == 1 then\n            res =\
    \ (res * p) % MOD\n        end\n        p = (p * p) % MOD\n        n = math.floor(n\
    \ / 2)\n    end\n    return res\nend", "    if p == 1 then\n        return 0\n\
    \    end\n    local r = 1\n    while n > 0 do\n        if n % 2 == 1 then\n  \
    \          r = (r * 2) % p\n        end\n        n = math.floor(n / 2)\n    end\n\
    \    return r\nend", "  if p == 1 then return 0 end\n  local pow = p\n  while\
    \ n % 2 == 0 do\n    n = n / 2\n    pow = pow * pow % p\n  end\n  local m = 1\n\
    \  while n > 1 do\n    m = m * pow % p\n    n = n - 1\n  end\n  return m\nend",
  "  local l, e, r = 0, n, 1\n  while e > 0 do\n    l, e, r = l + 1, floor(e / 2),\
    \ r * r % p\n    if bit.band(e, 1) == 1 then\n      r = r * n % p\n    end\n \
    \ end\n  return r\nend", "    -- 2 ^ (4k) == 1 mod p\n    local x = modp2k(n %\
    \ (p - 1), p)\n    if n >= p - 1 then\n        x = (x * 2) % p\n    end\n    return\
    \ x\nend", "    if n < 0 then\n        return modp(-n, p)\n    end\n    local\
    \ result = 1\n    local t = n\n    local pp = p\n    while t > 0 do\n        if\
    \ t % 2 == 1 then\n            result = (result * pp) % p\n        end\n     \
    \   t = math.floor(t / 2)\n        pp = (pp * pp) % p\n    end\n    return result\n\
    end", "    local r = 1\n    local a = 2\n    while n > 0 do\n        local d =\
    \ n % 2\n        if d == 1 then\n            r = (r * a) % p\n        end\n  \
    \      n = (n - d) / 2\n        a = (a * a) % p\n    end\n    return r\nend",
  "  local ap = (p - 1)\n  local b, e = 0, 1\n  while n > 0 do\n    b, e = e, ((n\
    \ % 2) * ap + e) % p\n    n = math.floor(n / 2)\n    ap = (ap * ap) % p\n  end\n\
    \  return e\nend", "  if n == 0 then return 1 end\n  if n % 2 == 0 then\n    return\
    \ ((modp(n/2, p) % p) ^ 2) % p\n  else\n    return (n * modp(n-1, p)) % p\n  end\n\
    end", "  if n == 0 then return 1 end\n  if n % 2 == 0 then\n    return (modp(n\
    \ / 2, p) ^ 2) % p\n  else\n    return (2 * modp(n - 1, p)) % p\n  end\nend",
  "\t-- Compute modulo with the naive method O(n)\n\tif n == 0 then\n\t\treturn 1\n\
    \tend\n\tlocal y = 1\n\tfor _ = 1, n do\n\t\ty = (y * 2) % p\n\tend\n\treturn\
    \ y\nend", "    local r = 1\n    for d in tostring(n):gmatch('.') do\n       \
    \ d = tonumber(d)\n        r = (r * r) % p\n        if d == 1 then\n         \
    \   r = (r * 2) % p\n        end\n    end\n    return r\nend", "  local r = 1\n\
    \  for i = 1, n do\n    r = (r * 2) % p\n  end\n  return r\nend", "    if p <=\
    \ 2 then\n        return p\n    end\n    local result = 1\n    while n > 0 do\n\
    \        if n % 2 == 1 then\n            result = (result * 2) % p\n        end\n\
    \        n = math.floor(n / 2)\n    end\n    return result\nend", "    local x\
    \ = 1\n    local pow2 = 2\n    local c = n\n    while c > 0 do\n        if c %\
    \ 2 == 1 then\n            x = (x * pow2) % p\n        end\n        pow2 = (pow2\
    \ * pow2) % p\n        c = math.floor(c / 2)\n    end\n    return x\nend", " \
    \ local r = 1\n  local a = 2 % p\n  local p2 = p * p\n  while n > 0 do\n    if\
    \ n % 2 == 1 then\n      r = (r * a) % p2\n    end\n    n = math.floor(n / 2)\n\
    \    a = (a * a) % p2\n  end\n  return r % p\nend", "\tif p <= 0 then\n\t\terror(\"\
    The prime number in 'modp' must be positive.\")\n\tend\n\tlocal result = 1\n\t\
    local x = n % p\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tresult = (result\
    \ * x) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\t\tx = (x * x) % p\n\tend\n\t\
    return result\nend", "\tlocal result = 1\n\twhile n > 0 do\n\t\tif bit.band(n,\
    \ 1) > 0 then\n\t\t\tresult = result * 2 % p\n\t\tend\n\t\tn = bit.rshift(n, 1)\n\
    \tend\n\treturn result\nend", "    if n == 0 then\n        return 1\n    elseif\
    \ n == 1 then\n        return p\n    elseif n % 2 == 0 then\n        return (modp(n\
    \ / 2, p) ^ 2) % p\n    else\n        return (modp(n - 1, p) * p) % p\n    end\n\
    end", "  if n == 0 then return 1 end\n  if n == 1 then return p end\n  local modv\
    \ = modp(n/2, p)\n  if n % 2 == 0 then\n    return modv * modv % p\n  else\n \
    \   return modv * modv * p % p\n  end\nend", "    if p == 2 then\n        return\
    \ 1\n    end\n    local fac = 1\n    while n > 0 do\n        if n % 2 == 1 then\n\
    \            fac = (fac * 2) % p\n        end\n        n = math.floor(n / 2)\n\
    \    end\n    return fac\nend", "    -- You are here because you do not know what\
    \ type metatables are.\n    -- Congratulations, you have found this comment.\n\
    \    -- Lua is an object-oriented language, but it does not have classes.\n  \
    \  -- Instead, it has *metatables* which are used to simulate classes.\n    --\
    \ Metatables can be used to define the operations of a certain type.\n    -- Since\
    \ Lua's types are mutable, it is even possible to assign a\n    -- metatable to\
    \ an instance of a certain type.\n    -- Since Lua is dynamically typed, you can\
    \ also assign a metatable to\n    -- a table and every table that does not have\
    \ a metatable associated with\n    -- it in Lua is a table. Lua's tables are actually\
    \ implemented as hash\n    -- tables and when you assign a metatable to a table,\
    \ it becomes a\n    -- hash table that has a metatable.\n    -- This is used to\
    \ make arithmetic possible in Lua using the __add,\n    -- __sub, __mul, __div,\
    \ __mod, __pow and __unm metamethods.\n    -- When you call a + b and a or b have\
    \ a metatable assigned, it will\n    -- try to execute the __add metamethod that\
    \ is assigned to the metatable\n    -- of a or b.\n    -- This is how we define\
    \ the modulo operation for the numeric type in Lua.\n    -- Since the result of\
    \ this function is only used for the comparison\n    -- \"a == b\", we can just\
    \ assign a metatable to the number returned by\n    -- this function and it will\
    \ use the __eq metamethod that is assigned\n    -- to this metatable.\n    --\
    \ Since the number we are operating on is actually a string, we would\n    --\
    \ need to define the modulo operation for strings as well.\n    -- Since the number\
    \ returned by this function is only used for the\n    -- comparison \"a == b\"\
    , we can just assign a metatable to the number\n    -- returned by this function\
    \ and it will use the __eq metamethod that\n    -- is assigned to this metatable.\n\
    \    local mt = {\n        __add = function(a, b)\n            return a + b -\
    \ p * math.floor((a + b) / p)\n        end,\n        __sub", "  local p2 = p *\
    \ 2\n  local m = 0\n  for i = 1, n do\n    local n2 = m * 2\n    if n2 >= p2 then\n\
    \      m = n2 - p2\n    else\n      m = n2\n    end\n  end\n  return m - p\nend",
  "    local res = 1\n    for _ = 1, n do\n        res = res * 2 % p\n    end\n  \
    \  return res\nend", "\tif p == 1 then\n\t\treturn 0\n\tend\n\tlocal res = 1\n\
    \twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * 2) % p\n\t\tend\n\
    \t\tn = math.floor(n / 2)\n\tend\n\treturn res\nend", "    return n % p\nend",
  "    local res = 1\n    while n > 0 do\n        if n % 2 == 1 then\n           \
    \ res = (res * 2) % p\n        end\n        n = n // 2\n    end\n    return res\n\
    end", "    local b = 1\n    local k = 0\n    while k < n do\n        b = (b *\
    \ 2) % p\n        k = k + 1\n    end\n    return b\nend", "\tlocal a = 1\n\tlocal\
    \ b = 2\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\ta = (a * b) % p\n\t\t\
    end\n\t\tn = math.floor(n / 2)\n\t\tb = (b * b) % p\n\tend\n\treturn a\nend",
  "  local r = 1\n  while n > 0 do\n    if n % 2 == 1 then\n      r = (r * 2) % p\n\
    \    end\n    n = math.floor(n / 2)\n  end\n  return r\nend", "  assert(p > 0)\n\
    \  if n >= p then\n    n = n % p\n  end\n  local result = 1\n  for bit=0,30 do\n\
    \    if n >= 2^bit then\n      result = (result * result) % p\n      if n >= 2^(bit+1)\
    \ then\n        result = (result * 2) % p\n      end\n    end\n  end\n  return\
    \ result\nend", "  if n >= p then\n    local m = modp(n, p * 2)\n    if m < p\
    \ then\n      return m\n    else\n      return m - p\n    end\n  elseif n >= 1\
    \ then\n    return n\n  elseif n == 0 then\n    return 1\n  else\n    return modp(p\
    \ - (-n) % p, p)\n  end\nend", "    local result = 1\n    local base = 2\n   \
    \ while n > 0 do\n        if n % 2 == 1 then\n            result = (result * base)\
    \ % p\n        end\n        n = math.floor(n / 2)\n        base = (base * base)\
    \ % p\n    end\n    return result\nend", "  local result = 1\n  for i = 1, n do\n\
    \    result = (result * 2) % p\n  end\n  return result\nend", "    local k = 2\n\
    \    local a = 1\n    local b = 2\n    while b <= n do\n        a = a * b % p\n\
    \        b = b * k\n    end\n    return a\nend", "  if n == 0 then return 1 end\n\
    \  local t = n % 2\n  n = (n - t) / 2\n  local res = modp(n, p)\n  if t == 0 then\n\
    \    return (res * res) % p\n  else\n    return (res * res * 2) % p\n  end\nend",
  "    if p == 2 then\n        return 1\n    end\n    if p == 4 then\n        if n\
    \ % 2 == 0 then\n            return 1\n        else\n            return 3\n  \
    \      end\n    end\n    if p == 3 then\n        if n % 2 == 0 then\n        \
    \    return 1\n        else\n            return 2\n        end\n    end\n    local\
    \ np = 1\n    local i = 1\n    local x = 2\n    while i <= n do\n        x = (x\
    \ * x) % p\n        if n - i == 0 then\n            np = (np * x) % p\n      \
    \  end\n        i = i + 1\n    end\n    return np\nend", "  local i = 0\n  local\
    \ res = 1\n  while n ~= 0 do\n    if n % 2 == 1 then\n      res = (res * p) %\
    \ m\n    end\n    n = math.floor(n / 2)\n    p = (p ^ 2) % m\n  end\n  return\
    \ res\nend", "  if n == 0 then return 1 end\n  local r = 1\n  local rp = n % p\n\
    \  local q = n / p\n  for k = 0, q do\n    r = (r * rp) % p\n  end\n  return r\n\
    end", "    if n == 0 then\n        return 1\n    elseif n % 2 == 0 then\n    \
    \    return ((modp(n / 2, p) % p) ^ 2) % p\n    else\n        return (modp(n -\
    \ 1, p) * n) % p\n    end\nend", "  local m = 1\n  local res = 1\n  while n >\
    \ 0 do\n    if n % 2 == 1 then\n      res = (res * m) % p\n    end\n    m = (m\
    \ * m) % p\n    n = floor(n / 2)\n  end\n  return res\nend", "    local result\
    \ = 1\n    local _2exp = n\n    local _n = n\n    n = n % (p - 1)\n    while n\
    \ > 0 do\n        if n % 2 == 1 then\n            result = (result * _2exp) %\
    \ p\n        end\n        _2exp = (_2exp * _2exp) % p\n        n = math.floor(n\
    \ / 2)\n    end\n    return result\nend", "\t-- Base case.\n\tif n == 0 then\n\
    \t\treturn 1\n\tend", "  local r = 1\n  while n > 0 do\n    if n % 2 == 1 then\n\
    \      r = (r * 2) % p\n    end\n    n = floor(n / 2)\n  end\n  return r\nend",
  "  if n > p then return modp(n % p, p) end\n  local res = 1\n  for i = 1, n do\n\
    \    res = res * 2 % p\n  end\n  return res\nend", "\tif n == 0 then\n\t\treturn\
    \ 1\n\telseif n == 1 then\n\t\treturn n\n\telseif n == 2 then\n\t\treturn 1\n\t\
    elseif n % 2 == 0 then\n\t\tlocal r = modp(n/2, p)\n\t\treturn (r*r) % p\n\telse\n\
    \t\treturn (2 * modp(n-1, p)) % p\n\tend\nend", "  assert(n, \"need n\")\n  assert(p,\
    \ \"need p\")\n  if n == 0 then return 1 end\n  if n == 1 then return n end\n\
    \  local p2 = modp(n/2, p)\n  local p2e2 = (p2 * p2) % p\n  if n % 2 == 0 then\n\
    \    return p2e2\n  else\n    return (p2e2 * n) % p\n  end\nend", "  local m =\
    \ 1\n  for i = 1, n do\n    m = m * 2 % p\n  end\n  return m\nend", "\tlocal r\
    \ = 1\n\tfor i = 1, n do\n\t\tr = (r * 2) % p\n\tend\n\treturn r\nend", "\tif\
    \ n == 0 then\n\t\treturn 1\n\telseif n % 2 == 0 then\n\t\tlocal r = modp(n /\
    \ 2, p)\n\t\treturn (r * r) % p\n\telse\n\t\treturn (modp(n - 1, p) * n) % p\n\
    \tend\nend", "  local res = 1\n  n = n % p\n  while n > 0 do\n    if n % 2 ==\
    \ 1 then\n      res = (res * 2) % p\n    end\n    n = math.floor(n / 2)\n  end\n\
    \  return res\nend", "  local q = n / p\n  local r = n - q * p\n  if r < 0 then\n\
    \    r = r + p\n  end\n  return r\nend", "  assert(p > 1)\n  if n == 0 then return\
    \ 1 end\n  local m = modp(n // 2, p)\n  m = (m * m) % p\n  if n % 2 == 1 then\n\
    \    m = (m * 2) % p\n  end\n  return m\nend", "  if n == 0 then return 1 end\n\
    \  local r = n % 2\n  local n = n - r\n  return (r * modp(n, p) * modp(n, p))\
    \ % p\nend", "    local r = 1\n    for _ = 1, n do\n        r = r * 2 % p\n  \
    \  end\n    return r\nend", "    local r = 1\n    local d = n\n    repeat\n  \
    \      if d % 2 == 1 then\n            r = (r * n) % p\n        end\n        d\
    \ = d // 2\n        n = (n * n) % p\n    until d == 0\n    return r\nend", "\t\
    local x = 1\n\tlocal power = n\n\twhile power > 0 do\n\t\tlocal d = power % 2\n\
    \t\tif d == 1 then\n\t\t\tx = (x * n) % p\n\t\tend\n\t\tn = (n * n) % p\n\t\t\
    power = (power - d) / 2\n\tend\n\treturn x\nend", "    assert(n >= 0, \"input\
    \ should be non-negative\")\n    if n == 0 then\n        return 1\n    elseif\
    \ n % 2 == 0 then\n        return modp(n/2, p)^2 % p\n    else\n        return\
    \ (2 * modp(n-1, p)) % p\n    end\nend", "    assert(n>=0, \"negative exponent\"\
    )\n    assert(n>=0, \"negative modulus\")\n    local r = 1\n    local b = 2\n\
    \    while n>0 do\n        if n%2==1 then\n            r = (r*b)%p\n        end\n\
    \        n = math.floor(n/2)\n        b = (b*b)%p\n    end\n    return r\nend",
  "  local res = 1\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * 2)\
    \ % p\n    end\n    n = math.floor(n / 2)\n  end\n  return res\nend", "  if n\
    \ == 0 then return 1 end\n  if n % 2 == 0 then\n    local half = modp(n / 2, p)\n\
    \    return half * half % p\n  else\n    return n * modp(n - 1, p) % p\n  end\n\
    end", "  if n == 0 then return 1 end\n  local res = 1\n  local x = n\n  local\
    \ p_ = p\n  local one = bigint.bigint(1)\n  while x > 0 do\n    if x % 2 == 1\
    \ then\n      res = (res * x) % p_\n    end\n    x = math.floor(x / 2)\n    x\
    \ = bigint.bigint(x)\n    p_ = (p_ * p_) % p\n  end\n  return res\nend", "   \
    \ local res = 1\n    while n > 0 do\n        if n % 2 == 1 then\n            res\
    \ = (res * 2) % p\n        end\n        n = math.floor(n / 2)\n    end\n    return\
    \ res\nend", "    local q, r = math.modf(n / p)\n    return n - q * p\nend", " \
    \   if n == 0 then\n        return 1\n    elseif n == 1 then\n        return n\n\
    \    elseif n == 2 then\n        return n % p\n    else\n        local a = 1\n\
    \        local b = 1\n        for i = 1, n do\n            a = (a * 2) % p\n \
    \           b = (b * a) % p\n        end\n        return b\n    end\nend", " \
    \ if n == 0 then return 1 end\n  if n == 1 then return 2 end\n  local ans = 1\n\
    \  local t = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      ans = ans * t\
    \ % p\n    end\n    t = t * t % p\n    n = math.floor(n / 2)\n  end\n  return\
    \ ans\nend", "\tif p == 2 then\n\t\tif n % 2 == 0 then\n\t\t\treturn 2\n\t\telse\n\
    \t\t\treturn 1\n\t\tend\n\tend\n\tlocal ret = 1\n\tfor i = 1, n do\n\t\tret =\
    \ ret * 2\n\t\tif ret > p then\n\t\t\tret = ret - p\n\t\tend\n\tend\n\treturn\
    \ ret\nend", "    assert(p > 0, \"modulo not defined for p = \" .. p)\n    assert(n\
    \ >= 0, \"modulo not defined for n = \" .. n)\n    local i = 0\n    local a =\
    \ 1\n    local twop = 0\n    while twop < n do\n        twop = twop + twop + 1\n\
    \        i = i + 1\n    end\n    while i > 0 do\n        i = i - 1\n        twop\
    \ = twop - twop - 1\n        a = a * a % p\n        if twop < n then\n       \
    \     a = a * p % (p*p)\n        end\n    end\n    return a\nend", "    local\
    \ res = 1\n    for i = 1, n do\n        res = res * 2 % p\n    end\n    return\
    \ res\nend", "    if p == 2 then\n        return n % 2\n    end\n    if n == 0\
    \ then\n        return 1\n    end\n    local r = 1\n    local t = 2\n    while\
    \ n > 0 do\n        if n % 2 == 1 then\n            r = r * t % p\n        end\n\
    \        n = math.floor(n / 2)\n        t = t * t % p\n    end\n    return r\n\
    end", "  local k = 1\n  local nn = n\n  while nn > 0 do\n    nn = floor(nn / 2)\n\
    \    k = k * 2\n  end\n  k = min(k, p - 1)\n  local res = 1\n  while k > 0 do\n\
    \    if n >= k then\n      res = (res * 2) % p\n      n = n - k\n    end\n   \
    \ k = floor(k / 2)\n  end\n  return res\nend", "  local x = 1\n  while n > 0 do\n\
    \    if n % 2 == 1 then\n      x = (x * 2) % p\n    end\n    n = math.floor(n\
    \ / 2)\n  end\n  return x\nend", "\t-- n < p^2\n\tlocal nn = n % p\n\tif nn <=\
    \ p / 2 then\n\t\treturn nn\n\telse\n\t\treturn nn - p\n\tend\nend", "  local\
    \ r = 1\n  local x = 2 % p\n  local i = 0\n  while n > 0 do\n    if n % 2 == 1\
    \ then\n      r = (r * x) % p\n    end\n    x = (x * x) % p\n    n = n / 2\n \
    \   i = i + 1\n  end\n  return r\nend", "  local x, n = 1, n\n  while n ~= 0 do\n\
    \    if n % 2 == 1 then\n      x = (x * n) % p\n    end\n    n = n >> 1\n  end\n\
    \  return x\nend", "  if (n == 0) then\n    return 1\n  elseif (n % 2 == 0) then\n\
    \    return (modp(n/2, p)^2) % p\n  else\n    return (2 * modp(n-1, p)) % p\n\
    \  end\nend", "    if n < 0 then\n        n = -n\n    end\n    if n == 0 then\n\
    \        return 1\n    end\n    local l = math.floor(math.log(n, 2))\n    local\
    \ result = 1\n    while l >= 0 do\n        result = (result * result) % p\n  \
    \      if (n % (2 ^ l)) >= 1 then\n            result = (result * 2) % p\n   \
    \     end\n        l = l - 1\n    end\n    return result\nend", "  local r = 1\n\
    \  while n > 0 do\n    if n % 2 ~= 0 then\n      r = r * 2 % p\n    end\n    n\
    \ = n // 2\n  end\n  return r\nend", "\treturn bit32.bxor(n, (n-1) % p)\nend",
  "    if p == 2 then\n        if n % 2 == 0 then\n            return 2\n        else\n\
    \            return 1\n        end\n    end\n    if n == 0 then\n        return\
    \ 1\n    end\n    if n < 0 then\n        n = n + p\n    end\n    n = n % p\n \
    \   if n % 2 == 0 then\n        return modp(n / 2, p)\n    else\n        return\
    \ p - modp(p - n, p)\n    end\nend", "  local r = 1\n  local x = 2\n  while n\
    \ > 0 do\n    if n % 2 == 1 then\n      r = r * x % p\n    end\n    x = x * x\
    \ % p\n    n = math.floor(n / 2)\n  end\n  return r\nend", "\tlocal sq = 1\n\t\
    local res = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * sq)\
    \ % p\n\t\tend\n\t\tsq = (sq * sq) % p\n\t\tn = math.floor(n / 2)\n\tend\n\treturn\
    \ res\nend", "    if n == 0 then\n        return 1\n    elseif n % 2 == 0 then\n\
    \        local d = modp(n / 2, p)\n        return (d * d) % p\n    else\n    \
    \    return (2 * modp(n - 1, p)) % p\n    end\nend", "  local r = 1\n  for i =\
    \ 1, n do\n    r = (r * 2) % p\n  end\n  return r\nend", "  local r = 1\n  while\
    \ n > 0 do\n    if n % 2 == 1 then\n      r = (r * 2) % p\n    end\n    n = math.floor(n\
    \ / 2)\n  end\n  return r\nend", "\tlocal result = 1\n\tlocal b = n\n\twhile b\
    \ > 0 do\n\t\tif b % 2 == 1 then\n\t\t\tresult = (result * n) % p\n\t\tend\n\t\
    \tb = math.floor(b / 2)\n\t\tn = (n * n) % p\n\tend\n\treturn result\nend", " \
    \ local res = 1\n  local v = 2\n  while true do\n    if n == 0 then\n      return\
    \ res\n    end\n    if n % 2 == 1 then\n      res = (res * v) % p\n    end\n \
    \   n = n // 2\n    v = (v * v) % p\n  end\nend", "    if n == 0 then\n      \
    \  return 1\n    elseif n == 1 then\n        return n\n    elseif n % 2 == 0 then\n\
    \        local t = modp(n/2, p)\n        return (t * t) % p\n    else\n      \
    \  return ((2 * modp(n-1, p)) % p)\n    end\nend", "  -- Local copies of the rules.\n\
    \  local R = rules.R\n  local S = rules.S\n  local U = rules.U\n  local V = rules.V\n\
    \  local W = rules.W\n  local E = rules.E\n  local B = rules.B\n  local D = rules.D\n\
    \  local F = rules.F\n  local H = rules.H\n  local K = rules.K\n  local L = rules.L\n\
    \  local M = rules.M\n  local P = rules.P\n  local Z = rules.Z\n  local q = n\n\
    \  local r = n\n  local r_mod = n % p\n  local total_bits = n:len()\n  local cur_bit_index\
    \ = total_bits\n  local cur_bit\n  -- for log(n) steps, that is O(log(n))\n  while\
    \ q > 1 do\n    q = math.floor(q / 2)\n    cur_bit_index = cur_bit_index - 1\n\
    \    cur_bit = S[total_bits + 1 - cur_bit_index]\n    if cur_bit == \"1\" then\n\
    \      r = r * r_mod\n      r_mod = r % p\n    end\n  end\n  return r_mod\nend",
  "    if n == 0 then\n        return 1\n    elseif n % 2 == 0 then\n        local\
    \ t = modp(n/2, p)\n        return (t * t) % p\n    else\n        return (modp(n-1,\
    \ p) * n) % p\n    end\nend", "  local res = 1\n  local b = n\n  while b > 0 do\n\
    \    if b % 2 == 1 then\n      res = (res * n) % p\n    end\n    n = (n * n) %\
    \ p\n    b = math.floor(b / 2)\n  end\n  return res\nend", "    local n = n %\
    \ p\n    if n < 0 then\n        n = n + p\n    end\n    return n\nend", "  if\
    \ n == 0 then\n    return 1\n  elseif n == 1 then\n    return 2\n  elseif n %\
    \ 2 == 0 then\n    local d = modp(n/2, p)\n    local x = (d * d) % p\n    if x\
    \ > p/2 then\n      return p - x\n    else\n      return x\n    end\n  else\n\
    \    local x = modp(n-1, p)\n    return (2 * x) % p\n  end\nend", "  local a =\
    \ 1\n  for i = 0, n - 1 do\n    a = (a * 2) % p\n  end\n  return a\nend", "  \
    \  local a = 1\n    for i = 1, n do\n        a = (a * 2) % p\n    end\n    return\
    \ a\nend", "  local a = 1\n  for i = 1, n do\n    a = (a * 2) % p\n  end\n  return\
    \ a\nend", "    if p == 1 then\n        return 0\n    end\n    if n == 0 then\n\
    \        return 1\n    end\n    local res = 1\n    for _ = 1, n do\n        res\
    \ = res * 2\n        if res >= p then\n            res = res % p\n        end\n\
    \    end\n    return res\nend", "    return b_mod(b_pow(2, n), p)\nend", "   \
    \ -- \u03A0\u03B1\u03C1\u03B1\u03C4\u03B7\u03C1\u03AE\u03C3\u03B5\u03B9\u03C2\
    :\n    -- \u038C\u03C3\u03BF n > 0, modp(n) = modp(n >> 1) ^ 2 mod p\n    -- \u038C\
    \u03C3\u03BF n > 0 \u03BA\u03B1\u03B9 (n & 1) == 1, modp(n) = modp(n - 1) * 2\
    \ mod p", "\tlocal m = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tm =\
    \ (m * 2) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\tend\n\treturn m\nend", " \
    \ if n == 0 then return 1 end\n  --if n % 2 == 0 then return (modp(n/2, p)^2)\
    \ % p end\n  local y = modp(n/2, p)\n  local z = y^2\n  local w = z % p\n  if\
    \ n % 2 == 0 then return w end\n  return (p*w) % p\nend", "    -- n=0: p-1 will\
    \ be 1, 0^1 is 0\n    if n == 0 then return 1 end\n    -- look at the bits\n \
    \   local r = 1\n    while n > 0 do\n        -- if bit is set, then add (2^i mod\
    \ p)\n        if n % 2 == 1 then\n            r = (r * 2) % p\n        end\n \
    \       -- shift n and i\n        n = floor(n / 2)\n    end\n    return r\nend",
  "  local res = 1\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * 2)\
    \ % p\n    end\n    n = math.floor(n / 2)\n  end\n  return res\nend", "\tlocal\
    \ r = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * 2) % p\n\t\t\
    end\n\t\tn = floor(n / 2)\n\tend\n\treturn r\nend", "    assert(n>=0, 'n must\
    \ be non-negative')\n    local r = 1\n    n = n % (p-1)\n    while n > 0 do\n\
    \        if n % 2 == 1 then\n            r = (r * 2) % p\n        end\n      \
    \  n = math.floor(n / 2)\n    end\n    return r\nend", "\tlocal res = 1\n\tlocal\
    \ a = n\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = res * a % p\n\t\
    \tend\n\t\ta = a * a % p\n\t\tn = n // 2\n\tend\n\treturn res\nend", "    if n\
    \ < p then\n        return n\n    end\n    local result = 1\n    local x = n\n\
    \    local y = p\n    while y > 0 do\n        local b = y % 2\n        if b ==\
    \ 1 then\n            result = (result * x) % p\n        end\n        x = (x *\
    \ x) % p\n        y = math.floor(y / 2)\n    end\n    return result\nend", "\t\
    local res = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * n)\
    \ % p\n\t\tend\n\t\tn = floor(n / 2)\n\tend\n\treturn res\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
