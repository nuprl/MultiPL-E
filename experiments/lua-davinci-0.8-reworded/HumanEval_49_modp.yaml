name: HumanEval_49_modp
language: lua
prompt: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n\
  -- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n--\
  \ 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
  \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
  \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
  \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
  \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return n % p\nend", "  if n == 0 then return 1 end\n  if n % 2 ==\
    \ 0 then\n    local tmp = modp(n/2, p)\n    return tmp * tmp % p\n  else\n   \
    \ return n * modp(n-1, p) % p\n  end\nend", "\tlocal b = to_binary(n)\n\tlocal\
    \ r = 1\n\tfor i = #b, 1, -1 do\n\t\tr = (r * r) % p\n\t\tif b[i] == 1 then\n\t\
    \t\tr = (r * 2) % p\n\t\tend\n\tend\n\treturn r\nend", "  assert(n >= 0, \"expected\
    \ n >= 0\")\n  if n == 0 then return 1 end\n  if n < 1024 then\n    -- efficient\
    \ for small n\n    return 2^n % p\n  else\n    -- beware of the numerics for large\
    \ n\n    local N = 2^(n % (intlog2(p)-1))\n    return (N * 2^(n - n % (intlog2(p)-1)))\
    \ % p\n  end\nend", "    local t = 1\n    local r = 1\n    for i = 0, p-1 do\n\
    \        if n & t > 0 then\n            r = (r * 2) % p\n        end\n       \
    \ t = t * 2\n    end\n    return r\nend", "\tassert(p > 1, \"prime number p must\
    \ be > 1\")\n\tassert(type(n) == \"number\", \"n must be a number\")\n\tassert(type(p)\
    \ == \"number\", \"p must be a number\")\n\tlocal ret = 1\n\tfor i = 1, n do\n\
    \t\tret = ret * 2 % p\n\tend\n\treturn ret\nend", "    if n == 0 then\n      \
    \  return 1\n    elseif n == 1 then\n        return n\n    elseif n % 2 == 0 then\n\
    \        local e = modp(n / 2, p)\n        return (e * e) % p\n    else\n    \
    \    return (n * modp(n - 1, p)) % p\n    end\nend", "  if n == 0 then return\
    \ 1 end\n  local u = 2^math.mod(n, p-1)\n  local res = math.mod(u * 2^math.floor(n/(p-1)),\
    \ p)\n  return res\nend", "\tif p <= 0 then error('p must be > 0', 2) end\n\t\
    if n < 0 then error('n must be >= 0', 2) end\n\tif n == 0 then return 1 end\n\t\
    if n % 2 == 0 then\n\t\treturn (modp(n/2, p)^2) % p\n\telse\n\t\treturn (2 * modp(n-1,\
    \ p)) % p\n\tend\nend", "  local res = 1\n  local x = n\n  while n > 0 do\n  \
    \  if n % 2 == 1 then\n      res = (res * x) % p\n    end\n    x = (x * x) % p\n\
    \    n = math.floor(n / 2)\n  end\n  return res\nend", "    return floor(p * (n\
    \ - floor(n / p) * p))\nend", "    local res = 1\n    for i = 1, n do\n      \
    \  res = res * 2 % p\n    end\n    return res\nend", "    if p == 1 then\n   \
    \     return 0\n    end\n    if n == 0 then\n        return 1\n    end\n    local\
    \ x = modp(n//2, p)\n    local x = (x * x) % p\n    if n % 2 == 1 then\n     \
    \   x = (x * 2) % p\n    end\n    return x\nend", "  local r = 1\n  local x =\
    \ n\n  while n > 0 do\n    if n % 2 == 1 then\n      r = (r * x) % p\n    end\n\
    \    x = (x * x) % p\n    n = math.floor(n / 2)\n  end\n  return r\nend", "  local\
    \ r = 1\n  for i = 1, #n do\n    local d = n:sub(i, i)\n    r = (r * 2^d) % p\n\
    \  end\n  return r\nend", "  local val = 1\n  for i = 1, n do\n    val = (val\
    \ * 2) % p\n  end\n  return val\nend", "    local r = 1\n    while n > 0 do\n\
    \        if n % 2 == 1 then\n            r = (r * 2) % p\n        end\n      \
    \  n = math.floor(n / 2)\n    end\n    return r\nend", "    local n = n % p\n\
    \    if n == 0 then\n        return 1\n    else\n        return n\n    end\nend",
  "  if n == 0 then return 1 end\n  local nn = modp(n>>1, p)^2 % p\n  if n & 1 ==\
    \ 1 then\n    return nn * 2 % p\n  else\n    return nn\n  end\nend", "    if (n\
    \ == 0) then\n        return 1\n    elseif (n % 2 == 0) then\n        return (modp(n\
    \ / 2, p) ^ 2) % p\n    else\n        return (modp(n - 1, p) * 2) % p\n    end\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
