name: HumanEval_6_parse_nested_parens
language: lua
prompt: "-- Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n-- For each of the group, output the deepest\
  \ level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n-- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  -- {2, 3, 1, 3}\nlocal function parse_nested_parens(paren_string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_nested_parens\n\
  \    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})\n \
  \   lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})\n    lu.assertEquals(candidate('(()(())((())))'),\
  \ {4})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local paren_groups = {}\n    for paren_group in paren_string:gmatch('%s*%(([^%)]*)%)%s*')\
    \ do\n        -- Count matching pairs of parentheses, i.e. level of nesting\n\
    \        local depth = paren_group:gsub('[^()]', ''):gsub('%(%(%(+)()', '%1'):gsub('()(%))%))',\
    \ '%1'):len()\n        table.insert(paren_groups, depth)\n    end\n    return\
    \ paren_groups\nend", "    local base_levels = {}\n    for paren_group in stringx.split(paren_string,\
    \ ' ') do\n        local levels = {}\n        local level = 0\n        for char\
    \ in stringx.split(paren_group, '') do\n            if char == '(' then\n    \
    \            level = level + 1\n            elseif char == ')' then\n        \
    \        level = level - 1\n            end\n            table.insert(levels,\
    \ level)\n        end\n        table.insert(base_levels, math.max(unpack(levels)))\n\
    \    end\n    return base_levels\nend", "    local paren_table = {}\n    local\
    \ lparen_count = 0\n    local depth = 0\n    for ch in paren_string:gmatch('.')\
    \ do\n        if ch == '(' then\n            lparen_count = lparen_count + 1\n\
    \            depth = depth + 1\n        elseif ch == ')' then\n            depth\
    \ = depth - 1\n            lparen_count = lparen_count - 1\n            if lparen_count\
    \ == 0 then\n                table.insert(paren_table, depth)\n              \
    \  depth = 0\n            end\n        end\n    end\n    return paren_table\n\
    end", "    local depth_for_paren_group = {}\n    local depth = 0\n    local start\
    \ = 1\n    local max_depth = 0\n    local function process_group()\n        depth_for_paren_group[start]\
    \ = max_depth\n        start = i + 1\n        max_depth = 0\n    end\n    for\
    \ i = 1, #paren_string do\n        local ch = paren_string:sub(i, i)\n       \
    \ if ch == '(' then\n            depth = depth + 1\n            if depth > max_depth\
    \ then\n                max_depth = depth\n            end\n        elseif ch\
    \ == ')' then\n            depth = depth - 1\n        elseif ch == ' ' then\n\
    \            process_group()\n        end\n    end\n    process_group()\n    return\
    \ depth_for_paren_group\nend", "    local depth = {}\n    local max = 0\n    local\
    \ parens = re.findall('\\\\((+\\\\))', paren_string)\n    for i = 1, #parens do\n\
    \        local grp = parens[i]\n        depth[i] = #grp - 1\n        if depth[i]\
    \ > max then\n            max = depth[i]\n        end\n    end\n    -- Convert\
    \ to 1-indexed.\n    for i = 1, #depth do\n        depth[i] = depth[i] + 1\n \
    \   end\n    return depth\nend", "    local max_nested_levels = {}\n    for group\
    \ in paren_string:gmatch('%b()') do\n        local i = 0\n        for _ in group:gmatch('%b()')\
    \ do\n            i = i + 1\n        end\n        table.insert(max_nested_levels,\
    \ i)\n    end\n    return max_nested_levels\nend", "  local nested_parens = {}\n\
    \  for paren_substring in paren_string:gmatch(\"%S+\") do\n    local depth = 0\n\
    \    local max_depth = 0\n    for c in paren_substring:gmatch(\".\") do\n    \
    \  if c == '(' then\n        depth = depth + 1\n        if depth > max_depth then\n\
    \          max_depth = depth\n        end\n      elseif c == ')' then\n      \
    \  depth = depth - 1\n      end\n    end\n    table.insert(nested_parens, max_depth)\n\
    \  end\n  return nested_parens\nend", "    -- parse the paren string to a list\n\
    \    local paren_list = {}\n    for paren in paren_string:gmatch('%S+') do\n \
    \       paren_list[#paren_list + 1] = paren\n    end", "    --### if '()' is a\
    \ single token and we have 5 such tokens then we have '()' => 1, '()()' => 2 etc.\n\
    \    --### but if '(())' is a single token then we have '()' => 1, '(())' => 2\
    \ etc.\n    local w = {}\n    local level = 0\n    local max_level = 0\n    for\
    \ t in stringx.split(paren_string) do\n        local l = t:len()\n        level\
    \ = level + l\n        if l > 1 then\n            level = level - 1\n        end\n\
    \        max_level = math.max(max_level, level)\n        table.insert(w, tostring(max_level))\n\
    \        if l > 1 then\n            level = level + 1\n        end\n    end\n\
    \    return w\nend", "\tlocal levels = {}\n\tlocal level = 0\n\tlocal max_level\
    \ = 0\n\tlocal groups = {}\n\tfor i = 1, #paren_string do\n\t\tlocal c = paren_string:sub(i,\
    \ i)\n\t\tif c == '(' then\n\t\t\tlevel = level + 1\n\t\t\tif level > max_level\
    \ then\n\t\t\t\tmax_level = level\n\t\t\tend\n\t\telseif c == ')' then\n\t\t\t\
    level = level - 1\n\t\telseif c == ' ' then\n\t\t\tgroups[#groups + 1] = level\n\
    \t\t\tlevel = 0\n\t\t\tmax_level = 0\n\t\tend\n\tend\n\treturn groups\nend", " \
    \ local max_nesting = {}\n  -- Strip whitespace.\n  paren_string = paren_string:gsub('%s',\
    \ '')\n  -- We keep an index into the paren string (which increments after every\
    \ group)\n  -- and a stack for counting the depth of nesting.\n  local i = 1\n\
    \  local stack = {}\n  while i <= #paren_string do\n    -- If the current character\
    \ is a '(' push onto the stack.\n    if paren_string:sub(i, i) == '(' then\n \
    \     table.insert(stack, 1)\n    -- If the current character is a ')' pop from\
    \ the stack.\n    elseif paren_string:sub(i, i) == ')' then\n      table.remove(stack)\n\
    \    end\n    -- Increment i.\n    i = i + 1\n    -- If i points to a space or\
    \ the end of the string, that means we're done with a group.\n    if paren_string:sub(i,\
    \ i) == ' ' or i > #paren_string then\n      -- Insert the maximum nesting of\
    \ the group into the result.\n      table.insert(max_nesting, #stack)\n      --\
    \ Reset the stack.\n      stack = {}\n    end\n  end\n  return max_nesting\nend",
  "  -- Note that the maximum number of nested parens is more than 1000. Hence, we\
    \ use a list to store the nestings.\n  local nestings = {}\n  local max_level\
    \ = 0\n  local current_level = 0\n  local current_index = 1\n  local i = 1\n \
    \ while i <= #paren_string do\n    local char = paren_string:sub(i, i)\n    if\
    \ char == '(' then\n      current_level = current_level + 1\n      max_level =\
    \ math.max(max_level, current_level)\n    elseif char == ')' then\n      nestings[current_index]\
    \ = current_level\n      current_index = current_index + 1\n      current_level\
    \ = current_level - 1\n    end\n    i = i + 1\n  end\n  return nestings\nend",
  "  local paren_group_list = split(paren_string, ' ')\n  local result = {}\n  for\
    \ _, paren_group in ipairs(paren_group_list) do\n    local depth = 0\n    local\
    \ max_depth = 0\n    for _, paren in utf8.codes(paren_group) do\n      if paren\
    \ == 40 then\n        depth = depth + 1\n        if depth > max_depth then\n \
    \         max_depth = depth\n        end\n      elseif paren == 41 then\n    \
    \    depth = depth - 1\n      end\n    end\n    table.insert(result, max_depth)\n\
    \  end\n  return result\nend", "\tlocal paren_level = 0\n\tlocal max_levels =\
    \ {}\n\tfor ch in paren_string:gmatch('.') do\n\t\tif ch == '(' then\n\t\t\tparen_level\
    \ = paren_level + 1\n\t\telseif ch == ')' then\n\t\t\tmax_levels[#max_levels +\
    \ 1] = paren_level\n\t\t\tparen_level = paren_level - 1\n\t\tend\n\tend\n\treturn\
    \ max_levels\nend", "  local paren_groups = {}\n  local paren_level = 0\n  local\
    \ max_level = 0\n  local current_level = 0\n  local start_i = 1\n  local end_i\
    \ = 1\n  local max_i = string.len(paren_string)\n  while true do\n    while true\
    \ do\n      end_i = start_i\n      while true do\n        end_i = end_i + 1\n\
    \        if end_i > max_i then break end\n        if string.sub(paren_string,\
    \ end_i, end_i) == '(' then\n          current_level = current_level + 1\n   \
    \     elseif string.sub(paren_string, end_i, end_i) == ')' then\n          current_level\
    \ = current_level - 1\n        end\n        if current_level == 0 then break end\n\
    \      end\n      if current_level == 0 then break end\n      start_i = start_i\
    \ + 1\n    end\n    if max_level < current_level then max_level = current_level\
    \ end\n    current_level = 0\n    start_i = end_i + 1\n    if start_i > max_i\
    \ then break end\n  end\n  return max_level\nend", "    local levels = {}\n  \
    \  for group in paren_string:gmatch(\"%b()\") do\n        table.insert(levels,\
    \ _.reduce(group, function(acc, v)\n            if v == '(' then\n           \
    \     return acc + 1\n            elseif v == ')' then\n                return\
    \ acc - 1\n            end\n        end, 0))\n    end\n    return levels\nend",
  "  local stack = {}\n  local max_level = {}\n  local cur_level = 0\n  local cur_group\
    \ = 1\n  local char_seen = false\n  for i = 1, #paren_string do\n    local char\
    \ = paren_string:sub(i, i)\n    if char == ' ' then\n      if char_seen then\n\
    \        max_level[cur_group] = cur_level\n        cur_group = cur_group + 1\n\
    \        cur_level = 0\n        char_seen = false\n      end\n    else\n     \
    \ char_seen = true\n      if char == '(' then\n        table.insert(stack, char)\n\
    \        cur_level = cur_level + 1\n      elseif char == ')' then\n        table.remove(stack)\n\
    \        cur_level = cur_level - 1\n      end\n    end\n  end\n  if char_seen\
    \ then\n    max_level[cur_group] = cur_level\n  end\n  return max_level\nend",
  "  local max_level = {}\n  local level = 0\n  for i = 1, #paren_string do\n    local\
    \ s = paren_string:sub(i, i)\n    if s == '(' then\n      level = level + 1\n\
    \    elseif s == ')' then\n      level = level - 1\n    elseif s == ' ' then\n\
    \      max_level[#max_level + 1] = level\n      level = 0\n    end\n  end\n  max_level[#max_level\
    \ + 1] = level\n  return max_level\nend", "    local no_parens = paren_string:gsub('%s',\
    \ '')\n    local len = no_parens:len()\n    local no_parens_table = {}\n    for\
    \ i = 1, len do\n        no_parens_table[i] = no_parens:sub(i, i)\n    end\n \
    \   local level = 0\n    local max_level = 0\n    local max_level_table = {}\n\
    \    for i = 1, len do\n        local char = no_parens_table[i]\n        if char\
    \ == '(' then\n            level = level + 1\n        elseif char == ')' then\n\
    \            level = level - 1\n        end\n        if level > max_level then\n\
    \            max_level = level\n        end\n        if char == ')' then\n   \
    \         table.insert(max_level_table, max_level)\n            max_level = 0\n\
    \        end\n    end\n    return max_level_table\nend", "    local result = {}\n\
    \    for paren_group in paren_string:gmatch('[^%s]+') do\n        local level\
    \ = 0\n        local max_level = 0\n        for c in paren_group:gmatch('.') do\n\
    \            if c == '(' then\n                level = level + 1\n           \
    \ elseif c == ')' then\n                level = level - 1\n            end\n \
    \           max_level = math.max(max_level, level)\n        end\n        table.insert(result,\
    \ max_level)\n    end\n    return result\nend", "  local max_nested_parens = {}\n\
    \  local depth = 0\n  local max_depth = 0\n  for c in paren_string:gmatch('.')\
    \ do\n    if c == '(' then\n      depth = depth + 1\n      if depth > max_depth\
    \ then\n        max_depth = depth\n      end\n    elseif c == ')' then\n     \
    \ depth = depth - 1\n    elseif c == ' ' then\n      max_nested_parens[#max_nested_parens\
    \ + 1] = max_depth\n      max_depth = 0\n      depth = 0\n    end\n  end\n  max_nested_parens[#max_nested_parens\
    \ + 1] = max_depth\n  return max_nested_parens\nend", "    local res = {}\n  \
    \  local max_nesting = 0\n    local nesting = 0\n    for char in paren_string:gmatch('.')\
    \ do\n        if char == '(' then\n            nesting = nesting + 1\n       \
    \     max_nesting = max(max_nesting, nesting)\n        elseif char == ')' then\n\
    \            nesting = nesting - 1\n        end\n    end\n    table.insert(res,\
    \ max_nesting)\n    return res\nend", "  local groups = {}\n  local max_nest_by_group\
    \ = {}\n  local max_nest = 0\n  local max_nest_group = nil\n  local cur_nest =\
    \ 0\n  local cur_group = nil\n  for c in paren_string:gmatch('%S') do\n    if\
    \ c == '(' then\n      cur_nest = cur_nest + 1\n      if cur_nest > max_nest then\n\
    \        max_nest = cur_nest\n        max_nest_group = cur_group\n      end\n\
    \    elseif c == ')' then\n      cur_nest = cur_nest - 1\n      max_nest_by_group[cur_group]\
    \ = max_nest\n      max_nest = 0\n      cur_group = nil\n    else\n      cur_group\
    \ = c\n    end\n  end\n  return max_nest_by_group\nend", "    local paren_levels\
    \ = {}\n    local depth = 0\n    local max_depth = 0\n    for paren in paren_string:gmatch('%S')\
    \ do\n        if paren == '(' then\n            depth = depth + 1\n          \
    \  max_depth = math.max(max_depth, depth)\n        elseif paren == ')' then\n\
    \            depth = depth - 1\n        end\n    end\n    table.insert(paren_levels,\
    \ max_depth)\n    return paren_levels\nend", "\t-- for each group\n\tlocal paren_groups\
    \ = split(paren_string, \" \")\n\tlocal group_nest_levels = {}\n\tfor _, group\
    \ in ipairs(paren_groups) do\n\t\tlocal current_group_level = 0\n\t\tlocal max_group_level\
    \ = 0\n\t\tfor i = 1, #group do\n\t\t\tlocal letter = group:sub(i, i)\n\t\t\t\
    if letter == \"(\" then\n\t\t\t\tcurrent_group_level = current_group_level + 1\n\
    \t\t\t\tif current_group_level > max_group_level then\n\t\t\t\t\tmax_group_level\
    \ = current_group_level\n\t\t\t\tend\n\t\t\telseif letter == \")\" then\n\t\t\t\
    \tcurrent_group_level = current_group_level - 1\n\t\t\tend\n\t\tend\n\t\ttable.insert(group_nest_levels,\
    \ max_group_level)\n\tend\n\treturn group_nest_levels\nend", "    local paren_group\
    \ = split(paren_string, '%s+')\n    local max_paren_levels = {}\n    for _, group\
    \ in ipairs(paren_group) do\n        local count = group:gsub('[^()]', ''):gsub('()',\
    \ ''):len()\n        table.insert(max_paren_levels, count)\n    end\n    return\
    \ max_paren_levels\nend", "  local paren_groups = {}\n  local paren_levels = {}\n\
    \  local paren_groups_str = split(paren_string, ' ')\n  local group_idx = 1\n\
    \  for i = 1, #paren_groups_str do\n    local paren_group = paren_groups_str[i]\n\
    \    local count = 0\n    local level = 0\n    for i = 1, #paren_group do\n  \
    \    local paren = paren_group:sub(i, i)\n      if paren == '(' then\n       \
    \ count = count + 1\n        level = level + 1\n      elseif paren == ')' then\n\
    \        count = count - 1\n        if count == 0 then\n          table.insert(paren_groups,\
    \ paren_group)\n          table.insert(paren_levels, level)\n          group_idx\
    \ = group_idx + 1\n          break\n        end\n      end\n    end\n  end\n \
    \ return paren_groups, paren_levels\nend", "    local result = {}\n    local paren_group_start\
    \ = 0\n    local paren_group_end = 0\n    local idx = 1\n    while idx <= #paren_string\
    \ do\n        if paren_string:sub(idx, idx) == '(' then\n            if paren_group_start\
    \ == 0 then\n                paren_group_start = idx\n            end\n      \
    \      paren_group_end = idx\n        elseif paren_string:sub(idx, idx) == ')'\
    \ then\n            if paren_group_start > 0 then\n                paren_group_end\
    \ = idx\n            end\n        elseif paren_string:sub(idx, idx) == ' ' then\n\
    \            if paren_group_start > 0 then\n                local paren_group\
    \ = paren_string:sub(paren_group_start, paren_group_end)\n                table.insert(result,\
    \ #paren_group - paren_group:gsub('%(%(', ''):len())\n                paren_group_start\
    \ = 0\n                paren_group_end = 0\n            end\n        end\n   \
    \     idx = idx + 1\n    end\n    if paren_group_start > 0 then\n        local\
    \ paren_group = paren_string:sub(paren_group_start, paren_group_end)\n       \
    \ table.insert(result, #paren_group - paren_group:gsub('%(%(', ''):len())\n  \
    \  end\n    return result\nend", "    assert(type(paren_string) == 'string')\n\
    \    local groups = {}\n    for _, paren_group in pairs(stringx.split(paren_string,\
    \ ' ')) do\n        local group = {}\n        local max_depth = 0\n        local\
    \ cur_depth = 0\n        for i = 1, string.len(paren_group) do\n            local\
    \ char = string.sub(paren_group, i, i)\n            if char == '(' then\n    \
    \            cur_depth = cur_depth + 1\n                if cur_depth > max_depth\
    \ then\n                    max_depth = cur_depth\n                end\n     \
    \       elseif char == ')' then\n                cur_depth = cur_depth - 1\n \
    \           end\n        end\n        table.insert(groups, max_depth)\n    end\n\
    \    return groups\nend", "\tlocal depth = 0\n\tlocal max_depth = 0\n\tlocal paren_count\
    \ = 0\n\tlocal depths = {}\n\t\n\tfor i = 1, #paren_string do\n\t\tlocal char\
    \ = paren_string:sub(i, i)\n\t\tif char == '(' then\n\t\t\tdepth = depth + 1\n\
    \t\t\tmax_depth = math.max(max_depth, depth)\n\t\telseif char == ')' then\n\t\t\
    \tif depth > 0 then\n\t\t\t\tdepth = depth - 1\n\t\t\telse\n\t\t\t\tprint('Error:\
    \ unexpected )')\n\t\t\tend\n\t\telseif char == ' ' then\n\t\t\tdepths[paren_count]\
    \ = max_depth\n\t\t\tparen_count = paren_count + 1\n\t\t\tmax_depth = 0\n\t\t\t\
    depth = 0\n\t\tend\n\tend\n\t\n\treturn depths\nend", "  local paren_string =\
    \ paren_string:gsub('%s+', '')\n  local paren_arr = {}\n  local start_index =\
    \ 1\n  local max_level = 0\n  local i = 1\n  while i <= #paren_string do\n   \
    \ if paren_string:sub(i, i) == '(' then\n      local j = i + 1\n      local level\
    \ = 1\n      while j <= #paren_string do\n        if paren_string:sub(j, j) ==\
    \ '(' then\n          level = level + 1\n        elseif paren_string:sub(j, j)\
    \ == ')' then\n          level = level - 1\n          if level == 0 then\n   \
    \         break\n          end\n        end\n        j = j + 1\n      end\n  \
    \    paren_arr[#paren_arr + 1] = level\n      max_level = math.max(max_level,\
    \ level)\n      i = j\n    else\n      i = i + 1\n    end\n  end\n  local result\
    \ = {}\n  for i = 1, max_level do\n    result[i] = 0\n  end\n  for i = 1, #paren_arr\
    \ do\n    result[paren_arr[i]] = result[paren_arr[i]] + 1\n  end\n  return result\n\
    end", "    local paren_groups = tokenize(paren_string, ' ')\n    local paren_nesting\
    \ = {}\n    for i = 1, #paren_groups do\n        local max_nesting = 0\n     \
    \   local nesting = 0\n        for j = 1, #paren_groups[i] do\n            if\
    \ paren_groups[i]:sub(j, j) == '(' then\n                nesting = nesting + 1\n\
    \            elseif paren_groups[i]:sub(j, j) == ')' then\n                nesting\
    \ = nesting - 1\n            end\n            if nesting > max_nesting then\n\
    \                max_nesting = nesting\n            end\n        end\n       \
    \ paren_nesting[i] = max_nesting\n    end\n    return paren_nesting\nend", " \
    \   local res = {}\n    for match in paren_string:gmatch('%b()') do\n        local\
    \ lv = 1\n        for c in match:sub(2, -2):gmatch('.') do\n            if c ==\
    \ '(' then\n                lv = lv + 1\n            elseif c == ')' then\n  \
    \              lv = lv - 1\n            end\n        end\n        res[#res + 1]\
    \ = lv\n    end\n    return res\nend", "    local level_table = {}\n    local\
    \ level = 0\n    local paren_pat = S('()')\n    local paren_string = paren_string\n\
    \    local is_start = false\n    while #paren_string > 0 do\n        local paren\
    \ = paren_string:match(paren_pat)\n        if paren == '(' then\n            level\
    \ = level + 1\n            is_start = true\n        elseif paren == ')' then\n\
    \            level = level - 1\n            is_start = false\n        end\n  \
    \      paren_string = paren_string:sub(2)\n        if level == 0 and not is_start\
    \ then\n            table.insert(level_table, level)\n        end\n    end\n \
    \   return level_table\nend", "\tlocal result = {}\n\tlocal deepness = 0\n\tlocal\
    \ paren_ind = 0\n\tfor char in paren_string:gmatch('.') do\n\t\tif char == '('\
    \ then\n\t\t\tdeepness = deepness + 1\n\t\telseif char == ')' then\n\t\t\tresult[paren_ind]\
    \ = deepness\n\t\t\tdeepness = deepness - 1\n\t\t\tparen_ind = paren_ind + 1\n\
    \t\tend\n\tend\n\treturn result\nend", "  local paren_groups = {}\n  for parens\
    \ in string.gmatch(paren_string, \"[^%s]+\") do\n    local num_open = 0\n    local\
    \ num_close = 0\n    for i=1,#parens do\n      if parens:sub(i,i) == '(' then\n\
    \        num_open = num_open + 1\n      elseif parens:sub(i,i) == ')' then\n \
    \       num_close = num_close + 1\n      end\n    end\n    if num_open ~= num_close\
    \ then\n      log.warn(\"Mismatched parentheses in string: \", parens)\n    end\n\
    \    table.insert(paren_groups, num_open)\n  end\n  return paren_groups\nend",
  "\tassert(paren_string)\n\tlocal paren_groups = {}\n\tfor group in stringx.split(paren_string)\
    \ do\n\t\tlocal level = 0\n\t\tlocal max_level = 0\n\t\tfor ch in stringx.chars(group)\
    \ do\n\t\t\tif ch == '(' then\n\t\t\t\tlevel = level + 1\n\t\t\t\tmax_level =\
    \ math.max(max_level, level)\n\t\t\telseif ch == ')' then\n\t\t\t\tlevel = level\
    \ - 1\n\t\t\tend\n\t\tend\n\t\tassert(level == 0, 'Incorrect nesting of parentheses\
    \ in: ' .. group)\n\t\ttable.insert(paren_groups, max_level)\n\tend\n\treturn\
    \ paren_groups\nend", "  local paren_groups = split(paren_string, ' ')\n  local\
    \ max_levels = {}\n  for i, group in ipairs(paren_groups) do\n    local paren_count\
    \ = 0\n    local max_level = 0\n    for i = 1, group:len() do\n      if group:sub(i,\
    \ i) == '(' then\n        paren_count = paren_count + 1\n        if paren_count\
    \ > max_level then\n          max_level = paren_count\n        end\n      elseif\
    \ group:sub(i, i) == ')' then\n        paren_count = paren_count - 1\n      end\n\
    \    end\n    table.insert(max_levels, max_level)\n  end\n  return max_levels\n\
    end", "    local nested_levels = {}\n    local deep_level = 0\n    local cur_level\
    \ = 0\n    for token in paren_string:gmatch(\"%S+\") do\n        for _, char in\
    \ ipairs(token:split(\"\")) do\n            if char == \"(\" then\n          \
    \      cur_level = cur_level + 1\n                if cur_level > deep_level then\n\
    \                    deep_level = cur_level\n                end\n           \
    \ elseif char == \")\" then\n                cur_level = cur_level - 1\n     \
    \       end\n        end\n        nested_levels[#nested_levels + 1] = deep_level\n\
    \        deep_level = 0\n        cur_level = 0\n    end\n    return nested_levels\n\
    end", "  return ffi.C.parse_nested_parens(paren_string)\nend", "    local paren_groups\
    \ = paren_string:split(' ')\n    local deepest_levels = {}\n    for _, group in\
    \ ipairs(paren_groups) do\n        local current_level = 0\n        local max_level\
    \ = 0\n        for _, char in ipairs(group) do\n            if char == '(' then\n\
    \                current_level = current_level + 1\n            elseif char ==\
    \ ')' then\n                if current_level > max_level then\n              \
    \      max_level = current_level\n                end\n                current_level\
    \ = current_level - 1\n            end\n        end\n        table.insert(deepest_levels,\
    \ max_level)\n    end\n    return deepest_levels\nend", "    local max_level =\
    \ 1\n    local current_level = 1\n    local max_level_per_group = {}\n    for\
    \ word in paren_string:gmatch(\"%S+\") do\n        for char in word:gmatch(\"\
    .\") do\n            if char == '(' then\n                current_level = current_level\
    \ + 1\n            elseif char == ')' then\n                if current_level >\
    \ max_level then\n                    max_level = current_level\n            \
    \    end\n                current_level = current_level - 1\n            end\n\
    \        end\n        table.insert(max_level_per_group, max_level)\n        max_level\
    \ = 1\n        current_level = 1\n    end\n    return max_level_per_group\nend",
  "  local groups = {}\n  local level = 0\n  local max = 0\n  local depth = {}\n \
    \ for c in string.gmatch(paren_string, '.') do\n    if c == '(' then\n      level\
    \ = level + 1\n      if level > max then\n        max = level\n      end\n   \
    \ elseif c == ')' then\n      level = level - 1\n    elseif c == ' ' then\n  \
    \    depth[#depth + 1] = max\n      max = 0\n    end\n  end\n  depth[#depth +\
    \ 1] = max\n  return depth\nend", "    local depth = 0\n    local max = 0\n  \
    \  local paren_depths = {}\n    for c in paren_string:gmatch('.') do\n       \
    \ if c == '(' then\n            depth = depth + 1\n            if depth > max\
    \ then\n                max = depth\n            end\n        elseif c == ')'\
    \ then\n            table.insert(paren_depths, depth)\n            depth = depth\
    \ - 1\n        end\n    end\n    table.insert(paren_depths, max)\n    return paren_depths\n\
    end", "    local level = function(paren)\n        local l = 0\n        for i=1,\
    \ #paren do\n            if paren:sub(i,i) == '(' then\n                l = l\
    \ + 1\n            elseif paren:sub(i,i) == ')' then\n                l = l -\
    \ 1\n            end\n        end\n        return l\n    end\n    local out =\
    \ {}\n    for paren in paren_string:gmatch('%S+') do\n        local l = level(paren)\n\
    \        assert(l == 0, 'Malformed parens: ' .. paren)\n        table.insert(out,\
    \ l)\n    end\n    return out\nend", "    local paren_list = {}\n    local start\
    \ = 1\n    for match in paren_string:gmatch('[()]+') do\n        table.insert(paren_list,\
    \ #match/2)\n        start = start + #match\n    end\n    return paren_list\n\
    end", "  local res = {}\n  for _, paren_group in ipairs(paren_string:split(' '))\
    \ do\n    table.insert(res, paren_group:gsub('%b()', function(s)\n      return\
    \ ' ' .. tostring(s:len() - 2) .. ' '\n    end):match('^%s*(.-)%s*$'))\n  end\n\
    \  return res\nend", "  local nest_depths = {}\n  -- if a string is in the form\
    \ of '(A) B', then B would be the part after first ')', and '(A)' would be part\
    \ between\n  -- the first '(' and first ')'.\n  local function get_part_after_first_paren(str)\n\
    \    local parts = mw.text.split(str, '%s*%)%s*')\n    if #parts < 2 then\n  \
    \    return parts[1], ''\n    end\n    local rest = parts[2]\n    for i = 3, #parts\
    \ do\n      rest = rest .. ')' .. parts[i]\n    end\n    local first_paren_index\
    \ = mw.ustring.find(str, '%(')\n    local part_between_parens = mw.ustring.sub(str,\
    \ first_paren_index, #parts[1] + 1)\n    return part_between_parens, rest\n  end\n\
    \  -- if a string is in the form of 'A (B)', then '(B)' would be the part inside\
    \ the first pair of parentheses, and A\n  -- would be part before the first '('\n\
    \  local function get_part_before_first_paren(str)\n    local parts = mw.text.split(str,\
    \ '%s*%(')\n    if #parts < 2 then\n      return '', parts[1]\n    end\n    local\
    \ first_paren_index = mw.ustring.find(str, '%(')\n    local part_between_parens\
    \ = mw.ustring.sub(str, first_paren_index, -1)\n    local left = parts[1]\n  \
    \  for i = 2, #parts - 1 do\n      left = left .. '(' .. parts[i]\n    end\n \
    \   return left, part_between_parens\n  end\n  -- if a string is in the form of\
    \ 'A (B) C', then '(B)' would be the part inside the first pair of parentheses,\
    \ and\n  -- 'A (B)' would be the part before the first ')'\n  local function get_part_before_first_right_paren(str)\n\
    \    local parts = mw.text.split(str, '%s*", "    local num_parens = {}\n    for\
    \ paren in paren_string:gmatch('%b()') do\n        num_parens[#num_parens + 1]\
    \ = parse_parens(paren)\n    end\n    return num_parens\nend", "  local paren_string\
    \ = paren_string or ''\n  local paren_string = string.gsub(paren_string, '[%s]+',\
    \ ' ')\n  local paren_list = split(paren_string, ' ')\n  local paren_counts =\
    \ {}\n  for i, paren in ipairs(paren_list) do\n    local paren_count = find_nested_parens(paren)\n\
    \    paren_counts[i] = paren_count\n  end\n  return paren_counts\nend", "\tlocal\
    \ res = {}\n\tfor match in paren_string:gmatch('%(+%)+') do\n\t\tres[#res + 1]\
    \ = match:len() - 1\n\tend\n\treturn res\nend", "\tlocal paren_tree = {}\n\tlocal\
    \ paren_index = 1\n\t-- build a tree\n\tfor paren_group in string.gmatch(paren_string,\
    \ '%s*%b()%s*') do\n\t\tlocal paren_level = 0\n\t\tfor i = 1, string.len(paren_group)\
    \ do\n\t\t\tif string.sub(paren_group, i, i) == '(' then\n\t\t\t\tparen_level\
    \ = paren_level + 1\n\t\t\telseif string.sub(paren_group, i, i) == ')' then\n\t\
    \t\t\tparen_level = paren_level - 1\n\t\t\tend\n\t\tend\n\t\tparen_tree[paren_index]\
    \ = paren_level\n\t\tparen_index = paren_index + 1\n\tend\n\treturn paren_tree\n\
    end", "    local max_levels = {}\n    for paren_group in paren_string:gmatch('%b()')\
    \ do\n        local level = 0\n        for _ in paren_group:gmatch('%b()') do\n\
    \            level = level + 1\n        end\n        table.insert(max_levels,\
    \ level)\n    end\n    return max_levels\nend", "    local levels = {}\n    for\
    \ s in string.gmatch(paren_string, '[()]*') do\n        local level = 0\n    \
    \    for c in string.gmatch(s, '[()]') do\n            if c == '(' then\n    \
    \            level = level + 1\n            else\n                level = level\
    \ - 1\n            end\n        end\n        table.insert(levels, level)\n   \
    \ end\n    return levels\nend", "  local t = {}\n  for paren in paren_string:gmatch('%S+')\
    \ do\n    local level = 0\n    local max_level = 0\n    for c in paren:gmatch('.')\
    \ do\n      if c == '(' then\n        level = level + 1\n      elseif c == ')'\
    \ then\n        level = level - 1\n      end\n      max_level = math.max(max_level,\
    \ level)\n    end\n    t[#t + 1] = max_level\n  end\n  return t\nend", "  local\
    \ groups = groups(paren_string)\n  local depths = {}\n  for _, group in ipairs(groups)\
    \ do\n    depths[#depths + 1] = max_depth(group)\n  end\n  return depths\nend",
  "  local nest_levels = {}\n  for _, paren_group in ipairs(m_string.split(paren_string,\
    \ ' ')) do\n    local nest_level = 0\n    local max_nest_level = 0\n    for _,\
    \ char in ipairs(m_string.chars(paren_group)) do\n      if char == '(' then\n\
    \        nest_level = nest_level + 1\n      elseif char == ')' then\n        nest_level\
    \ = nest_level - 1\n      end\n      max_nest_level = math.max(max_nest_level,\
    \ nest_level)\n    end\n    nest_levels[#nest_levels + 1] = max_nest_level\n \
    \ end\n  return nest_levels\nend", "    local current_max = 0\n    local nested_level\
    \ = 0\n    local nest_levels = {}\n    local paren_count = 0\n    local paren_index\
    \ = 1\n    local paren_max_level = 0\n    while paren_index <= #paren_string do\n\
    \        local char = paren_string:sub(paren_index, paren_index)\n        if char\
    \ == '(' then\n            nested_level = nested_level + 1\n            paren_count\
    \ = paren_count + 1\n            if paren_count > paren_max_level then\n     \
    \           paren_max_level = paren_count\n            end\n        elseif char\
    \ == ')' then\n            nested_level = nested_level - 1\n            paren_count\
    \ = paren_count - 1\n        elseif char == ' ' then\n            if nested_level\
    \ == 0 then\n                table.insert(nest_levels, paren_max_level)\n    \
    \            paren_max_level = 0\n            end\n        end\n        paren_index\
    \ = paren_index + 1\n    end\n    return nest_levels\nend", "\tlocal level_groups\
    \ = {}\n\tfor match in paren_string:gmatch('[^%s]+') do\n\t\tlocal level = 0\n\
    \t\tlocal max_level = 0\n\t\tfor symbol in match:gmatch('.') do\n\t\t\tif symbol\
    \ == '(' then\n\t\t\t\tlevel = level + 1\n\t\t\t\tif level > max_level then\n\t\
    \t\t\t\tmax_level = level\n\t\t\t\tend\n\t\t\telseif symbol == ')' then\n\t\t\t\
    \tlevel = level - 1\n\t\t\tend\n\t\tend\n\t\ttable.insert(level_groups, max_level)\n\
    \tend\n\treturn level_groups\nend", "    local values = {}\n    for group in stringx.split(paren_string,\
    \ ' ') do\n        local count = 0\n        local max_count = 0\n        for i=1,\
    \ #group do\n            if group:sub(i, i) == '(' then\n                count\
    \ = count + 1\n            elseif group:sub(i, i) == ')' then\n              \
    \  count = count - 1\n            end\n            max_count = math.max(max_count,\
    \ count)\n        end\n        table.insert(values, max_count)\n    end\n    return\
    \ values\nend", "  local max_levels = {}\n  for g in string.gmatch(paren_string,\
    \ \"[^%s]+\") do\n    local depth = 0\n    local max_depth = 0\n    for c in string.gmatch(g,\
    \ \".\") do\n      if c == '(' then\n        depth = depth + 1\n        if depth\
    \ > max_depth then\n          max_depth = depth\n        end\n      elseif c ==\
    \ ')' then\n        depth = depth - 1\n      end\n    end\n    table.insert(max_levels,\
    \ max_depth)\n  end\n  return max_levels\nend", "    local paren_groups = stringx.split(paren_string,\
    \ ' ')\n    local deep_levels = {}\n    for i = 1, #paren_groups do\n        local\
    \ paren_group = paren_groups[i]\n        local deep_level = 0\n        local level\
    \ = 0\n        for j = 1, #paren_group do\n            local c = paren_group:sub(j,\
    \ j)\n            if c == '(' then\n                level = level + 1\n      \
    \          if level > deep_level then\n                    deep_level = level\n\
    \                end\n            elseif c == ')' then\n                level\
    \ = level - 1\n            end\n        end\n        table.insert(deep_levels,\
    \ deep_level)\n    end\n    return deep_levels\nend", "    local depth_dict =\
    \ {}\n    for g, p in paren_string:gmatch('%((%w+)%)%s*') do\n        depth_dict[g]\
    \ = p:gsub('%b()', function(m)\n            return m:gsub('%(', function(m)\n\
    \                return ''\n            end):gsub('%)', function(m)\n        \
    \        return ' '\n            end)\n        end):gsub('%s%s+', ' '):len()\n\
    \    end\n    return depth_dict\nend", "  local paren_groups = {}\n  for paren_group\
    \ in string.gmatch(paren_string, '[^ ]+') do\n    table.insert(paren_groups, paren_group)\n\
    \  end\n  local count_groups = {}\n  for k, v in pairs(paren_groups) do\n    local\
    \ count = 0\n    local max_count = 0\n    for i = 1, #v do\n      local char =\
    \ string.sub(v, i, i)\n      if char == '(' then\n        count = count + 1\n\
    \      elseif char == ')' then\n        count = count - 1\n      end\n      if\
    \ count > max_count then\n        max_count = count\n      end\n    end\n    table.insert(count_groups,\
    \ max_count)\n  end\n  return count_groups\nend", "  -- convert string to array\n\
    \  local paren_arr = explode(paren_string, ' ')\n  local res = {}\n  -- iterate\
    \ over array\n  for i, paren in ipairs(paren_arr) do\n    -- find out the number\
    \ of open parenthesis\n    local left_p = 0\n    -- iterate over character in\
    \ a group\n    for char in paren:gmatch('.') do\n      if char == '(' then\n \
    \       left_p = left_p + 1\n      end\n    end\n    res[i] = left_p\n  end\n\
    \  return res\nend", "\tlocal groups = {}\n\tfor token in paren_string:gmatch('%S+')\
    \ do\n\t\tgroups[#groups + 1] = token\n\tend\n\tlocal result = {}\n\tfor i = 1,\
    \ #groups do\n\t\tlocal group = groups[i]\n\t\tlocal count = 0\n\t\tlocal max_count\
    \ = 0\n\t\tfor c in group:gmatch('.') do\n\t\t\tif c == '(' then\n\t\t\t\tcount\
    \ = count + 1\n\t\t\telseif c == ')' then\n\t\t\t\tcount = count - 1\n\t\t\tend\n\
    \t\t\tif count > max_count then\n\t\t\t\tmax_count = count\n\t\t\tend\n\t\tend\n\
    \t\tresult[i] = max_count\n\tend\n\treturn result\nend", "    local num_parens\
    \ = 0\n    local max_depth = 0\n    local max_depth_list = {}\n    local parent_level\
    \ = 0\n    local parent_level_list = {}\n    local is_start = false\n    local\
    \ parent_index = 0\n    local paren_index = 0\n    local last_paren_index = 0\n\
    \    local last_parent_index = 0\n    local last_paren_level = 0\n    local last_parent_level\
    \ = 0\n    local paren_level = 0\n    local parent_level = 0\n    local last_is_paren\
    \ = false\n    local last_is_parent = false\n    local is_paren = false\n    local\
    \ is_parent = false\n    local is_nil = false\n    for i = 1, #paren_string do\n\
    \        if paren_string:sub(i, i) == '(' then\n            num_parens = num_parens\
    \ + 1\n            paren_index = paren_index + 1\n            paren_level = paren_level\
    \ + 1\n            if is_nil == true then\n                parent_level = 0\n\
    \                is_nil = false\n            end\n            is_paren = true\n\
    \            if is_parent == true then\n                parent_level = parent_level\
    \ + 1\n            end\n            if paren_level > max_depth then\n        \
    \        max_depth = paren_level\n            end\n            if paren_level\
    \ >= last_paren_level then\n                last_paren_level = paren_level\n \
    \               last_paren_index = paren_index\n            end\n            if\
    \ parent_level >= last_parent_level then\n                last_parent_level =\
    \ parent_level\n                last_parent_index = parent_index\n           \
    \ end\n            last_is_paren = true\n            last_is_parent = false\n\
    \        elseif paren_string:sub(i, i) == ')' then\n            num_parens = num_parens\
    \ - 1\n            paren_level = paren_level - 1\n            is_paren = true\n\
    \            if is_parent == true then\n                parent_level = parent_level\
    \ - 1\n            end\n            if paren_level < 0 then\n                paren_level\
    \ = 0\n", "    local paren_count = {}\n    local paren_depth = 0\n    local tbl\
    \ = {}\n    for i = 1, #paren_string do\n        if paren_string:sub(i, i) ==\
    \ '(' then\n            paren_depth = paren_depth + 1\n        elseif paren_string:sub(i,\
    \ i) == ')' then\n            paren_depth = paren_depth - 1\n        elseif paren_string:sub(i,\
    \ i) == ' ' then\n            if paren_depth > 0 then\n                paren_count[#paren_count\
    \ + 1] = paren_depth\n            end\n            paren_depth = 0\n        end\n\
    \    end\n    if paren_depth > 0 then\n        paren_count[#paren_count + 1] =\
    \ paren_depth\n    end\n    paren_depth = 0\n    for i = 1, #paren_count do\n\
    \        local paren_num = paren_count[i]\n        if paren_num > paren_depth\
    \ then\n            paren_depth = paren_num\n        end\n        if paren_num\
    \ < paren_depth then\n            paren_depth = paren_num\n            if i <\
    \ #paren_count then\n                tbl[#tbl + 1] = paren_depth\n           \
    \ end\n        end\n    end\n    if #tbl == 0 then\n        tbl[1] = paren_depth\n\
    \    end\n    return tbl\nend", "  local max_levels = {}\n  for line in paren_string:gmatch('%S+')\
    \ do\n    local paren_stack = {}\n    local level = 0\n    for char in line:gmatch('.')\
    \ do\n      if char == '(' then\n        level = level + 1\n        paren_stack[level]\
    \ = 0\n      elseif char == ')' then\n        if level == 0 then\n          error(string.format('Closing\
    \ paren found at level %s', level))\n        end\n        level = level - 1\n\
    \      end\n    end\n    if level ~= 0 then\n      error(string.format('Reached\
    \ end at level %s', level))\n    end\n    max_levels[#max_levels + 1] = #paren_stack\n\
    \  end\n  return max_levels\nend", "    local deep_level = {}\n    for _,group\
    \ in ipairs(paren_string:split(' ')) do\n        local count = 0\n        for\
    \ paren in group:gmatch('%(') do\n            count = count + 1\n        end\n\
    \        table.insert(deep_level, count)\n    end\n    return deep_level\nend",
  "    local t = {}\n    for paren_substr in paren_string:gmatch('%b()') do\n    \
    \    local nested_parens = 1\n        local paren_start_idx = 2\n        while\
    \ paren_start_idx <= #paren_substr do\n            if paren_substr:sub(paren_start_idx,\
    \ paren_start_idx) == '(' then\n                nested_parens = nested_parens\
    \ + 1\n            elseif paren_substr:sub(paren_start_idx, paren_start_idx) ==\
    \ ')' then\n                nested_parens = nested_parens - 1\n            end\n\
    \            paren_start_idx = paren_start_idx + 1\n        end\n        table.insert(t,\
    \ nested_parens)\n    end\n    return t\nend", "    local function get_nesting_level(paren_string)\n\
    \        local level = 0\n        local levels = {}\n        for i = 1, #paren_string\
    \ do\n            local c = paren_string:sub(i, i)\n            if c == '(' then\n\
    \                level = level + 1\n            elseif c == ')' then\n       \
    \         level = level - 1\n            end\n            table.insert(levels,\
    \ level)\n        end\n        return levels\n    end", "    local paren_groups\
    \ = {}\n    for match in paren_string:gmatch('%b()') do\n        local paren_stack\
    \ = {}\n        local paren_depth = 0\n        for char in match:gmatch('.') do\n\
    \            if char == '(' then\n                paren_stack[#paren_stack + 1]\
    \ = char\n                paren_depth = paren_depth + 1\n            elseif char\
    \ == ')' then\n                paren_stack[#paren_stack] = nil\n             \
    \   paren_depth = paren_depth - 1\n            end\n        end\n        paren_groups[#paren_groups\
    \ + 1] = paren_depth\n    end\n    return paren_groups\nend", "  local depth =\
    \ {}\n  local max_depth = 1\n  for paren_group in paren_string:gmatch('%S+') do\n\
    \    for opening, closing in paren_group:gmatch('()%(()') do\n      if opening\
    \ == closing - 1 then\n        -- Empty parenthesis are always at depth 1\n  \
    \      table.insert(depth, 1)\n      else\n        local nesting = 1\n       \
    \ for i = opening + 1, closing - 1 do\n          if paren_group:sub(i, i) == '('\
    \ then\n            nesting = nesting + 1\n          else\n            nesting\
    \ = nesting - 1\n          end\n        end\n        table.insert(depth, nesting)\n\
    \        max_depth = math.max(max_depth, nesting)\n      end\n    end\n  end\n\
    \  return depth, max_depth\nend", "    local function parse_parens(paren_string)\n\
    \        local match_group = ngx.re.match(paren_string, '^([()]*)')\n        if\
    \ match_group then\n            local result = parse_nested_parens(match_group[1])\n\
    \            return (result or 0) + 1\n        end\n        return nil\n    end",
  "  local groups = {}\n  local _, num_groups = string.gsub(paren_string, '[()]+',\
    \ function(group)\n    table.insert(groups, group)\n  end)\n  assert(num_groups\
    \ > 0, 'No paren groups found in ' .. paren_string)\n  local depths = {}\n  for\
    \ _, group in ipairs(groups) do\n    local depth = 0\n    local max_depth = 0\n\
    \    for i = 1, string.len(group) do\n      local c = string.sub(group, i, i)\n\
    \      if c == '(' then\n        depth = depth + 1\n      elseif c == ')' then\n\
    \        depth = depth - 1\n      end\n      max_depth = math.max(max_depth, depth)\n\
    \    end\n    table.insert(depths, max_depth)\n  end\n  return depths\nend", " \
    \ local groups = {}\n  for group in paren_string:gmatch(\"%s*%b()%s*\") do\n \
    \   local count = 0\n    for c in group:gmatch(\"%b()\") do\n      count = count\
    \ + 1\n    end\n    table.insert(groups, count)\n  end\n  return groups\nend",
  "  local paren_string = paren_string or ''\n  -- extract input for each group\n\
    \  local paren_groups = parse_multiple_inputs(paren_string)\n  local max_depth\
    \ = {}\n  for i = 1, #paren_groups do\n    -- discard the parentheses at the end\n\
    \    local group = string.sub(paren_groups[i], 2, -2)\n    local depth = 0\n \
    \   local max_depth_for_this_group = 0\n    for j = 1, #group do\n      local\
    \ char = string.sub(group, j, j)\n      if char == '(' then\n        depth = depth\
    \ + 1\n      elseif char == ')' then\n        depth = depth - 1\n      end\n \
    \     if depth > max_depth_for_this_group then\n        max_depth_for_this_group\
    \ = depth\n      end\n    end\n    table.insert(max_depth, max_depth_for_this_group)\n\
    \  end\n  return max_depth\nend", "  local max_level = {}\n  for group in paren_string:gmatch('[^%s]+')\
    \ do\n    local level = 0\n    local max_level_in_group = 0\n    for l in group:gmatch('%(')\
    \ do\n      level = level + 1\n      max_level_in_group = math.max(max_level_in_group,\
    \ level)\n    end\n    for r in group:gmatch('%)') do\n      level = level - 1\n\
    \    end\n    table.insert(max_level, max_level_in_group)\n  end\n  return max_level\n\
    end", "    local out = {}\n    for group in string.gmatch(paren_string, '%S+')\
    \ do\n        table.insert(out, parse_parens(group))\n    end\n    return out\n\
    end", "    local max_nesting = {}\n    for group in string.gmatch(paren_string,\
    \ \"([^%s]+)\") do\n        max_nesting[#max_nesting + 1] = get_max_nesting(group)\n\
    \    end\n    return max_nesting\nend", "  -- >>> paren_string = '()(())()'\n\
    \  local paren_groups = {}\n  -- >>> paren_groups = {'', '', ''}\n  local max_nested_count\
    \ = 0\n  -- >>> max_nested_count = 0\n  local start_index = 1\n  local end_index\
    \ = 1\n  -- >>> start_index = 1\n  -- >>> end_index = 1\n  for i = 1,#paren_string\
    \ do\n    -- >>> i = 1\n    if paren_string:sub(i,i) == '(' then\n      -- >>>\
    \ if paren_string:sub(i,i) == '(' then\n      if max_nested_count == 0 then\n\
    \        -- >>> if max_nested_count == 0 then\n        start_index = i\n     \
    \   -- >>> start_index = 1\n      end\n      -- >>> end\n      max_nested_count\
    \ = max_nested_count + 1\n      -- >>> max_nested_count = 1\n    elseif paren_string:sub(i,i)\
    \ == ')' then\n      -- >>> elseif paren_string:sub(i,i) == ')' then\n      max_nested_count\
    \ = max_nested_count - 1\n      -- >>> max_nested_count = 0\n      if max_nested_count\
    \ == 0 then\n        -- >>> if max_nested_count == 0 then\n        end_index =\
    \ i\n        -- >>> end_index = 2\n        paren_groups[#paren_groups + 1] = paren_string:sub(start_index,end_index)\n\
    \        -- >>> paren_groups[#paren_groups + 1] = paren_string:sub(start_index,end_index)\n\
    \        -- >>> paren_groups = {'()', '', ''}\n      end\n      -- >>> end\n \
    \   end\n    -- >>> end\n  end\n  -- >>> end\n  local nested_parens = {}\n  --\
    \ >>> nested_parens = {}\n  for i = 1,#paren_groups do\n    -- >>> i = 1\n   \
    \ if paren_groups[i] ~= '' then\n      -- >>> if paren_groups[i] ~", "    local\
    \ ret_val = {}\n    local max_level = 0\n    local cur_level = 0\n    for i=1,\
    \ #paren_string do\n        local c = paren_string:sub(i,i)\n        if c == '('\
    \ then\n            cur_level = cur_level + 1\n            if cur_level > max_level\
    \ then\n                max_level = cur_level\n            end\n        elseif\
    \ c == ')' then\n            cur_level = cur_level - 1\n        elseif c == '\
    \ ' then\n            ret_val[#ret_val+1] = max_level\n            max_level =\
    \ 0\n            cur_level = 0\n        end\n    end\n    return ret_val\nend",
  "    local nested_levels = {}\n    for paren_group in paren_string:gmatch('%S+')\
    \ do\n        local level = 0\n        local max_level = 0\n        for char in\
    \ paren_group:gmatch('.') do\n            if char == '(' then\n              \
    \  level = level + 1\n            elseif char == ')' then\n                level\
    \ = level - 1\n            end\n            max_level = math.max(max_level, level)\n\
    \        end\n        table.insert(nested_levels, max_level)\n    end\n    return\
    \ nested_levels\nend", "  local idx = 1\n  local depth = 0\n  local max_depth\
    \ = 0\n  local depths = {}\n  while idx <= #paren_string do\n    if paren_string:sub(idx,\
    \ idx) == '(' then\n      depth = depth + 1\n      if depth > max_depth then\n\
    \        max_depth = depth\n      end\n    elseif paren_string:sub(idx, idx) ==\
    \ ')' then\n      depths[#depths + 1] = max_depth\n      depth = depth - 1\n \
    \     max_depth = depth\n    end\n    idx = idx + 1\n  end\n  return depths\n\
    end", "    local paren_levels = {}\n    local current_level = 0\n    for char\
    \ in paren_string:gmatch(\".\") do\n        if char == '(' then\n            current_level\
    \ = current_level + 1\n        elseif char == ')' then\n            paren_levels[#paren_levels\
    \ + 1] = current_level\n            current_level = current_level - 1\n      \
    \  end\n    end\n    return paren_levels\nend", "  local max_count = {}\n  for\
    \ group in paren_string:gmatch(\"%b()\") do\n    local max_level = 1\n    local\
    \ count = 0\n    for c in group:gmatch(\".\") do\n      if c == \"(\" then\n \
    \       count = count + 1\n        if count > max_level then\n          max_level\
    \ = count\n        end\n      elseif c == \")\" then\n        count = count -\
    \ 1\n      end\n    end\n    table.insert(max_count, max_level)\n  end\n  return\
    \ max_count\nend", "    local max_depth = 0\n    local depth = 0\n    local depths\
    \ = {}\n    for c in paren_string:gmatch(\".\") do\n        if c == '(' then\n\
    \            depth = depth + 1\n            if depth > max_depth then\n      \
    \          max_depth = depth\n            end\n        elseif c == ')' then\n\
    \            depths[#depths + 1] = depth\n            depth = depth - 1\n    \
    \    end\n    end\n    return depths\nend", "\tlocal m = {}\n\tlocal c\n\tlocal\
    \ c_max = 0\n\tfor c in paren_string:gmatch(\"[^%s]+\") do\n\t\tc_max = c:gsub(\"\
    [^(]\", \"\"):len()\n\t\tm[#m+1] = c_max\n\tend\n\treturn m\nend", "    local\
    \ depth_table = {}\n    local level = 0\n    local start = 1\n    for i = 1, #paren_string\
    \ do\n        local curr_ch = paren_string:sub(i, i)\n        if curr_ch == '('\
    \ then\n            level = level + 1\n        elseif curr_ch == ')' then\n  \
    \          level = level - 1\n        elseif curr_ch == ' ' then\n           \
    \ if level ~= 0 then\n                error('Mismatched parentheses ' .. paren_string)\n\
    \            end\n            table.insert(depth_table, level)\n            level\
    \ = 0\n            start = i + 1\n        end\n    end\n    return depth_table\n\
    end", "  local paren_table = parse_groups(paren_string)\n  local depth_table =\
    \ {}\n  for _, group in ipairs(paren_table) do\n    local depth = get_depth(group)\n\
    \    depth_table[#depth_table + 1] = depth\n  end\n  return depth_table\nend",
  "    local levels = {}\n    local i = 1\n    while i <= #paren_string do\n     \
    \   local char = paren_string:sub(i, i)\n        if char == ' ' then\n       \
    \     i = i + 1\n        elseif char == '(' then\n            local level = 0\n\
    \            while char == '(' do\n                level = level + 1\n       \
    \         i = i + 1\n                char = paren_string:sub(i, i)\n         \
    \   end\n            table.insert(levels, level)\n        else\n            i\
    \ = i + 1\n        end\n    end\n    return levels\nend", "  local paren_groups\
    \ = pl.utils.split(paren_string, '%s+')\n  local result = {}\n  for i = 1, #paren_groups\
    \ do\n    local paren_group = paren_groups[i]\n    local max_nesting = 0\n   \
    \ local nesting = 0\n    for j = 1, #paren_group do\n      local char = paren_group:sub(j,\
    \ j)\n      if char == '(' then\n        nesting = nesting + 1\n      elseif char\
    \ == ')' then\n        nesting = nesting - 1\n      end\n      max_nesting = math.max(max_nesting,\
    \ nesting)\n    end\n    result[i] = max_nesting\n  end\n  return result\nend",
  "  local ret = {}\n  for m in paren_string:gmatch('%b()') do\n    ret[#ret+1] =\
    \ get_nested_parens(m)\n  end\n  return ret\nend", "    local max_depth_table\
    \ = {}\n    local paren_depth = 0\n    local max_depth = 0\n    for paren in paren_string:gmatch(\"\
    .\") do\n        if paren == '(' then\n            paren_depth = paren_depth +\
    \ 1\n            if paren_depth > max_depth then\n                max_depth =\
    \ paren_depth\n            end\n        elseif paren == ')' then\n           \
    \ max_depth_table[#max_depth_table + 1] = max_depth\n            max_depth = 0\n\
    \            paren_depth = paren_depth - 1\n        end\n    end\n    return max_depth_table\n\
    end", "\tlocal paren_stack = Stack:new()\n\tlocal paren_scores = {}\n\tlocal score\
    \ = 0\n\tlocal parens_to_count = {'(', ')'}\n\tlocal parens_to_ignore = {'(',\
    \ ')', ' '}\n\tlocal ignore_flag = false\n\tfor i = 1, #paren_string do\n\t\t\
    local current_char = paren_string:sub(i, i)\n\t\tif not contains(parens_to_ignore,\
    \ current_char) then\n\t\t\tignore_flag = false\n\t\telseif not ignore_flag then\n\
    \t\t\tif current_char == '(' then\n\t\t\t\tscore = score + 1\n\t\t\t\tparen_stack:push(score)\n\
    \t\t\telseif current_char == ')' then\n\t\t\t\tscore = paren_stack:pop()\n\t\t\
    \telseif current_char == ' ' then\n\t\t\t\tscore = 0\n\t\t\t\tignore_flag = true\n\
    \t\t\t\ttable.insert(paren_scores, paren_stack:pop())\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn paren_scores\nend", "  local max_nested_parens = {}\n  for parens\
    \ in paren_string:gmatch('%b()') do\n    local level = 1\n    while parens:find('%b()')\
    \ do\n      parens = parens:gsub('%b()','')\n      level = level + 1\n    end\n\
    \    table.insert(max_nested_parens, level)\n  end\n  return max_nested_parens\n\
    end", "  local acc,max = 0,0\n  local result = {}\n  for char in paren_string:gmatch('.')\
    \ do\n    if char == '(' then\n      acc = acc + 1\n      max = math.max(max,\
    \ acc)\n    elseif char == ')' then\n      acc = acc - 1\n    end\n  end\n  for\
    \ i=0,max do\n    result[#result+1] = i\n  end\n  return result\nend", "  local\
    \ levels = {}\n  for group in paren_string:gmatch('%S+') do\n    assert(group:sub(1,1)\
    \ == '(' and group:sub(-1) == ')', 'Error: parse_nested_parens -- incorrect parentheses')\n\
    \    local level = 0\n    local max_level = 0\n    for c in group:gmatch('.')\
    \ do\n      if c == '(' then\n        level = level + 1\n      elseif c == ')'\
    \ then\n        level = level - 1\n      end\n      max_level = math.max(max_level,\
    \ level)\n    end\n    table.insert(levels, max_level)\n  end\n  return levels\n\
    end", "    local cnt_open_paren = {}\n    local cnt_paren = 0\n    local cnt_group\
    \ = 0\n    local start_idx = 1\n    for i = 1, #paren_string do\n        local\
    \ char = paren_string:sub(i, i)\n        if char == '(' then\n            cnt_paren\
    \ = cnt_paren + 1\n        elseif char == ')' then\n            cnt_paren = cnt_paren\
    \ - 1\n        elseif char == ' ' then\n            cnt_open_paren[cnt_group]\
    \ = cnt_paren\n            cnt_group = cnt_group + 1\n            cnt_paren =\
    \ 0\n        end\n    end\n    return cnt_open_paren\nend", "\tlocal max_nested_parens\
    \ = {}\n\tfor group in paren_string:gmatch('%S+') do\n\t\tlocal level = 0\n\t\t\
    local max_level = 0\n\t\tfor c in group:gmatch('.') do\n\t\t\tif c == '(' then\n\
    \t\t\t\tlevel = level + 1\n\t\t\telseif c == ')' then\n\t\t\t\tlevel = level -\
    \ 1\n\t\t\tend\n\t\t\tif level > max_level then\n\t\t\t\tmax_level = level\n\t\
    \t\tend\n\t\tend\n\t\tmax_nested_parens[#max_nested_parens + 1] = max_level\n\t\
    end\n\treturn max_nested_parens\nend", "    local result = {}\n    for word in\
    \ paren_string:gmatch('%S+') do\n        local nest_level = 0\n        local max_nest_level\
    \ = 0\n        for c in word:gmatch('.') do\n            if c == '(' then\n  \
    \              nest_level = nest_level + 1\n            elseif c == ')' then\n\
    \                nest_level = nest_level - 1\n            end\n            if\
    \ nest_level > max_nest_level then\n                max_nest_level = nest_level\n\
    \            end\n        end\n        result[#result + 1] = max_nest_level\n\
    \    end\n    return result\nend", "    local groups = {}\n    for g in string.gmatch(paren_string,\
    \ '%S+') do\n        local level = 0\n        local result = 1\n        for i\
    \ = 1, #g do\n            if g:sub(i, i) == '(' then\n                level =\
    \ level + 1\n                if level > result then\n                    result\
    \ = level\n                end\n            elseif g:sub(i, i) == ')' then\n \
    \               level = level - 1\n            end\n        end\n        table.insert(groups,\
    \ result)\n    end\n    return groups\nend", "  local res = {}\n  local max_depth\
    \ = 0\n  local tmp_depth = 0\n  for char in paren_string:gmatch('.') do\n    if\
    \ char == '(' then\n      tmp_depth = tmp_depth + 1\n      if tmp_depth > max_depth\
    \ then\n        max_depth = tmp_depth\n      end\n    elseif char == ')' then\n\
    \      tmp_depth = tmp_depth - 1\n    elseif char == ' ' then\n      if tmp_depth\
    \ ~= 0 then\n        error(\"Input string is not well-formed!\")\n      end\n\
    \      table.insert(res, max_depth)\n      max_depth = 0\n    else\n      error(\"\
    Invalid character in input!\")\n    end\n  end\n  if tmp_depth ~= 0 then\n   \
    \ error(\"Input string is not well-formed!\")\n  end\n  table.insert(res, max_depth)\n\
    \  return res\nend", "    local paren_levels = {}\n    for paren_group in paren_string:gmatch('%S+')\
    \ do\n        paren_levels[#paren_levels + 1] = parenthetical_level(paren_group)\n\
    \    end\n    return paren_levels\nend", "    assert(paren_string)\n    local\
    \ paren_hash = {}\n    local level = 0\n    for i = 1, #paren_string do\n    \
    \    local c = paren_string:sub(i, i)\n        if c == '(' then\n            level\
    \ = level + 1\n        elseif c == ')' then\n            level = level - 1\n \
    \       elseif c == ' ' then\n            paren_hash[#paren_hash + 1] = level\n\
    \            level = 0\n        else\n            error('Invalid character ' ..\
    \ c)\n        end\n    end\n    if level ~= 0 then\n        error('Unbalanced\
    \ parentheses')\n    end\n    return paren_hash\nend", "    if not paren_string\
    \ then return nil end\n    local paren_groups = split(paren_string, ' ')\n   \
    \ local answer = {}\n    for _, group in ipairs(paren_groups) do\n        table.insert(answer,\
    \ paren_depth(group))\n    end\n    return answer\nend", "    local sub_strings\
    \ = util.split(paren_string, ' ')\n    local result = util.array()\n    for _,\
    \ sub_string in ipairs(sub_strings) do\n        local max_depth = 0\n        local\
    \ current_depth = 0\n        for idx = 1, #sub_string do\n            local curr_char\
    \ = sub_string:sub(idx, idx)\n            if curr_char == '(' then\n         \
    \       current_depth = current_depth + 1\n            elseif curr_char == ')'\
    \ then\n                current_depth = current_depth - 1\n            end\n \
    \           max_depth = math.max(max_depth, current_depth)\n        end\n    \
    \    result:insert(max_depth)\n    end\n    return result\nend", "  local groups\
    \ = {}\n  for paren_str in paren_string:gmatch('%S+') do\n    local paren_stack\
    \ = {}\n    local max_nesting = 0\n    for paren in paren_str:gmatch('.') do\n\
    \      if paren == '(' then\n        table.insert(paren_stack, '(')\n        max_nesting\
    \ = math.max(max_nesting, #paren_stack)\n      elseif paren == ')' then\n    \
    \    if #paren_stack > 0 then\n          table.remove(paren_stack)\n        else\n\
    \          error('Input is not a valid nested parentheses string!')\n        end\n\
    \      else\n        error('Input is not a valid nested parentheses string!')\n\
    \      end\n    end\n    if #paren_stack ~= 0 then\n      error('Input is not\
    \ a valid nested parentheses string!')\n    end\n    table.insert(groups, max_nesting)\n\
    \  end\n  return groups\nend", "    local result = {}\n    for match in string.gmatch(paren_string,\
    \ \"()%b()\") do\n        local count = 0\n        local paren_level = 1\n   \
    \     while paren_level ~= 0 do\n            if string.sub(paren_string, match,\
    \ match) == \"(\" then\n                paren_level = paren_level + 1\n      \
    \      else\n                paren_level = paren_level - 1\n            end\n\
    \            count = count + 1\n            match = match + 1\n        end\n \
    \       table.insert(result, count)\n    end\n    return result\nend", "    local\
    \ result = {}\n    for paren_group in paren_string:gmatch(\"%b()\") do\n     \
    \   result[#result + 1] = parse_parens(paren_group)\n    end\n    return result\n\
    end", "    local depths = {}\n    for m in paren_string:gmatch('([()]+)') do\n\
    \        local depth = 0\n        local max_depth = 0\n        for p in m:gmatch('[()]')\
    \ do\n            if p == '(' then\n                depth = depth + 1\n      \
    \      else\n                depth = depth - 1\n            end\n            max_depth\
    \ = math.max(max_depth, depth)\n        end\n        depths[#depths + 1] = max_depth\n\
    \    end\n    return depths\nend", "    local depth_array = {}\n    for _, paren_string\
    \ in pairs(paren_string:split()) do\n        local depth = 0\n        local max_depth\
    \ = 0\n        for paren in paren_string:gmatch(\"%(\") do\n            depth\
    \ = depth + 1\n            if depth > max_depth then\n                max_depth\
    \ = depth\n            end\n        end\n        for paren in paren_string:gmatch(\"\
    %)\") do\n            depth = depth - 1\n        end\n        depth_array[#depth_array\
    \ + 1] = max_depth\n    end\n    return depth_array\nend", "  local paren_levels\
    \ = {}\n  local current_level = 0\n  for i=1,#paren_string do\n    local curr_char\
    \ = paren_string:sub(i,i)\n    if curr_char == '(' then\n      current_level =\
    \ current_level + 1\n    elseif curr_char == ')' then\n      current_level = current_level\
    \ - 1\n    elseif curr_char == ' ' then\n      table.insert(paren_levels, current_level)\n\
    \      current_level = 0\n    end\n  end\n  return paren_levels\nend", "    local\
    \ levels = {}\n    local level = 0\n    for c in string.gmatch(paren_string, '.')\
    \ do\n        if c == '(' then\n            level = level + 1\n        elseif\
    \ c == ')' then\n            table.insert(levels, level)\n            level =\
    \ level - 1\n        end\n    end\n    return levels\nend", "    local max_depth\
    \ = 0\n    local curr_depth = 0\n    local paren_levels = {}\n    local paren_char\
    \ = {'(', ')'}\n    for i=1, #paren_string do\n        local char = paren_string:sub(i,\
    \ i)\n        if char == paren_char[1] then\n            curr_depth = curr_depth\
    \ + 1\n            if curr_depth > max_depth then\n                max_depth =\
    \ curr_depth\n            end\n        elseif char == paren_char[2] then\n   \
    \         paren_levels[#paren_levels + 1] = curr_depth\n            curr_depth\
    \ = curr_depth - 1\n        end\n    end\n    return paren_levels\nend", "  local\
    \ groups = {}\n  for paren_group in paren_string:gmatch('[^%s]+') do\n    table.insert(groups,parse_nested_parens_single(paren_group))\n\
    \  end\n  return table.concat(groups,', ')\nend", "    local max_nesting = {}\n\
    \    for paren in paren_string:gmatch('%s*%(%(*%)%)%s*') do\n        local nesting\
    \ = 0\n        for c in paren:gmatch('%(') do\n            nesting = nesting +\
    \ 1\n        end\n        table.insert(max_nesting, nesting)\n    end\n    return\
    \ max_nesting\nend", "  return moses.map(function(str)\n    local max_level =\
    \ 0\n    local level = 0\n    for c in str:gmatch(\".\") do\n      if c == '('\
    \ then\n        level = level + 1\n        max_level = math.max(max_level, level)\n\
    \      elseif c == ')' then\n        level = level - 1\n      end\n    end\n \
    \   return max_level\n  end, stringx.split(paren_string))\nend", "    local out\
    \ = {}\n    local lev = 0\n    local max_lev = 0\n    local paren_list = {}\n\
    \    for ch in paren_string:gmatch('.') do\n        if ch == '(' then\n      \
    \      table.insert(paren_list, ch)\n            lev = lev + 1\n            if\
    \ lev > max_lev then\n                max_lev = lev\n            end\n       \
    \ elseif ch == ')' then\n            if #paren_list == 0 then\n              \
    \  error('Too many closing parentheses')\n            end\n            table.remove(paren_list)\n\
    \            if lev == max_lev then\n                table.insert(out, max_lev)\n\
    \                max_lev = 0\n            end\n            lev = lev - 1\n   \
    \     end\n    end\n    if #paren_list > 0 then\n        error('Too many opening\
    \ parentheses')\n    end\n    return out\nend", "    --[[first_paren_index = 1\n\
    \    last_paren_index = 1\n    paren_depth = 0\n    while(1) do\n        index\
    \ = string.find(paren_string, \"%b()\", last_paren_index)\n        if (index ~=\
    \ nil) then\n            print(index)\n            paren_depth = paren_depth +\
    \ 1\n            last_paren_index = index + 1\n        else\n            break\n\
    \        end\n    end]]--\n    return {}\nend", "\tlocal function helper(left,\
    \ right, count)\n\t\tif #left == 0 then return count end\n\t\tif left[1] == \"\
    (\" then\n\t\t\ttable.remove(left, 1)\n\t\t\tcount = helper(left, right, count\
    \ + 1)\n\t\telse\n\t\t\ttable.insert(right, table.remove(left, 1))\n\t\tend\n\t\
    \treturn count\n\tend\n\tlocal result = {}\n\tfor paren_string in paren_string:gmatch(\"\
    [%S]+\") do\n\t\tlocal left, right = {}, {}\n\t\tfor c in paren_string:gmatch(\"\
    .\") do\n\t\t\ttable.insert(left, c)\n\t\tend\n\t\ttable.insert(result, helper(left,\
    \ right, 0))\n\tend\n\treturn result\nend", "    local depth = 0\n    local depths\
    \ = {}\n    for paren in paren_string:gmatch('%S+') do\n        depth = 0\n  \
    \      for _ in paren:gmatch('%b()') do\n            depth = depth + 1\n     \
    \   end\n        table.insert(depths, depth)\n    end\n    return depths\nend",
  "    local paren_groups = split(paren_string, '%s+')\n    local result = {}\n  \
    \  for i, group in ipairs(paren_groups) do\n        local paren_stack = {}\n \
    \       local max_nesting = 0\n        for j = 1, #group do\n            local\
    \ paren = group:sub(j, j)\n            if paren == '(' then\n                table.insert(paren_stack,\
    \ j)\n            elseif paren == ')' then\n                table.remove(paren_stack)\n\
    \                max_nesting = math.max(max_nesting, #paren_stack)\n         \
    \   end\n        end\n        result[i] = max_nesting\n    end\n    return result\n\
    end", "    local max_nesting = torch.zeros(paren_string:count(' ') + 1)\n    local\
    \ cur_max_nesting = 0\n    local cur_max_nesting_idx = 1\n    for i = 1, paren_string:len()\
    \ do\n        if paren_string:sub(i, i) == '(' then\n            cur_max_nesting\
    \ = cur_max_nesting + 1\n        elseif paren_string:sub(i, i) == ')' then\n \
    \           cur_max_nesting = cur_max_nesting - 1\n            if cur_max_nesting\
    \ == 0 then\n                max_nesting[cur_max_nesting_idx] = max_nesting[cur_max_nesting_idx]\
    \ + 1\n                cur_max_nesting_idx = cur_max_nesting_idx + 1\n       \
    \     end\n        end\n    end\n    return max_nesting\nend", "    -- TODO: Write\
    \ this function!\n    local paren_table = {}\n    local depth = 0\n    local maximum\
    \ = 0\n    for i = 1, #paren_string do\n        local current = paren_string:sub(i,\
    \ i)\n        if current == '(' then\n            depth = depth + 1\n        \
    \    if depth > maximum then\n                maximum = depth\n            end\n\
    \        elseif current == ')' then\n            table.insert(paren_table, maximum)\n\
    \            depth = 0\n            maximum = 0\n        end\n    end\n    return\
    \ paren_table\nend", "    local tokens = tokenize(paren_string)\n    local level_counts\
    \ = {}\n    for _, paren_group in ipairs(tokens) do\n        table.insert(level_counts,\
    \ parenthesize(paren_group))\n    end\n    return level_counts\nend", "    local\
    \ group_counter = 1\n    local paren_set = {}\n    local paren_counter = 0\n \
    \   local max_counter = 0\n    for char in paren_string:gmatch('.') do\n     \
    \   if char == '(' then\n            paren_counter = paren_counter + 1\n     \
    \       if paren_counter > max_counter then\n                max_counter = paren_counter\n\
    \            end\n        elseif char == ')' then\n            paren_counter =\
    \ paren_counter - 1\n        elseif char == ' ' then\n            table.insert(paren_set,\
    \ max_counter)\n            group_counter = group_counter + 1\n            paren_counter\
    \ = 0\n            max_counter = 0\n        end\n    end\n    return paren_set\n\
    end", "    local paren_levels = {}\n    local paren_level = 0\n    for _, paren\
    \ in ipairs(paren_string:split(\" \")) do\n        for char in paren:gmatch(\"\
    .\") do\n            if char == \"(\" then\n                paren_level = paren_level\
    \ + 1\n            elseif char == \")\" then\n                paren_level = paren_level\
    \ - 1\n            end\n        end\n        table.insert(paren_levels, paren_level)\n\
    \        paren_level = 0\n    end\n    return paren_levels\nend", "\t-- print(paren_string)\n\
    \tlocal depth = 0\n\tlocal depth_list = {}\n\tfor i = 1, #paren_string do\n\t\t\
    local ch = paren_string:sub(i, i)\n\t\tif ch == '(' then\n\t\t\tdepth = depth\
    \ + 1\n\t\telseif ch == ')' then\n\t\t\tdepth = depth - 1\n\t\telseif ch == '\
    \ ' then\n\t\t\tdepth_list[#depth_list + 1] = depth\n\t\t\tdepth = 0\n\t\tend\n\
    \tend\n\tdepth_list[#depth_list + 1] = depth\n\treturn depth_list\nend", "   \
    \ local paren_list = stringx.split(paren_string)\n    local result = {}\n    for\
    \ i = 1, #paren_list do\n        local paren = paren_list[i]\n        local paren_count\
    \ = 0\n        local paren_stack = 0\n        for _, v in pairs(stringx.split(paren))\
    \ do\n            if v == '(' then\n                paren_stack = paren_stack\
    \ + 1\n                paren_count = math.max(paren_count, paren_stack)\n    \
    \        elseif v == ')' then\n                paren_stack = paren_stack - 1\n\
    \            end\n        end\n        result[i] = paren_count\n    end\n    return\
    \ result\nend", "    local max_level = {}\n    for i,v in ipairs(stringx.split(paren_string))\
    \ do\n        max_level[i] = parse_paren(v)\n    end\n    return max_level\nend",
  "  local paren_table = {}\n  for paren_group in paren_string:gmatch('%S+') do\n\
    \    local paren_stack = {}\n    local paren_count = 0\n    for paren in paren_group:gmatch('[()]')\
    \ do\n      if paren == '(' then\n        paren_stack[#paren_stack + 1] = '('\n\
    \      elseif paren == ')' then\n        if #paren_stack == 0 then\n         \
    \ error('extra closing paren: ' .. paren_group)\n        end\n        paren_stack[#paren_stack]\
    \ = nil\n      end\n      paren_count = math.max(paren_count, #paren_stack)\n\
    \    end\n    if #paren_stack > 0 then\n      error('missing closing paren: '\
    \ .. paren_group)\n    end\n    paren_table[#paren_table + 1] = paren_count\n\
    \  end\n  return paren_table\nend", "\tlocal max_paren_counts = {}\n\tlocal max_paren_count\
    \ = 0\n\tlocal start_index = 1\n\tlocal paren_count = 0\n\tfor i=1, string.len(paren_string)\
    \ do\n\t\tlocal char = string.sub(paren_string, i, i)\n\t\tif char == '(' then\n\
    \t\t\tparen_count = paren_count + 1\n\t\telseif char == ')' then\n\t\t\tparen_count\
    \ = paren_count - 1\n\t\telseif char == ' ' then\n\t\t\tif paren_count > max_paren_count\
    \ then\n\t\t\t\tmax_paren_count = paren_count\n\t\t\tend\n\t\t\tlocal paren_length\
    \ = i - start_index\n\t\t\ttable.insert(max_paren_counts, paren_length)\n\t\t\t\
    start_index = i + 1\n\t\t\tparen_count = 0\n\t\tend\n\tend\n\treturn max_paren_counts\n\
    end", "    local paren_list = split(paren_string, \" \")\n    local level_list\
    \ = {}\n    for k, v in pairs(paren_list) do\n        local level = 0\n      \
    \  local max_level = 0\n        for i = 1, string.len(v) do\n            if string.sub(v,\
    \ i, i) == \"(\" then\n                level = level + 1\n            elseif string.sub(v,\
    \ i, i) == \")\" then\n                level = level - 1\n            end\n  \
    \          if level > max_level then\n                max_level = level\n    \
    \        end\n        end\n        table.insert(level_list, max_level)\n    end\n\
    \    return level_list\nend", "    local groups = {}\n    local group_level =\
    \ {}\n    local level = 0\n    for i = 1, #paren_string do\n        local paren\
    \ = paren_string:sub(i, i)\n        if paren == '(' then\n            level =\
    \ level + 1\n        elseif paren == ')' then\n            level = level - 1\n\
    \        elseif paren == ' ' then\n            groups[#groups + 1] = level\n \
    \           level = 0\n        end\n    end\n    groups[#groups + 1] = level\n\
    \    return groups\nend", "    local result = {}\n    -- The code below is equivalent\
    \ to the code commented out.\n    -- I think the following version is cleaner\
    \ and easier to understand,\n    -- but I think both versions will have the same\
    \ performance.\n    for paren_group in string.gmatch(paren_string, '[^%s]+') do\n\
    \        local level = 0\n        local max_level = 0\n        for paren in string.gmatch(paren_group,\
    \ '.') do\n            if paren == '(' then\n                level = level + 1\n\
    \            elseif paren == ')' then\n                level = level - 1\n   \
    \         end\n            if level > max_level then\n                max_level\
    \ = level\n            end\n        end\n        table.insert(result, max_level)\n\
    \    end\n    --[[\n    for paren_group in string.gmatch(paren_string, '[^%s]+')\
    \ do\n        local level = 0\n        local max_level = 0\n        local stack\
    \ = {}\n        for paren in string.gmatch(paren_group, '.') do\n            if\
    \ paren == '(' then\n                table.insert(stack, '(')\n              \
    \  level = level + 1\n            elseif paren == ')' then\n                table.remove(stack)\n\
    \                level = level - 1\n            end\n            if level > max_level\
    \ then\n                max_level = level\n            end\n        end\n    \
    \    table.insert(result, max_level)\n    end\n    --]]\n    return result\nend",
  "  assert(type(paren_string) == 'string')\n  local result = {}\n  for group in paren_string:gmatch('%b()')\
    \ do\n    local _, open_count = group:gsub('%(', '')\n    local _, close_count\
    \ = group:gsub('%)', '')\n    local nesting_level = math.min(open_count, close_count)\n\
    \    table.insert(result, nesting_level)\n  end\n  return result\nend", "    local\
    \ max_depth = 0\n    local depths = {}\n    local depth = 0\n    local start_position\
    \ = 0\n    for position, character in utf8.codes(paren_string) do\n        if\
    \ character == 40 then\n            depth = depth + 1\n            if depth >\
    \ max_depth then\n                max_depth = depth\n            end\n       \
    \ elseif character == 41 then\n            depths[#depths + 1] = depth\n     \
    \       depth = depth - 1\n        end\n    end\n    return depths\nend", "  \
    \  -- this is not a particularly efficient way to parse nested parentheses, but\
    \ it is easy to write and easy to understand\n    paren_string = paren_string:gsub('\
    \ ', '')\n    local s = 0\n    local max_depth = {}\n    for level, paren in paren_string:gmatch('()%b()')\
    \ do\n        if paren:sub(1, 1) == '(' then\n            s = s + 1\n        else\n\
    \            max_depth[#max_depth + 1] = s\n            s = s - 1\n        end\n\
    \    end\n    return max_depth\nend", "  local levels = {}\n  local current_level\
    \ = 0\n  for paren in paren_string:gmatch('%s*%b()%s*') do\n    paren = paren:gsub('^%s*(.-)%s*$',\
    \ '%1')\n    current_level = 0\n    for opening_paren in paren:gmatch('%(+') do\n\
    \      current_level = current_level + 1\n    end\n    table.insert(levels, current_level)\n\
    \  end\n  return levels\nend", "    local out = {}\n    for substring in paren_string:gmatch('[%(|%)]+')\
    \ do\n        table.insert(out, parse_nested_parens_helper(substring))\n    end\n\
    \    return out\nend", "    local output = {}\n    for paren_string in string.gmatch(paren_string,\
    \ '%S+') do\n        local level = 0\n        local max_level = 0\n        for\
    \ i = 1, #paren_string do\n            if paren_string:sub(i, i) == '(' then\n\
    \                level = level + 1\n            elseif paren_string:sub(i, i)\
    \ == ')' then\n                level = level - 1\n            end\n          \
    \  if level > max_level then\n                max_level = level\n            end\n\
    \        end\n        table.insert(output, max_level)\n    end\n    return output\n\
    end", "  local paren_groups = {}\n  for paren_group in paren_string:gmatch('[^%s]+')\
    \ do\n    table.insert(paren_groups, 1 + paren_group:gsub('[^()]', ''):gsub('%(%(+)',\
    \ ''):gsub('%)%)+)', ''):len())\n  end\n  return paren_groups\nend", "    local\
    \ deep_levels = {}\n    local level = 0\n    for c in paren_string:gmatch('.')\
    \ do\n        if c == '(' then\n            level = level + 1\n        elseif\
    \ c == ')' then\n            deep_levels[#deep_levels + 1] = level\n         \
    \   level = level - 1\n        end\n    end\n    return deep_levels\nend", " \
    \   local depth_list = {}\n    local depth = 0\n    for i = 1, string.len(paren_string)\
    \ do\n        local cur_char = string.sub(paren_string, i, i)\n        if cur_char\
    \ == '(' then\n            depth = depth + 1\n        elseif cur_char == ')' then\n\
    \            depth = depth - 1\n        elseif cur_char == ' ' then\n        \
    \    table.insert(depth_list, depth)\n            depth = 0\n        end\n   \
    \ end\n    return depth_list\nend", "    local result = {}\n    for paren_group\
    \ in string.gmatch(paren_string, '[^ ]+') do\n        local nesting_level = 0\n\
    \        local max_nesting_level = 0\n        for i = 1, #paren_group do\n   \
    \         local char = paren_group:sub(i, i)\n            if char == '(' then\n\
    \                nesting_level = nesting_level + 1\n            elseif char ==\
    \ ')' then\n                nesting_level = nesting_level - 1\n            end\n\
    \            max_nesting_level = math.max(max_nesting_level, nesting_level)\n\
    \        end\n        table.insert(result, max_nesting_level)\n    end\n    return\
    \ result\nend", "  local group_max_nesting = {}\n  for group in string.gmatch(paren_string,\
    \ '%s*%(%s*(%b())%s*') do\n    local max_nesting = 0\n    local current_nesting\
    \ = 0\n    for c in string.gmatch(group, '%b()') do\n      if c == '(' then\n\
    \        current_nesting = current_nesting + 1\n      else\n        current_nesting\
    \ = current_nesting - 1\n      end\n      if current_nesting > max_nesting then\n\
    \        max_nesting = current_nesting\n      end\n    end\n    table.insert(group_max_nesting,\
    \ max_nesting)\n  end\n  return group_max_nesting\nend", "  local groups = {}\n\
    \  for group in paren_string:gmatch('%s*([^%s]+)%s*') do\n    local curr_level\
    \ = 0\n    local max_level = 0\n    for char in group:gmatch('.') do\n      if\
    \ char == '(' then\n        curr_level = curr_level + 1\n      elseif char ==\
    \ ')' then\n        curr_level = curr_level - 1\n      end\n      max_level =\
    \ math.max(max_level, curr_level)\n    end\n    table.insert(groups, max_level)\n\
    \  end\n  return groups\nend", "    local paren_set = {}\n    local paren_array\
    \ = stringx.split(paren_string)\n    local paren_index = 1\n    for _, group in\
    \ pairs(paren_array) do\n        local group_paren_count = 0\n        local max_paren_count\
    \ = 0\n        for char in group:gmatch'.' do\n            if char == '(' then\n\
    \                group_paren_count = group_paren_count + 1\n            elseif\
    \ char == ')' then\n                group_paren_count = group_paren_count - 1\n\
    \            end\n            if group_paren_count > max_paren_count then\n  \
    \              max_paren_count = group_paren_count\n            end\n        end\n\
    \        paren_set[paren_index] = max_paren_count\n        paren_index = paren_index\
    \ + 1\n    end\n    return paren_set\nend", "    local results = {}\n    for s\
    \ in paren_string:gmatch('%S+') do\n        if s:sub(1, 1) == '(' then\n     \
    \       local count = 0\n            for i = 1, #s do\n                if s:sub(i,\
    \ i) == '(' then\n                    count = count + 1\n                elseif\
    \ s:sub(i, i) == ')' then\n                    count = count - 1\n           \
    \     end\n            end\n            table.insert(results, count)\n       \
    \ end\n    end\n    return results\nend", "\tlocal ret = {}\n\tlocal recurse\n\
    \trecurse = function(str)\n\t\tlocal prefix = str:match('^%s*')\n\t\tlocal suffix\
    \ = str:match('%s*$')\n\t\tstr = str:gsub('^%s*', ''):gsub('%s*$', '')\n\t\tlocal\
    \ depth = 0\n\t\tlocal max_depth = 0\n\t\tlocal i = 1\n\t\tlocal tmp = ''\n\t\t\
    while i <= #str do\n\t\t\tif str:sub(i, i) == '(' then\n\t\t\t\tdepth = depth\
    \ + 1\n\t\t\t\tif depth > max_depth then\n\t\t\t\t\tmax_depth = depth\n\t\t\t\t\
    end\n\t\t\telseif str:sub(i, i) == ')' then\n\t\t\t\tdepth = depth - 1\n\t\t\t\
    elseif str:sub(i, i) == ' ' then\n\t\t\t\tif tmp ~= '' then\n\t\t\t\t\tret[#ret\
    \ + 1] = recurse(tmp)\n\t\t\t\t\ttmp = ''\n\t\t\t\tend\n\t\t\tend\n\t\t\ttmp =\
    \ tmp .. str:sub(i, i)\n\t\t\ti = i + 1\n\t\tend\n\t\tif tmp ~= '' then\n\t\t\t\
    ret[#ret + 1] = recurse(tmp)\n\t\tend\n\t\treturn max_depth\n\tend\n\trecurse(paren_string)\n\
    \treturn ret\nend", "    local result = {}\n    for s in paren_string:gmatch('[^%s]+')\
    \ do\n        if s:sub(1, 1) == '(' then\n            result[#result + 1] = #s\
    \ - #s:gsub('%(', '')\n        else\n            result[#result + 1] = 0\n   \
    \     end\n    end\n    return result\nend", "    local paren_levels = {}\n  \
    \  local current_level = 0\n    for paren in paren_string:gmatch('%S+') do\n \
    \       local temp_level = 0\n        for p in paren:gmatch('.') do\n        \
    \    if p == '(' then\n                temp_level = temp_level + 1\n         \
    \   elseif p == ')' then\n                temp_level = temp_level - 1\n      \
    \      end\n        end\n        table.insert(paren_levels, temp_level)\n    end\n\
    \    return paren_levels\nend", "  local depth = 0\n  local max_depth = 0\n  local\
    \ max_depths = {}\n  for c in paren_string:gmatch'.' do\n    if c == '(' then\n\
    \      depth = depth + 1\n      if depth > max_depth then\n        max_depth =\
    \ depth\n      end\n    elseif c == ')' then\n      depth = depth - 1\n      table.insert(max_depths,\
    \ max_depth)\n      max_depth = 0\n    end\n  end\n  return max_depths\nend",
  "\tlocal max_nesting = Set{}\n\tfor group in paren_string:gmatch('%b()') do\n\t\t\
    local count = 0\n\t\tfor paren in group:gmatch('%b()') do\n\t\t\tcount = count\
    \ + 1\n\t\tend\n\t\tmax_nesting:insert(count)\n\tend\n\treturn max_nesting\nend",
  "  local level_set = {}\n  for paren_group in string.gmatch(paren_string, '[^ ]+')\
    \ do\n    local level = 0\n    local levels = {}\n    for i = 1, #paren_group\
    \ do\n      local char = paren_group:sub(i, i)\n      if char == '(' then\n  \
    \      level = level + 1\n      elseif char == ')' then\n        level = level\
    \ - 1\n      end\n      table.insert(levels, level)\n    end\n    table.insert(level_set,\
    \ math.max(unpack(levels)))\n  end\n  return level_set\nend", "  local nested_parens\
    \ = {}\n  local max_level = 0\n  local cur_level = 0\n  for str in string.gmatch(paren_string,\
    \ \"%S+\") do\n    cur_level = 0\n    max_level = 0\n    for paren in string.gmatch(str,\
    \ \".\") do\n      if paren == '(' then\n        cur_level = cur_level + 1\n \
    \       if cur_level > max_level then\n          max_level = cur_level\n     \
    \   end\n      elseif paren == ')' then\n        cur_level = cur_level - 1\n \
    \     end\n    end\n    nested_parens[#nested_parens + 1] = max_level\n  end\n\
    \  return nested_parens\nend", "  -- Convert string to a list.\n  local str_tbl\
    \ = {}\n  for ch in paren_string:gmatch'.' do\n    table.insert(str_tbl, ch)\n\
    \  end\n  -- Record the level of nesting at each position.\n  local nest_levels\
    \ = {}\n  local nest_count = 0\n  for i = 1, #str_tbl do\n    if str_tbl[i] ==\
    \ '(' then\n      nest_count = nest_count + 1\n    elseif str_tbl[i] == ')' then\n\
    \      nest_count = nest_count - 1\n    end\n    nest_levels[i] = nest_count\n\
    \  end\n  -- Search for the deepest level of nesting.\n  local max_nest = 0\n\
    \  for i = 1, #str_tbl do\n    if str_tbl[i] == '(' or str_tbl[i] == ')' then\n\
    \      if nest_levels[i] > max_nest then\n        max_nest = nest_levels[i]\n\
    \      end\n    end\n  end\n  return max_nest\nend", "  local tokens = {}\n  for\
    \ t in string.gmatch(paren_string, '%s*%((%b())%s*') do\n    table.insert(tokens,\
    \ t)\n  end\n  local max_pairs = {}\n  for _, token in ipairs(tokens) do\n   \
    \ local pairs = 0\n    for c in string.gmatch(token, '%b()') do\n      pairs =\
    \ pairs + 1\n    end\n    table.insert(max_pairs, pairs)\n  end\n  return max_pairs\n\
    end", "    local paren_stack = {}\n    local max_depth = {}\n    local current_depth\
    \ = 0\n    local max_depth_seen = 0\n    local nesting_levels = {}\n    local\
    \ current_group = {}\n    for i = 1, #paren_string do\n        local current_char\
    \ = paren_string:sub(i, i)\n        if current_char == '(' then\n            paren_stack[#paren_stack\
    \ + 1] = '('\n            current_depth = current_depth + 1\n            if current_depth\
    \ > max_depth_seen then\n                max_depth_seen = current_depth\n    \
    \        end\n        elseif current_char == ')' then\n            if current_depth\
    \ == 0 then\n                error('Mismatched parentheses.')\n            end\n\
    \            paren_stack[#paren_stack] = nil\n            current_depth = current_depth\
    \ - 1\n        elseif current_char == ' ' then\n            if #paren_stack ~=\
    \ 0 then\n                error('Mismatched parentheses.')\n            end\n\
    \            if #current_group ~= 0 then\n                current_group[#current_group\
    \ + 1] = max_depth_seen\n                nesting_levels[#nesting_levels + 1] =\
    \ current_group\n                current_group = {}\n            end\n       \
    \     max_depth_seen = 0\n        else\n            current_group[#current_group\
    \ + 1] = current_char\n        end\n    end\n    if #paren_stack ~= 0 then\n \
    \       error('Mismatched parentheses.')\n    end\n    if #current_group ~= 0\
    \ then\n        current_group[#current_group + 1] = max_depth_seen\n        nesting_levels[#nesting_levels\
    \ + 1] = current_group\n    end\n    return nesting_levels\nend", "  return lpeg.match(nested_parens_grammar,\
    \ paren_string)\nend", "  local last_open = -1\n  local levels = {}\n  for i =\
    \ 1, string.len(paren_string) do\n    local c = string.sub(paren_string, i, i)\n\
    \    if c == '(' then\n      last_open = i\n    elseif c == ')' then\n      local\
    \ depth = i - last_open\n      levels[#levels + 1] = depth\n      last_open =\
    \ -1\n    end\n  end\n  return levels\nend", "  local paren_groups = {}\n  for\
    \ paren_group in paren_string:gmatch('[^%s]+') do\n    local depth = 0\n    local\
    \ paren_group_depth = 0\n    for c in paren_group:gmatch('.') do\n      if c ==\
    \ '(' then\n        depth = depth + 1\n        if depth > paren_group_depth then\n\
    \          paren_group_depth = depth\n        end\n      elseif c == ')' then\n\
    \        depth = depth - 1\n      end\n    end\n    paren_groups[#paren_groups\
    \ + 1] = paren_group_depth\n  end\n  return paren_groups\nend", "  local nested_levels\
    \ = {}\n  for paren in string.gmatch(paren_string, '%s*(%b())%s*') do\n    local\
    \ nesting_level = 0\n    for _ in string.gmatch(paren, '%(+') do\n      nesting_level\
    \ = nesting_level + 1\n    end\n    table.insert(nested_levels, nesting_level)\n\
    \  end\n  return nested_levels\nend", "  local depth = 0\n  local max_depth =\
    \ 0\n  local paren_table = {}\n  for i=1, #paren_string do\n    local char = paren_string:sub(i,i)\n\
    \    if char == '(' then\n      depth = depth + 1\n      if depth > max_depth\
    \ then\n        max_depth = depth\n      end\n    elseif char == ')' then\n  \
    \    depth = depth - 1\n    elseif char == ' ' then\n      table.insert(paren_table,\
    \ max_depth)\n      max_depth = 0\n    end\n  end\n  table.insert(paren_table,\
    \ max_depth)\n  return paren_table\nend", "  local groups = {}\n  for match in\
    \ paren_string:gmatch('%S+') do\n    table.insert(groups, find_depth(match))\n\
    \  end\n  return groups\nend", "  local function parse_parentheses(paren_string)\n\
    \    local s = 0\n    local level = 0\n    local deepest = 0\n    for i = 1, #paren_string\
    \ do\n      local b = paren_string:sub(i, i)\n      if b == '(' then\n       \
    \ s = s + 1\n        level = level + 1\n        if level > deepest then\n    \
    \      deepest = level\n        end\n      elseif b == ')' then\n        s = s\
    \ - 1\n        level = level - 1\n      end\n    end\n    if s ~= 0 then\n   \
    \   error('syntax error in parse_nested_parens, unmatched parentheses')\n    end\n\
    \    return deepest\n  end", "    local paren_groups = {}\n    for _, str in ipairs(split(paren_string,\
    \ \" \")) do\n        table.insert(paren_groups, count_parens(str))\n    end\n\
    \    return paren_groups\nend", "    local paren_string = paren_string\n    local\
    \ level_stack = {0} -- Stack of levels of parentheses\n    local max_levels =\
    \ {} -- List of maximum levels at each group (group separated by space)\n    local\
    \ max_level = 0 -- maximum level of parentheses of the group\n    local group_counter\
    \ = 0 -- Counts number of groups (separated by spaces)\n    local search_pos =\
    \ 1 -- Current position for parsing parentheses", "    local level_counts = {}\n\
    \    for i, g in ipairs(paren_string:split(' ')) do\n        level_counts[i] =\
    \ 0\n        for char in g:gmatch('[()]') do\n            if char == '(' then\n\
    \                level_counts[i] = level_counts[i] + 1\n            else\n   \
    \             level_counts[i] = level_counts[i] - 1\n            end\n       \
    \ end\n    end\n    return level_counts\nend", "\tlocal max_levels = {}\n\tfor\
    \ paren_string in paren_string:gmatch(\"[^%s]+\") do\n\t\tlocal paren_stack =\
    \ {}\n\t\tlocal max_level = 0\n\t\tfor c in paren_string:gmatch(\".\") do\n\t\t\
    \tif c == \"(\" then\n\t\t\t\ttable.insert(paren_stack, c)\n\t\t\t\tmax_level\
    \ = math.max(max_level, #paren_stack)\n\t\t\telseif c == \")\" then\n\t\t\t\t\
    table.remove(paren_stack)\n\t\t\tend\n\t\tend\n\t\ttable.insert(max_levels, max_level)\n\
    \tend\n\treturn max_levels\nend", "    -- TODO: what should we do when the input\
    \ is empty?\n    local paren_table = {}\n    for level in paren_string:gmatch('%b()')\
    \ do\n        table.insert(paren_table, level:match('^%(%)(.*)$'))\n    end\n\
    \    return paren_table\nend", "    local result = {}\n    local level = 0\n \
    \   local max_level = 0\n    for i=1, string.len(paren_string) do\n        local\
    \ ch = string.sub(paren_string, i, i)\n        if ch == '(' then\n           \
    \ level = level + 1\n            if level > max_level then\n                max_level\
    \ = level\n            end\n        elseif ch == ')' then\n            level =\
    \ level - 1\n        elseif ch == ' ' then\n            result[#result+1] = max_level\n\
    \            max_level = 0\n            level = 0\n        end\n    end\n    result[#result+1]\
    \ = max_level\n    return result\nend", "  local max_depth = 0\n  local depth\
    \ = 0\n  local depths = {}\n  for _, paren in ipairs(split(paren_string, ' '))\
    \ do\n    for i = 1, #paren do\n      if paren:sub(i, i) == '(' then\n       \
    \ depth = depth + 1\n        if depth > max_depth then\n          max_depth =\
    \ depth\n        end\n      elseif paren:sub(i, i) == ')' then\n        depth\
    \ = depth - 1\n      end\n    end\n    depths[#depths + 1] = max_depth\n    max_depth\
    \ = 0\n    depth = 0\n  end\n  return depths\nend", "    return map(paren_string:gmatch('%b()'),\
    \ function(s)\n        local count = 0\n        for c in s:gmatch('()') do count\
    \ = count + 1 end\n        return count - 1\n    end)\nend", "    local result\
    \ = {}\n    local paren_stack = Stack:new()\n    local max_nesting = 0\n    local\
    \ nesting = 0\n    for c in string.gmatch(paren_string, '.') do\n        if c\
    \ == '(' then\n            paren_stack:push(c)\n            nesting = nesting\
    \ + 1\n            if nesting > max_nesting then\n                max_nesting\
    \ = nesting\n            end\n        elseif c == ')' then\n            if paren_stack:size()\
    \ == 0 then\n                print(\"Parentheses are not balanced!\")\n      \
    \          return {}\n            end\n            paren_stack:pop()\n       \
    \     nesting = nesting - 1\n        end\n    end\n    if paren_stack:size() ~=\
    \ 0 then\n        print(\"Parentheses are not balanced!\")\n        return {}\n\
    \    end\n    table.insert(result, max_nesting)\n    return result\nend", "  \
    \  local depth = {}\n    local max_depth = 0\n    local cur_depth = 0\n    for\
    \ i = 1, string.len(paren_string) do\n        if string.sub(paren_string, i, i)\
    \ == '(' then\n            cur_depth = cur_depth + 1\n            if cur_depth\
    \ > max_depth then\n                max_depth = cur_depth\n            end\n \
    \       elseif string.sub(paren_string, i, i) == ')' then\n            depth[cur_depth]\
    \ = (depth[cur_depth] or 0) + 1\n            cur_depth = cur_depth - 1\n     \
    \   end\n    end\n    return depth\nend", "    local paren_list = split(paren_string,\
    \ ' ')\n    local nested_parens = {}\n    for _, paren in ipairs(paren_list) do\n\
    \        local max_nested = 0\n        local current_nested = 0\n        for i=1,#paren\
    \ do\n            if paren:sub(i,i) == '(' then\n                current_nested\
    \ = current_nested + 1\n                if current_nested > max_nested then\n\
    \                    max_nested = current_nested\n                end\n      \
    \      elseif paren:sub(i,i) == ')' then\n                current_nested = current_nested\
    \ - 1\n            end\n        end\n        nested_parens[#nested_parens+1] =\
    \ max_nested\n    end\n    return nested_parens\nend", "  local t = {}\n  local\
    \ max_nesting = 0\n  local sum_nesting = 0\n  local paren_count = 0\n  for c in\
    \ string.gmatch(paren_string, '.') do\n    if c == '(' then\n      paren_count\
    \ = paren_count + 1\n      max_nesting = max(max_nesting, paren_count)\n    elseif\
    \ c == ')' then\n      paren_count = paren_count - 1\n    elseif c == ' ' then\n\
    \      t[#t+1] = max_nesting\n      sum_nesting = sum_nesting + max_nesting\n\
    \      max_nesting = 0\n    end\n  end\n  -- print(paren_string)\n  -- print(table.concat(t,\
    \ ' '))\n  -- print(sum_nesting)\n  return t, sum_nesting\nend", "    return paren_string:gmatch(\"\
    (%b())\")\n        :map(function(s) return #s:gsub(\"[^(]*[^(]\", \"\") end)\n\
    end", "    local positions = {}\n    local deepest_nesting = {}\n    local start_pos\
    \ = nil\n    local nesting_level = 0\n    local current_group = 1\n    local char\n\
    \    for i = 1, string.len(paren_string) do\n        char = string.sub(paren_string,\
    \ i, i)\n        if char == '(' then\n            start_pos = i\n            nesting_level\
    \ = nesting_level + 1\n        elseif char == ')' then\n            if nesting_level\
    \ == 1 then\n                table.insert(positions, {start_pos, i})\n       \
    \         if not deepest_nesting[current_group] then\n                    deepest_nesting[current_group]\
    \ = 0\n                end\n                if nesting_level > deepest_nesting[current_group]\
    \ then\n                    deepest_nesting[current_group] = nesting_level\n \
    \               end\n                current_group = current_group + 1\n     \
    \       end\n            nesting_level = nesting_level - 1\n        elseif char\
    \ == ' ' then\n            current_group = current_group + 1\n        end\n  \
    \  end\n    return positions, deepest_nesting\nend", "  local paren_tokens = {}\n\
    \  local indices = {}\n  local opening_indices = {}\n  local closing_indices =\
    \ {}\n  for paren in paren_string:gmatch('%S+') do\n    table.insert(paren_tokens,\
    \ paren)\n  end\n  for i = 1, #paren_tokens do\n    local match = 0\n    for index\
    \ in paren_tokens[i]:gmatch('%(') do\n      table.insert(opening_indices, match\
    \ + 1)\n      match = match + 1\n    end\n    match = 0\n    for index in paren_tokens[i]:gmatch('%)')\
    \ do\n      table.insert(closing_indices, match + 1)\n      match = match + 1\n\
    \    end\n    if #opening_indices == #closing_indices then\n      table.insert(indices,\
    \ math.max(#opening_indices))\n    else\n      table.insert(indices, 0)\n    end\n\
    \    opening_indices = {}\n    closing_indices = {}\n  end\n  return indices\n\
    end", "  local paren_levels = {}\n  local current_level = 0\n  for paren in utf8.gmatch(paren_string,\
    \ '.') do\n    if paren == '(' then\n      current_level = current_level + 1\n\
    \    elseif paren == ')' then\n      current_level = current_level - 1\n    end\n\
    \    table.insert(paren_levels, current_level)\n  end\n  return paren_levels\n\
    end", "  local paren_levels = {}\n  local current_level = 0\n  for paren in paren_string:gmatch('%(%))')\
    \ do\n    if paren == '()' then\n      current_level = current_level + 1\n   \
    \ else\n      current_level = current_level - 1\n      table.insert(paren_levels,\
    \ current_level)\n    end\n  end\n  return paren_levels\nend", "    local groups\
    \ = string.split(paren_string, ' ')\n    return map(function(group)\n        local\
    \ depth = 0\n        local count = 0\n        local max_depth = 0\n        for\
    \ idx = 1, string.len(group) do\n            local char = string.sub(group, idx,\
    \ idx)\n            if char == '(' then\n                depth = depth + 1\n \
    \               count = count + 1\n                if depth > max_depth then\n\
    \                    max_depth = depth\n                end\n            elseif\
    \ char == ')' then\n                depth = depth - 1\n            end\n     \
    \   end\n        assert(count % 2 == 0)\n        return max_depth\n    end, groups)\n\
    end", "\tlocal count = {}\n\tlocal max_count = 0\n\tfor w in string.gmatch(paren_string,\
    \ '%S+') do\n\t\tcount[#count + 1] = 0\n\t\tfor p in string.gmatch(w, '%b()')\
    \ do\n\t\t\tcount[#count] = count[#count] + 1\n\t\tend\n\t\tmax_count = math.max(max_count,\
    \ count[#count])\n\tend\n\treturn count, max_count\nend", "  local stack = {}\n\
    \  local max_nesting = 0\n  local max_nesting_list = {}\n  for i = 1, #paren_string\
    \ do\n    if paren_string:sub(i, i) == '(' then\n      table.insert(stack, 1)\n\
    \    elseif paren_string:sub(i, i) == ')' then\n      table.remove(stack, 1)\n\
    \    elseif paren_string:sub(i, i) == ' ' then\n      table.insert(max_nesting_list,\
    \ max_nesting)\n      max_nesting = 0\n    end\n    max_nesting = math.max(max_nesting,\
    \ #stack)\n  end\n  table.insert(max_nesting_list, max_nesting)\n  return max_nesting_list\n\
    end", "\t-- Function outputs a table, this table contains the max nestings for\
    \ each of the groups of nested parentheses\n\tlocal nestings = {}\n\t-- First\
    \ parse the string into a table of individual characters\n\tlocal chars = {}\n\
    \tfor c in paren_string:gmatch\".\" do table.insert(chars, c) end\n\tlocal idx\
    \ = 1\n\tlocal start = 0\n\tlocal max_nesting = 0\n\tlocal count = 0\n\t-- Read\
    \ through each of the characters\n\twhile idx <= #chars do\n\t\tlocal c = chars[idx]\n\
    \t\t-- If we found a '(' then increment the counter, then keep going to the next\
    \ character\n\t\tif c == '(' then\n\t\t\tcount = count + 1\n\t\t\tidx = idx +\
    \ 1\n\t\t\t-- If we found a ')' then decrement the counter, update the max nesting\
    \ if needed,\n\t\t\t-- and keep going to the next character\n\t\telseif c == ')'\
    \ then\n\t\t\tcount = count - 1\n\t\t\tif count > max_nesting then max_nesting\
    \ = count end\n\t\t\tidx = idx + 1\n\t\t\t-- If we found a space then push the\
    \ maximum nesting found so far and reset the counters\n\t\telseif c == ' ' then\n\
    \t\t\ttable.insert(nestings, max_nesting)\n\t\t\tmax_nesting = 0\n\t\t\tcount\
    \ = 0\n\t\t\tidx = idx + 1\n\t\tend\n\tend\n\t-- After we finish reading the string,\
    \ we push the max nesting found so far one last time\n\ttable.insert(nestings,\
    \ max_nesting)\n\treturn nestings\nend", "    -- Input checks\n    if type(paren_string)\
    \ ~= 'string' then\n        error('parse_nested_parens requires a string input',\
    \ 2)\n    end", "    local depth = 0\n    local max_depth = 0\n    local depths\
    \ = {}\n    local start_idx = 1\n    local end_idx = 0\n    local i = 1\n    local\
    \ n = string.len(paren_string)\n    while i <= n do\n        local c = string.sub(paren_string,\
    \ i, i)\n        if c == '(' then\n            depth = depth + 1\n           \
    \ if depth > max_depth then\n                max_depth = depth\n            end\n\
    \        elseif c == ')' then\n            if depth == max_depth then\n      \
    \          depths[#depths + 1] = max_depth\n                max_depth = 0\n  \
    \              depth = 0\n            else\n                depth = depth - 1\n\
    \            end\n        elseif c == ' ' then\n            if depth == max_depth\
    \ then\n                depths[#depths + 1] = max_depth\n                max_depth\
    \ = 0\n                depth = 0\n            end\n        end\n        i = i\
    \ + 1\n    end\n    if depth == max_depth then\n        depths[#depths + 1] =\
    \ max_depth\n    end\n    return depths\nend", "    local paren_groups = split(paren_string,\
    \ '%s+')\n    local max_level = 0\n    local paren_level = {}\n    for i,group\
    \ in ipairs(paren_groups) do\n        local current_level = 0\n        for _,c\
    \ in utf8.codes(group) do\n            if c == 40 then -- 40 is the ASCII code\
    \ for '('\n                current_level = current_level + 1\n            elseif\
    \ c == 41 then -- 41 is the ASCII code for ')'\n                current_level\
    \ = current_level - 1\n            end\n            max_level = math.max(max_level,\
    \ current_level)\n        end\n        table.insert(paren_level, max_level)\n\
    \    end\n    return paren_level\nend", "  local max_level = {}\n  local current_level\
    \ = 0\n  local max_level_at_group = 0\n  for i=1, string.len(paren_string) do\n\
    \    local current_char = string.sub(paren_string, i, i)\n    if current_char\
    \ == '(' then\n      current_level = current_level + 1\n    elseif current_char\
    \ == ')' then\n      current_level = current_level - 1\n    elseif current_char\
    \ == ' ' then\n      max_level_at_group = math.max(max_level_at_group, current_level)\n\
    \      table.insert(max_level, max_level_at_group)\n      max_level_at_group =\
    \ 0\n    end\n  end\n  -- Insert the maximum level for the last group\n  max_level_at_group\
    \ = math.max(max_level_at_group, current_level)\n  table.insert(max_level, max_level_at_group)\n\
    \  return max_level\nend", "    local group_counts = {}\n    for group in paren_string:gmatch('%S+')\
    \ do\n        local count = 0\n        for paren in group:gmatch('[()]') do\n\
    \            if paren == '(' then\n                count = count + 1\n       \
    \     else\n                count = count - 1\n            end\n        end\n\
    \        group_counts[#group_counts + 1] = count\n    end\n    return group_counts\n\
    end", "    local max_count = 0\n    local counts = {}\n    local current_count\
    \ = 0\n    for c in paren_string:gmatch(\".\") do\n        if c == '(' then\n\
    \            current_count = current_count + 1\n            if current_count >\
    \ max_count then\n                max_count = current_count\n            end\n\
    \        elseif c == ')' then\n            current_count = current_count - 1\n\
    \        elseif c == ' ' then\n            table.insert(counts, max_count)\n \
    \           max_count = 0\n            current_count = 0\n        end\n    end\n\
    \    return counts\nend", "  local max_nested_parens = {}\n  for paren_grp in\
    \ paren_string:gmatch(\"%S+\") do\n    local max_level = 0\n    local current_level\
    \ = 0\n    for c in paren_grp:gmatch(\".\") do\n      if c == '(' then\n     \
    \   current_level = current_level + 1\n      elseif c == ')' then\n        current_level\
    \ = current_level - 1\n      end\n      if current_level > max_level then\n  \
    \      max_level = current_level\n      end\n    end\n    table.insert(max_nested_parens,\
    \ max_level)\n  end\n  return max_nested_parens\nend", "  local max_count = 1\n\
    \  local count = 0\n  local output = {}\n  for i = 1, #paren_string do\n    local\
    \ char = paren_string:sub(i, i)\n    if char == '(' then\n      count = count\
    \ + 1\n      if count > max_count then\n        max_count = count\n      end\n\
    \    elseif char == ')' then\n      count = count - 1\n    elseif char == ' '\
    \ then\n      table.insert(output, max_count)\n      max_count = 1\n      count\
    \ = 0\n    end\n  end\n  table.insert(output, max_count)\n  return output\nend",
  "    local levels = {}\n    for _, line in ipairs(string.split(paren_string, ' '))\
    \ do\n        local n_level = 0\n        for c in line:gmatch('.') do\n      \
    \      if c == '(' then\n                n_level = n_level + 1\n            elseif\
    \ c == ')' then\n                n_level = n_level - 1\n            end\n    \
    \    end\n        assert(n_level == 0, 'Mismatched parentheses in: ' .. line)\n\
    \        table.insert(levels, n_level)\n    end\n    return levels\nend", "  \
    \  local paren_counts = {}\n    for paren_str in utils.split(paren_string, ' ')\
    \ do\n        local open_count = string.count(paren_str, '(')\n        local max_nest\
    \ = 0\n        local open_count = 0\n        for ch in utils.iterator(paren_str)\
    \ do\n            if ch == '(' then\n                open_count = open_count +\
    \ 1\n                max_nest = math.max(max_nest, open_count)\n            elseif\
    \ ch == ')' then\n                open_count = open_count - 1\n            end\n\
    \        end\n        table.insert(paren_counts, max_nest)\n    end\n    return\
    \ paren_counts\nend", "  local nested_parens = {}\n  local i = 1\n  local parens\
    \ = {}\n  local group_start = 1\n  while i <= #paren_string do\n    local c =\
    \ paren_string:sub(i, i)\n    if c == '(' then\n      table.insert(parens, i)\n\
    \    elseif c == ')' then\n      table.remove(parens)\n    elseif c == ' ' then\n\
    \      if #parens == 0 then\n        local group = paren_string:sub(group_start,\
    \ i - 1)\n        table.insert(nested_parens, parse_nested_parens_group(group))\n\
    \        group_start = i + 1\n      end\n    end\n    i = i + 1\n  end\n  if group_start\
    \ <= #paren_string then\n    local group = paren_string:sub(group_start, #paren_string)\n\
    \    table.insert(nested_parens, parse_nested_parens_group(group))\n  end\n  return\
    \ nested_parens\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
