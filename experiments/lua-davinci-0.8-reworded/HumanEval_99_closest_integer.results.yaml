name: HumanEval_99_closest_integer
language: lua
results:
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpypaeiy_w.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpypaeiy_w.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local result\
    \ = 0\n  if number > 0 then\n    result = math.floor(number + 0.5)\n  else\n \
    \   result = math.ceil(number - 0.5)\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- remove all\
    \ characters that are not digits\n    -- and parse value to a number\n    local\
    \ value = tonumber(value:gsub(\"%D\", \"\"))\n    -- if it is nil, then the input\
    \ was not a number\n    if not value then\n        return 0\n    end\n    -- get\
    \ the decimal part of the number\n    local decimal = value - math.floor(value)\n\
    \    -- if the decimal part is larger than 0.5, round up\n    if decimal > 0.5\
    \ then\n        return math.ceil(value)\n    -- if the decimal part is smaller\
    \ than 0.5, round down\n    elseif decimal < 0.5 then\n        return math.floor(value)\n\
    \    -- if the decimal part is exactly 0.5, round away from zero\n    else\n \
    \       return math.floor(value * 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_779qmzc.lua:17:\
    \ bad argument #2 to 'tonumber' (base out of range)\nstack traceback:\n\t/tmp/tmp_779qmzc.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp_779qmzc.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if not num then\n        return nil\n    end\n    return num + (num > 0 and\
    \ -0.5 or 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp89u4flof.lua:25:\
    \ expected: 10, actual: 9.5\nstack traceback:\n\t/tmp/tmp89u4flof.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  if not value then\
    \ return nil end\n  return math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpry1692jw.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpry1692jw.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdlov8v66.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdlov8v66.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiytjrarv.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpiytjrarv.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphiqlm3_6.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphiqlm3_6.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp65b7kh73.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp65b7kh73.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4zhusw9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt4zhusw9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return value\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5gxloz_9.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmp5gxloz_9.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjksxrptd.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjksxrptd.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  return n and math.floor(n + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjr_d5_15.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjr_d5_15.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local closest_int\
    \ = tonumber(value)\n    if (closest_int < 0) then\n        closest_int = closest_int\
    \ - 0.5\n    else\n        closest_int = closest_int + 0.5\n    end\n    return\
    \ math.floor(closest_int)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if value == nil\
    \ then\n        return nil\n    end\n    local n = tonumber(value)\n    if n ==\
    \ nil then\n        return nil\n    end\n    local i = math.floor(n)\n    if n\
    \ < 0 then\n        if n - i <= i + 1 - n then\n            return i\n       \
    \ else\n            return i + 1\n        end\n    else\n        if n - i <= i\
    \ + 1 - n then\n            return i\n        else\n            return i + 1\n\
    \        end\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnr19txkg.lua:42:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpnr19txkg.lua:42: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    --TODO: Implement\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9cv3tl0w.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp9cv3tl0w.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
