language: lua
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpypaeiy_w.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpypaeiy_w.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local result\
    \ = 0\n  if number > 0 then\n    result = math.floor(number + 0.5)\n  else\n \
    \   result = math.ceil(number - 0.5)\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- remove all\
    \ characters that are not digits\n    -- and parse value to a number\n    local\
    \ value = tonumber(value:gsub(\"%D\", \"\"))\n    -- if it is nil, then the input\
    \ was not a number\n    if not value then\n        return 0\n    end\n    -- get\
    \ the decimal part of the number\n    local decimal = value - math.floor(value)\n\
    \    -- if the decimal part is larger than 0.5, round up\n    if decimal > 0.5\
    \ then\n        return math.ceil(value)\n    -- if the decimal part is smaller\
    \ than 0.5, round down\n    elseif decimal < 0.5 then\n        return math.floor(value)\n\
    \    -- if the decimal part is exactly 0.5, round away from zero\n    else\n \
    \       return math.floor(value * 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_779qmzc.lua:17:\
    \ bad argument #2 to 'tonumber' (base out of range)\nstack traceback:\n\t/tmp/tmp_779qmzc.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp_779qmzc.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if not num then\n        return nil\n    end\n    return num + (num > 0 and\
    \ -0.5 or 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp89u4flof.lua:25:\
    \ expected: 10, actual: 9.5\nstack traceback:\n\t/tmp/tmp89u4flof.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  if not value then\
    \ return nil end\n  return math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpry1692jw.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpry1692jw.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdlov8v66.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdlov8v66.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiytjrarv.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpiytjrarv.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphiqlm3_6.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphiqlm3_6.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp65b7kh73.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp65b7kh73.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4zhusw9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt4zhusw9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return value\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5gxloz_9.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmp5gxloz_9.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjksxrptd.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjksxrptd.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  return n and math.floor(n + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjr_d5_15.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjr_d5_15.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local closest_int\
    \ = tonumber(value)\n    if (closest_int < 0) then\n        closest_int = closest_int\
    \ - 0.5\n    else\n        closest_int = closest_int + 0.5\n    end\n    return\
    \ math.floor(closest_int)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if value == nil\
    \ then\n        return nil\n    end\n    local n = tonumber(value)\n    if n ==\
    \ nil then\n        return nil\n    end\n    local i = math.floor(n)\n    if n\
    \ < 0 then\n        if n - i <= i + 1 - n then\n            return i\n       \
    \ else\n            return i + 1\n        end\n    else\n        if n - i <= i\
    \ + 1 - n then\n            return i\n        else\n            return i + 1\n\
    \        end\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnr19txkg.lua:42:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpnr19txkg.lua:42: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    --TODO: Implement\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9cv3tl0w.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp9cv3tl0w.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return value\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkvx7qmqm.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmpkvx7qmqm.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    return math.floor(number + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptm8xufgg.lua:27:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmptm8xufgg.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return tonumber(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvkthw05v.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpvkthw05v.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4zhusw9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt4zhusw9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return value\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkvx7qmqm.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmpkvx7qmqm.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\treturn round(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpyqjptjer.lua:15:\
    \ attempt to call a nil value (global 'round')\nstack traceback:\n\t/tmp/tmpyqjptjer.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpyqjptjer.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local int, num\
    \ = string.match(value, '(%d+).(%d+)')\n    if num and tonumber(num) >= 5 then\n\
    \        return tonumber(int) + 1\n    else\n        return tonumber(int)\n  \
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4og_qv7l.lua:26:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp4og_qv7l.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- read the number\
    \ from the string, using the default reading function\n  local number = tonumber(value)\n\
    \  -- if the number is negative, round it downwards\n  if number < 0 then\n  \
    \  return math.floor(number)\n  -- if the number is positive, round it upwards\n\
    \  else\n    return math.ceil(number)\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn8fyca_6.lua:32:\
    \ expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpn8fyca_6.lua:32: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.round(tonumber(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbf0sgm04.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmpbf0sgm04.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpbf0sgm04.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  local ceiling = math.ceil(number)\n  local floor = math.floor(number)\n\
    \  if number < 0 then\n    if math.abs(number - floor) < math.abs(number - ceiling)\
    \ then\n      return floor\n    else\n      return ceiling\n    end\n  else\n\
    \    if math.abs(number - floor) > math.abs(number - ceiling) then\n      return\
    \ ceiling\n    else\n      return floor\n    end\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp57fwhqu0.lua:37:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp57fwhqu0.lua:37: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local v = tonumber(value)\n\
    \    if v == nil then\n        return \"0\"\n    end\n    return tostring(math.floor(v\
    \ + 0.5))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphlqbhzaw.lua:25:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmphlqbhzaw.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiytjrarv.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpiytjrarv.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- your code\
    \ here\n    return nil\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdxj1t_n6.lua:22:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpdxj1t_n6.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  if type(value)\
    \ ~= 'string' then\n    return nil\n  end\n  local converted = tonumber(value)\n\
    \  if converted == nil then\n    return nil\n  end\n  local integer = math.floor(converted)\n\
    \  if converted - integer >= 0.5 then\n    return integer + 1\n  else\n    return\
    \ integer\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphaiw82na.lua:35:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphaiw82na.lua:35: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return value\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkvx7qmqm.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmpkvx7qmqm.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local int = math.floor(tonumber(value))\n\
    \  local frac = tonumber(value) - int\n  if frac >= 0.5 then\n    return int +\
    \ 1\n  else\n    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdi0uka5q.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdi0uka5q.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return tonumber(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr2maj6lw.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpr2maj6lw.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4zhusw9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt4zhusw9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local i, f = math.modf(tonumber(value))\n\
    \  if f > 0.5 then\n    return i + 1\n  elseif f < -0.5 then\n    return i - 1\n\
    \  else\n    return i\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzcebdu4j.lua:29:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpzcebdu4j.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return nil\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp94azlfj7.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp94azlfj7.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp65b7kh73.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp65b7kh73.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\tlocal int_value\
    \ = tonumber(value)\n\tlocal decimal_part = int_value - math.floor(int_value)\n\
    \tif decimal_part == 0.5 then\n\t\tif int_value > 0 then\n\t\t\treturn math.ceil(int_value)\n\
    \t\telse\n\t\t\treturn math.floor(int_value)\n\t\tend\n\telse\n\t\treturn math.floor(int_value\
    \ + 0.5)\n\tend\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value+0.5)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8x7zvo5b.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8x7zvo5b.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaiwqqulq.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpaiwqqulq.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local b_positive\
    \ = value:sub(1, 1) ~= '-'\n    local value = math.abs(tonumber(value))\n    local\
    \ quotient = math.floor(value)\n    local remainder = value - quotient\n    if\
    \ remainder >= 0.5 then\n        return b_positive and quotient + 1 or -quotient\
    \ - 1\n    else\n        return b_positive and quotient or -quotient\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  local int, frac = math.modf(num)\n  local diff = frac - 0.5\n  if diff < 0\
    \ then\n    return int\n  else\n    return int + 1\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfc7hdgdp.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpfc7hdgdp.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local function\
    \ sign(x)\n        return x>0 and 1 or -1\n    end\n    local value = tonumber(value)\n\
    \    if math.floor(value) == value then\n        return value\n    else\n    \
    \    return math.floor(value + 0.5 * sign(value))\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nassert(closest_integer('10') == 10)\nassert(closest_integer('15.3')\
    \ == 15)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmtnmn220.lua:25:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmtnmn220.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return value\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5gxloz_9.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmp5gxloz_9.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if math.abs(num - math.floor(num)) >= 0.5 then\n    return math.ceil(num)\n\
    \  else\n    return math.floor(num)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwtolz6rk.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpwtolz6rk.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if value > 1\
    \ then\n        return math.floor(value)\n    elseif value < -1 then\n       \
    \ return math.ceil(value)\n    else\n        return 0\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8wbkynn_.lua:15:\
    \ attempt to compare number with string\nstack traceback:\n\t/tmp/tmp8wbkynn_.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp8wbkynn_.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: Your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc_f0yr9e.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpc_f0yr9e.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- Your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsjqh_e0j.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpsjqh_e0j.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if (value ==\
    \ nil) then\n        error(\"value is nil\")\n    end\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppnl1t2l2.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmppnl1t2l2.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    return number % 1 < 0.5 and math.floor(number) or math.ceil(number)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpscw95t4n.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpscw95t4n.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  local int = math.floor(num)\n  if num - int < 0.5 then\n    return int\n  else\n\
    \    return int + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpubckn94m.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpubckn94m.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    if number - integer\
    \ < 0.5 then\n        return integer\n    else\n        return integer + 1\n \
    \   end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxb11j3mr.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpxb11j3mr.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local float =\
    \ tonumber(value)\n    local integer = float - float % 1\n    local decimal =\
    \ float % 1\n    if decimal >= 0.5 then\n        return integer + 1\n    else\n\
    \        return integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6un8mrqj.lua:30:\
    \ expected: -16, actual: -15.0\nstack traceback:\n\t/tmp/tmp6un8mrqj.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return tonumber(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvkthw05v.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpvkthw05v.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- write your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptmaeuv8b.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmptmaeuv8b.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  local i = math.floor(n)\n  if n - i < 0.5 then\n    return i\n  else\n    return\
    \ i + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwhdrdz9s.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpwhdrdz9s.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- Write your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0elvoq3h.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp0elvoq3h.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  if n % 1 >= 0.5 then\n    return math.ceil(n)\n  else\n    return math.floor(n)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmihraw6b.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmihraw6b.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local integer,\
    \ decimal = value:match('(%d+)(%.?%d*)')\n    if #decimal > 0 then\n        if\
    \ integer + 1 == value then\n            return integer + 1\n        elseif integer\
    \ == value then\n            return integer\n        else\n            return\
    \ integer - 1\n        end\n    else\n        return tonumber(value)\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp08wtvoh0.lua:33:\
    \ expected: 15, actual: 13\nstack traceback:\n\t/tmp/tmp08wtvoh0.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local r = math.floor(tonumber(value)\
    \ + 0.5)\n  local d = tonumber(value) - r\n  if d > 0 then r = r + 1 end\n  return\
    \ r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp903ipvwt.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp903ipvwt.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\tlocal number =\
    \ tonumber(value)\n\tif number - math.floor(number) < 0.5 then\n\t\treturn math.floor(number)\n\
    \telse\n\t\treturn math.ceil(number)\n\tend\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplppv97l8.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmplppv97l8.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local n = tonumber(value)\n\
    \    if n - math.floor(n) < 0.5 then\n        return math.floor(n)\n    else\n\
    \        return math.ceil(n)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr580yoys.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpr580yoys.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- Write your\
    \ code here\n    local n = tonumber(value)\n    return n % 1 >= 0.5 and math.ceil(n)\
    \ or math.floor(n)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8krs_0yb.lua:25:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8krs_0yb.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return round(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzg_ve748.lua:15:\
    \ attempt to call a nil value (global 'round')\nstack traceback:\n\t/tmp/tmpzg_ve748.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpzg_ve748.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number > 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- code goes here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1v7v4lxv.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp1v7v4lxv.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    return number and number >= 0 and math.floor(number)\
    \ or math.ceil(number)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnapa1mks.lua:23:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpnapa1mks.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return tonumber(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr2maj6lw.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpr2maj6lw.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return value\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5gxloz_9.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmp5gxloz_9.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if type(value)\
    \ ~= 'string' then\n        error('must be string')\n    end\n    if tonumber(value)\
    \ then\n        return math.floor(tonumber(value) + 0.5)\n    else\n        return\
    \ nil\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8_e_3zez.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8_e_3zez.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number < 0 then\n        return -closest_integer(-number)\n\
    \    end\n    local integer = math.floor(number)\n    local fraction = number\
    \ - integer\n    if fraction < 0.5 then\n        return integer\n    else\n  \
    \      return integer + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    local remainder\
    \ = number - integer\n    return integer + (remainder > 0.5 and 1 or 0)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx0ij_yb4.lua:25:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpx0ij_yb4.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local rounded = math.floor(number + 0.5)\n    if number\
    \ < 0 then\n        rounded = math.ceil(number - 0.5)\n    end\n    return rounded\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp65b7kh73.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp65b7kh73.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- Implement your\
    \ solution here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnfqwemkd.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpnfqwemkd.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- Write your\
    \ code here\n    return closest_integer\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoim2dk24.lua:22:\
    \ expected: 10, actual: function: 0x55fe778fa690\nstack traceback:\n\t/tmp/tmpoim2dk24.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  assert(number, 'Invalid value type')\n  return math.floor(number\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpafmj0vjt.lua:25:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpafmj0vjt.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- Parsing the\
    \ string to a number\n    local parsed_value = tonumber(value)\n    -- Comparing\
    \ the number to the next and previous integer\n    if parsed_value % 1 > 0.5 then\n\
    \        return math.ceil(parsed_value)\n    elseif parsed_value % 1 < 0.5 then\n\
    \        return math.floor(parsed_value)\n    else\n        return math.ceil(parsed_value)\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps3gc7n1r.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmps3gc7n1r.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local f = function(x)\n\
    \    local floor = math.floor(x)\n    local ceil = math.ceil(x)\n    local diff1\
    \ = math.abs(x - floor)\n    local diff2 = math.abs(x - ceil)\n    return diff1\
    \ < diff2 and floor or ceil\n  end\n  local number = tonumber(value)\n  return\
    \ (number ~= nil) and f(number) or nil\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpeadcdao5.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpeadcdao5.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return value\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkvx7qmqm.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmpkvx7qmqm.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local f, _ = math.modf(value)\n\
    \  return (f >= 0.5) and math.ceil(value) or math.floor(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdw73yfti.lua:25:\
    \ expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpdw73yfti.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\tlocal result =\
    \ math.floor(value + 0.5)\n\treturn result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6sdjz1fe.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6sdjz1fe.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return tonumber(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvkthw05v.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpvkthw05v.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphiqlm3_6.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphiqlm3_6.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local _,_,num =\
    \ string.find(value, '(-?%d*%.?%d*)')\n  return math.floor(num + 0.5)\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3uo4mwge.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3uo4mwge.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local result = number\n    local floor = math.floor(number)\n\
    \    local ceil = math.ceil(number)\n    local diff = number - floor\n    local\
    \ ceil_diff = ceil - number\n    if diff > ceil_diff then\n        result = ceil\n\
    \    elseif diff < ceil_diff then\n        result = floor\n    else\n        if\
    \ number > 0 then\n            result = ceil\n        else\n            result\
    \ = floor\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  if tonumber(value)\
    \ == nil then\n    return nil\n  end\n  return math.floor(value + 0.5)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqsw4g7n2.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpqsw4g7n2.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local y = math.floor(tonumber(value))\n\
    \    local z = y + 1\n    local diff1 = value - y\n    local diff2 = z - value\n\
    \    if diff1 < diff2 then\n        return y\n    else\n        return z\n   \
    \ end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprybplci8.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprybplci8.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.round(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp11fnfswt.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmp11fnfswt.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp11fnfswt.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjksxrptd.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjksxrptd.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- return the closest\
    \ integer from given value\n  --\n  -- parameters:\n  --  value (string): string\
    \ representing a number\n  --\n  -- returns:\n  --  (integer): the closest integer\
    \ from given value\n  local num = tonumber(value)\n  if num % 1 >= 0.5 then\n\
    \    return math.ceil(num)\n  else\n    return math.floor(num)\n  end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuhmzvsv1.lua:35:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpuhmzvsv1.lua:35: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- your code\
    \ here\n    return math.floor(value+0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp95s9m91t.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp95s9m91t.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.ceil(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3daerzk4.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3daerzk4.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local converted\
    \ = tonumber(value)\n  local integer = math.floor(converted)\n  local decimal\
    \ = converted - integer\n  if decimal < 0.5 then\n    return integer\n  else\n\
    \    return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu_xmeem3.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpu_xmeem3.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if not num then\n        return nil\n    end\n    local i, f = math.modf(num)\n\
    \    return f > 0.5 and i + 1 or i\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqngwisvj.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpqngwisvj.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp65b7kh73.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp65b7kh73.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- write your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmbn6yui4.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpmbn6yui4.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    if integer +\
    \ 0.5 <= number then\n        return integer + 1\n    else\n        return integer\n\
    \    end\nend\nassert(closest_integer('10') == 10)\nassert(closest_integer('15.3')\
    \ == 15)\nassert(closest_integer('14.5') == 15)\nassert(closest_integer('-14.5')\
    \ == -15)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: "lua: /tmp/tmpgzbcor9j.lua:26: assertion failed!\nstack traceback:\n\t[C]:\
    \ in function 'assert'\n\t/tmp/tmpgzbcor9j.lua:26: in main chunk\n\t[C]: in ?\n"
  stdout: ''
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  local int = math.floor(n)\n  if n - int < 0.5 then\n    return int\n  else\n\
    \    return int + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpib1ar9u5.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpib1ar9u5.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if not value\
    \ then\n        return nil\n    end\n    local v = tonumber(value)\n    local\
    \ c = math.floor(v + 0.5)\n    if v - c > 0.5 then\n        c = c + 1\n    end\n\
    \    return c\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6bo9a35r.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6bo9a35r.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- your code\
    \ here\n    return tonumber(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmmmuwjap.lua:23:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpmmmuwjap.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  assert(num)\n  return math.floor(num + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwc83x21u.lua:25:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpwc83x21u.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjksxrptd.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjksxrptd.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local value_n\
    \ = tonumber(value)\n    local b, e = math.modf(value_n)\n    if value_n >= 0\
    \ then\n        return (e >= 0.5) and b + 1 or b\n    else\n        return (e\
    \ >= -0.5) and b or b - 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplfhklvqc.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmplfhklvqc.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if not value\
    \ then\n        return nil\n    end\n    return math.floor(value + 0.5)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd_fdm0sf.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpd_fdm0sf.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiytjrarv.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpiytjrarv.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return (math.floor(tonumber(value)\
    \ + 0.5))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfnbi3719.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpfnbi3719.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp65b7kh73.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp65b7kh73.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local fraction\
    \ = number - math.floor(number)\n  if fraction < 0.5 then\n    return math.floor(number)\n\
    \  else\n    return math.ceil(number)\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3h7g8avz.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3h7g8avz.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  local int_part = math.floor(num)\n  local frac_part = num - int_part\n  local\
    \ result\n  if frac_part == 0.5 then\n    result = num >= 0 and int_part + 1 or\
    \ int_part - 1\n  else\n    result = num >= 0 and math.ceil(num) or math.floor(num)\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwhvfiq_h.lua:32:\
    \ expected: -16, actual: -17\nstack traceback:\n\t/tmp/tmpwhvfiq_h.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return tonumber(string.format(\"\
    %.0f\", value))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphszg0exa.lua:22:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmphszg0exa.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.round(tonumber(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbf0sgm04.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmpbf0sgm04.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpbf0sgm04.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- your code\
    \ here\n    return nil\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdxj1t_n6.lua:22:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpdxj1t_n6.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: Implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgnaq7fq7.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpgnaq7fq7.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return (math.floor(value\
    \ + 0.5))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp13ebcjfv.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp13ebcjfv.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- YOUR CODE HERE\n\
    \  local num_value = tonumber(value)\n  if num_value < 0 then\n    num_value =\
    \ num_value - 0.5\n  else\n    num_value = num_value + 0.5\n  end\n  return math.floor(num_value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local flt = tonumber(value)\n\
    \    local int = math.floor(flt)\n    if (flt - int >= 0.5) then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp308nfdk8.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp308nfdk8.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.ceil(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3daerzk4.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3daerzk4.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local int, frac\
    \ = string.match(value, '(%d+)%.(%d+)')\n    if frac == nil then\n        return\
    \ tonumber(value)\n    elseif string.sub(frac, 1, 1) == '5' then\n        return\
    \ tonumber(int) + 1\n    else\n        return tonumber(int)\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9ggj43s5.lua:30:\
    \ expected: -16, actual: 16\nstack traceback:\n\t/tmp/tmp9ggj43s5.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- local res,\
    \ _ = math.modf(tonumber(value))\n    -- if res >= 0.5 then\n    --     return\
    \ res + 1\n    -- else\n    --     return res\n    -- end\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpeat04z2x.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpeat04z2x.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  if n then\n    return math.floor(n + 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpykgmupsb.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpykgmupsb.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local val = tonumber(value)\n\
    \  if val > 0 then\n    return math.floor(val + 0.5)\n  else\n    return math.ceil(val\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if not num then\n    return nil\n  end\n  return math.floor(num + 0.5)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl35_o9xu.lua:27:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpl35_o9xu.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- implementation\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpra7cd2b9.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpra7cd2b9.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local int = math.floor(tonumber(value))\n\
    \    if tonumber(value) - int < 0.5 then\n        return int\n    else\n     \
    \   return int + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplhci60wx.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmplhci60wx.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if not value\
    \ then\n        return nil\n    end\n    local int, frac = math.modf(tonumber(value))\n\
    \    if math.abs(frac) >= 0.5 then\n        int = int + (frac < 0 and -1 or 1)\n\
    \    end\n    return int\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiytjrarv.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpiytjrarv.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local is_neg = false\n    if number < 0 then\n      \
    \  is_neg = true\n        number = number * -1\n    end\n    local integer = math.floor(number)\n\
    \    local difference = number - integer\n    if difference < 0.5 then\n     \
    \   return integer\n    else\n        return integer + 1\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2xc5mze6.lua:35:\
    \ expected: -16, actual: 16\nstack traceback:\n\t/tmp/tmp2xc5mze6.lua:35: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value+0.5)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9a4qmz5t.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp9a4qmz5t.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    return math.floor(number + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuf29h6iv.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpuf29h6iv.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.ceil(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3daerzk4.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3daerzk4.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integral, fractional = math.modf(number)\n    if\
    \ fractional >= 0.5 then\n        return integral + 1\n    else\n        return\
    \ integral\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzhf4jtqm.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpzhf4jtqm.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4zhusw9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt4zhusw9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return\n    end\n    if num >= 0 then\n     \
    \   return math.floor(num + 0.5)\n    else\n        return math.ceil(num - 0.5)\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4zhusw9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt4zhusw9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4zhusw9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt4zhusw9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.round(tonumber(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbf0sgm04.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmpbf0sgm04.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpbf0sgm04.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009471
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  value = tonumber(value)\n\
    \  local abs_value = math.abs(value)\n  local floor_value = math.floor(abs_value)\n\
    \  local diff = abs_value - floor_value\n  local ceil_value = math.ceil(abs_value)\n\
    \  local difference = math.abs(ceil_value - abs_value)\n  if diff < difference\
    \ then\n    return floor_value * math.sign(value)\n  else\n    return ceil_value\
    \ * math.sign(value)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptyv2fxrm.lua:24:\
    \ attempt to call a nil value (field 'sign')\nstack traceback:\n\t/tmp/tmptyv2fxrm.lua:24:\
    \ in local 'candidate'\n\t/tmp/tmptyv2fxrm.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  if type(value)\
    \ ~= 'string' then\n    return\n  end\n  local fl = tonumber(value)\n  if fl %\
    \ 1 < 0.5 then\n    return math.floor(fl)\n  else\n    return math.ceil(fl)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8andajih.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8andajih.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local n = tonumber(value)\n\
    \    if n ~= n then return nil end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp_cq6n6em.lua:28: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local function\
    \ ci_helper(n)\n        local flr = math.floor(n)\n        if n - flr > 0.5 then\n\
    \            return flr + 1\n        else\n            return flr\n        end\n\
    \    end\n    local n = tonumber(value)\n    if n == nil then\n        return\
    \ nil\n    else\n        return ci_helper(n)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpea5gkaqz.lua:35:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpea5gkaqz.lua:35: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.round(tonumber(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbf0sgm04.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmpbf0sgm04.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpbf0sgm04.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: you\
    \ code here\n    local num = value\n    if num > 0 then\n        return math.floor(num\
    \ + 0.5)\n    else\n        return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbs4_l2qw.lua:17:\
    \ attempt to compare number with string\nstack traceback:\n\t/tmp/tmpbs4_l2qw.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmpbs4_l2qw.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4zhusw9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt4zhusw9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local n = tonumber(value)\n\
    \    if n ~= n then\n        error(\"value must be a number or a number string\"\
    )\n    end\n    if n == math.floor(n) then\n        return n\n    end\n    local\
    \ sign = n >= 0 and 1 or -1\n    return sign * math.floor(math.abs(n) + 0.5)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local to_string\
    \ = tostring(value)\n    local number = tonumber(to_string)\n    local offset\
    \ = 0.5\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp7gcd3jo9.lua:29: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
  timestamp: 1660009472
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local ivalue\
    \ = tonumber(value)\n    if ivalue > 0 then\n        return math.floor(ivalue\
    \ + 0.5)\n    else\n        return math.ceil(ivalue - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaiwqqulq.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpaiwqqulq.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return 0\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt_bn1bmo.lua:21:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpt_bn1bmo.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value+0.5)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8x7zvo5b.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8x7zvo5b.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009471
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = math.floor(tonumber(value)\
    \ + 0.5)\n  return (value - n) <= 0 and n or n - 1\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphptiibsv.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphptiibsv.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyhpualn2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyhpualn2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local int_part,\
    \ dec_part = math.modf(value)\n  local rounded_value = int_part\n  if dec_part\
    \ > 0.5 then\n    rounded_value = int_part + 1\n  elseif dec_part < -0.5 then\n\
    \    rounded_value = int_part - 1\n  end\n  return rounded_value\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpib_8bti2.lua:29:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpib_8bti2.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpncn0p_mt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpncn0p_mt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiytjrarv.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpiytjrarv.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    if value == '0'\
    \ then\n        return 0\n    end\n    local n = tonumber(value)\n    local x\
    \ = math.floor(n)\n    local y = math.ceil(n)\n    if n - x > y - n then\n   \
    \     return y\n    else\n        return x\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp75iwc1id.lua:32:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp75iwc1id.lua:32: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.ceil(tonumber(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6mzfw8eo.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6mzfw8eo.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local f = tonumber(value)\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpbyx8m3ol.lua:27: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
  timestamp: 1660009472
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kctg58q.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kctg58q.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
