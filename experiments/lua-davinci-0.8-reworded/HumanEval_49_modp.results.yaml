name: HumanEval_49_modp
language: lua
results:
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  return n % p\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp932fnjfz.lua:20:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmp932fnjfz.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  if n % 2 == 0 then\n    local tmp = modp(n/2, p)\n    return\
    \ tmp * tmp % p\n  else\n    return n * modp(n-1, p) % p\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplo7gqscw.lua:26:\
    \ expected: 2, actual: 94\nstack traceback:\n\t/tmp/tmplo7gqscw.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal b = to_binary(n)\n\
    \tlocal r = 1\n\tfor i = #b, 1, -1 do\n\t\tr = (r * r) % p\n\t\tif b[i] == 1 then\n\
    \t\t\tr = (r * 2) % p\n\t\tend\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptmkgtdhv.lua:13:\
    \ attempt to call a nil value (global 'to_binary')\nstack traceback:\n\t/tmp/tmptmkgtdhv.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmptmkgtdhv.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  assert(n >= 0,\
    \ \"expected n >= 0\")\n  if n == 0 then return 1 end\n  if n < 1024 then\n  \
    \  -- efficient for small n\n    return 2^n % p\n  else\n    -- beware of the\
    \ numerics for large n\n    local N = 2^(n % (intlog2(p)-1))\n    return (N *\
    \ 2^(n - n % (intlog2(p)-1))) % p\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpc0vgsa96.lua:20:\
    \ attempt to call a nil value (global 'intlog2')\nstack traceback:\n\t/tmp/tmpc0vgsa96.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmpc0vgsa96.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local t = 1\n\
    \    local r = 1\n    for i = 0, p-1 do\n        if n & t > 0 then\n         \
    \   r = (r * 2) % p\n        end\n        t = t * 2\n    end\n    return r\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy72cs46l.lua:27:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpy72cs46l.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tassert(p > 1,\
    \ \"prime number p must be > 1\")\n\tassert(type(n) == \"number\", \"n must be\
    \ a number\")\n\tassert(type(p) == \"number\", \"p must be a number\")\n\tlocal\
    \ ret = 1\n\tfor i = 1, n do\n\t\tret = ret * 2 % p\n\tend\n\treturn ret\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return n\n    elseif n % 2\
    \ == 0 then\n        local e = modp(n / 2, p)\n        return (e * e) % p\n  \
    \  else\n        return (n * modp(n - 1, p)) % p\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5vstq0b8.lua:29:\
    \ expected: 2, actual: 94\nstack traceback:\n\t/tmp/tmp5vstq0b8.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  local u = 2^math.mod(n, p-1)\n  local res = math.mod(u * 2^math.floor(n/(p-1)),\
    \ p)\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzz0_07pv.lua:14:\
    \ attempt to call a nil value (field 'mod')\nstack traceback:\n\t/tmp/tmpzz0_07pv.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpzz0_07pv.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif p <= 0 then\
    \ error('p must be > 0', 2) end\n\tif n < 0 then error('n must be >= 0', 2) end\n\
    \tif n == 0 then return 1 end\n\tif n % 2 == 0 then\n\t\treturn (modp(n/2, p)^2)\
    \ % p\n\telse\n\t\treturn (2 * modp(n-1, p)) % p\n\tend\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  local x = n\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * x)\
    \ % p\n    end\n    x = (x * x) % p\n    n = math.floor(n / 2)\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjb5tv04_.lua:28:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpjb5tv04_.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    return floor(p\
    \ * (n - floor(n / p) * p))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7n6twz1k.lua:13:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmp7n6twz1k.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmp7n6twz1k.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local res =\
    \ 1\n    for i = 1, n do\n        res = res * 2 % p\n    end\n    return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if p == 1 then\n\
    \        return 0\n    end\n    if n == 0 then\n        return 1\n    end\n  \
    \  local x = modp(n//2, p)\n    local x = (x * x) % p\n    if n % 2 == 1 then\n\
    \        x = (x * 2) % p\n    end\n    return x\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local r = 1\n\
    \  local x = n\n  while n > 0 do\n    if n % 2 == 1 then\n      r = (r * x) %\
    \ p\n    end\n    x = (x * x) % p\n    n = math.floor(n / 2)\n  end\n  return\
    \ r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvdumibta.lua:28:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpvdumibta.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local r = 1\n\
    \  for i = 1, #n do\n    local d = n:sub(i, i)\n    r = (r * 2^d) % p\n  end\n\
    \  return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgsku_k8_.lua:14:\
    \ attempt to get length of a number value (local 'n')\nstack traceback:\n\t/tmp/tmpgsku_k8_.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpgsku_k8_.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local val = 1\n\
    \  for i = 1, n do\n    val = (val * 2) % p\n  end\n  return val\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = 1\n\
    \    while n > 0 do\n        if n % 2 == 1 then\n            r = (r * 2) % p\n\
    \        end\n        n = math.floor(n / 2)\n    end\n    return r\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n  \
    \  lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
    \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsex9xiq0.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpsex9xiq0.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local n = n\
    \ % p\n    if n == 0 then\n        return 1\n    else\n        return n\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdg9jk81l.lua:25:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpdg9jk81l.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  local nn = modp(n>>1, p)^2 % p\n  if n & 1 == 1 then\n    return\
    \ nn * 2 % p\n  else\n    return nn\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if (n == 0)\
    \ then\n        return 1\n    elseif (n % 2 == 0) then\n        return (modp(n\
    \ / 2, p) ^ 2) % p\n    else\n        return (modp(n - 1, p) * 2) % p\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
