name: HumanEval_21_rescale_to_unit
language: lua
prompt: "-- Given table of numbers (of at least two elements), apply a linear transform\
  \ to that table,\n-- such that the smallest number will become 0 and the largest\
  \ will become 1\n-- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25,\
  \ 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n\
  \    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0,\
  \ 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}),\
  \ {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0,\
  \ 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local min_number = min(numbers)\n    local max_number = max(numbers)\n\
    \    local range = max_number - min_number\n    local result = {}\n    for _,number\
    \ in ipairs(numbers) do\n        table.insert(result, (number - min_number) /\
    \ range)\n    end\n    return result\nend", "  local max = numbers[1]\n  local\
    \ min = numbers[1]\n  for _, number in ipairs(numbers) do\n    if number > max\
    \ then\n      max = number\n    end\n    if number < min then\n      min = number\n\
    \    end\n  end\n  return transform_table(numbers, function(x) return (x - min)\
    \ / (max - min) end)\nend", "    assert(#numbers >= 2)\n    local min, max = numbers[1],\
    \ numbers[1]\n    for _,v in ipairs(numbers) do\n        if v < min then min =\
    \ v\n        elseif v > max then max = v end\n    end\n    local range = max -\
    \ min\n    local result = {}\n    for _,v in ipairs(numbers) do\n        table.insert(result,\
    \ (v - min) / range)\n    end\n    return result\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, num in ipairs(numbers) do\n        if\
    \ min > num then\n            min = num\n        end\n        if max < num then\n\
    \            max = num\n        end\n    end\n    local result = {}\n    for _,\
    \ num in ipairs(numbers) do\n        result[#result + 1] = (num - min) / (max\
    \ - min)\n    end\n    return result\nend", "    local min = numbers[1]\n    local\
    \ max = numbers[1]\n    for _, v in ipairs(numbers) do\n        if v < min then\n\
    \            min = v\n        end\n        if v > max then\n            max =\
    \ v\n        end\n    end\n    local result = {}\n    for _, v in ipairs(numbers)\
    \ do\n        table.insert(result, (v - min) / (max - min))\n    end\n    return\
    \ result\nend", "\tassert(numbers ~= nil)\n\tassert(#numbers >= 2)\n\t\n\tlocal\
    \ function rescale_helper(numbers, min, max)\n\t\tlocal new_table = {}\n\t\tfor\
    \ _, v in ipairs(numbers) do\n\t\t\tif v < min then\n\t\t\t\tmin = v\n\t\t\tend\n\
    \t\t\tif v > max then\n\t\t\t\tmax = v\n\t\t\tend\n\t\tend\n\t\t\n\t\tlocal range\
    \ = max - min\n\t\t\n\t\tfor _, v in ipairs(numbers) do\n\t\t\ttable.insert(new_table,\
    \ (v - min) / range)\n\t\tend\n\t\t\n\t\treturn new_table\n\tend\n\t\n\tlocal\
    \ new_table = rescale_helper(numbers, numbers[1], numbers[1])\n\t\n\treturn new_table\n\
    end", "\tlocal min, max = min_max(numbers)\n\tif min == max then\n\t\treturn {0.5}\n\
    \tend\n\tlocal scale = max - min\n\tlocal result = {}\n\tfor _, n in ipairs(numbers)\
    \ do\n\t\ttable.insert(result, (n - min) / scale)\n\tend\n\treturn result\nend",
  "  local min = numbers[1]\n  local max = numbers[1]\n  for _, number in ipairs(numbers)\
    \ do\n    if number < min then\n      min = number\n    end\n    if number > max\
    \ then\n      max = number\n    end\n  end\n  local scale = 1 / (max - min)\n\
    \  local result = {}\n  for _, number in ipairs(numbers) do\n    table.insert(result,\
    \ (number - min) * scale)\n  end\n  return result\nend", "\tlocal min = math.min(table.unpack(numbers))\n\
    \tlocal max = math.max(table.unpack(numbers))\n\treturn tablex.map(function(x)\
    \ return (x - min) / (max - min) end, numbers)\nend", "    local highest = math.max(unpack(numbers))\n\
    \    local smallest = math.min(unpack(numbers))\n    local scaled = {}\n    for\
    \ _, num in ipairs(numbers) do\n        table.insert(scaled, (num - smallest)\
    \ / (highest - smallest))\n    end\n    return scaled\nend", "  local min_value\
    \ = math.min(unpack(numbers))\n  local max_value = math.max(unpack(numbers))\n\
    \  local scale = max_value - min_value\n  local normalized = {}\n  for i,v in\
    \ ipairs(numbers) do\n    table.insert(normalized, (v - min_value) / scale)\n\
    \  end\n  return normalized\nend", "    local min = numbers[1]\n    local max\
    \ = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i] < min then\n\
    \            min = numbers[i]\n        elseif numbers[i] > max then\n        \
    \    max = numbers[i]\n        end\n    end\n    local result = {}\n    for i\
    \ = 1, #numbers do\n        result[i] = (numbers[i] - min) / (max - min)\n   \
    \ end\n    return result\nend", "\tlocal min_value = numbers[1]\n\tlocal max_value\
    \ = numbers[1]\n\tfor _,n in ipairs(numbers) do\n\t\tif n < min_value then min_value\
    \ = n end\n\t\tif n > max_value then max_value = n end\n\tend\n\tif max_value\
    \ > min_value then\n\t\tfor i,n in ipairs(numbers) do\n\t\t\tnumbers[i] = (n -\
    \ min_value) / (max_value - min_value)\n\t\tend\n\tend\n\treturn numbers\nend",
  "  local minimum, maximum = math.huge, -math.huge\n  for _, n in ipairs(numbers)\
    \ do\n    minimum = math.min(minimum, n)\n    maximum = math.max(maximum, n)\n\
    \  end\n  local function rescale(x)\n    return (x - minimum) / (maximum - minimum)\n\
    \  end\n  return fmap(rescale, numbers)\nend", "\tlocal min, max = nil, nil\n\t\
    for _,number in ipairs(numbers) do\n\t\tif min == nil or number < min then\n\t\
    \t\tmin = number\n\t\tend\n\t\tif max == nil or number > max then\n\t\t\tmax =\
    \ number\n\t\tend\n\tend\n\tlocal result = {}\n\tfor _,number in ipairs(numbers)\
    \ do\n\t\tresult[#result+1] = (number - min) / (max - min)\n\tend\n\treturn result\n\
    end", "\tif not numbers then\n\t\treturn\n\tend\n\tlocal n = #numbers\n\tif n\
    \ < 2 then\n\t\treturn numbers\n\tend\n\tlocal min_val = math.huge\n\tlocal max_val\
    \ = -math.huge\n\tfor i = 1, n do\n\t\tmin_val = math.min(min_val, numbers[i])\n\
    \t\tmax_val = math.max(max_val, numbers[i])\n\tend\n\tlocal range = max_val -\
    \ min_val\n\tfor i = 1, n do\n\t\tnumbers[i] = (numbers[i] - min_val) / range\n\
    \tend\n\treturn numbers\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for _, number in ipairs(numbers) do\n        if number < min then\n     \
    \       min = number\n        end\n        if number > max then\n            max\
    \ = number\n        end\n    end\n    local scale = 1 / (max - min)\n    local\
    \ rescaled = {}\n    for _, number in ipairs(numbers) do\n        table.insert(rescaled,\
    \ (number - min) * scale)\n    end\n    return rescaled\nend", "  -- all numbers\
    \ must be finite\n  local smallest = math.huge\n  local largest = -math.huge\n\
    \  for _, num in ipairs(numbers) do\n    assert(math.type(num) == \"float\")\n\
    \    assert(num == num) -- must be not NaN\n    if num < smallest then\n     \
    \ smallest = num\n    end\n    if num > largest then\n      largest = num\n  \
    \  end\n  end\n  -- nothing to do if all numbers are the same\n  if smallest ==\
    \ largest then\n    return numbers\n  end\n  -- rescale\n  local new_numbers =\
    \ {}\n  for _, num in ipairs(numbers) do\n    new_numbers[#new_numbers + 1] =\
    \ (num - smallest) / (largest - smallest)\n  end\n  return new_numbers\nend",
  "    local min, max = min_max(numbers)\n    local mul = 1.0 / (max - min)\n    local\
    \ r = {}\n    for _,v in ipairs(numbers) do\n        r[#r+1] = (v - min) * mul\n\
    \    end\n    return r\nend", "  local min = math.min(unpack(numbers))\n  local\
    \ max = math.max(unpack(numbers))\n  local result = {}\n  for _, number in ipairs(numbers)\
    \ do\n    table.insert(result, (number - min) / (max - min))\n  end\n  return\
    \ result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
