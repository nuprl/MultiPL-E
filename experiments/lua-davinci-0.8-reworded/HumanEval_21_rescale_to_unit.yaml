name: HumanEval_21_rescale_to_unit
language: lua
prompt: "-- Given table of numbers (of at least two elements), apply a linear transform\
  \ to that table,\n-- such that the smallest number will become 0 and the largest\
  \ will become 1\n-- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25,\
  \ 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n\
  \    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0,\
  \ 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}),\
  \ {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0,\
  \ 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local min_number = min(numbers)\n    local max_number = max(numbers)\n\
    \    local range = max_number - min_number\n    local result = {}\n    for _,number\
    \ in ipairs(numbers) do\n        table.insert(result, (number - min_number) /\
    \ range)\n    end\n    return result\nend", "  local max = numbers[1]\n  local\
    \ min = numbers[1]\n  for _, number in ipairs(numbers) do\n    if number > max\
    \ then\n      max = number\n    end\n    if number < min then\n      min = number\n\
    \    end\n  end\n  return transform_table(numbers, function(x) return (x - min)\
    \ / (max - min) end)\nend", "    assert(#numbers >= 2)\n    local min, max = numbers[1],\
    \ numbers[1]\n    for _,v in ipairs(numbers) do\n        if v < min then min =\
    \ v\n        elseif v > max then max = v end\n    end\n    local range = max -\
    \ min\n    local result = {}\n    for _,v in ipairs(numbers) do\n        table.insert(result,\
    \ (v - min) / range)\n    end\n    return result\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, num in ipairs(numbers) do\n        if\
    \ min > num then\n            min = num\n        end\n        if max < num then\n\
    \            max = num\n        end\n    end\n    local result = {}\n    for _,\
    \ num in ipairs(numbers) do\n        result[#result + 1] = (num - min) / (max\
    \ - min)\n    end\n    return result\nend", "    local min = numbers[1]\n    local\
    \ max = numbers[1]\n    for _, v in ipairs(numbers) do\n        if v < min then\n\
    \            min = v\n        end\n        if v > max then\n            max =\
    \ v\n        end\n    end\n    local result = {}\n    for _, v in ipairs(numbers)\
    \ do\n        table.insert(result, (v - min) / (max - min))\n    end\n    return\
    \ result\nend", "\tassert(numbers ~= nil)\n\tassert(#numbers >= 2)\n\t\n\tlocal\
    \ function rescale_helper(numbers, min, max)\n\t\tlocal new_table = {}\n\t\tfor\
    \ _, v in ipairs(numbers) do\n\t\t\tif v < min then\n\t\t\t\tmin = v\n\t\t\tend\n\
    \t\t\tif v > max then\n\t\t\t\tmax = v\n\t\t\tend\n\t\tend\n\t\t\n\t\tlocal range\
    \ = max - min\n\t\t\n\t\tfor _, v in ipairs(numbers) do\n\t\t\ttable.insert(new_table,\
    \ (v - min) / range)\n\t\tend\n\t\t\n\t\treturn new_table\n\tend\n\t\n\tlocal\
    \ new_table = rescale_helper(numbers, numbers[1], numbers[1])\n\t\n\treturn new_table\n\
    end", "\tlocal min, max = min_max(numbers)\n\tif min == max then\n\t\treturn {0.5}\n\
    \tend\n\tlocal scale = max - min\n\tlocal result = {}\n\tfor _, n in ipairs(numbers)\
    \ do\n\t\ttable.insert(result, (n - min) / scale)\n\tend\n\treturn result\nend",
  "  local min = numbers[1]\n  local max = numbers[1]\n  for _, number in ipairs(numbers)\
    \ do\n    if number < min then\n      min = number\n    end\n    if number > max\
    \ then\n      max = number\n    end\n  end\n  local scale = 1 / (max - min)\n\
    \  local result = {}\n  for _, number in ipairs(numbers) do\n    table.insert(result,\
    \ (number - min) * scale)\n  end\n  return result\nend", "\tlocal min = math.min(table.unpack(numbers))\n\
    \tlocal max = math.max(table.unpack(numbers))\n\treturn tablex.map(function(x)\
    \ return (x - min) / (max - min) end, numbers)\nend", "    local highest = math.max(unpack(numbers))\n\
    \    local smallest = math.min(unpack(numbers))\n    local scaled = {}\n    for\
    \ _, num in ipairs(numbers) do\n        table.insert(scaled, (num - smallest)\
    \ / (highest - smallest))\n    end\n    return scaled\nend", "  local min_value\
    \ = math.min(unpack(numbers))\n  local max_value = math.max(unpack(numbers))\n\
    \  local scale = max_value - min_value\n  local normalized = {}\n  for i,v in\
    \ ipairs(numbers) do\n    table.insert(normalized, (v - min_value) / scale)\n\
    \  end\n  return normalized\nend", "    local min = numbers[1]\n    local max\
    \ = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i] < min then\n\
    \            min = numbers[i]\n        elseif numbers[i] > max then\n        \
    \    max = numbers[i]\n        end\n    end\n    local result = {}\n    for i\
    \ = 1, #numbers do\n        result[i] = (numbers[i] - min) / (max - min)\n   \
    \ end\n    return result\nend", "\tlocal min_value = numbers[1]\n\tlocal max_value\
    \ = numbers[1]\n\tfor _,n in ipairs(numbers) do\n\t\tif n < min_value then min_value\
    \ = n end\n\t\tif n > max_value then max_value = n end\n\tend\n\tif max_value\
    \ > min_value then\n\t\tfor i,n in ipairs(numbers) do\n\t\t\tnumbers[i] = (n -\
    \ min_value) / (max_value - min_value)\n\t\tend\n\tend\n\treturn numbers\nend",
  "  local minimum, maximum = math.huge, -math.huge\n  for _, n in ipairs(numbers)\
    \ do\n    minimum = math.min(minimum, n)\n    maximum = math.max(maximum, n)\n\
    \  end\n  local function rescale(x)\n    return (x - minimum) / (maximum - minimum)\n\
    \  end\n  return fmap(rescale, numbers)\nend", "\tlocal min, max = nil, nil\n\t\
    for _,number in ipairs(numbers) do\n\t\tif min == nil or number < min then\n\t\
    \t\tmin = number\n\t\tend\n\t\tif max == nil or number > max then\n\t\t\tmax =\
    \ number\n\t\tend\n\tend\n\tlocal result = {}\n\tfor _,number in ipairs(numbers)\
    \ do\n\t\tresult[#result+1] = (number - min) / (max - min)\n\tend\n\treturn result\n\
    end", "\tif not numbers then\n\t\treturn\n\tend\n\tlocal n = #numbers\n\tif n\
    \ < 2 then\n\t\treturn numbers\n\tend\n\tlocal min_val = math.huge\n\tlocal max_val\
    \ = -math.huge\n\tfor i = 1, n do\n\t\tmin_val = math.min(min_val, numbers[i])\n\
    \t\tmax_val = math.max(max_val, numbers[i])\n\tend\n\tlocal range = max_val -\
    \ min_val\n\tfor i = 1, n do\n\t\tnumbers[i] = (numbers[i] - min_val) / range\n\
    \tend\n\treturn numbers\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for _, number in ipairs(numbers) do\n        if number < min then\n     \
    \       min = number\n        end\n        if number > max then\n            max\
    \ = number\n        end\n    end\n    local scale = 1 / (max - min)\n    local\
    \ rescaled = {}\n    for _, number in ipairs(numbers) do\n        table.insert(rescaled,\
    \ (number - min) * scale)\n    end\n    return rescaled\nend", "  -- all numbers\
    \ must be finite\n  local smallest = math.huge\n  local largest = -math.huge\n\
    \  for _, num in ipairs(numbers) do\n    assert(math.type(num) == \"float\")\n\
    \    assert(num == num) -- must be not NaN\n    if num < smallest then\n     \
    \ smallest = num\n    end\n    if num > largest then\n      largest = num\n  \
    \  end\n  end\n  -- nothing to do if all numbers are the same\n  if smallest ==\
    \ largest then\n    return numbers\n  end\n  -- rescale\n  local new_numbers =\
    \ {}\n  for _, num in ipairs(numbers) do\n    new_numbers[#new_numbers + 1] =\
    \ (num - smallest) / (largest - smallest)\n  end\n  return new_numbers\nend",
  "    local min, max = min_max(numbers)\n    local mul = 1.0 / (max - min)\n    local\
    \ r = {}\n    for _,v in ipairs(numbers) do\n        r[#r+1] = (v - min) * mul\n\
    \    end\n    return r\nend", "  local min = math.min(unpack(numbers))\n  local\
    \ max = math.max(unpack(numbers))\n  local result = {}\n  for _, number in ipairs(numbers)\
    \ do\n    table.insert(result, (number - min) / (max - min))\n  end\n  return\
    \ result\nend", "  local min_val = math.min(table.unpack(numbers))\n  local max_val\
    \ = math.max(table.unpack(numbers))\n  local offset = -min_val\n  local scale\
    \ = 1.0 / (max_val - min_val)\n  local scaled_numbers = {}\n  for _,n in ipairs(numbers)\
    \ do\n    table.insert(scaled_numbers, (n + offset) * scale)\n  end\n  return\
    \ scaled_numbers\nend", "  assert(#numbers >= 2)\n  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  local out = {}\n  for _, number in\
    \ ipairs(numbers) do\n    table.insert(out, (number - min) / (max - min))\n  end\n\
    \  return out\nend", "    assert(#numbers >= 2)\n    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, number in ipairs(numbers) do\n       \
    \ if number < min then\n            min = number\n        end\n        if number\
    \ > max then\n            max = number\n        end\n    end\n    if max > min\
    \ then\n        local factor = 1.0 / (max - min)\n        local rescaled = {}\n\
    \        for _, number in ipairs(numbers) do\n            table.insert(rescaled,\
    \ (number - min) * factor)\n        end\n        return rescaled\n    else\n \
    \       return numbers\n    end\nend", "  local a = math.min(unpack(numbers))\n\
    \  local b = math.max(unpack(numbers))\n  local result = {}\n  for _, n in ipairs(numbers)\
    \ do\n    table.insert(result, (n - a) / (b - a))\n  end\n  return result\nend",
  "  local min_number = math.min(unpack(numbers))\n  local max_number = math.max(unpack(numbers))\n\
    \  local ret = {}\n  local denominator = max_number - min_number\n  local min_is_equal_to_max\
    \ = denominator == 0\n  for _, num in ipairs(numbers) do\n    local ratio = (num\
    \ - min_number) / denominator\n    table.insert(ret, min_is_equal_to_max and 0\
    \ or ratio)\n  end\n  return ret\nend", "  local minimum = numbers[1]\n  local\
    \ maximum = numbers[1]\n  for i = 2, #numbers do\n    minimum = math.min(minimum,\
    \ numbers[i])\n    maximum = math.max(maximum, numbers[i])\n  end\n  local span\
    \ = maximum - minimum\n  local result = {}\n  for i = 1, #numbers do\n    result[i]\
    \ = (numbers[i] - minimum) / span\n  end\n  return result\nend", "  local max\
    \ = numbers[1]\n  local min = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i]\
    \ > max then\n      max = numbers[i]\n    end\n    if numbers[i] < min then\n\
    \      min = numbers[i]\n    end\n  end\n  local linear_transform = function(x)\n\
    \    return (x - min) / (max - min)\n  end\n  local result = {}\n  for i = 1,\
    \ #numbers do\n    result[i] = linear_transform(numbers[i])\n  end\n  return result\n\
    end", "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    return { (numbers[1] - min) / (max - min),\n             (numbers[2] - min)\
    \ / (max - min),\n             (numbers[3] - min) / (max - min),\n           \
    \  (numbers[4] - min) / (max - min),\n             (numbers[5] - min) / (max -\
    \ min) }\nend", "  assert(#numbers >= 2)\n  local min_value = min(numbers)\n \
    \ local max_value = max(numbers)\n  local result = {}\n  for i, x in ipairs(numbers)\
    \ do\n    table.insert(result, (x - min_value) / (max_value - min_value))\n  end\n\
    \  return result\nend", "  local max = math.max(unpack(numbers))\n  local min\
    \ = math.min(unpack(numbers))\n  local delta = max - min\n  local new_numbers\
    \ = {}\n  for _, number in ipairs(numbers) do\n    table.insert(new_numbers, (number\
    \ - min) / delta)\n  end\n  return new_numbers\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, number in ipairs(numbers) do\n       \
    \ if number < min then\n            min = number\n        end\n        if number\
    \ > max then\n            max = number\n        end\n    end\n    local result\
    \ = {}\n    for _, number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - min) / (max - min))\n    end\n    return result\nend", "    -- TODO:\
    \ add unit test\n    local min = math.min(table.unpack(numbers))\n    local max\
    \ = math.max(table.unpack(numbers))\n    local result = {}\n    for _, v in ipairs(numbers)\
    \ do\n        table.insert(result, (v - min) / (max - min))\n    end\n    return\
    \ result\nend", "\tlocal mi = numbers[1]\n\tlocal ma = numbers[1]\n\tfor i, v\
    \ in ipairs(numbers) do\n\t\tif v < mi then\n\t\t\tmi = v\n\t\tend\n\t\tif v >\
    \ ma then\n\t\t\tma = v\n\t\tend\n\tend\n\tlocal r = ma - mi\n\tif r == 0 then\
    \ r = 1 end\n\treturn table.map(numbers, function(v) return (v - mi) / r end)\n\
    end", "  local max = math.max(unpack(numbers))\n  local min = math.min(unpack(numbers))\n\
    \  return map(function(n) return (n - min) / (max - min) end, numbers)\nend",
  "\tlocal numbers = copy(numbers)\n\tlocal min = math.min(unpack(numbers))\n\tlocal\
    \ max = math.max(unpack(numbers))\n\tif max == min then\n\t\treturn numbers\n\t\
    end\n\tfor i, n in ipairs(numbers) do\n\t\tnumbers[i] = (n - min) / (max - min)\n\
    \tend\n\treturn numbers\nend", "  local min_num = math.min(unpack(numbers))\n\
    \  local max_num = math.max(unpack(numbers))\n  if max_num == min_num then\n \
    \   -- Just return a table of zeros\n    return build_table(#numbers, 0)\n  end\n\
    \  local rescaled = {}\n  for _, number in ipairs(numbers) do\n    table.insert(rescaled,\
    \ (number - min_num) / (max_num - min_num))\n  end\n  return rescaled\nend", "\t\
    local minimum, maximum = math.huge, -math.huge\n\tfor _, v in ipairs(numbers)\
    \ do\n\t\tminimum = math.min(minimum, v)\n\t\tmaximum = math.max(maximum, v)\n\
    \tend\n\tlocal unit_range = maximum - minimum\n\tif unit_range < 0.00001 then\n\
    \t\treturn numbers\n\tend\n\tlocal rescaled = {}\n\tfor _, v in ipairs(numbers)\
    \ do\n\t\ttable.insert(rescaled, (v - minimum) / unit_range)\n\tend\n\treturn\
    \ rescaled\nend", "    local min = numbers[1]\n    local max = numbers[1]\n  \
    \  for _, number in ipairs(numbers) do\n        if number < min then\n       \
    \     min = number\n        end\n        if number > max then\n            max\
    \ = number\n        end\n    end\n    local result = {}\n    local amplitude =\
    \ max - min\n    for _, number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - min) / amplitude)\n    end\n    return result\nend", "    local min\
    \ = numbers[1]\n    local max = numbers[1]\n    for i, n in ipairs(numbers) do\n\
    \        if n < min then\n            min = n\n        end\n        if n > max\
    \ then\n            max = n\n        end\n    end\n    local l = {}\n    local\
    \ scale = 1.0 / (max - min)\n    for i, n in ipairs(numbers) do\n        l[i]\
    \ = (n - min) * scale\n    end\n    return l\nend", "    assert(#numbers >= 2)\n\
    \    local x_max = -math.huge\n    local x_min = math.huge\n    for i, v in ipairs(numbers)\
    \ do\n        x_max = math.max(x_max, v)\n        x_min = math.min(x_min, v)\n\
    \    end\n    local x_range = x_max - x_min\n    local scale = 1 / x_range\n \
    \   local new_numbers = {}\n    for i, v in ipairs(numbers) do\n        new_numbers[i]\
    \ = (v - x_min) * scale\n    end\n    return new_numbers\nend", "  local min =\
    \ math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n  local\
    \ unit = (1 / (max - min))\n  local ret = {}\n  for i, v in ipairs(numbers) do\n\
    \    ret[i] = (v - min) * unit\n  end\n  return ret\nend", "    assert(#numbers\
    \ >= 2)\n    local min, max = unpack(util.extrema(numbers))\n    return util.map(numbers,\
    \ function(n) return (n - min) / (max - min) end)\nend", "  local minval = min(numbers)\n\
    \  local maxval = max(numbers)\n  local scaled = {}\n  for i = 1, #numbers do\n\
    \    scaled[i] = (numbers[i] - minval) / (maxval - minval)\n  end\n  return scaled\n\
    end", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local range = max - min\n  return table.map(numbers, function(n) return (n\
    \ - min) / range end)\nend", "    local smallest = min(numbers)\n    local largest\
    \ = max(numbers)\n    local result = {}\n    for _,v in ipairs(numbers) do\n \
    \       local alpha = (v - smallest) / (largest - smallest)\n        table.insert(result,\
    \ alpha)\n    end\n    return result\nend", "    local min_max = min_max_of_table(numbers)\n\
    \    local min, max = min_max[1], min_max[2]\n    local a = 1 / (max - min)\n\
    \    local b = -a * min\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(result, a * number + b)\n    end\n    return result\n\
    end", "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tfor i = 2, #numbers\
    \ do\n\t\tmin = math.min(min, numbers[i])\n\t\tmax = math.max(max, numbers[i])\n\
    \tend\n\tlocal unit_range = max - min\n\tlocal rescaled = {}\n\tfor i = 1, #numbers\
    \ do\n\t\trescaled[i] = (numbers[i] - min) / unit_range\n\tend\n\treturn rescaled\n\
    end", "    assert(type(numbers) == \"table\", \"Number list argument was not a\
    \ table\")\n    local number_count = #numbers\n    assert(number_count >= 2, \"\
    Number list argument should contain at least two values\")\n    local number_min\
    \ = math.huge\n    local number_max = -math.huge\n    for _, number in ipairs(numbers)\
    \ do\n        if number < number_min then\n            number_min = number\n \
    \       end\n        if number > number_max then\n            number_max = number\n\
    \        end\n    end\n    local diff = number_max - number_min\n    if diff ==\
    \ 0 then\n        return {}\n    end\n    local result = {}\n    for _, number\
    \ in ipairs(numbers) do\n        table.insert(result, (number - number_min) /\
    \ diff)\n    end\n    return result\nend", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    local range = max - min\n    local\
    \ transform = function(number)\n        return (number - min) / range\n    end\n\
    \    return map(transform, numbers)\nend", "  local min, max = numbers[1], numbers[1]\n\
    \  for i = 2, #numbers do\n    min = math.min(min, numbers[i])\n    max = math.max(max,\
    \ numbers[i])\n  end\n  local scale = 1 / (max - min)\n  local result = {}\n \
    \ for i = 1, #numbers do\n    result[i] = (numbers[i] - min) * scale\n  end\n\
    \  return result\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for _, n in ipairs(numbers) do\n        if n < min then\n            min\
    \ = n\n        end\n        if n > max then\n            max = n\n        end\n\
    \    end\n    local coef = 1 / (max - min)\n    local rescaled = {}\n    for _,\
    \ n in ipairs(numbers) do\n        rescaled[#rescaled + 1] = (n - min) * coef\n\
    \    end\n    return rescaled\nend", "  local result = {}\n  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  for _, v in ipairs(numbers) do\n \
    \   result[#result + 1] = (v - min) / (max - min)\n  end\n  return result\nend",
  "    -- get minimum and maximum numbers\n    local min, max = numbers[1], numbers[1]\n\
    \    for _, v in ipairs(numbers) do\n        if v < min then min = v end\n   \
    \     if v > max then max = v end\n    end\n    -- apply linear transform\n  \
    \  local res = {}\n    for i, v in ipairs(numbers) do\n        res[i] = (v - min)\
    \ / (max - min)\n    end\n    return res\nend", "    -- find largest and smallest\n\
    \    local min = math.huge\n    local max = -math.huge\n    for _, x in ipairs(numbers)\
    \ do\n        if x < min then\n            min = x\n        end\n        if x\
    \ > max then\n            max = x\n        end\n    end\n    local span = max\
    \ - min\n    -- now rescale\n    local out = {}\n    for _, x in ipairs(numbers)\
    \ do\n        out[#out + 1] = (x - min) / span\n    end\n    return out\nend",
  "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local denom = max - min\n    if denom == 0 then\n        denom = 1\n    end\n\
    \    local result = {}\n    for i, v in ipairs(numbers) do\n        result[i]\
    \ = (v - min) / denom\n    end\n    return result\nend", "  local m = math.min(unpack(numbers))\n\
    \  local M = math.max(unpack(numbers))\n  local unit = {}\n  for i = 1, #numbers\
    \ do\n    unit[i] = (numbers[i] - m) / (M - m)\n  end\n  return unit\nend", "\t\
    local min, max = min_max(numbers)\n\tassert(min < max, \"Trying to rescale 0-length\
    \ array\")\n\tlocal factor = 1.0 / (max - min)\n\tlocal result = {}\n\tfor _,\
    \ n in ipairs(numbers) do\n\t\tresult[#result + 1] = (n - min) * factor\n\tend\n\
    \treturn result\nend", "  local min = math.min(unpack(numbers))\n  local max =\
    \ math.max(unpack(numbers))\n  if max == min then return numbers end\n  local\
    \ len = max - min\n  return map(function(n) return (n - min) / len end, numbers)\n\
    end", "\tlocal minimum = 0 --math.min(table.unpack(numbers))\n\tlocal maximum\
    \ = 1 --math.max(table.unpack(numbers))\n\tlocal length = maximum - minimum\n\t\
    local numbers_rescaled = {}\n\tfor k, v in pairs(numbers) do\n\t\tnumbers_rescaled[k]\
    \ = (v - minimum) / length\n\tend\n\treturn numbers_rescaled\nend", "    local\
    \ mn, mx = numbers[1], numbers[1]\n    for _, x in ipairs(numbers) do\n      \
    \  mn = math.min(mn, x)\n        mx = math.max(mx, x)\n    end\n    if mn == mx\
    \ then\n        return numbers\n    end\n    local f = 1.0 / (mx - mn)\n    local\
    \ scaled = {}\n    for _, x in ipairs(numbers) do\n        scaled[#scaled + 1]\
    \ = (x - mn) * f\n    end\n    return scaled\nend", "    local m = math.min(unpack(numbers))\n\
    \    local M = math.max(unpack(numbers))\n    local result = {}\n    for _, num\
    \ in ipairs(numbers) do\n        table.insert(result, (num - m) / (M - m))\n \
    \   end\n    return result\nend", "\tif not numbers then return numbers end\n\t\
    assert(#numbers > 1, \"not enough numbers to normalize\")\n\tlocal min_n = math.min(unpack(numbers))\n\
    \tlocal max_n = math.max(unpack(numbers))\n\tlocal result = {}\n\tfor _, n in\
    \ ipairs(numbers) do\n\t\tresult[#result+1] = (n - min_n) / (max_n - min_n)\n\t\
    end\n\treturn result\nend", "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\
    \tfor _,number in ipairs(numbers) do\n\t\tif number < min then\n\t\t\tmin = number\n\
    \t\tend\n\t\tif number > max then\n\t\t\tmax = number\n\t\tend\n\tend\n\tlocal\
    \ scale = 1.0 / (max - min)\n\tlocal rescaled = {}\n\tfor _,number in ipairs(numbers)\
    \ do\n\t\trescaled[#rescaled+1] = (number - min) * scale\n\tend\n\treturn rescaled\n\
    end", "    local min_num = min(numbers)\n    local max_num = max(numbers)\n  \
    \  local delta = max_num - min_num\n    if delta == 0 then delta = 1 end\n   \
    \ return map(function(x) return (x - min_num) / delta end, numbers)\nend", "\t\
    local max, min = numbers[1], numbers[1]\n\tfor i,v in ipairs(numbers) do\n\t\t\
    max = math.max(max, v)\n\t\tmin = math.min(min, v)\n\tend\n\treturn array.map(numbers,\
    \ function(v) return (v - min) / (max - min) end)\nend", "  local range = numbers[#numbers]\
    \ - numbers[1]\n  local output = {}\n  for i = 1, #numbers do\n    local t = (numbers[i]\
    \ - numbers[1]) / range\n    if t < 0 then\n      t = 0\n    elseif t > 1 then\n\
    \      t = 1\n    end\n    output[i] = t\n  end\n  return output\nend", "    local\
    \ min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local range = max - min\n    return map(function(x) return (x - min) / range\
    \ end, numbers)\nend", "    assert(#numbers >= 2)\n    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n\
    \ < min then\n            min = n\n        end\n        if n > max then\n    \
    \        max = n\n        end\n    end\n    local result = {}\n    for _, n in\
    \ ipairs(numbers) do\n        table.insert(result, (n - min) / (max - min))\n\
    \    end\n    return result\nend", "  -- find the minimum and maximum values\n\
    \  local min = numbers[1]\n  local max = numbers[1]\n  for i, v in ipairs(numbers)\
    \ do\n    if v < min then min = v end\n    if v > max then max = v end\n  end\n\
    \  -- find the delta\n  local delta = max - min\n  if delta == 0 then\n    --\
    \ if all numbers are the same, return a table of 0.5's\n    local array = {}\n\
    \    for i, _ in ipairs(numbers) do\n      array[i] = 0.5\n    end\n    return\
    \ array\n  end\n  -- return the rescaled numbers\n  local array = {}\n  for i,\
    \ v in ipairs(numbers) do\n    array[i] = (v - min) / delta\n  end\n  return array\n\
    end", "\tlocal min, max = unpack(numbers)\n\tfor _, n in ipairs(numbers) do\n\t\
    \tif n < min then min = n end\n\t\tif n > max then max = n end\n\tend\n\tlocal\
    \ scale = 1 / (max - min)\n\tfor i, _ in ipairs(numbers) do\n\t\tnumbers[i] =\
    \ (numbers[i] - min) * scale\n\tend\n\treturn numbers\nend", "\tlocal len = #numbers\n\
    \tlocal max = numbers[1]\n\tlocal min = numbers[1]\n\tfor i = 2, len do\n\t\t\
    if max < numbers[i] then\n\t\t\tmax = numbers[i]\n\t\tend\n\t\tif min > numbers[i]\
    \ then\n\t\t\tmin = numbers[i]\n\t\tend\n\tend\n\tlocal scale = 1.0 / (max - min)\n\
    \tlocal new_numbers = {}\n\tfor i = 1, len do\n\t\tnew_numbers[i] = (numbers[i]\
    \ - min) * scale\n\tend\n\treturn new_numbers\nend", "    assert(#numbers >= 2)\n\
    \    local min_max = min_max_of_table(numbers)\n    return map(numbers, function(n)\
    \ return (n - min_max.min) / (min_max.max - min_max.min) end)\nend", "    local\
    \ max = numbers[1]\n    local min = numbers[1]\n    for _, number in ipairs(numbers)\
    \ do\n        if number > max then\n            max = number\n        end\n  \
    \      if number < min then\n            min = number\n        end\n    end\n\
    \    local range = max - min\n    if range == 0 then\n        for i, number in\
    \ ipairs(numbers) do\n            numbers[i] = 0\n        end\n    else\n    \
    \    for i, number in ipairs(numbers) do\n            numbers[i] = (number - min)\
    \ / range\n        end\n    end\n    return numbers\nend", "  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  local scale = 1 / (max - min)\n  local\
    \ result = {}\n  for i, v in ipairs(numbers) do\n    result[i] = (v - min) * scale\n\
    \  end\n  return result\nend", "    local min_num = numbers[1]\n    local max_num\
    \ = numbers[1]\n    for _, num in ipairs(numbers) do\n        if num < min_num\
    \ then\n            min_num = num\n        end\n        if num > max_num then\n\
    \            max_num = num\n        end\n    end\n    local scale = max_num -\
    \ min_num\n    local rescaled = {}\n    for _, num in ipairs(numbers) do\n   \
    \     local rescaled_num = (num - min_num) / scale\n        table.insert(rescaled,\
    \ rescaled_num)\n    end\n    return rescaled\nend", "  assert(#numbers >= 2)\n\
    \  local min_val = math.min(unpack(numbers))\n  local max_val = math.max(unpack(numbers))\n\
    \  local scale = 1 / (max_val - min_val)\n  local numbers_rescaled = {}\n  for\
    \ _, num in ipairs(numbers) do\n    table.insert(numbers_rescaled, (num - min_val)\
    \ * scale)\n  end\n  return numbers_rescaled\nend", "  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  return rescale(numbers, min, max,\
    \ 0, 1)\nend", "    assert(numbers and #numbers >= 2, \"Failed to rescale data\
    \ to unit interval: at least two numbers needed\")\n    local min_value = math.min(unpack(numbers))\n\
    \    local max_value = math.max(unpack(numbers))\n    local scale = max_value\
    \ - min_value\n    if scale == 0 then\n        scale = 1\n    end\n    local scaled_numbers\
    \ = {}\n    for _, number in ipairs(numbers) do\n        table.insert(scaled_numbers,\
    \ (number - min_value) / scale)\n    end\n    return scaled_numbers\nend", "\t\
    local min_number = min(numbers)\n\tlocal max_number = max(numbers)\n\tlocal scale\
    \ = max_number - min_number\n\tlocal lin_transformed = {}\n\tlocal zero_index\
    \ = 1\n\tfor i, num in ipairs(numbers) do\n\t\tlocal trans_num = (num - min_number)\
    \ / scale\n\t\tlin_transformed[i] = trans_num\n\t\tif trans_num == 0 then\n\t\t\
    \tzero_index = i\n\t\tend\n\tend\n\t-- reorder the table such that all the zeros\
    \ appear at the beginning\n\tif zero_index ~= 1 then\n\t\tlocal new_order = {}\n\
    \t\tlocal i = 1\n\t\tfor j = zero_index, #lin_transformed do\n\t\t\tnew_order[i]\
    \ = lin_transformed[j]\n\t\t\ti = i + 1\n\t\tend\n\t\tfor j = 1, zero_index -\
    \ 1 do\n\t\t\tnew_order[i] = lin_transformed[j]\n\t\t\ti = i + 1\n\t\tend\n\t\t\
    lin_transformed = new_order\n\tend\n\treturn lin_transformed\nend", "  -- Find\
    \ current min and max\n  local max, min = math.max(unpack(numbers)), math.min(unpack(numbers))\n\
    \  local range = max - min\n  -- Apply linear transform\n  local rescaled = {}\n\
    \  for k, v in pairs(numbers) do\n    rescaled[k] = (v - min) / range\n  end\n\
    \  return rescaled\nend", "  local mn, mx = minimum(numbers), maximum(numbers)\n\
    \  local scale = 1.0 / (mx - mn)\n  local translated = {}\n  for i, v in ipairs(numbers)\
    \ do\n    translated[i] = (v - mn) * scale\n  end\n  return translated\nend",
  "    local min_number = min(numbers)\n    local max_number = max(numbers)\n    local\
    \ numbers_range = max_number - min_number\n    if numbers_range == 0 then\n  \
    \      return numbers\n    end\n    local rescaled_numbers = {}\n    for _, number\
    \ in ipairs(numbers) do\n        rescaled_numbers[#rescaled_numbers + 1] = (number\
    \ - min_number) / numbers_range\n    end\n    return rescaled_numbers\nend", "\t\
    local min = numbers[1]\n\tlocal max = numbers[1]\n\tfor _, n in ipairs(numbers)\
    \ do\n\t\tif n < min then\n\t\t\tmin = n\n\t\tend\n\t\tif n > max then\n\t\t\t\
    max = n\n\t\tend\n\tend\n\tlocal scale = 1.0 / (max - min)\n\tlocal result = {}\n\
    \tfor _, n in ipairs(numbers) do\n\t\ttable.insert(result, (n - min) * scale)\n\
    \tend\n\treturn result\nend", "    local min = min(numbers)\n    local max = max(numbers)\n\
    \    local result = {}\n    for _, n in ipairs(numbers) do\n        result[#result\
    \ + 1] = (n - min) / (max - min)\n    end\n    return result\nend", "    local\
    \ min_val = numbers[1]\n    local max_val = numbers[1]\n    for i = 2, #numbers\
    \ do\n        min_val = math.min(min_val, numbers[i])\n        max_val = math.max(max_val,\
    \ numbers[i])\n    end\n    for i = 1, #numbers do\n        numbers[i] = (numbers[i]\
    \ - min_val) / (max_val - min_val)\n    end\n    return numbers\nend", "  assert(type(numbers)\
    \ == \"table\")\n  assert(#numbers >= 2)\n  local min_value = math.min(unpack(numbers))\n\
    \  local max_value = math.max(unpack(numbers))\n  local rescaled = {}\n  for i\
    \ = 1, #numbers do\n    rescaled[i] = (numbers[i] - min_value) / (max_value -\
    \ min_value)\n  end\n  return rescaled\nend", "  assert(#numbers >= 2)\n  local\
    \ numbers_copy = table_copy(numbers)\n  table.sort(numbers_copy)\n  local min\
    \ = numbers_copy[1]\n  local max = numbers_copy[#numbers_copy]\n  local result\
    \ = {}\n  local f = 1 / (max - min)\n  for i, v in ipairs(numbers) do\n    result[i]\
    \ = (v - min) * f\n  end\n  return result\nend", "    assert(#numbers >= 2)\n\
    \    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local result = {}\n    for i, value in ipairs(numbers) do\n        result[i]\
    \ = (value - min) / (max - min)\n    end\n    return result\nend", "\tlocal mn,\
    \ mx = numbers[1], numbers[1]\n\tfor _, n in ipairs(numbers) do\n\t\tif n < mn\
    \ then mn = n end\n\t\tif n > mx then mx = n end\n\tend\n\tif mx == mn then return\
    \ {0.5} end\n\tlocal scale = 1 / (mx - mn)\n\tlocal rescaled = {}\n\tfor _, n\
    \ in ipairs(numbers) do\n\t\ttable.insert(rescaled, (n - mn) * scale)\n\tend\n\
    \treturn rescaled\nend", "  local min = math.min(unpack(numbers))\n  local max\
    \ = math.max(unpack(numbers))\n  if max - min <= 0 then\n    return numbers\n\
    \  end\n  local unit = function(x) return (x - min) / (max - min) end\n  return\
    \ map(unit, numbers)\nend", "    local min, max = math.min(table.unpack(numbers)),\
    \ math.max(table.unpack(numbers))\n    local output = {}\n    for _, v in ipairs(numbers)\
    \ do\n        table.insert(output, (v - min) / (max - min))\n    end\n    return\
    \ output\nend", "  local ini, fin = table.min(numbers), table.max(numbers)\n \
    \ return table.map(numbers, function(x) return (x - ini) / (fin - ini) end)\n\
    end", "    local min_value = numbers[1]\n    local max_value = numbers[1]\n  \
    \  for i = 2, #numbers do\n        if numbers[i] < min_value then\n          \
    \  min_value = numbers[i]\n        elseif numbers[i] > max_value then\n      \
    \      max_value = numbers[i]\n        end\n    end\n    local span = max_value\
    \ - min_value\n    if span == 0 then\n        return {}\n    end\n    local rescaled\
    \ = {}\n    for i = 1, #numbers do\n        rescaled[i] = (numbers[i] - min_value)\
    \ / span\n    end\n    return rescaled\nend", "    local size = #numbers\n   \
    \ local min_n = numbers[1]\n    local max_n = numbers[1]\n    for i = 2, size\
    \ do\n        if numbers[i] < min_n then\n            min_n = numbers[i]\n   \
    \     elseif numbers[i] > max_n then\n            max_n = numbers[i]\n       \
    \ end\n    end\n    if min_n == max_n then\n        return nil\n    end\n    local\
    \ scale = 1.0 / (max_n - min_n)\n    local result = {}\n    for i = 1, size do\n\
    \        result[i] = (numbers[i] - min_n) * scale\n    end\n    return result\n\
    end", "    local nmin = math.min(unpack(numbers))\n    local nmax = math.max(unpack(numbers))\n\
    \    local nrange = nmax - nmin\n    local result = {}\n    for _, value in ipairs(numbers)\
    \ do\n        table.insert(result, (value - nmin) / nrange)\n    end\n    return\
    \ result\nend", "    assert(#numbers >= 2)\n    local biggest = numbers[1]\n \
    \   local smallest = numbers[1]\n    for i, number in ipairs(numbers) do\n   \
    \     if biggest < number then\n            biggest = number\n        end\n  \
    \      if smallest > number then\n            smallest = number\n        end\n\
    \    end\n    assert(biggest ~= smallest)\n    local rescaled = {}\n    for i,\
    \ number in ipairs(numbers) do\n        rescaled[i] = (number - smallest) / (biggest\
    \ - smallest)\n    end\n    return rescaled\nend", "  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  local new_numbers = {}\n  for i, v\
    \ in ipairs(numbers) do\n    new_numbers[i] = (v - min) / (max - min)\n  end\n\
    \  return new_numbers\nend", "    local t = {}\n    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    for _, v in ipairs(numbers) do\n\
    \        t[#t+1] = (v - min) / (max - min)\n    end\n    return t\nend", "\tif\
    \ (#numbers < 2) then\n\t\treturn numbers\n\tend\n\tlocal min_number = math.min(unpack(numbers))\n\
    \tlocal max_number = math.max(unpack(numbers))\n\tlocal transformed_numbers =\
    \ {}\n\tfor _, number in ipairs(numbers) do\n\t\ttransformed_numbers[#transformed_numbers\
    \ + 1] = (number - min_number) / (max_number - min_number)\n\tend\n\treturn transformed_numbers\n\
    end", "\tlocal smallest, largest = numbers[1], numbers[1]\n\tfor _, number in\
    \ ipairs(numbers) do\n\t\tif number < smallest then\n\t\t\tsmallest = number\n\
    \t\telseif number > largest then\n\t\t\tlargest = number\n\t\tend\n\tend\n\tlocal\
    \ smallest_1 = smallest - 1\n\tlocal delta = largest - smallest\n\tlocal result\
    \ = {}\n\tfor _, number in ipairs(numbers) do\n\t\tresult[#result + 1] = (number\
    \ - smallest_1) / delta\n\tend\n\treturn result\nend", "    local result = {}\n\
    \    local numbers_min = math.min(unpack(numbers))\n    local numbers_max = math.max(unpack(numbers))\n\
    \    for k, v in pairs(numbers) do\n        result[k] = (v - numbers_min) / (numbers_max\
    \ - numbers_min)\n    end\n    return result\nend", "    local min, max = math.min(table.unpack(numbers)),\
    \ math.max(table.unpack(numbers))\n    local output = {}\n    for _, n in ipairs(numbers)\
    \ do\n        table.insert(output, (n - min) / (max - min))\n    end\n    return\
    \ output\nend", "\tlocal max_in_table = math.max(unpack(numbers))\n\tlocal min_in_table\
    \ = math.min(unpack(numbers))\n\tlocal result = {}\n\tfor i = 1, #numbers do\n\
    \t\tresult[i] = (numbers[i] - min_in_table) / (max_in_table - min_in_table)\n\t\
    end\n\treturn result\nend", "    local max = numbers[1]\n    local min = numbers[1]\n\
    \    for i = 2, #numbers do\n        if numbers[i] > max then\n            max\
    \ = numbers[i]\n        end\n        if numbers[i] < min then\n            min\
    \ = numbers[i]\n        end\n    end\n    local range = max - min\n    if range\
    \ == 0 then\n        error(\"Numbers have no range\")\n    end\n    local result\
    \ = {}\n    for i = 1, #numbers do\n        result[i] = (numbers[i] - min) / range\n\
    \    end\n    return result\nend", "    local min_val = numbers[1]\n    local\
    \ max_val = numbers[1]\n    for i, number in ipairs(numbers) do\n        if number\
    \ < min_val then\n            min_val = number\n        end\n        if number\
    \ > max_val then\n            max_val = number\n        end\n    end\n    local\
    \ delta = max_val - min_val\n    local result = {}\n    for i, number in ipairs(numbers)\
    \ do\n        result[i] = (number - min_val) / delta\n    end\n    return result\n\
    end", "    local smallest = math.huge\n    local largest = -math.huge\n    for\
    \ _,num in ipairs(numbers) do\n        if num < smallest then smallest = num end\n\
    \        if num > largest then largest = num end\n    end\n    local result =\
    \ {}\n    local diff = largest - smallest\n    for _,num in ipairs(numbers) do\n\
    \        table.insert(result, (num - smallest) / diff)\n    end\n    return result\n\
    end", "\tlocal largest, smallest = math.max(unpack(numbers)), math.min(unpack(numbers))\n\
    \tlocal unit = {}\n\tfor _, v in ipairs(numbers) do\n\t\ttable.insert(unit, v\
    \ / (largest - smallest))\n\tend\n\treturn unit\nend", "\tlocal min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n\tlocal result = {}\n\tfor _, number in ipairs(numbers)\
    \ do\n\t\ttable.insert(result, (number - min) / (max - min))\n\tend\n\treturn\
    \ result\nend", "\tlocal min = math.min(table.unpack(numbers))\n\tlocal max =\
    \ math.max(table.unpack(numbers))\n\tlocal delta = max - min\n\treturn map(numbers,\
    \ function(number)\n\t\treturn (number - min) / delta\n\tend)\nend", "\tif not\
    \ numbers then return nil end\n\tif #numbers < 2 then return numbers end\n\tlocal\
    \ min = math.min(unpack(numbers))\n\tlocal max = math.max(unpack(numbers))\n\t\
    local range = max - min\n\treturn table.map(numbers, function(i) return (i - min)\
    \ / range end)\nend", "    assert(#numbers >= 2)\n    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    local result = {}\n    for _,\
    \ n in ipairs(numbers) do\n        local ratio = (n - min) / (max - min)\n   \
    \     table.insert(result, ratio)\n    end\n    return result\nend", "    local\
    \ max = -math.huge\n    local min = math.huge\n    for _, num in ipairs(numbers)\
    \ do\n        if num > max then\n            max = num\n        end\n        if\
    \ num < min then\n            min = num\n        end\n    end\n    local multiplier\
    \ = 1 / (max - min)\n    for i, num in ipairs(numbers) do\n        numbers[i]\
    \ = (num - min) * multiplier\n    end\n    return numbers\nend", "  -- Find the\
    \ min and max of the array\n  local min_number = numbers[1]\n  local max_number\
    \ = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] < min_number then\n\
    \      min_number = numbers[i]\n    end\n    if numbers[i] > max_number then\n\
    \      max_number = numbers[i]\n    end\n  end", "    -- Find range\n    local\
    \ min = min(numbers)\n    local max = max(numbers)\n    local range = max - min",
  "    local min = numbers[1]\n    local max = numbers[1]\n    for i, v in ipairs(numbers)\
    \ do\n        if min > v then\n            min = v\n        end\n        if max\
    \ < v then\n            max = v\n        end\n    end\n    local result = {}\n\
    \    for i, v in ipairs(numbers) do\n        result[i] = (v - min) / (max - min)\n\
    \    end\n    return result\nend", "    assert(#numbers >= 2)\n    local res =\
    \ {}\n    local min_value = math.min(unpack(numbers))\n    local max_value = math.max(unpack(numbers))\n\
    \    for _, v in ipairs(numbers) do\n        local c = (v - min_value) / (max_value\
    \ - min_value)\n        assert(c >= 0 and c <= 1)\n        table.insert(res, c)\n\
    \    end\n    return res\nend", "    local max, min = math.max(unpack(numbers)),\
    \ math.min(unpack(numbers))\n    local result = {}\n    for i, v in ipairs(numbers)\
    \ do\n        result[i] = (v - min) / (max - min)\n    end\n    return result\n\
    end", "  local max = numbers[1]\n  local min = numbers[1]\n  for i, value in ipairs(numbers)\
    \ do\n    max = math.max(max, value)\n    min = math.min(min, value)\n  end\n\
    \  local coef = 1 / (max - min)\n  local rescaled = {}\n  for i, value in ipairs(numbers)\
    \ do\n    rescaled[i] = (value - min) * coef\n  end\n  return rescaled\nend",
  "\tlocal tbl = {}\n\t-- Find min and max values\n\tlocal min = numbers[1]\n\tlocal\
    \ max = numbers[1]\n\tfor i = 2, #numbers do\n\t\tif numbers[i] < min then\n\t\
    \t\tmin = numbers[i]\n\t\telseif numbers[i] > max then\n\t\t\tmax = numbers[i]\n\
    \t\tend\n\tend\n\tlocal delta = max - min\n\tfor i = 1, #numbers do\n\t\ttbl[i]\
    \ = (numbers[i] - min) / delta\n\tend\n\treturn tbl\nend", "    local max, min\
    \ = numbers[1], numbers[1]\n    for _, n in ipairs(numbers) do\n        if n >\
    \ max then max = n end\n        if n < min then min = n end\n    end\n    local\
    \ scale = 1 / (max - min)\n    local result = {}\n    for _, n in ipairs(numbers)\
    \ do\n        table.insert(result, (n - min) * scale)\n    end\n    return result\n\
    end", "    local n_min = math.min(unpack(numbers))\n    local n_max = math.max(unpack(numbers))\n\
    \    local n_range = n_max - n_min\n    return ipairs(numbers):map(function(x)\
    \ return (x - n_min) / n_range end)\nend", "    local min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n    if min == max then\n        return array_of_n(#numbers,\
    \ 0.5)\n    end\n    local res = {}\n    for i, v in ipairs(numbers) do\n    \
    \    res[i] = (v - min) / (max - min)\n    end\n    return res\nend", "    local\
    \ min_value = math.min(unpack(numbers))\n    local max_value = math.max(unpack(numbers))\n\
    \    local delta = max_value - min_value\n    local rescaled = {}\n    for _,\
    \ number in ipairs(numbers) do\n        local rescaled_number = (number - min_value)\
    \ / delta\n        table.insert(rescaled, rescaled_number)\n    end\n    return\
    \ rescaled\nend", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local result = {}\n  for _, x in ipairs(numbers) do\n    result[#result + 1]\
    \ = (x - min) / (max - min)\n  end\n  return result\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i]\
    \ < min then\n            min = numbers[i]\n        elseif numbers[i] > max then\n\
    \            max = numbers[i]\n        end\n    end\n    local ret = {}\n    for\
    \ i = 1, #numbers do\n        ret[i] = (numbers[i] - min) / (max - min)\n    end\n\
    \    return ret\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for _, x in ipairs(numbers) do\n        if x < min then\n            min\
    \ = x\n        end\n        if x > max then\n            max = x\n        end\n\
    \    end\n    local a = 1.0 / (max - min)\n    local b = -a * min\n    local result\
    \ = {}\n    for _, x in ipairs(numbers) do\n        result[#result + 1] = a *\
    \ x + b\n    end\n    return result\nend", "    assert(#numbers >= 2)\n    local\
    \ min = numbers[1]\n    local max = numbers[1]\n    for i = 2, #numbers do\n \
    \       if numbers[i] < min then\n            min = numbers[i]\n        elseif\
    \ numbers[i] > max then\n            max = numbers[i]\n        end\n    end\n\
    \    assert(min < max)\n    local table_unit = {}\n    for i = 1, #numbers do\n\
    \        table_unit[i] = (numbers[i] - min) / (max - min)\n    end\n    return\
    \ table_unit\nend", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local delta = max - min\n  local range = {unpack(numbers)}\n  for i, n in ipairs(range)\
    \ do\n    range[i] = (n - min) / delta\n  end\n  return range\nend", "\tlocal\
    \ min_value = numbers[1]\n\tlocal max_value = numbers[1]\n\tfor i = 2, #numbers\
    \ do\n\t\tif numbers[i] < min_value then\n\t\t\tmin_value = numbers[i]\n\t\telseif\
    \ numbers[i] > max_value then\n\t\t\tmax_value = numbers[i]\n\t\tend\n\tend\n\t\
    local range = max_value - min_value\n\tlocal result = {}\n\tfor i = 1, #numbers\
    \ do\n\t\tresult[i] = (numbers[i] - min_value) / range\n\tend\n\treturn result\n\
    end", "  local min_number = math.min(unpack(numbers))\n  local max_number = math.max(unpack(numbers))\n\
    \  local scale = max_number - min_number\n  if scale == 0 then\n    error(\"Input\
    \ table contains only the same number. Cannot rescale\")\n  end\n  local rescaled_numbers\
    \ = {}\n  for _, number in ipairs(numbers) do\n    table.insert(rescaled_numbers,\
    \ (number - min_number) / scale)\n  end\n  return rescaled_numbers\nend", "  local\
    \ max_value = numbers[1]\n  local min_value = numbers[1]\n  for i, value in ipairs(numbers)\
    \ do\n    if value > max_value then\n      max_value = value\n    end\n    if\
    \ value < min_value then\n      min_value = value\n    end\n  end\n  local delta\
    \ = max_value - min_value\n  local rescaled = {}\n  for i, value in ipairs(numbers)\
    \ do\n    if max_value == min_value then\n      rescaled[i] = 1.0\n    else\n\
    \      rescaled[i] = (value - min_value) / delta\n    end\n  end\n  return rescaled\n\
    end", "  local mi = math.min(table.unpack(numbers))\n  local ma = math.max(table.unpack(numbers))\n\
    \  local scaled = {}\n  for _, v in ipairs(numbers) do\n    local scaled_val =\
    \ (v - mi) / (ma - mi)\n    table.insert(scaled, scaled_val)\n  end\n  return\
    \ scaled\nend", "  local result = {}\n  local minimum = numbers[1]\n  local maximum\
    \ = numbers[1]\n  for _, n in ipairs(numbers) do\n    if n < minimum then\n  \
    \    minimum = n\n    end\n    if n > maximum then\n      maximum = n\n    end\n\
    \  end\n  if maximum == minimum then\n    maximum = minimum + 1\n  end\n  for\
    \ _, n in ipairs(numbers) do\n    table.insert(result, (n - minimum) / (maximum\
    \ - minimum))\n  end\n  return result\nend", "  local min, max = get_min_max(numbers)\n\
    \  local res = {}\n  for i, n in ipairs(numbers) do\n    res[i] = (n - min) /\
    \ (max - min)\n  end\n  return res\nend", "  local a = math.min(unpack(numbers))\n\
    \  local b = math.max(unpack(numbers))\n  local c = b - a\n  return map(function(x)\
    \ return (x - a) / c end, numbers)\nend", "    local mn, mx = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n    return table.map(function(x) return (x - mn)\
    \ / (mx - mn) end, numbers)\nend", "    assert(#numbers >= 2)\n    local min =\
    \ math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n    local\
    \ factor = max - min\n    return map(function(num) return (num - min) / factor\
    \ end, numbers)\nend", "  assert(#numbers >= 2)\n  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  local range = max - min\n  if range\
    \ == 0 then\n    return {1, 1, 1, 1, 1}\n  end\n  local result = {}\n  for _,\
    \ v in ipairs(numbers) do\n    table.insert(result, (v - min) / range)\n  end\n\
    \  return result\nend", "\tlocal max = numbers[1]\n\tlocal min = numbers[1]\n\t\
    for i = 2, #numbers do\n\t\tlocal value = numbers[i]\n\t\tif value > max then\n\
    \t\t\tmax = value\n\t\telseif value < min then\n\t\t\tmin = value\n\t\tend\n\t\
    end\n\tlocal span = max - min\n\tif span == 0 then\n\t\tspan = 1\n\tend\n\tlocal\
    \ out = {}\n\tfor i = 1, #numbers do\n\t\tout[i] = (numbers[i] - min) / span\n\
    \tend\n\treturn out\nend", "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\
    \tfor _, n in ipairs(numbers) do\n\t\tif n < min then\n\t\t\tmin = n\n\t\tend\n\
    \t\tif n > max then\n\t\t\tmax = n\n\t\tend\n\tend\n\tassert(min < max)\n\tlocal\
    \ transformation = function(n)\n\t\treturn (n - min) / (max - min)\n\tend\n\t\
    return transformation\nend", "  local max = 0\n  local min = 0\n  local delta\
    \ = 0\n  for i, number in ipairs(numbers) do\n    if i == 1 then\n      max =\
    \ number\n      min = number\n    else\n      if number > max then\n        max\
    \ = number\n      end\n      if number < min then\n        min = number\n    \
    \  end\n    end\n  end\n  delta = max - min\n  local rescaled = {}\n  for i, number\
    \ in ipairs(numbers) do\n    if delta == 0 then\n      table.insert(rescaled,\
    \ 0)\n    else\n      table.insert(rescaled, (number - min) / delta)\n    end\n\
    \  end\n  return rescaled\nend", "    -- find largest and smallest\n    local\
    \ min = math.huge\n    local max = -math.huge\n    for _, number in ipairs(numbers)\
    \ do\n        if min > number then\n            min = number\n        end\n  \
    \      if max < number then\n            max = number\n        end\n    end\n\
    \    -- transform to unit interval\n    local transformed = {}\n    for _, number\
    \ in ipairs(numbers) do\n        table.insert(transformed, (number - min) / (max\
    \ - min))\n    end\n    return transformed\nend", "  assert(type(numbers) == \"\
    table\", \"rescale_to_unit expected a table\")\n  assert(#numbers >= 2, \"rescale_to_unit\
    \ expected a table of at least two elements\")\n  local smallest = numbers[1]\n\
    \  local largest = numbers[1]\n  for _,number in ipairs(numbers) do\n    if number\
    \ < smallest then\n      smallest = number\n    end\n    if number > largest then\n\
    \      largest = number\n    end\n  end\n  local result = {}\n  for _,number in\
    \ ipairs(numbers) do\n    table.insert(result, (number - smallest) / (largest\
    \ - smallest))\n  end\n  return result\nend", "\tlocal min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n\tlocal scale = 1.0 / (max - min)\n\tlocal scaled\
    \ = {}\n\tfor _, v in ipairs(numbers) do\n\t\ttable.insert(scaled, (v - min) *\
    \ scale)\n\tend\n\treturn scaled\nend", "\tlocal smallest, largest\n\tfor _, number\
    \ in ipairs(numbers) do\n\t\tif smallest == nil or number < smallest then\n\t\t\
    \tsmallest = number\n\t\tend\n\t\tif largest == nil or number > largest then\n\
    \t\t\tlargest = number\n\t\tend\n\tend\n\tlocal unit_numbers = {}\n\tfor _, number\
    \ in ipairs(numbers) do\n\t\tlocal unit_number = (number - smallest) / (largest\
    \ - smallest)\n\t\ttable.insert(unit_numbers, unit_number)\n\tend\n\treturn unit_numbers\n\
    end", "  local max = numbers[1]\n  local min = numbers[1]\n  for _, n in ipairs(numbers)\
    \ do\n    max = math.max(max, n)\n    min = math.min(min, n)\n  end\n  local out\
    \ = {}\n  for _, n in ipairs(numbers) do\n    out[#out + 1] = (n - min) / (max\
    \ - min)\n  end\n  return out\nend", "  local x = numbers\n  local mi = math.min(unpack(x))\n\
    \  local ma = math.max(unpack(x))\n  local x = vmap(function(a) return (a - mi)\
    \ / (ma - mi) end, x)\n  return x\nend", "  assert(#numbers >= 2)\n  local min_num\
    \ = math.min(unpack(numbers))\n  local max_num = math.max(unpack(numbers))\n \
    \ local factor = 1 / (max_num - min_num)\n  local new_numbers = {}\n  for _, num\
    \ in ipairs(numbers) do\n    table.insert(new_numbers, (num - min_num) * factor)\n\
    \  end\n  return new_numbers\nend", "  local size = #numbers\n  if size < 2 then\n\
    \    return numbers\n  end\n  local max, min = numbers[1], numbers[1]\n  for i\
    \ = 2, size do\n    local number = numbers[i]\n    if number > max then\n    \
    \  max = number\n    elseif number < min then\n      min = number\n    end\n \
    \ end\n  local unit_distance = max - min\n  if unit_distance == 0 then\n    unit_distance\
    \ = 0.0001\n  end\n  local result = {}\n  for i = 1, size do\n    result[i] =\
    \ (numbers[i] - min) / unit_distance\n  end\n  return result\nend", "    local\
    \ min = numbers[1]\n    local max = numbers[1]\n    for _, n in ipairs(numbers)\
    \ do\n        if n < min then\n            min = n\n        end\n        if n\
    \ > max then\n            max = n\n        end\n    end\n    local range = max\
    \ - min\n    if range < 1e-9 then\n        -- special case, because of div-by-zero\n\
    \        range = 1.0\n    end\n    for i, n in ipairs(numbers) do\n        numbers[i]\
    \ = (n - min) / range\n    end\n    return numbers\nend", "\tlocal min, max =\
    \ math.min(unpack(numbers)), math.max(unpack(numbers))\n\tlocal length = max -\
    \ min\n\tif length ~= 0 then\n\t\tfor i, num in ipairs(numbers) do\n\t\t\tnumbers[i]\
    \ = (num - min) / length\n\t\tend\n\tend\n\treturn numbers\nend", "\tlocal min_n\
    \ = numbers[1]\n\tlocal max_n = numbers[1]\n\tfor _, n in ipairs(numbers) do\n\
    \t\tif n < min_n then\n\t\t\tmin_n = n\n\t\tend\n\t\tif n > max_n then\n\t\t\t\
    max_n = n\n\t\tend\n\tend\n\tlocal f = 1 / (max_n - min_n)\n\tlocal table_out\
    \ = {}\n\tfor _, n in ipairs(numbers) do\n\t\ttable.insert(table_out, (n - min_n)\
    \ * f)\n\tend\n\treturn table_out\nend", "  local min = numbers[1]\n  local max\
    \ = numbers[1]\n  for _,number in ipairs(numbers) do\n    if number < min then\n\
    \      min = number\n    elseif number > max then\n      max = number\n    end\n\
    \  end\n  local span = max - min\n  if span == 0 then\n    return numbers\n  end\n\
    \  local unit_numbers = {}\n  for _,number in ipairs(numbers) do\n    unit_numbers[#unit_numbers+1]\
    \ = (number - min) / span\n  end\n  return unit_numbers\nend", "  local s_max\
    \ = -math.huge\n  local s_min = math.huge\n  for _,n in ipairs(numbers) do\n \
    \   s_max = math.max(s_max, n)\n    s_min = math.min(s_min, n)\n  end\n  local\
    \ s_diff = s_max - s_min\n  local s_unit = {}\n  for _,n in ipairs(numbers) do\n\
    \    s_unit[#s_unit+1] = (n - s_min) / s_diff\n  end\n  return s_unit\nend", " \
    \   local min = numbers[1]\n    local max = numbers[1]\n    for i, num in ipairs(numbers)\
    \ do\n        if num < min then\n            min = num\n        end\n        if\
    \ num > max then\n            max = num\n        end\n    end\n    if min == max\
    \ then\n        min = min - 1\n        max = max + 1\n    end\n    local result\
    \ = {}\n    for i, num in ipairs(numbers) do\n        result[i] = (num - min)\
    \ / (max - min)\n    end\n    return result\nend", "    local lo, hi = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        result[#result + 1] = (number - lo) / (hi - lo)\n    end\n    return\
    \ result\nend", "    local max_value = math.max(unpack(numbers))\n    local min_value\
    \ = math.min(unpack(numbers))\n    local scale = 1.0 / (max_value - min_value)\n\
    \    local scaled_numbers = {}\n    for i, n in ipairs(numbers) do\n        scaled_numbers[i]\
    \ = (n - min_value) * scale\n    end\n    return scaled_numbers\nend", "    assert(#numbers\
    \ >= 2)\n    local min_number = math.min(unpack(numbers))\n    local max_number\
    \ = math.max(unpack(numbers))\n    local transformed_numbers = {}\n    for _,\
    \ number in ipairs(numbers) do\n        table.insert(transformed_numbers, (number\
    \ - min_number) / (max_number - min_number))\n    end\n    return transformed_numbers\n\
    end", "  local min = numbers[1]\n  local max = numbers[1]\n  for i = 2, #numbers\
    \ do\n    min = math.min(min, numbers[i])\n    max = math.max(max, numbers[i])\n\
    \  end\n  local range = max - min\n  for i = 1, #numbers do\n    numbers[i] =\
    \ (numbers[i] - min) / range\n  end\n  return numbers\nend", "    local lowest,\
    \ highest = numbers[1], numbers[1]\n    for _, v in ipairs(numbers) do\n     \
    \   if v < lowest then lowest = v end\n        if v > highest then highest = v\
    \ end\n    end\n    local scale = 1.0 / (highest - lowest)\n    local rescaled\
    \ = {}\n    for _, v in ipairs(numbers) do\n        rescaled[#rescaled + 1] =\
    \ (v - lowest) * scale\n    end\n    return rescaled\nend", "    local minimum\
    \ = numbers[1]\n    local maximum = numbers[1]\n    for i = 2, #numbers do\n \
    \       if numbers[i] < minimum then\n            minimum = numbers[i]\n     \
    \   elseif numbers[i] > maximum then\n            maximum = numbers[i]\n     \
    \   end\n    end\n    local result = {}\n    for i = 1, #numbers do\n        result[i]\
    \ = (numbers[i] - minimum) / (maximum - minimum)\n    end\n    return result\n\
    end", "    assert(numbers ~= nil, \"numbers is nil\")\n    assert(#numbers >=\
    \ 2, \"not enough numbers to rescale\")\n    -- find max, min\n    local max_number\
    \ = numbers[1]\n    local min_number = numbers[1]\n    for i = 2, #numbers do\n\
    \        if numbers[i] > max_number then\n            max_number = numbers[i]\n\
    \        end\n        if numbers[i] < min_number then\n            min_number\
    \ = numbers[i]\n        end\n    end\n    -- transform\n    local rescaled_numbers\
    \ = {}\n    for i = 1, #numbers do\n        rescaled_numbers[i] = (numbers[i]\
    \ - min_number) / (max_number - min_number)\n    end\n    return rescaled_numbers\n\
    end", "    local n = #numbers\n    local smallest, largest = math.huge, -math.huge\n\
    \    for i = 1, n do\n        local val = numbers[i]\n        if val < smallest\
    \ then\n            smallest = val\n        end\n        if val > largest then\n\
    \            largest = val\n        end\n    end\n    local lin_func = function(x)\
    \ return (x - smallest) / (largest - smallest) end\n    local new_table = {}\n\
    \    for i = 1, n do\n        new_table[i] = lin_func(numbers[i])\n    end\n \
    \   return new_table\nend", "\tassert(#numbers >= 2, \"Need at least two numbers\
    \ for rescaling\")\n\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tfor\
    \ i = 2, #numbers do\n\t\tmin = math.min(min, numbers[i])\n\t\tmax = math.max(max,\
    \ numbers[i])\n\tend\n\tlocal diff = max - min\n\treturn func.map(function(x)\
    \ return (x - min) / diff end, numbers)\nend", "    local min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n    local rescaled = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(rescaled, (number - min) / (max - min))\n    end\n\
    \    return rescaled\nend", "    local max_number = numbers[1]\n    local min_number\
    \ = numbers[1]\n    for _, number in ipairs(numbers) do\n        if number > max_number\
    \ then\n            max_number = number\n        end\n        if number < min_number\
    \ then\n            min_number = number\n        end\n    end\n    local delta\
    \ = max_number - min_number\n    local output = {}\n    for _, number in ipairs(numbers)\
    \ do\n        output[#output + 1] = (number - min_number) / delta\n    end\n \
    \   return output\nend", "  local min_number = math.min(unpack(numbers))\n  local\
    \ max_number = math.max(unpack(numbers))\n  local transform = function(value)\n\
    \    return (value - min_number) / (max_number - min_number)\n  end\n  return\
    \ utils.map(transform, numbers)\nend", "  local min_number = numbers[1]\n  local\
    \ max_number = numbers[1]\n  for _, number in ipairs(numbers) do\n    if number\
    \ < min_number then\n      min_number = number\n    end\n    if number > max_number\
    \ then\n      max_number = number\n    end\n  end\n  local zero_to_one_numbers\
    \ = {}\n  for _, number in ipairs(numbers) do\n    table.insert(zero_to_one_numbers,\
    \ (number - min_number) / (max_number - min_number))\n  end\n  return zero_to_one_numbers\n\
    end", "    local min_num = math.min(unpack(numbers))\n    local max_num = math.max(unpack(numbers))\n\
    \    local scalar = 1 / (max_num - min_num)\n    local result = {}\n    for _,\
    \ num in ipairs(numbers) do\n        table.insert(result, (num - min_num) * scalar)\n\
    \    end\n    return result\nend", "\tlocal min = math.min(unpack(numbers))\n\t\
    local max = math.max(unpack(numbers))\n\tlocal scale = max - min\n\treturn table.map(numbers,\
    \ function(n) return (n - min) / scale end)\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, number in ipairs(numbers) do\n       \
    \ if number < min then\n            min = number\n        end\n        if number\
    \ > max then\n            max = number\n        end\n    end\n    if max - min\
    \ <= 0 then\n        return { 1.0 }\n    end\n    local output = {}\n    for _,\
    \ number in ipairs(numbers) do\n        output[#output + 1] = (number - min) /\
    \ (max - min)\n    end\n    return output\nend", "    local the_min = math.min(unpack(numbers))\n\
    \    local the_max = math.max(unpack(numbers))\n    return map(function(n) return\
    \ (n - the_min) / (the_max - the_min) end, numbers)\nend", "    -- find smallest\
    \ and largest\n    local smallest = numbers[1]\n    local largest = numbers[1]\n\
    \    for i = 2, #numbers do\n        if numbers[i] < smallest then\n         \
    \   smallest = numbers[i]\n        end\n        if numbers[i] > largest then\n\
    \            largest = numbers[i]\n        end\n    end\n    -- subtract smallest\
    \ from all elements\n    for i = 1, #numbers do\n        numbers[i] = numbers[i]\
    \ - smallest\n    end\n    -- divide all elements by the difference between largest\
    \ and smallest\n    local factor = largest - smallest\n    for i = 1, #numbers\
    \ do\n        numbers[i] = numbers[i] / factor\n    end\n    return numbers\n\
    end", "    local mn, mx = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \    local r = mx - mn\n    if r == 0 then\n        -- If there's no difference\
    \ in numbers, just return 1 for the largest and 0 for the rest\n        local\
    \ largest = 0\n        for i, v in ipairs(numbers) do\n            if numbers[largest]\
    \ < v then\n                largest = i\n            end\n        end\n      \
    \  local res = {}\n        for i, v in ipairs(numbers) do\n            res[i]\
    \ = i == largest and 1 or 0\n        end\n        return res\n    end\n    local\
    \ res = {}\n    for i, v in ipairs(numbers) do\n        res[i] = (v - mn) / r\n\
    \    end\n    return res\nend", "    -- Determine the largest and smallest numbers\n\
    \    local smallest, largest = numbers[1], numbers[1]\n    for i, n in ipairs(numbers)\
    \ do\n        if n < smallest then\n            smallest = n\n        elseif n\
    \ > largest then\n            largest = n\n        end\n    end", "    local min\
    \ = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n   \
    \ local result = {}\n    for _,number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - min) / (max - min))\n    end\n    return result\nend", "    local\
    \ min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n    local range\
    \ = max - min\n    local result = {}\n    for _, number in ipairs(numbers) do\n\
    \        result[#result + 1] = (number - min) / range\n    end\n    return result\n\
    end", "  local max_value = numbers[1]\n  local min_value = numbers[1]\n  for i\
    \ = 2, #numbers do\n    max_value = math.max(max_value, numbers[i])\n    min_value\
    \ = math.min(min_value, numbers[i])\n  end\n  local rescaled_result = {}\n  local\
    \ range = max_value - min_value\n  for i = 1, #numbers do\n    local rescaled_value\
    \ = (numbers[i] - min_value) / range\n    table.insert(rescaled_result, rescaled_value)\n\
    \  end\n  return rescaled_result\nend", "    local n = #numbers\n    if n < 2\
    \ then\n        return numbers\n    end\n    local min_num = numbers[1]\n    local\
    \ max_num = numbers[1]\n    for i = 2, n do\n        local num = numbers[i]\n\
    \        if num < min_num then\n            min_num = num\n        elseif num\
    \ > max_num then\n            max_num = num\n        end\n    end\n    local range\
    \ = max_num - min_num\n    local result = {}\n    for i = 1, n do\n        local\
    \ num = numbers[i]\n        local new_value = (num - min_num) / range\n      \
    \  result[i] = new_value\n    end\n    return result\nend", "  local smallest\
    \ = math.huge\n  local largest = -math.huge\n  for _, v in ipairs(numbers) do\n\
    \    if v < smallest then\n      smallest = v\n    end\n    if v > largest then\n\
    \      largest = v\n    end\n  end\n  local range = largest - smallest\n  local\
    \ rescaled = {}\n  for _, v in ipairs(numbers) do\n    table.insert(rescaled,\
    \ (v - smallest) / range)\n  end\n  return rescaled\nend", "  local min = numbers[1]\n\
    \  local max = numbers[1]\n  for i = 2, #numbers do\n    min = math.min(min, numbers[i])\n\
    \    max = math.max(max, numbers[i])\n  end\n  -- We want max-min to be exactly\
    \ 1.0, but we can't use / to get it due to floating point\n  -- weirdness that\
    \ can lead to subtle rounding errors. Instead, we'll scale by 1.0/max, and\n \
    \ -- then scale by max-min.\n  local scale = (max - min)\n  for i = 1, #numbers\
    \ do\n    numbers[i] = (numbers[i] - min) / scale\n  end\n  return numbers\nend",
  "\tlocal min_x = min(numbers)\n\tlocal max_x = max(numbers)\n\tlocal denominator\
    \ = max_x - min_x\n\tlocal numbers_rescaled = {}\n\tfor index, number in ipairs(numbers)\
    \ do\n\t\tnumbers_rescaled[index] = (number - min_x) / denominator\n\tend\n\t\
    return numbers_rescaled\nend", "  local min_num = numbers[1]\n  local max_num\
    \ = numbers[1]\n  for i, number in ipairs(numbers) do\n    if number < min_num\
    \ then\n      min_num = number\n    end\n    if number > max_num then\n      max_num\
    \ = number\n    end\n  end\n  local result = {}\n  for i, number in ipairs(numbers)\
    \ do\n    result[i] = (number - min_num) / (max_num - min_num)\n  end\n  return\
    \ result\nend", "  local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \  local transform = {[min] = 0.0, [max] = 1.0}\n  local unit_values = {}\n  for\
    \ i,v in ipairs(numbers) do\n    unit_values[i] = transform[v]\n  end\n  return\
    \ unit_values\nend", "  -- So that the full range of numbers is defined.\n  assert(#numbers\
    \ > 1)\n  local min_n = math.min(unpack(numbers))\n  local max_n = math.max(unpack(numbers))\n\
    \  local diff = max_n - min_n\n  local unit = {}\n  for _, n in ipairs(numbers)\
    \ do\n    table.insert(unit, (n - min_n) / diff)\n  end\n  return unit\nend",
  "    local min, max = math.min(table.unpack(numbers)), math.max(table.unpack(numbers))\n\
    \    local step = (max - min) / (1 - 0)", "    local maxval = max(numbers)\n \
    \   local minval = min(numbers)\n    local scale = 1.0 / (maxval - minval)\n \
    \   local output = {}\n    for i, v in ipairs(numbers) do\n        output[i] =\
    \ (v - minval) * scale\n    end\n    return output\nend", "    local min_val =\
    \ numbers[1]\n    local max_val = numbers[1]\n    for i, val in ipairs(numbers)\
    \ do\n        if val < min_val then\n            min_val = val\n        end\n\
    \        if val > max_val then\n            max_val = val\n        end\n    end\n\
    \    local delta = max_val - min_val\n    if delta == 0 then delta = 1 end\n \
    \   local rescaled = {}\n    for i, val in ipairs(numbers) do\n        rescaled[i]\
    \ = (val - min_val) / delta\n    end\n    return rescaled\nend", "    local min_val\
    \ = math.min(unpack(numbers))\n    local max_val = math.max(unpack(numbers))\n\
    \    local ret = {}\n    for i,v in ipairs(numbers) do\n        ret[i] = (v -\
    \ min_val) / (max_val - min_val)\n    end\n    return ret\nend", "    local min_number\
    \ = min(numbers)\n    local max_number = max(numbers)\n    local delta = max_number\
    \ - min_number\n    local result = {}\n    for i,n in ipairs(numbers) do\n   \
    \     result[i] = (n - min_number) / delta\n    end\n    return result\nend",
  "  local min, max, result = nil, nil, {}\n  for i, number in ipairs(numbers) do\n\
    \    if not min or number < min then min = number end\n    if not max or number\
    \ > max then max = number end\n  end\n  for i, number in ipairs(numbers) do\n\
    \    result[i] = (number - min) / (max - min)\n  end\n  return result\nend", " \
    \   local smallest = numbers[1]\n    local largest = numbers[1]\n    for i = 2,\
    \ #numbers do\n        if numbers[i] < smallest then\n            smallest = numbers[i]\n\
    \        elseif numbers[i] > largest then\n            largest = numbers[i]\n\
    \        end\n    end\n    local range = largest - smallest\n    local output\
    \ = {}\n    for i = 1, #numbers do\n        output[i] = (numbers[i] - smallest)\
    \ / range\n    end\n    return output\nend", "  local res = {}\n  local biggest\
    \ = numbers[1]\n  local smallest = numbers[1]\n  for i,v in ipairs(numbers) do\n\
    \    biggest = math.max(biggest, v)\n    smallest = math.min(smallest, v)\n  end\n\
    \  for i,v in ipairs(numbers) do\n    res[i] = (v - smallest) / (biggest - smallest)\n\
    \  end\n  return res\nend", "    local minmax = minmax_numbers(numbers)\n    local\
    \ scale = 1 / (minmax.max - minmax.min)\n    local result = {}\n    for _, number\
    \ in ipairs(numbers) do\n        table.insert(result, (number - minmax.min) *\
    \ scale)\n    end\n    return result\nend", "  local numbers_min = math.min(unpack(numbers))\n\
    \  local numbers_max = math.max(unpack(numbers))\n  local scale = numbers_max\
    \ - numbers_min\n  local result = {}\n  for _, number in ipairs(numbers) do\n\
    \    table.insert(result, (number - numbers_min) / scale)\n  end\n  return result\n\
    end", "  local min = numbers[1]\n  local max = numbers[1]\n  for _, n in ipairs(numbers)\
    \ do\n    if n < min then min = n end\n    if n > max then max = n end\n  end\n\
    \  if min == max then return numbers end\n  for i, n in ipairs(numbers) do\n \
    \   numbers[i] = (n - min) / (max - min)\n  end\n  return numbers\nend", "  assert(#numbers\
    \ >= 2)\n  local min_n = min(numbers)\n  local max_n = max(numbers)\n  return\
    \ map(function(x) return (x - min_n) / (max_n - min_n) end, numbers)\nend", " \
    \ -- TODO: this is not very efficient, there are faster ways to do this\n  local\
    \ min = numbers[1]\n  local max = numbers[1]\n  for _, n in ipairs(numbers) do\n\
    \    if n < min then min = n end\n    if n > max then max = n end\n  end\n  local\
    \ rescaled = {}\n  for _, n in ipairs(numbers) do\n    table.insert(rescaled,\
    \ (n - min) / (max - min))\n  end\n  return rescaled\nend", "    local min_number\
    \ = math.min(unpack(numbers))\n    local max_number = math.max(unpack(numbers))\n\
    \    if min_number == max_number then\n        return numbers\n    end\n    local\
    \ scale = max_number - min_number\n    local scaled_table = {}\n    for k, v in\
    \ pairs(numbers) do\n        scaled_table[k] = (v - min_number) / scale\n    end\n\
    \    return scaled_table\nend", "    local highest = math.max(unpack(numbers))\n\
    \    local lowest = math.min(unpack(numbers))\n    local range = highest - lowest\n\
    \    return map(numbers, function(a) return (a - lowest) / range end)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
