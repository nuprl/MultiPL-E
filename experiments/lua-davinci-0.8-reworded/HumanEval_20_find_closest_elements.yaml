name: HumanEval_20_find_closest_elements
language: lua
prompt: "-- From a supplied table of numbers (of length at least two) select and return\
  \ two that are the closest to each\n-- other and return them in order (smaller number,\
  \ larger number).\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n\
  -- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n--\
  \ {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_closest_elements\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), {3.9, 4.0})\n  \
  \  lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}), {5.0, 5.9})\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), {2.0, 2.2})\n    lu.assertEquals(candidate({1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0}), {2.0, 2.0})\n    lu.assertEquals(candidate({1.1, 2.2, 3.1,\
  \ 4.1, 5.1}), {2.2, 3.1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local smallest_distance, closest_elements = math.huge\n  local n\
    \ = #numbers\n  for i = 1, n - 1 do\n    for j = i + 1, n do\n      local distance\
    \ = numbers[j] - numbers[i]\n      if distance < smallest_distance then\n    \
    \    smallest_distance = distance\n        closest_elements = {numbers[i], numbers[j]}\n\
    \      end\n    end\n  end\n  return closest_elements\nend", "  local a = numbers[1]\n\
    \  local b = numbers[2]\n  local closest_distance = math.abs(a - b)\n  for i =\
    \ 1, #numbers do\n    for j = i + 1, #numbers do\n      local distance = math.abs(numbers[i]\
    \ - numbers[j])\n      if distance < closest_distance then\n        a = numbers[i]\n\
    \        b = numbers[j]\n        closest_distance = distance\n      end\n    end\n\
    \  end\n  if a > b then\n    return {b, a}\n  else\n    return {a, b}\n  end\n\
    end", "    assert(#numbers >= 2)\n    local closest, closest_diff = 1, math.huge\n\
    \    for i = 1, #numbers do\n        local diff = numbers[i] - numbers[i % #numbers\
    \ + 1]\n        if diff < closest_diff then\n            closest_diff = diff\n\
    \            closest = i\n        end\n    end\n    return numbers[closest], numbers[closest\
    \ % #numbers + 1]\nend", "    -- TODO: add comments and docstring\n    -- TODO:\
    \ implement this function\n    -- Hint: You don't need to do anything special\
    \ here for the case where there are duplicates,\n    --       because this is\
    \ handled by the next function\n    if (#numbers<2) then \n        return nil\n\
    \    end\n    local gap=9999\n    local i=1\n    local j=2\n    local m=0\n  \
    \  local n=0\n    while (i<=#numbers) do\n        j=i+1\n        while (j<=#numbers)\
    \ do\n            if math.abs(numbers[i]-numbers[j])<gap then\n              \
    \  gap=math.abs(numbers[i]-numbers[j])\n                m=i\n                n=j\n\
    \            end\n            j=j+1\n        end\n        i=i+1\n    end\n   \
    \ return {numbers[m],numbers[n]}\nend", "  local min_distance = math.huge\n  local\
    \ number_1, number_2\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n\
    \      local distance = math.abs(numbers[i] - numbers[j])\n      if distance <\
    \ min_distance then\n        min_distance = distance\n        number_1 = numbers[i]\n\
    \        number_2 = numbers[j]\n      end\n    end\n  end\n  return {number_1,\
    \ number_2}\nend", "\tif #numbers < 2 then\n\t\terror(\"Parameter must be at least\
    \ two elements\", 2)\n\tend\n\tlocal closest_pair = {numbers[1], numbers[2]}\n\
    \tlocal closest_distance = math.abs(numbers[1] - numbers[2])\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif distance < closest_distance then\n\t\t\t\tclosest_distance\
    \ = distance\n\t\t\t\tclosest_pair = {numbers[i], numbers[j]}\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn closest_pair\nend", "    local min_gap = nil\n    local closest_pair\
    \ = nil\n    for i, value in ipairs(numbers) do\n        for j, other_value in\
    \ ipairs(numbers) do\n            if i ~= j then\n                local gap =\
    \ math.abs(value - other_value)\n                if min_gap == nil or gap < min_gap\
    \ then\n                    min_gap = gap\n                    closest_pair =\
    \ {value, other_value}\n                end\n            end\n        end\n  \
    \  end\n    return closest_pair\nend", "    assert(#numbers >= 2)\n    local diff\
    \ = math.abs(numbers[1] - numbers[2])\n    local ret = {numbers[1], numbers[2]}\n\
    \    for i = 1, #numbers - 1 do\n        local d = math.abs(numbers[i] - numbers[i\
    \ + 1])\n        if d < diff then\n            diff = d\n            ret = {numbers[i],\
    \ numbers[i + 1]}\n        end\n    end\n    return ret\nend", "  local smallest_distance\
    \ = math.huge -- first guess at the smallest_distance\n  local best_x = nil\n\
    \  local best_y = nil\n  for i, x in ipairs(numbers) do\n    for j, y in ipairs(numbers)\
    \ do\n      if i ~= j then\n        local distance = math.abs(x - y)\n       \
    \ if distance < smallest_distance then\n          smallest_distance = distance\n\
    \          best_x = x\n          best_y = y\n        end\n      end\n    end\n\
    \  end\n  if best_x > best_y then\n    return {best_y, best_x}\n  else\n    return\
    \ {best_x, best_y}\n  end\nend", "\tlocal n = #numbers\n\tassert(n >= 2, \"need\
    \ at least two numbers\")\n\tlocal closest_pair = {numbers[1], numbers[2]}\n\t\
    local closest_distance = math.abs(numbers[1] - numbers[2])\n\tfor i = 1, n - 1\
    \ do\n\t\tfor j = i + 1, n do\n\t\t\tlocal candidate_distance = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif candidate_distance < closest_distance then\n\t\t\t\t\
    closest_distance = candidate_distance\n\t\t\t\tclosest_pair = {numbers[i], numbers[j]}\n\
    \t\t\tend\n\t\tend\n\tend\n\ttable.sort(closest_pair)\n\treturn closest_pair\n\
    end", "  local numbers = assert(numbers, \"no numbers supplied\")\n  assert(#numbers\
    \ >= 2, \"not enough numbers\")\n  local result = { numbers[1], numbers[2] }\n\
    \  local min_distance = math.abs(numbers[1] - numbers[2])\n  for i=1,#numbers-1\
    \ do\n    for j=i+1,#numbers do\n      local distance = math.abs(numbers[i] -\
    \ numbers[j])\n      if distance < min_distance then\n        min_distance = distance\n\
    \        result = { numbers[i], numbers[j] }\n      end\n    end\n  end\n  return\
    \ result\nend", "    assert(#numbers >= 2)\n    local closest = {numbers[1], numbers[2]}\n\
    \    local min_distance = math.abs(numbers[1] - numbers[2])\n    for i = 1, #numbers\
    \ - 1 do\n        for j = i + 1, #numbers do\n            local distance = math.abs(numbers[i]\
    \ - numbers[j])\n            if distance < min_distance then\n               \
    \ min_distance = distance\n                closest = {numbers[i], numbers[j]}\n\
    \            end\n        end\n    end\n    return closest\nend", "\tlocal smallest_distance,\
    \ index_of_a, index_of_b = math.huge, nil, nil\n\tfor i = 1, #numbers - 1 do\n\
    \t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif distance < smallest_distance then\n\t\t\t\tsmallest_distance = distance\n\
    \t\t\t\tindex_of_a, index_of_b = i, j\n\t\t\tend\n\t\tend\n\tend\n\treturn numbers[index_of_a],\
    \ numbers[index_of_b]\nend", "    local min_distance = math.huge\n    local closest_elements\
    \ = {}\n    for i, first_number in ipairs(numbers) do\n        for j, second_number\
    \ in ipairs(numbers) do\n            if i ~= j then\n                local distance\
    \ = math.abs(first_number - second_number)\n                if distance < min_distance\
    \ then\n                    min_distance = distance\n                    closest_elements\
    \ = {first_number, second_number}\n                end\n            end\n    \
    \    end\n    end\n    return closest_elements\nend", "\tlocal min = math.huge\n\
    \tlocal a = numbers[1]\n\tlocal b = numbers[2]\n\tfor i = 1, #numbers do\n\t\t\
    for j = i + 1, #numbers do\n\t\t\tlocal x = numbers[i]\n\t\t\tlocal y = numbers[j]\n\
    \t\t\tlocal diff = math.abs(x - y)\n\t\t\tif diff < min then\n\t\t\t\tmin = diff\n\
    \t\t\t\ta = x\n\t\t\t\tb = y\n\t\t\tend\n\t\tend\n\tend\n\treturn a, b\nend",
  "  local small, large = numbers[1], numbers[2]\n  local small_index, large_index\
    \ = 1, 2\n  local best_distance = math.abs(large - small)\n  for i = 2, #numbers\
    \ do\n    local x, y = numbers[i], numbers[i + 1]\n    if y == nil then break\
    \ end\n    local distance = math.abs(y - x)\n    if distance < best_distance then\n\
    \      small, large = x, y\n      small_index, large_index = i, i + 1\n      best_distance\
    \ = distance\n    end\n  end\n  return small, large, small_index, large_index\n\
    end", "\ttable.sort(numbers)\n\tlocal closest_difference = math.huge\n\tlocal\
    \ smallest_number = numbers[1]\n\tlocal biggest_number = numbers[1]\n\tfor i =\
    \ 2, #numbers do\n\t\tlocal this_difference = numbers[i] - numbers[i - 1]\n\t\t\
    if this_difference < closest_difference then\n\t\t\tclosest_difference = this_difference\n\
    \t\t\tsmallest_number = numbers[i - 1]\n\t\t\tbiggest_number = numbers[i]\n\t\t\
    end\n\tend\n\treturn smallest_number, biggest_number\nend", "    local closest_elements\
    \ = {numbers[1], numbers[2]}\n    local difference = math.abs(numbers[1] - numbers[2])\n\
    \    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n        \
    \    local diff = math.abs(numbers[i] - numbers[j])\n            if diff < difference\
    \ then\n                closest_elements = {numbers[i], numbers[j]}\n        \
    \        difference = diff\n            end\n        end\n    end\n    return\
    \ closest_elements\nend", "\tlocal closest_dist = math.huge\n\tlocal closest_pair\
    \ = { math.huge, math.huge }\n\tlocal numbers_size = #numbers\n\tfor i = 1, numbers_size\
    \ - 1 do\n\t\tfor j = i + 1, numbers_size do\n\t\t\tlocal diff = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif diff < closest_dist then\n\t\t\t\tclosest_dist = diff\n\
    \t\t\t\tclosest_pair = { numbers[i], numbers[j] }\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn closest_pair\nend", "    local smallest_difference = math.huge\n    local\
    \ closest_pair = {nil, nil}\n    local number_count = #numbers\n    for i = 1,\
    \ number_count do\n        local number = numbers[i]\n        local j = i + 1\n\
    \        while j <= number_count do\n            local number2 = numbers[j]\n\
    \            local difference = math.abs(number - number2)\n            if difference\
    \ < smallest_difference then\n                smallest_difference = difference\n\
    \                closest_pair = {number, number2}\n            end\n         \
    \   j = j + 1\n        end\n    end\n    return closest_pair\nend", "    local\
    \ smallest_difference = math.huge\n    local smallest_difference_i, smallest_difference_j\
    \ = 0, 0\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n   \
    \         local difference = math.abs(numbers[i] - numbers[j])\n            if\
    \ difference < smallest_difference then\n                smallest_difference =\
    \ difference\n                smallest_difference_i = i\n                smallest_difference_j\
    \ = j\n            end\n        end\n    end\n    local smallest_number = math.min(numbers[smallest_difference_i],\
    \ numbers[smallest_difference_j])\n    local largest_number = math.max(numbers[smallest_difference_i],\
    \ numbers[smallest_difference_j])\n    return {smallest_number, largest_number}\n\
    end", "    local smallest_difference = 0\n    local closest_elements = {}\n  \
    \  for i, _ in ipairs(numbers) do\n        if i + 1 <= #numbers then\n       \
    \     local difference = math.abs(numbers[i] - numbers[i + 1])\n            if\
    \ smallest_difference == 0 or difference < smallest_difference then\n        \
    \        closest_elements = {numbers[i], numbers[i + 1]}\n                smallest_difference\
    \ = difference\n            end\n        end\n    end\n    return closest_elements\n\
    end", "  if #numbers < 2 then\n    return nil\n  end\n  local smallest_distance\
    \ = math.huge\n  local smallest_distance_index_1, smallest_distance_index_2\n\
    \  for index_1 = 1, #numbers - 1 do\n    for index_2 = index_1 + 1, #numbers do\n\
    \      local number_1 = numbers[index_1]\n      local number_2 = numbers[index_2]\n\
    \      local distance = math.abs(number_1 - number_2)\n      if distance < smallest_distance\
    \ then\n        smallest_distance = distance\n        smallest_distance_index_1\
    \ = index_1\n        smallest_distance_index_2 = index_2\n      end\n    end\n\
    \  end\n  return {numbers[smallest_distance_index_1], numbers[smallest_distance_index_2]}\n\
    end", "\t-- Check that the table has at least two elements.\n\tassert(#numbers\
    \ >= 2, \"Not enough numbers to find two closest numbers.\")", "    local min_difference\
    \ = math.huge\n    local min_difference_pair\n    for i = 1, #numbers - 1 do\n\
    \        local difference = math.abs(numbers[i] - numbers[i + 1])\n        if\
    \ difference < min_difference then\n            min_difference = difference\n\
    \            min_difference_pair = {numbers[i], numbers[i + 1]}\n        end\n\
    \    end\n    return min_difference_pair\nend", "    local smallest_separation\
    \ = 1000.0\n    local result = {0.0, 0.0}\n    local n = #numbers\n    for i =\
    \ 1, n - 1 do\n        for j = i + 1, n do\n            local separation = math.abs(numbers[i]\
    \ - numbers[j])\n            if separation < smallest_separation then\n      \
    \          smallest_separation = separation\n                result[1] = numbers[i]\n\
    \                result[2] = numbers[j]\n            end\n        end\n    end\n\
    \    return result\nend", "\tassert(#numbers >= 2, \"need at least two numbers\"\
    )\n\tlocal diff = numbers[2] - numbers[1]\n\tlocal best_pairs = {numbers[1], numbers[2]}\n\
    \tfor i = 2, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal d = numbers[j]\
    \ - numbers[i]\n\t\t\tif d < diff then\n\t\t\t\tdiff = d\n\t\t\t\tbest_pairs =\
    \ {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn best_pairs\nend",
  "    local first = numbers[1]\n    local second = numbers[2]\n    local lowest_difference\
    \ = math.abs(first - second)\n    for i = 1, #numbers - 1 do\n        for j =\
    \ i + 1, #numbers do\n            local difference = math.abs(numbers[i] - numbers[j])\n\
    \            if difference < lowest_difference then\n                lowest_difference\
    \ = difference\n                first = numbers[i]\n                second = numbers[j]\n\
    \            end\n        end\n    end\n    return {first, second}\nend", "\t\
    local min_difference = math.huge\n\tlocal min_pair = {0, 0}\n\tfor i, number in\
    \ ipairs(numbers) do\n\t\tlocal number_plus_one = numbers[i + 1]\n\t\tif number_plus_one\
    \ then\n\t\t\tlocal difference = math.abs(number - number_plus_one)\n\t\t\tif\
    \ difference < min_difference then\n\t\t\t\tmin_difference = difference\n\t\t\t\
    \tmin_pair = {number, number_plus_one}\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(min_pair)\n\
    \treturn min_pair\nend", "  local closest_numbers = {numbers[1], numbers[2]}\n\
    \  local smallest_difference = math.abs(numbers[1] - numbers[2])\n  for i, number\
    \ in ipairs(numbers) do\n    if i > 2 then\n      for j, other_number in ipairs(numbers)\
    \ do\n        if j ~= i then\n          local difference = math.abs(number - other_number)\n\
    \          if difference < smallest_difference then\n            smallest_difference\
    \ = difference\n            closest_numbers = {number, other_number}\n       \
    \   end\n        end\n      end\n    end\n  end\n  return closest_numbers\nend",
  "    local min_diff = math.huge\n    local min_diff_elements = {0, 0}\n    for index,\
    \ this_number in ipairs(numbers) do\n        local next_number = numbers[index\
    \ + 1]\n        if next_number then\n            local diff = math.abs(this_number\
    \ - next_number)\n            if diff < min_diff then\n                min_diff\
    \ = diff\n                min_diff_elements = {this_number, next_number}\n   \
    \         end\n        end\n    end\n    return min_diff_elements\nend", "   \
    \ local n = numbers[1]\n    local m = numbers[2]\n    local d = math.abs(n - m)\n\
    \    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n        \
    \    local dij = math.abs(numbers[i] - numbers[j])\n            if dij < d then\n\
    \                n = numbers[i]\n                m = numbers[j]\n            \
    \    d = dij\n            end\n        end\n    end\n    if n > m then\n     \
    \   return {m, n}\n    else\n        return {n, m}\n    end\nend", "    assert(type(numbers)\
    \ == \"table\", \"expected a table argument, got \" .. type(numbers))\n    if\
    \ #numbers == 0 then return nil end", "  assert(type(numbers) == \"table\")\n\
    \  assert(#numbers >= 2)\n  local min_diff = math.huge\n  local min_diff_indices\
    \ = { 1, 2 }\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n     \
    \ local diff = math.abs(numbers[i] - numbers[j])\n      if diff < min_diff then\n\
    \        min_diff = diff\n        min_diff_indices = { i, j }\n      end\n   \
    \ end\n  end\n  return numbers[min_diff_indices[1]], numbers[min_diff_indices[2]]\n\
    end", "    local closest = {math.huge, math.huge}\n    local closest_dist = math.huge\n\
    \    for i, a in ipairs(numbers) do\n        for j, b in ipairs(numbers) do\n\
    \            if i ~= j then\n                local dist = math.abs(a - b)\n  \
    \              if dist < closest_dist then\n                    closest = {a,\
    \ b}\n                    closest_dist = dist\n                end\n         \
    \   end\n        end\n    end\n    return closest\nend", "    assert(#numbers\
    \ >= 2)\n    local smallest_distance = math.huge\n    local closest_elements =\
    \ {}\n    for index = 1, #numbers - 1 do\n        local a = numbers[index]\n \
    \       local b = numbers[index + 1]\n        local distance = math.abs(a - b)\n\
    \        if distance < smallest_distance then\n            smallest_distance =\
    \ distance\n            closest_elements = {a, b}\n        end\n    end\n    return\
    \ closest_elements\nend", "  assert(type(numbers) == \"table\", \"find_closest_elements:\
    \ expected 'numbers' to be a table, got \" .. type(numbers))\n  assert(#numbers\
    \ >= 2, \"find_closest_elements: expected 'numbers' to have length at least 2,\
    \ got \" .. #numbers)\n  for i, _ in ipairs(numbers) do\n    assert(type(numbers[i])\
    \ == \"number\", \"find_closest_elements: expected 'numbers[\" .. i .. \"]' to\
    \ be a number, got \" .. type(numbers[i]))\n  end", "  assert(#numbers >= 2)\n\
    \  local result = {numbers[1], numbers[2]}\n  for i = 1, #numbers do\n    for\
    \ j = i + 1, #numbers do\n      if math.abs(numbers[i] - numbers[j]) < math.abs(result[1]\
    \ - result[2]) then\n        result = {numbers[i], numbers[j]}\n      end\n  \
    \  end\n  end\n  return result\nend", "    assert(#numbers >= 2)\n    local num_one,\
    \ num_two = numbers[1], numbers[2]\n    local min_distance = math.abs(num_one\
    \ - num_two)\n    for i, x in ipairs(numbers) do\n        for j, y in ipairs(numbers)\
    \ do\n            if i ~= j then\n                local distance = math.abs(x\
    \ - y)\n                if distance < min_distance then\n                    num_one,\
    \ num_two = x, y\n                    min_distance = distance\n              \
    \  end\n            end\n        end\n    end\n    return num_one, num_two\nend",
  "    local smallest_distance = math.huge\n    local closest_elements = {1, 1}",
  "    local count = #numbers\n    if count < 2 then\n        return nil\n    end\n\
    \    local smallest = numbers[1]\n    local largest = numbers[1]\n    for i =\
    \ 2, count do\n        local num = numbers[i]\n        if num < smallest then\n\
    \            smallest = num\n        elseif num > largest then\n            largest\
    \ = num\n        end\n    end\n    local closest_diff = largest - smallest\n \
    \   local diff\n    for i = 1, count - 1 do\n        local a = numbers[i]\n  \
    \      for j = i + 1, count do\n            local b = numbers[j]\n           \
    \ diff = b - a\n            if diff < closest_diff then\n                closest_diff\
    \ = diff\n                smallest = a\n                largest = b\n        \
    \    end\n        end\n    end\n    return smallest, largest\nend", "    -- Find\
    \ the first closest pair of numbers, then compare to successive pairs.\n    local\
    \ min_distance = nil\n    local min_distance_i = 0\n    local min_distance_j =\
    \ 0\n    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n    \
    \        local distance = math.abs(numbers[i] - numbers[j])\n            if (min_distance\
    \ == nil) or (distance < min_distance) then\n                min_distance = distance\n\
    \                min_distance_i = i\n                min_distance_j = j\n    \
    \        end\n        end\n    end\n    -- Return the result.\n    return {numbers[min_distance_i],\
    \ numbers[min_distance_j]}\nend", "    if #numbers < 2 then return nil end\n \
    \   local first = numbers[1]\n    local second = first\n    local delta = math.abs(first\
    \ - second)\n    for i = 2, #numbers do\n        local d = math.abs(first - numbers[i])\n\
    \        if d < delta then\n            second = numbers[i]\n            delta\
    \ = d\n        end\n    end\n    if second < first then\n        first, second\
    \ = second, first\n    end\n    return {first, second}\nend", "    local smallest_index\
    \ = 0\n    local smallest_difference = numbers[2] - numbers[1]\n    for i = 2,\
    \ #numbers - 1 do\n        local difference = numbers[i + 1] - numbers[i]\n  \
    \      if difference < smallest_difference then\n            smallest_index =\
    \ i\n            smallest_difference = difference\n        end\n    end\n    return\
    \ numbers[smallest_index], numbers[smallest_index + 1]\nend", "    assert(type(numbers)\
    \ == \"table\", \"Expected a table\")\n    assert(#numbers >= 2, \"Expected at\
    \ least two numbers\")\n    local first = 1\n    local second = 2\n    local min_dist\
    \ = numbers[2] - numbers[1]\n    for j = 3, #numbers do\n        local dist =\
    \ numbers[j] - numbers[j - 1]\n        if dist < min_dist then\n            min_dist\
    \ = dist\n            first = j - 1\n            second = j\n        end\n   \
    \ end\n    return {numbers[first], numbers[second]}\nend", "  local closest_distance\
    \ = math.huge\n  local closest_elements = {math.huge, math.huge}\n  for i = 1,\
    \ #numbers do\n    local n1 = numbers[i]\n    for j = i + 1, #numbers do\n   \
    \   local n2 = numbers[j]\n      local n1n2_distance = math.abs(n1 - n2)\n   \
    \   if n1n2_distance < closest_distance then\n        closest_distance = n1n2_distance\n\
    \        closest_elements = {n1, n2}\n      end\n    end\n  end\n  return closest_elements\n\
    end", "    local first, second, diff, min_diff, len\n    first, second, diff,\
    \ min_diff = numbers[1], numbers[2], second - first, math.abs(diff)\n    for i\
    \ = 2, #numbers - 1 do\n        diff = numbers[i + 1] - numbers[i]\n        if\
    \ math.abs(diff) < min_diff then\n            first, second, min_diff = numbers[i],\
    \ numbers[i + 1], math.abs(diff)\n        end\n    end\n    return first, second\n\
    end", "    if #numbers < 2 then\n        return nil\n    end\n    if #numbers\
    \ == 2 then\n        return numbers\n    end\n    local min_so_far = math.abs(numbers[1]\
    \ - numbers[2])\n    local min_i = 1\n    local min_j = 2\n    for i = 1, #numbers\
    \ - 1 do\n        for j = i + 1, #numbers do\n            local current_min =\
    \ math.abs(numbers[i] - numbers[j])\n            if current_min < min_so_far then\n\
    \                min_so_far = current_min\n                min_i = i\n       \
    \         min_j = j\n            end\n        end\n    end\n    local table_of_min_two\
    \ = {numbers[min_i], numbers[min_j]}\n    if table_of_min_two[1] > table_of_min_two[2]\
    \ then\n        local temp = table_of_min_two[1]\n        table_of_min_two[1]\
    \ = table_of_min_two[2]\n        table_of_min_two[2] = temp\n    end\n    return\
    \ table_of_min_two\nend", "    local lowest_difference = math.huge\n    local\
    \ lower_number = math.huge\n    local higher_number = math.huge\n    for index,\
    \ number in ipairs(numbers) do\n        for index2, number2 in ipairs(numbers)\
    \ do\n            if index2 > index then\n                local difference = math.abs(number\
    \ - number2)\n                if difference < lowest_difference then\n       \
    \             lower_number = math.min(number, number2)\n                    higher_number\
    \ = math.max(number, number2)\n                    lowest_difference = difference\n\
    \                end\n            end\n        end\n    end\n    return {lower_number,\
    \ higher_number}\nend", "\tlocal n = #numbers\n\tassert(n >= 2, \"Array must contain\
    \ at least two numbers.\")\n\tlocal closest_pair = {math.huge, -math.huge}\n\t\
    local diff = math.huge\n\tfor i = 1, n - 1 do\n\t\tfor j = i + 1, n do\n\t\t\t\
    local d = math.abs(numbers[i] - numbers[j])\n\t\t\tif d < diff then\n\t\t\t\t\
    closest_pair = {numbers[i], numbers[j]}\n\t\t\t\tdiff = d\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn closest_pair\nend", "  assert(#numbers >= 2, \"expect at least\
    \ two numbers\")\n  local min_pair = {numbers[1], numbers[2]}\n  local min_diff\
    \ = math.abs(numbers[1] - numbers[2])\n  for i = 1, #numbers - 1 do\n    for j\
    \ = i + 1, #numbers do\n      local diff = math.abs(numbers[i] - numbers[j])\n\
    \      if diff < min_diff then\n        min_diff = diff\n        min_pair = {numbers[i],\
    \ numbers[j]}\n      end\n    end\n  end\n  if min_pair[1] > min_pair[2] then\n\
    \    min_pair[1], min_pair[2] = min_pair[2], min_pair[1]\n  end\n  return min_pair\n\
    end", "\tlocal closest = numbers[1]\n\tlocal second_closest = numbers[2]\n\tlocal\
    \ smallest_difference = math.abs(closest - second_closest)\n\tfor i = 2, #numbers\
    \ - 1 do\n\t\tlocal current_number = numbers[i]\n\t\tlocal next_number = numbers[i\
    \ + 1]\n\t\tlocal diff = math.abs(current_number - next_number)\n\t\tif diff <\
    \ smallest_difference then\n\t\t\tclosest = current_number\n\t\t\tsecond_closest\
    \ = next_number\n\t\t\tsmallest_difference = diff\n\t\tend\n\tend\n\treturn closest,\
    \ second_closest\nend", "\tassert(type(numbers) == \"table\", \"numbers is not\
    \ a table\")\n\tassert(#numbers >= 2, \"length of numbers is less than two\")\n\
    \tlocal first = numbers[1]\n\tlocal second = numbers[2]\n\tlocal closest_difference\
    \ = math.abs(first - second)\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers\
    \ do\n\t\t\tlocal diff = math.abs(numbers[i] - numbers[j])\n\t\t\tif diff < closest_difference\
    \ then\n\t\t\t\tfirst = numbers[i]\n\t\t\t\tsecond = numbers[j]\n\t\t\t\tclosest_difference\
    \ = diff\n\t\t\tend\n\t\tend\n\tend\n\treturn {first, second}\nend", "\tlocal\
    \ result = {numbers[1], numbers[2]}\n\tlocal smallest_difference = math.abs(numbers[1]\
    \ - numbers[2])\n\tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\
    \t\t\tlocal difference = math.abs(numbers[i] - numbers[j])\n\t\t\tif difference\
    \ < smallest_difference then\n\t\t\t\tresult = {numbers[i], numbers[j]}\n\t\t\t\
    \tsmallest_difference = difference\n\t\t\tend\n\t\tend\n\tend\n\treturn result\n\
    end", "    assert(#numbers >= 2)\n    local closest = math.abs(numbers[1] - numbers[2])\n\
    \    local element1 = numbers[1]\n    local element2 = numbers[2]\n    for i =\
    \ 1, #numbers - 1 do\n        local difference = math.abs(numbers[i] - numbers[i\
    \ + 1])\n        if difference < closest then\n            closest = difference\n\
    \            element1 = numbers[i]\n            element2 = numbers[i + 1]\n  \
    \      end\n    end\n    return {element1, element2}\nend", "    if #numbers <\
    \ 2 then\n        error(\"Invalid number of numbers supplied\")\n    end\n   \
    \ local min_diff = numbers[2] - numbers[1]\n    local min_diff_numbers = {numbers[1],\
    \ numbers[2]}\n    for i = 2, #numbers - 1 do\n        local diff = numbers[i\
    \ + 1] - numbers[i]\n        if diff < min_diff then\n            min_diff = diff\n\
    \            min_diff_numbers = {numbers[i], numbers[i + 1]}\n        end\n  \
    \  end\n    return min_diff_numbers\nend", "    local count = #numbers\n    local\
    \ smallest_difference = math.huge\n    local closest_elements = {}\n    for i\
    \ = 1, count do\n        local number_1 = numbers[i]\n        for j = i + 1, count\
    \ do\n            local number_2 = numbers[j]\n            local difference =\
    \ math.abs(number_1 - number_2)\n            if difference < smallest_difference\
    \ then\n                smallest_difference = difference\n                closest_elements\
    \ = {number_1, number_2}\n            end\n        end\n    end\n    return closest_elements\n\
    end", "    local min_diff = math.huge\n    local min_diff_a = nil\n    local min_diff_b\
    \ = nil\n    for i = 1, #numbers do\n        local a = numbers[i]\n        for\
    \ j = i + 1, #numbers do\n            local b = numbers[j]\n            local\
    \ diff = math.abs(a - b)\n            if diff < min_diff then\n              \
    \  min_diff = diff\n                min_diff_a = a\n                min_diff_b\
    \ = b\n            end\n        end\n    end\n    return min_diff_a, min_diff_b\n\
    end", "    local min_diff, min_i, min_j = math.huge, nil, nil\n    for i, a in\
    \ ipairs(numbers) do\n        for j, b in ipairs(numbers) do\n            if i\
    \ < j then\n                local diff = math.abs(a - b)\n                if diff\
    \ < min_diff then\n                    min_diff, min_i, min_j = diff, i, j\n \
    \               end\n            end\n        end\n    end\n    return {numbers[min_i],\
    \ numbers[min_j]}\nend", "\tlocal head = numbers[1]\n\tlocal last = head\n\tlocal\
    \ closest = head\n\tlocal csmall = head\n\tlocal clarge = head\n\tfor _, number\
    \ in ipairs(numbers) do\n\t\tlocal dist = math.abs(number - last)\n\t\tif dist\
    \ < closest then\n\t\t\tclosest = dist\n\t\t\tcsmall = math.min(number, last)\n\
    \t\t\tclarge = math.max(number, last)\n\t\tend\n\t\tlast = number\n\tend\n\treturn\
    \ {csmall, clarge}\nend", "\tlocal closest_distance = math.huge\n\tlocal closest_elements\
    \ = {}\n\tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal\
    \ d = math.abs(numbers[i] - numbers[j])\n\t\t\tif d < closest_distance then\n\t\
    \t\t\tclosest_distance = d\n\t\t\t\tclosest_elements = {numbers[i], numbers[j]}\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn closest_elements\nend", "    assert(#numbers\
    \ >= 2)\n    local smallest_distance = math.huge\n    local candidates = {numbers[1],\
    \ numbers[2]}\n    for i, value in ipairs(numbers) do\n        for j, other_value\
    \ in ipairs(numbers) do\n            if i ~= j then\n                local distance\
    \ = math.abs(value - other_value)\n                if distance < smallest_distance\
    \ then\n                    smallest_distance = distance\n                   \
    \ candidates = {value, other_value}\n                end\n            end\n  \
    \      end\n    end\n    return candidates\nend", "  if type(numbers) ~= \"table\"\
    \ then\n    return nil\n  end\n  local closest_distance = math.huge\n  local index_of_closest_1,\
    \ index_of_closest_2\n  for i, ni in ipairs(numbers) do\n    for j, nj in ipairs(numbers)\
    \ do\n      if i ~= j then\n        local distance = math.abs(ni - nj)\n     \
    \   if distance < closest_distance then\n          closest_distance = distance\n\
    \          index_of_closest_1 = i\n          index_of_closest_2 = j\n        end\n\
    \      end\n    end\n  end\n  local closest_1 = numbers[index_of_closest_1]\n\
    \  local closest_2 = numbers[index_of_closest_2]\n  return {math.min(closest_1,\
    \ closest_2), math.max(closest_1, closest_2)}\nend", "  local min_distance = math.huge\n\
    \  local result = {}\n  for i, a in ipairs(numbers) do\n    for j, b in ipairs(numbers)\
    \ do\n      if i ~= j then\n        local distance = math.abs(a - b)\n       \
    \ if distance < min_distance then\n          min_distance = distance\n       \
    \   result = {a, b}\n        end\n      end\n    end\n  end\n  return result\n\
    end", "\tassert(#numbers >= 2, \"find_closest_elements() requires at least two\
    \ numbers\")\n\tlocal smallest_difference = math.huge\n\tlocal closest_a = 0\n\
    \tlocal closest_b = 0\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\
    \t\t\tlocal current_difference = math.abs(numbers[i] - numbers[j])\n\t\t\tif current_difference\
    \ < smallest_difference then\n\t\t\t\tsmallest_difference = current_difference\n\
    \t\t\t\tclosest_a = numbers[i]\n\t\t\t\tclosest_b = numbers[j]\n\t\t\tend\n\t\t\
    end\n\tend\n\t-- since the loop is exhaustive, the second element will always\
    \ be the same or higher than the first,\n\t-- so we might need to swap them.\n\
    \tif closest_a > closest_b then\n\t\tclosest_a, closest_b = closest_b, closest_a\n\
    \tend\n\treturn {closest_a, closest_b}\nend", "  local min_distance = math.huge\n\
    \  local closest_elements = {}\n  for i,v in ipairs(numbers) do\n    for j,w in\
    \ ipairs(numbers) do\n      if i < j then\n        local distance = math.abs(v\
    \ - w)\n        if distance < min_distance then\n          min_distance = distance\n\
    \          closest_elements = {v, w}\n        end\n      end\n    end\n  end\n\
    \  return closest_elements\nend", "    local a, b, closest_distance\n    for i\
    \ = 1, #numbers do\n        for j = i+1, #numbers do\n            local distance\
    \ = math.abs(numbers[i] - numbers[j])\n            if (not closest_distance) or\
    \ (distance < closest_distance) then\n                a, b, closest_distance =\
    \ numbers[i], numbers[j], distance\n            end\n        end\n    end\n  \
    \  return {a, b}\nend", "  local min_difference = math.huge\n  local min_elements\
    \ = {}\n  for _,number in ipairs(numbers) do\n    if #min_elements == 0 then\n\
    \      min_elements[1] = number\n    elseif #min_elements == 1 then\n      local\
    \ difference = math.abs(number - min_elements[1])\n      if difference < min_difference\
    \ then\n        min_difference = difference\n        min_elements[2] = number\n\
    \      elseif difference == min_difference then\n        min_elements[2] = number\n\
    \      end\n    else\n      local difference = math.abs(number - min_elements[1])\n\
    \      if difference < min_difference then\n        min_difference = difference\n\
    \        min_elements[1] = number\n        min_elements[2] = nil\n      elseif\
    \ difference == min_difference then\n        min_elements[2] = number\n      end\n\
    \    end\n  end\n  if #min_elements == 1 then\n    min_elements[2] = min_elements[1]\n\
    \  end\n  -- Now sort the two elements if required\n  if min_elements[1] > min_elements[2]\
    \ then\n    min_elements[1], min_elements[2] = min_elements[2], min_elements[1]\n\
    \  end\n  return min_elements\nend", "\tlocal numlength = #numbers\n\tif numlength\
    \ < 2 then\n\t\treturn {}\n\tend\n\tlocal closest\n\tlocal closest_pair = {numbers[1],\
    \ numbers[2]}\n\tfor i = 1, numlength do\n\t\tfor j = i + 1, numlength do\n\t\t\
    \tlocal distance = math.abs(numbers[i] - numbers[j])\n\t\t\tif not closest or\
    \ distance < closest then\n\t\t\t\tclosest = distance\n\t\t\t\tclosest_pair =\
    \ {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn closest_pair\n\
    end", "\tlocal first = table.remove(numbers,1)\n\tlocal second = table.remove(numbers,1)\n\
    \tlocal smallest = math.abs(first - second)\n\tfor _,n in ipairs(numbers) do\n\
    \t\tlocal d = math.abs(first - n)\n\t\tif d < smallest then\n\t\t\tsecond = n\n\
    \t\t\tsmallest = d\n\t\tend\n\tend\n\tif first > second then\n\t\treturn second,\
    \ first\n\telse\n\t\treturn first, second\n\tend\nend", "  if type(numbers) ~=\
    \ \"table\" then return nil end\n  if #numbers < 2 then return nil end\n  local\
    \ smallest = nil\n  local largest = nil\n  local closest = nil\n  local closest_d\
    \ = nil\n  for i = 1, #numbers - 1 do\n    for j = i + 1, #numbers do\n      if\
    \ numbers[i] == numbers[j] then return {numbers[i], numbers[j]} end\n      local\
    \ d = math.abs(numbers[i] - numbers[j])\n      if closest_d == nil or d < closest_d\
    \ then\n        closest_d = d\n        closest = {i, j}\n      end\n    end\n\
    \  end\n  if closest[1] < closest[2] then\n    smallest = numbers[closest[1]]\n\
    \    largest = numbers[closest[2]]\n  else\n    smallest = numbers[closest[2]]\n\
    \    largest = numbers[closest[1]]\n  end\n  return {smallest, largest}\nend",
  "  -- Find the closest two numbers\n  local closest_numbers = {numbers[1], numbers[2]}\n\
    \  local closest_distance = math.abs(numbers[1] - numbers[2])\n  for i = 1, #numbers\
    \ - 1 do\n    for j = i + 1, #numbers do\n      local distance = math.abs(numbers[i]\
    \ - numbers[j])\n      if distance < closest_distance then\n        closest_numbers\
    \ = {numbers[i], numbers[j]}\n        closest_distance = distance\n      end\n\
    \    end\n  end\n  -- Order the two numbers\n  if closest_numbers[1] > closest_numbers[2]\
    \ then\n    closest_numbers[1], closest_numbers[2] = closest_numbers[2], closest_numbers[1]\n\
    \  end\n  return closest_numbers\nend", "    local best1 = numbers[1]\n    local\
    \ best2 = numbers[2]\n    local best_distance = math.abs(best1 - best2)\n    local\
    \ count = #numbers\n    for i = 1, count - 1 do\n        for j = i + 1, count\
    \ do\n            local n1 = numbers[i]\n            local n2 = numbers[j]\n \
    \           local distance = math.abs(n1 - n2)\n            if distance < best_distance\
    \ then\n                best1 = n1\n                best2 = n2\n             \
    \   best_distance = distance\n            end\n        end\n    end\n    if best1\
    \ > best2 then\n        return {best2, best1}\n    else\n        return {best1,\
    \ best2}\n    end\nend", "    local min_distance = math.huge\n    local result_a,\
    \ result_b = numbers[1], numbers[2]\n    for i = 1, #numbers - 1 do\n        local\
    \ a, b = numbers[i], numbers[i + 1]\n        local distance = math.abs(a - b)\n\
    \        if distance < min_distance then\n            min_distance = distance\n\
    \            result_a, result_b = a, b\n        end\n    end\n    return result_a,\
    \ result_b\nend", "\tassert(numbers and #numbers >= 2, \"find_closest_elements:\
    \ need at least two numbers!\")\n\tlocal smaller = numbers[1]\n\tlocal larger\
    \ = numbers[2]\n\tlocal difference = math.abs(smaller - larger)\n\tfor i = 1,\
    \ #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal d = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif d < difference then\n\t\t\t\tsmaller = numbers[i]\n\t\
    \t\t\tlarger = numbers[j]\n\t\t\t\tdifference = d\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn smaller, larger\nend", "\t-- find the minimum distance between any pair\
    \ of numbers.\n\tlocal min_distance = math.huge\n\tlocal min_distance_elements\
    \ = {nil, nil}\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\
    \tlocal distance = math.abs(numbers[i] - numbers[j])\n\t\t\tif distance < min_distance\
    \ then\n\t\t\t\tmin_distance = distance\n\t\t\t\tmin_distance_elements = {numbers[i],\
    \ numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn min_distance_elements\nend",
  "    local c1 = numbers[1]\n    local c2 = numbers[2]\n    local c_delta = math.abs(c1\
    \ - c2)\n    for i, n1 in ipairs(numbers) do\n        for j, n2 in ipairs(numbers)\
    \ do\n            if i ~= j then\n                local delta = math.abs(n1 -\
    \ n2)\n                if delta < c_delta then\n                    c1 = n1\n\
    \                    c2 = n2\n                    c_delta = delta\n          \
    \      end\n            end\n        end\n    end\n    return c1 < c2 and {c1,\
    \ c2} or {c2, c1}\nend", "  assert(#numbers >= 2)\n  local a, b = numbers[1],\
    \ numbers[2]\n  local ai, bi = 1, 2\n  for i = 1, #numbers do\n    for j = i +\
    \ 1, #numbers do\n      local diff = abs(numbers[i] - numbers[j])\n      if diff\
    \ < abs(a - b) then\n        a, b = numbers[i], numbers[j]\n        ai, bi = i,\
    \ j\n      end\n    end\n  end\n  assert(ai <= bi)\n  return a, b\nend", "   \
    \ local min_diff = math.huge;\n    local min_numbers = {};\n    for i = 1, #numbers\
    \ - 1 do\n        local diff = math.abs(numbers[i] - numbers[i + 1]);\n      \
    \  if diff < min_diff then\n            min_diff = diff;\n            min_numbers\
    \ = { numbers[i], numbers[i + 1] };\n        end\n    end\n    return min_numbers;\n\
    end", "\tlocal smallest = numbers[1]\n\tlocal second = numbers[2]\n\tlocal smallest_dist\
    \ = second - smallest\n\tfor i = 3, #numbers do\n\t\tlocal dist = numbers[i] -\
    \ smallest\n\t\tif dist < smallest_dist then\n\t\t\tsecond = numbers[i]\n\t\t\t\
    smallest_dist = dist\n\t\tend\n\tend\n\treturn smallest, second\nend", "    local\
    \ min_distance = math.huge\n    local min_elements = {0, 0}\n    local counter\
    \ = 1\n    while counter <= #numbers do\n        local number = numbers[counter]\n\
    \        local sub_counter = counter + 1\n        while sub_counter <= #numbers\
    \ do\n            local next_number = numbers[sub_counter]\n            local\
    \ distance = math.abs(number - next_number)\n            if distance < min_distance\
    \ then\n                min_distance = distance\n                min_elements\
    \ = {number, next_number}\n            end\n            sub_counter = sub_counter\
    \ + 1\n        end\n        counter = counter + 1\n    end\n    return min_elements\n\
    end", "\tif not numbers then\n\t\treturn\n\tend\n\tlocal numbers_len = #numbers\n\
    \tif numbers_len < 2 then\n\t\treturn\n\tend\n\t\n\tlocal n0, n1 = numbers[1],\
    \ numbers[2]\n\tlocal d_min = math.abs(n0 - n1)\n\tfor i = 1, #numbers do\n\t\t\
    local n0 = numbers[i]\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal n1 = numbers[j]\n\
    \t\t\tlocal d = math.abs(n0 - n1)\n\t\t\tif d < d_min then\n\t\t\t\td_min = d\n\
    \t\t\t\tn0, n1 = numbers[i], numbers[j]\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn\
    \ { math.min(n0, n1), math.max(n0, n1) }\nend", "    local smallest_distance =\
    \ math.huge\n    local closest_numbers = {0, 0}\n    for i = 1, #numbers do\n\
    \        for j = i + 1, #numbers do\n            local distance = math.abs(numbers[i]\
    \ - numbers[j])\n            if distance < smallest_distance then\n          \
    \      smallest_distance = distance\n                closest_numbers = {numbers[i],\
    \ numbers[j]}\n            end\n        end\n    end\n    return closest_numbers\n\
    end", "\tif #numbers < 2 then\n\t\treturn nil\n\tend\n\tlocal smallest_distance\
    \ = math.huge\n\tlocal closest_one = nil\n\tlocal closest_two = nil\n\tfor i,\
    \ x in ipairs(numbers) do\n\t\tfor j, y in ipairs(numbers) do\n\t\t\tif j > i\
    \ then\n\t\t\t\tlocal distance = math.abs(x - y)\n\t\t\t\tif distance < smallest_distance\
    \ then\n\t\t\t\t\tsmallest_distance = distance\n\t\t\t\t\tclosest_one = x\n\t\t\
    \t\t\tclosest_two = y\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn {closest_one,\
    \ closest_two}\nend", "\tlocal closest, distance = 1, math.huge\n\tfor i = 1,\
    \ #numbers do\n\t\tfor j = i+1, #numbers do\n\t\t\tlocal d = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif d < distance then\n\t\t\t\tclosest = {i, j}\n\t\t\t\t\
    distance = d\n\t\t\tend\n\t\tend\n\tend\n\treturn numbers[closest[1]], numbers[closest[2]]\n\
    end", "  local min_delta, min_a, min_b\n  for i, a in ipairs(numbers) do\n   \
    \ for j, b in ipairs(numbers) do\n      if i ~= j then\n        local delta =\
    \ math.abs(a - b)\n        if min_delta == nil or delta < min_delta then\n   \
    \       min_delta = delta\n          min_a = a\n          min_b = b\n        end\n\
    \      end\n    end\n  end\n  if min_a > min_b then\n    return {min_b, min_a}\n\
    \  else\n    return {min_a, min_b}\n  end\nend", "\tlocal min_num = math.huge\n\
    \tlocal min_num_pair = {}\n\tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers\
    \ do\n\t\t\tlocal tmp = math.abs(numbers[i] - numbers[j])\n\t\t\tif tmp < min_num\
    \ then\n\t\t\t\tmin_num = tmp\n\t\t\t\tmin_num_pair = {numbers[i], numbers[j]}\n\
    \t\t\t\ttable.sort(min_num_pair)\n\t\t\tend\n\t\tend\n\tend\n\treturn min_num_pair\n\
    end", '  local smallest_dist, smallest_a, smallest_b', "    assert(type(numbers)\
    \ == \"table\", \"requires a table of numbers\")\n    assert(#numbers >= 2, \"\
    requires a table of length at least two\")\n    for _, v in ipairs(numbers) do\n\
    \        assert(type(v) == \"number\", \"requires a table of numbers\")\n    end",
  "  assert(#numbers >= 2)\n  local minimum_delta = math.huge\n  local minimum_delta_elements\
    \ = { nil, nil }\n  local i = 1\n  while i <= #numbers do\n    local j = i + 1\n\
    \    while j <= #numbers do\n      local delta = math.abs(numbers[i] - numbers[j])\n\
    \      if delta < minimum_delta then\n        minimum_delta = delta\n        minimum_delta_elements\
    \ = {numbers[i], numbers[j]}\n      end\n      j = j + 1\n    end\n    i = i +\
    \ 1\n  end\n  return minimum_delta_elements\nend", "  local min_diff = math.huge\n\
    \  local min_diff_numbers = {}\n  for i, num1 in ipairs(numbers) do\n    for j,\
    \ num2 in ipairs(numbers) do\n      if i ~= j then\n        local diff = math.abs(num1\
    \ - num2)\n        if diff < min_diff then\n          min_diff = diff\n      \
    \    min_diff_numbers = {num1, num2}\n        end\n      end\n    end\n  end\n\
    \  return min_diff_numbers\nend", "    -- Your code here\nend", "  assert(#numbers\
    \ >= 2)\n  local smaller, bigger, diff = 0, 0, math.huge\n  for i = 1, #numbers\
    \ do\n    for j = i+1, #numbers do\n      local new_diff = math.abs(numbers[i]\
    \ - numbers[j])\n      if new_diff < diff then\n        diff = new_diff\n    \
    \    smaller = numbers[i]\n        bigger = numbers[j]\n      end\n    end\n \
    \ end\n  return {smaller, bigger}\nend", "    local smallest_difference = math.huge\n\
    \    local smallest_difference_numbers = {0, 0}\n    for i = 1, #numbers - 1 do\n\
    \        local difference = numbers[i + 1] - numbers[i]\n        if difference\
    \ < smallest_difference then\n            smallest_difference = difference\n \
    \           smallest_difference_numbers = {numbers[i], numbers[i + 1]}\n     \
    \   end\n    end\n    return smallest_difference_numbers\nend", "  assert(#numbers\
    \ >= 2)\n  local x, y = numbers[1], numbers[2]\n  local delta = math.abs(x - y)\n\
    \  for i = 1, #numbers - 1 do\n    local z = numbers[i + 1]\n    local new_delta\
    \ = math.abs(x - z)\n    if new_delta < delta then\n      y = z\n      delta =\
    \ new_delta\n    end\n  end\n  if x > y then\n    x, y = y, x\n  end\n  return\
    \ {x, y}\nend", "    table.sort(numbers)\n    local smaller, larger = numbers[1],\
    \ numbers[2]\n    local delta = larger - smaller\n    for i=2,#numbers-1 do\n\
    \        local smaller_delta = numbers[i+1] - numbers[i]\n        if smaller_delta\
    \ < delta then\n            smaller, larger = numbers[i], numbers[i+1]\n     \
    \       delta = smaller_delta\n        end\n    end\n    return {smaller, larger}\n\
    end", "    if #numbers < 2 then\n        return\n    end\n    local closest_distance\
    \ = math.huge\n    local element_1, element_2\n    for i = 1, #numbers do\n  \
    \      for j = i + 1, #numbers do\n            local distance = math.abs(numbers[i]\
    \ - numbers[j])\n            if distance < closest_distance then\n           \
    \     closest_distance = distance\n                element_1 = numbers[i]\n  \
    \              element_2 = numbers[j]\n            end\n        end\n    end\n\
    \    return {element_1, element_2}\nend", "    local result = {}\n    local smallest_difference\
    \ = math.huge\n    local first, second = numbers[1], numbers[2]\n    for i = 1,\
    \ #numbers do\n        for j = i + 1, #numbers do\n            local diff = math.abs(numbers[i]\
    \ - numbers[j])\n            if diff < smallest_difference then\n            \
    \    smallest_difference = diff\n                first, second = numbers[i], numbers[j]\n\
    \            end\n        end\n    end\n    table.insert(result, first)\n    table.insert(result,\
    \ second)\n    return result\nend", "  assert(#numbers >= 2)\n  local closest_distance\
    \ = math.huge\n  local smallest, largest\n  for i = 1, #numbers do\n    for j\
    \ = i + 1, #numbers do\n      local distance = math.abs(numbers[i] - numbers[j])\n\
    \      if distance < closest_distance then\n        closest_distance = distance\n\
    \        smallest = numbers[i]\n        largest = numbers[j]\n      end\n    end\n\
    \  end\n  if smallest > largest then\n    smallest, largest = largest, smallest\n\
    \  end\n  return smallest, largest\nend", "  assert(#numbers >= 2)\n  -- use first\
    \ number to set bounds\n  local smallest = numbers[1]\n  local largest = numbers[1]\n\
    \  -- get the closest elements in the list\n  for _, number in ipairs(numbers)\
    \ do\n    if number < smallest then\n      smallest = number\n    elseif number\
    \ > largest then\n      largest = number\n    end\n  end\n  -- find the closest\
    \ numbers\n  local closest_difference = math.huge\n  local closest_lower = nil\n\
    \  local closest_upper = nil\n  for i = 1, #numbers do\n    local number = numbers[i]\n\
    \    if number > smallest and number < largest then\n      local difference =\
    \ largest - number\n      if difference < closest_difference then\n        closest_difference\
    \ = difference\n        closest_lower = number\n        closest_upper = largest\n\
    \      end\n      difference = number - smallest\n      if difference < closest_difference\
    \ then\n        closest_difference = difference\n        closest_lower = smallest\n\
    \        closest_upper = number\n      end\n    end\n  end\n  return {closest_lower,\
    \ closest_upper}\nend", "    if (#numbers < 2) then\n        return nil\n    end\n\
    \    local lowest_difference = nil\n    local closest_pair = nil\n    for i =\
    \ 1, #numbers do\n        for j = 1, #numbers do\n            if (i ~= j) then\n\
    \                local difference = math.abs(numbers[i] - numbers[j])\n      \
    \          if (lowest_difference == nil or difference < lowest_difference) then\n\
    \                    closest_pair = {math.min(numbers[i], numbers[j]), math.max(numbers[i],\
    \ numbers[j])}\n                    lowest_difference = difference\n         \
    \       end\n            end\n        end\n    end\n    return closest_pair\n\
    end", "\tassert(#numbers >= 2, \"find_closest_elements: table of numbers must\
    \ be of length at least two\")\n\tlocal closest_value = math.huge\n\tlocal closest_index\
    \ = {1, 2}\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal\
    \ delta = math.abs(numbers[i] - numbers[j])\n\t\t\tif delta < closest_value then\n\
    \t\t\t\tclosest_value = delta\n\t\t\t\tclosest_index = {i, j}\n\t\t\tend\n\t\t\
    end\n\tend\n\t-- Note that we need to take into account that the same value may\
    \ exist in multiple places\n\t-- and return them all (because they are indeed\
    \ the closest)\n\tlocal return_table = {}\n\tfor i = 1, #numbers do\n\t\tif numbers[i]\
    \ == numbers[closest_index[1]] or numbers[i] == numbers[closest_index[2]] then\n\
    \t\t\ttable.insert(return_table, numbers[i])\n\t\tend\n\tend\n\ttable.sort(return_table)\n\
    \treturn return_table\nend", "    local min_num = 1/0  -- positive infinity.\n\
    \    local max_num = -1/0 -- negative infinity.\n    local closest = numbers[1]\n\
    \    local second_closest = numbers[2]\n    -- Loop over the numbers, find the\
    \ ones closest together.\n    for i = 1, #numbers do\n        local first = numbers[i]\n\
    \        for j = i + 1, #numbers do\n            local second = numbers[j]\n \
    \           local difference = math.abs(first - second)\n            if difference\
    \ < min_num then\n                min_num = difference\n                closest\
    \ = first\n                second_closest = second\n            end\n        end\n\
    \    end\n    -- Now we know which elements are closest, but we need to return\
    \ them in order.\n    if closest > second_closest then\n        local tmp = closest\n\
    \        closest = second_closest\n        second_closest = tmp\n    end\n   \
    \ return {closest, second_closest}\nend", "  local function aux(numbers, prev,\
    \ prev_index, closest, closest_index, closest_index2)\n    if prev_index > #numbers\
    \ then\n      return {numbers[closest_index], numbers[closest_index2]}\n    else\n\
    \      local current = numbers[prev_index]\n      local current_diff = math.abs(current\
    \ - prev)\n      if current_diff < closest then\n        return aux(numbers, current,\
    \ prev_index + 1, current_diff, prev_index, closest_index)\n      else\n     \
    \   return aux(numbers, current, prev_index + 1, closest, closest_index, closest_index2)\n\
    \      end\n    end\n  end\n  return aux(numbers, numbers[1], 2, math.huge, 1,\
    \ 2)\nend", "    -- The indicies of the elements that are currently the closest\n\
    \    local a, b = 1, 2\n    -- The current difference between them\n    local\
    \ diff = math.abs(numbers[b] - numbers[a])\n    for i = 2, #numbers do\n     \
    \   for j = i + 1, #numbers do\n            -- Find the difference between two\
    \ elements\n            local this_diff = math.abs(numbers[j] - numbers[i])\n\
    \            -- If it's less than the current 'smallest' difference then update\n\
    \            if this_diff < diff then\n                a, b = i, j\n         \
    \       diff = this_diff\n            end\n        end\n    end\n    -- Return\
    \ the numbers in order\n    if numbers[a] < numbers[b] then\n        return numbers[a],\
    \ numbers[b]\n    else\n        return numbers[b], numbers[a]\n    end\nend",
  "    assert(type(numbers) == \"table\", \"find_closest_elements: argument must be\
    \ a table\")\n    assert(#numbers >= 2, \"find_closest_elements: argument must\
    \ have at least two elements\")\n    local min_dist = math.huge\n    local min_pairs\
    \ = {}\n    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n \
    \           local d = numbers[j] - numbers[i]\n            if d < min_dist then\n\
    \                min_dist = d\n                min_pairs = {{numbers[i], numbers[j]}}\n\
    \            elseif d == min_dist then\n                table.insert(min_pairs,\
    \ {numbers[i], numbers[j]})\n            end\n        end\n    end\n    return\
    \ min_pairs[1]\nend", "\tlocal _,length= next(numbers)\n\tassert(length>=2,\"\
    Too few numbers to find closest pair.\")\n\tlocal difference = math.huge\n\tlocal\
    \ min_index = 1\n\tlocal max_index = 2\n\tfor i = 1,length do\n\t\tfor j = i+1,length\
    \ do\n\t\t\tlocal dif = numbers[j]-numbers[i]\n\t\t\tif dif < difference then\n\
    \t\t\t\tdifference = dif\n\t\t\t\tmin_index = i\n\t\t\t\tmax_index = j\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn numbers[min_index],numbers[max_index]\nend", " \
    \   -- Assert that the table of numbers has at least two elements.\n    assert(#numbers\
    \ >= 2, \"Not enough numbers given to find the closest two.\")", "  local smallest_difference\
    \ = math.huge\n  local closest_number_1 = numbers[1]\n  local closest_number_2\
    \ = numbers[2]\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n   \
    \   local difference = math.abs(numbers[i] - numbers[j])\n      if difference\
    \ < smallest_difference then\n        smallest_difference = difference\n     \
    \   closest_number_1 = numbers[i]\n        closest_number_2 = numbers[j]\n   \
    \   end\n    end\n  end\n  return {closest_number_1, closest_number_2}\nend",
  "\tif #numbers < 2 then\n\t\treturn nil\n\tend\n\ttable.sort(numbers)\n\tlocal min_diff\
    \ = math.abs(numbers[1] - numbers[2])\n\tlocal result = {numbers[1], numbers[2]}\n\
    \tfor i = 2, #numbers - 1 do\n\t\tlocal diff = math.abs(numbers[i] - numbers[i\
    \ + 1])\n\t\tif diff < min_diff then\n\t\t\tmin_diff = diff\n\t\t\tresult = {numbers[i],\
    \ numbers[i + 1]}\n\t\tend\n\tend\n\treturn result\nend", "\tlocal closest = {1e9,1e9}\n\
    \tlocal found\n\tfor i,v in ipairs(numbers) do\n\t\tfor j,w in ipairs(numbers)\
    \ do\n\t\t\tif i ~= j and math.abs(v-w) < math.abs(closest[1]-closest[2]) then\n\
    \t\t\t\tfound = true\n\t\t\t\tclosest = {v,w}\n\t\t\tend\n\t\tend\n\tend\n\tif\
    \ found then\n\t\treturn closest\n\telse\n\t\treturn {numbers[1],numbers[2]}\n\
    \tend\nend", "  local closest = math.huge\n  local closest_1 = 0\n  local closest_2\
    \ = 0\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n      local diff\
    \ = math.abs(numbers[i] - numbers[j])\n      if diff < closest then\n        closest\
    \ = diff\n        closest_1 = i\n        closest_2 = j\n      end\n    end\n \
    \ end\n  local closest_numbers = {numbers[closest_1], numbers[closest_2]}\n  table.sort(closest_numbers)\n\
    \  return closest_numbers\nend", "  local first, second = numbers[1], numbers[2]\n\
    \  local diff, cur_diff = math.abs(first - second), math.abs(first - second)\n\
    \  for i=1, #numbers do\n    for j=i+1, #numbers do\n      cur_diff = math.abs(numbers[i]\
    \ - numbers[j])\n      if cur_diff < diff then\n        first, second, diff =\
    \ numbers[i], numbers[j], cur_diff\n      end\n    end\n  end\n  return {first,\
    \ second}\nend", "\tlocal minimum_difference = math.huge\n\tlocal minimum_difference_indices\
    \ = {1, 2}\n\tfor i = 1, #numbers - 1 do\n\t\tlocal j = i + 1\n\t\tlocal difference\
    \ = numbers[j] - numbers[i]\n\t\tif difference < minimum_difference then\n\t\t\
    \tminimum_difference = difference\n\t\t\tminimum_difference_indices = {i, j}\n\
    \t\tend\n\tend\n\tlocal minimum_difference_elements = {}\n\tfor _, i in ipairs(minimum_difference_indices)\
    \ do\n\t\ttable.insert(minimum_difference_elements, numbers[i])\n\tend\n\treturn\
    \ minimum_difference_elements\nend", "\tif #numbers <= 1 then\n\t\treturn\n\t\
    end\n\t\n\tlocal min_difference = math.huge\n\tlocal min_i, min_j\n\tfor i = 1,\
    \ #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal difference = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif difference < min_difference then\n\t\t\t\tmin_difference\
    \ = difference\n\t\t\t\tmin_i = i\n\t\t\t\tmin_j = j\n\t\t\tend\n\t\tend\n\tend\n\
    \t\n\treturn numbers[min_i], numbers[min_j]\nend", "    local first_index = 1\n\
    \    local second_index = 2\n    local smallest_difference = numbers[second_index]\
    \ - numbers[first_index]\n    for index = 2, #numbers do\n        local test_difference\
    \ = numbers[index] - numbers[index - 1]\n        if test_difference < smallest_difference\
    \ then\n            smallest_difference = test_difference\n            first_index\
    \ = index - 1\n            second_index = index\n        end\n    end\n    return\
    \ { numbers[first_index], numbers[second_index] }\nend", "  assert(is_array(numbers),\
    \ \"Not an array of numbers\")\n  assert(#numbers >= 2, \"Not enough numbers in\
    \ array\")\n  local smallest_difference = math.huge\n  local closest_smaller_number,\
    \ closest_larger_number\n  for i = 1, #numbers do\n    local first_number = numbers[i]\n\
    \    for j = 1, #numbers do\n      local second_number = numbers[j]\n      if\
    \ first_number < second_number then\n        local difference = second_number\
    \ - first_number\n        if difference < smallest_difference then\n         \
    \ smallest_difference = difference\n          closest_smaller_number = first_number\n\
    \          closest_larger_number = second_number\n        end\n      end\n   \
    \ end\n  end\n  return {closest_smaller_number, closest_larger_number}\nend",
  "  assert(#numbers >= 2)\n  local closest = math.abs(numbers[1] - numbers[2])\n\
    \  local current\n  local smallest = 1\n  local larger = 2\n  for i = 2, #numbers\
    \ - 1 do\n    current = math.abs(numbers[i] - numbers[i + 1])\n    if current\
    \ < closest then\n      closest = current\n      smallest = i\n      larger =\
    \ i + 1\n    end\n  end\n  return {numbers[smallest], numbers[larger]}\nend",
  "    local result = {numbers[1], numbers[2]}\n    local difference = math.abs(numbers[1]\
    \ - numbers[2])\n    local i = 2\n    while i < #numbers do\n        local prev\
    \ = numbers[i]\n        local next = numbers[i + 1]\n        local new_difference\
    \ = math.abs(prev - next)\n        if new_difference < difference then\n     \
    \       result = {prev, next}\n            difference = new_difference\n     \
    \   end\n        i = i + 1\n    end\n    return result\nend", "  local min_delta\
    \ = math.huge\n  local a, b = numbers[1], numbers[2]\n  for i = 1, #numbers do\n\
    \    for j = i + 1, #numbers do\n      local delta = math.abs(numbers[i] - numbers[j])\n\
    \      if delta < min_delta then\n        min_delta = delta\n        a, b = numbers[i],\
    \ numbers[j]\n      end\n    end\n  end\n  return a < b and {a, b} or {b, a}\n\
    end", "\tassert(#numbers > 1, \"find_closest_elements: table of numbers must have\
    \ length at least two\")\n\tlocal closest_distance = math.huge\n\tlocal closest_elements\
    \ = { math.huge, math.huge }\n\tfor i,n in ipairs(numbers) do\n\t\tfor j,m in\
    \ ipairs(numbers) do\n\t\t\tif i ~= j then\n\t\t\t\tlocal distance = math.abs(n\
    \ - m)\n\t\t\t\tif distance < closest_distance then\n\t\t\t\t\tclosest_distance\
    \ = distance\n\t\t\t\t\tclosest_elements = { n, m }\n\t\t\t\tend\n\t\t\tend\n\t\
    \tend\n\tend\n\treturn closest_elements\nend", "\tlocal min_difference = math.huge\n\
    \tlocal current_min_one, current_min_two\n\tfor i = 1, #numbers - 1 do\n\t\tfor\
    \ j = i + 1, #numbers do\n\t\t\tlocal v = numbers[i]\n\t\t\tlocal w = numbers[j]\n\
    \t\t\tlocal diff = math.abs(v - w)\n\t\t\tif diff < min_difference then\n\t\t\t\
    \tmin_difference = diff\n\t\t\t\tcurrent_min_one = math.min(v, w)\n\t\t\t\tcurrent_min_two\
    \ = math.max(v, w)\n\t\t\tend\n\t\tend\n\tend\n\treturn {current_min_one, current_min_two}\n\
    end", "    -- First sort the list, then we can compare the adjacent numbers\n\
    \    local sorted_numbers = shallow_copy(numbers)\n    table.sort(sorted_numbers)",
  "  local min_diff = math.huge\n  local min_a, min_b = numbers[1], numbers[2]\n \
    \ for i = 1, #numbers do\n    for j = i + 1, #numbers do\n      local a, b = numbers[i],\
    \ numbers[j]\n      local diff = math.abs(a - b)\n      if diff < min_diff then\n\
    \        min_diff = diff\n        min_a, min_b = a, b\n      end\n    end\n  end\n\
    \  return min_a, min_b\nend", "    assert(type(numbers) == \"table\", \"input\
    \ must be a table\")\n    assert(#numbers >= 2, \"input must be a table of at\
    \ least length 2\")\n    local closest_difference = math.huge\n    local closest_elements\
    \ = {}\n    for i = 1, #numbers - 1 do\n        local difference = math.abs(numbers[i\
    \ + 1] - numbers[i])\n        if difference < closest_difference then\n      \
    \      closest_difference = difference\n            closest_elements = {numbers[i],\
    \ numbers[i + 1]}\n        end\n    end\n    return closest_elements\nend", " \
    \   assert(#numbers >= 2)\n    local closest = math.abs(numbers[1] - numbers[2])\n\
    \    local a, b = numbers[1], numbers[2]\n    for i = 1, #numbers do\n       \
    \ for j = i + 1, #numbers do\n            local d = math.abs(numbers[i] - numbers[j])\n\
    \            if d < closest then\n                closest = d\n              \
    \  a, b = numbers[i], numbers[j]\n            end\n        end\n    end\n    return\
    \ a, b\nend", "  assert(numbers ~= nil)\n  assert(#numbers >= 2)\n  -- Make a\
    \ shallow copy of the table to not alter the original\n  local sorted_numbers\
    \ = table.copy(numbers)\n  -- Sort the numbers in order so we can compare adjacent\
    \ elements\n  table.sort(sorted_numbers)\n  -- Now the elements are in order,\
    \ the first element will be the closest to the end element\n  local first = sorted_numbers[1]\n\
    \  local last = sorted_numbers[#sorted_numbers]\n  local min_difference = math.abs(first\
    \ - last)\n  local min_pair = {first, last}\n  for i=2,#sorted_numbers do\n  \
    \  local difference = math.abs(sorted_numbers[i] - sorted_numbers[i-1])\n    if\
    \ difference < min_difference then\n      min_difference = difference\n      min_pair\
    \ = {sorted_numbers[i-1], sorted_numbers[i]}\n    end\n  end\n  return min_pair\n\
    end", "    local closest_numbers = {numbers[1], numbers[2]}\n    local smallest_difference\
    \ = abs(numbers[1] - numbers[2])\n    for a = 1, #numbers - 1 do\n        for\
    \ b = a + 1, #numbers do\n            local difference = abs(numbers[a] - numbers[b])\n\
    \            if (difference < smallest_difference) then\n                smallest_difference\
    \ = difference\n                closest_numbers = {numbers[a], numbers[b]}\n \
    \           end\n        end\n    end\n    return closest_numbers\nend", "   \
    \ local min_index, min_index2, min_difference = 1, 1, math.huge\n    for i = 1,\
    \ #numbers do\n        for j = i + 1, #numbers do\n            local d = math.abs(numbers[i]\
    \ - numbers[j])\n            if d < min_difference then\n                min_index,\
    \ min_index2, min_difference = i, j, d\n            end\n        end\n    end\n\
    \    return numbers[min_index], numbers[min_index2]\nend", "    -- Check for a\
    \ valid input table, and that it has at least two elements\n    if type(numbers)\
    \ ~= \"table\" or #numbers < 2 then\n        -- Not valid input\n        return\
    \ false\n    end", "\tif #numbers < 2 then\n\t\treturn nil\n\tend\n\ttable.sort(numbers)\n\
    \tlocal closest_elements = {numbers[1], numbers[2]}\n\tlocal closest_distance\
    \ = math.abs(numbers[1] - numbers[2])\n\tfor i = 1, #numbers do\n\t\tfor j = i\
    \ + 1, #numbers do\n\t\t\tlocal distance = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif distance < closest_distance then\n\t\t\t\tclosest_elements = {numbers[i],\
    \ numbers[j]}\n\t\t\t\tclosest_distance = distance\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn closest_elements\nend", "    assert(#numbers >= 2)\n    local smallest_distance\
    \ = math.huge\n    local first, second\n    for i = 1, #numbers - 1 do\n     \
    \   for j = i + 1, #numbers do\n            local distance = math.abs(numbers[i]\
    \ - numbers[j])\n            if distance < smallest_distance then\n          \
    \      smallest_distance = distance\n                first, second = numbers[i],\
    \ numbers[j]\n            end\n        end\n    end\n    return first, second\n\
    end", "\tassert(type(numbers) == \"table\")\n\tassert(#numbers >= 2)\n\tlocal\
    \ result = {}\n\tlocal closest = math.huge\n\tlocal num1 = numbers[1]\n\tlocal\
    \ num2 = numbers[2]\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\
    \t\t\tlocal dist = math.abs(numbers[i] - numbers[j])\n\t\t\tif dist < closest\
    \ then\n\t\t\t\tclosest = dist\n\t\t\t\tnum1 = numbers[i]\n\t\t\t\tnum2 = numbers[j]\n\
    \t\t\tend\n\t\tend\n\tend\n\tif num1 > num2 then\n\t\tnum1, num2 = num2, num1\n\
    \tend\n\tresult[1] = num1\n\tresult[2] = num2\n\treturn result\nend", "    local\
    \ pair = {numbers[1], numbers[2]}\n    local distance = math.abs(numbers[1] -\
    \ numbers[2])\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n\
    \            local d = math.abs(numbers[i] - numbers[j])\n            if d < distance\
    \ then\n                distance = d\n                pair = {numbers[i], numbers[j]}\n\
    \            end\n        end\n    end\n    return pair\nend", "  local closest_elements\
    \ = {numbers[1], numbers[2]}\n  local closest_distance = math.abs(numbers[1] -\
    \ numbers[2])\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n    \
    \  local distance = math.abs(numbers[i] - numbers[j])\n      if distance < closest_distance\
    \ then\n        closest_distance = distance\n        closest_elements = {numbers[i],\
    \ numbers[j]}\n      end\n    end\n  end\n  return closest_elements\nend", " \
    \ local min_diff = math.huge\n  local min_pair\n  local first = numbers[1]\n \
    \ for i = 2, #numbers do\n    local second = numbers[i]\n    local diff = math.abs(first\
    \ - second)\n    if diff < min_diff then\n      min_diff = diff\n      min_pair\
    \ = {first, second}\n    end\n    first = second\n  end\n  return min_pair\nend",
  "  local _min = nil\n  local _max = nil\n  local min_distance = math.huge\n  local\
    \ previous_number = nil\n  for _, number in ipairs(numbers) do\n    if not previous_number\
    \ then\n      previous_number = number\n    else\n      local distance = number\
    \ - previous_number\n      if distance < min_distance then\n        min_distance\
    \ = distance\n        _min = previous_number\n        _max = number\n      end\n\
    \      previous_number = number\n    end\n  end\n  return {_min, _max}\nend",
  "\tlocal min = math.abs(numbers[1] - numbers[2])\n\tlocal min_elements = {numbers[1],\
    \ numbers[2]}\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\t\
    local n = math.abs(numbers[i] - numbers[j])\n\t\t\tif n < min then\n\t\t\t\tmin\
    \ = n\n\t\t\t\tmin_elements = {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn min_elements\nend", "\tlocal diff, closest = math.huge, {}\n\tfor\
    \ i = 1, #numbers do\n\t\tlocal j = (i % #numbers) + 1\n\t\tlocal d = math.abs(numbers[i]\
    \ - numbers[j])\n\t\tif d < diff then\n\t\t\tdiff, closest = d, { numbers[i],\
    \ numbers[j] }\n\t\tend\n\tend\n\treturn unpack(closest)\nend", "\tlocal min_dist\
    \ = numbers[2] - numbers[1]\n\tlocal ret = {numbers[1], numbers[2]}\n\tfor i =\
    \ 1, #numbers - 1 do\n\t\tlocal this_dist = numbers[i + 1] - numbers[i]\n\t\t\
    if this_dist < min_dist then\n\t\t\tmin_dist = this_dist\n\t\t\tret = {numbers[i],\
    \ numbers[i + 1]}\n\t\tend\n\tend\n\treturn ret\nend", "    local diff_min = math.huge\n\
    \    local i_min, j_min\n    for i = 1, #numbers - 1 do\n        for j = i + 1,\
    \ #numbers do\n            local diff = math.abs(numbers[i] - numbers[j])\n  \
    \          if diff < diff_min then\n                diff_min = diff\n        \
    \        i_min = i\n                j_min = j\n            end\n        end\n\
    \    end\n    return numbers[i_min], numbers[j_min]\nend", "  local min, min_pos\n\
    \  for i, number in ipairs(numbers) do\n    for j, other in ipairs(numbers) do\n\
    \      if j > i then\n        local diff = number - other\n        if (diff <\
    \ 0) then diff = -diff end\n        if not min or (diff < min) then\n        \
    \  min = diff\n          min_pos = {i, j}\n        end\n      end\n    end\n \
    \ end\n  if min_pos then\n    return {numbers[min_pos[1]], numbers[min_pos[2]]}\n\
    \  end\nend", "  -- Swap x and y (in place) if x > y.\n  local function swap_if_greater(x,\
    \ y)\n    if x > y then\n      x, y = y, x\n    end\n    return x, y\n  end",
  "\t-- We need at least two numbers to find the closest elements\n\tassert(#numbers\
    \ >= 2)", "    local l = #numbers\n    if l < 2 then\n        return false\n \
    \   end\n    local diff = numbers[2] - numbers[1]\n    local start = 1\n    local\
    \ stop = 2\n    for i = 2, l do\n        local new_diff = numbers[i] - numbers[i\
    \ - 1]\n        if new_diff < diff then\n            diff = new_diff\n       \
    \     start = i - 1\n            stop = i\n        end\n    end\n    return {numbers[start],\
    \ numbers[stop]}\nend", "    local min_diff = math.huge\n    local min_diff_element_1\
    \ = nil\n    local min_diff_element_2 = nil\n    local previous_number = nil\n\
    \    for _, number in ipairs(numbers) do\n        if previous_number ~= nil then\n\
    \            local diff = math.abs(number - previous_number)\n            if diff\
    \ < min_diff then\n                min_diff = diff\n                min_diff_element_1\
    \ = previous_number\n                min_diff_element_2 = number\n           \
    \ end\n        end\n        previous_number = number\n    end\n    return {min_diff_element_1,\
    \ min_diff_element_2}\nend", "  --[[\n  if #numbers < 2 then\n    error('Find\
    \ closest elements must be given at least two numbers.')\n  end\n  --]]\n  assert(#numbers\
    \ >= 2, 'Find closest elements must be given at least two numbers.')\n  local\
    \ min_distance = math.huge\n  local min_first = nil\n  local min_second = nil\n\
    \  for i = 1, #numbers do\n    local first = numbers[i]\n    for j = i + 1, #numbers\
    \ do\n      local second = numbers[j]\n      local distance = math.abs(first -\
    \ second)\n      if distance < min_distance then\n        min_distance = distance\n\
    \        min_first = first\n        min_second = second\n      end\n    end\n\
    \  end\n  if min_first < min_second then\n    return {min_first, min_second}\n\
    \  else\n    return {min_second, min_first}\n  end\nend", "  local index_min,\
    \ index_max, distance_min = 1, 2, math.abs(numbers[1] - numbers[2])\n  for i =\
    \ 1, #numbers do\n    for j = i + 1, #numbers do\n      local distance = math.abs(numbers[i]\
    \ - numbers[j])\n      if distance < distance_min then\n        index_min, index_max,\
    \ distance_min = i, j, distance\n      end\n    end\n  end\n  return numbers[index_min],\
    \ numbers[index_max]\nend", "    if #numbers < 2 then\n        return numbers\n\
    \    end\n    local smallest = numbers[1]\n    local largest = numbers[1]\n  \
    \  for i = 2, #numbers do\n        if numbers[i] < smallest then\n           \
    \ smallest = numbers[i]\n        elseif numbers[i] > largest then\n          \
    \  largest = numbers[i]\n        end\n    end\n    return {smallest, largest}\n\
    end", "    local best_smaller, best_larger = 0, 2^64  -- N.B. Numbers are strictly\
    \ positive\n    for k = 1, #numbers - 1 do\n        local smaller, larger = math.min(numbers[k],\
    \ numbers[k + 1]), math.max(numbers[k], numbers[k + 1])\n        if larger - smaller\
    \ < best_larger - best_smaller then\n            best_smaller, best_larger = smaller,\
    \ larger\n        end\n    end\n    return {best_smaller, best_larger}\nend",
  "\tlocal first = numbers[1]\n\tlocal second = numbers[2]\n\tlocal diff = math.abs(second\
    \ - first)\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal\
    \ d = math.abs(numbers[j] - numbers[i])\n\t\t\tif (d < diff) then\n\t\t\t\tfirst\
    \ = numbers[i]\n\t\t\t\tsecond = numbers[j]\n\t\t\t\tdiff = d\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn first, second\nend", "    -- The smallest and largest numbers\
    \ have the largest gap.\n    local smallest, largest = numbers[1], numbers[1]\n\
    \    for _,number in ipairs(numbers) do\n        if number < smallest then\n \
    \           smallest = number\n        elseif number > largest then\n        \
    \    largest = number\n        end\n    end\n    -- Override the largest and smallest\
    \ if the numbers themselves are closer.\n    for _,number in ipairs(numbers) do\n\
    \        if math.abs(number - smallest) < math.abs(largest - smallest) then\n\
    \            largest = number\n        elseif math.abs(number - largest) < math.abs(largest\
    \ - smallest) then\n            smallest = number\n        end\n    end\n    return\
    \ smallest, largest\nend", "  local min_dif = nil\n  local min_dif_index = nil\n\
    \  local i = 1\n  while i < #numbers do\n    local dif = math.abs(numbers[i+1]\
    \ - numbers[i])\n    if min_dif == nil or dif < min_dif then\n      min_dif =\
    \ dif\n      min_dif_index = i\n    end\n    i = i + 1\n  end\n  return {numbers[min_dif_index],\
    \ numbers[min_dif_index+1]}\nend", "\tlocal smallest_difference = math.huge\n\t\
    local closest_elements = {math.huge, math.huge}\n\tfor idx, number in ipairs(numbers)\
    \ do\n\t\tlocal next_number = numbers[idx + 1]\n\t\tif next_number then\n\t\t\t\
    local diff = math.abs(number - next_number)\n\t\t\tif diff < smallest_difference\
    \ then\n\t\t\t\tsmallest_difference = diff\n\t\t\t\tclosest_elements = {number,\
    \ next_number}\n\t\t\tend\n\t\tend\n\tend\n\treturn closest_elements\nend", " \
    \ local length = #numbers\n  local smallest_difference = math.huge\n  local c1,\
    \ c2\n  local previous_number = numbers[1]\n  for i = 2, length do\n    local\
    \ number = numbers[i]\n    local difference = math.abs(number - previous_number)\n\
    \    if difference < smallest_difference then\n      smallest_difference = difference\n\
    \      c1 = previous_number\n      c2 = number\n    end\n    previous_number =\
    \ number\n  end\n  return c1, c2\nend", "\tlocal min_distance = math.huge\n\t\
    local num1, num2\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\
    \t\tlocal dist = math.abs(numbers[i] - numbers[j])\n\t\t\tif dist < min_distance\
    \ then\n\t\t\t\tmin_distance = dist\n\t\t\t\tnum1 = numbers[i]\n\t\t\t\tnum2 =\
    \ numbers[j]\n\t\t\tend\n\t\tend\n\tend\n\treturn num1, num2\nend", "    local\
    \ min_diff = math.huge\n    local min_index = nil\n    local min_element = nil\n\
    \    for i, element in ipairs(numbers) do\n        local next_element = numbers[i\
    \ + 1]\n        if next_element then\n            local diff = math.abs(element\
    \ - next_element)\n            if diff < min_diff then\n                min_diff\
    \ = diff\n                min_index = i\n                min_element = element\n\
    \            end\n        end\n    end\n    return {min_element, numbers[min_index\
    \ + 1]}\nend", "    assert(numbers and #numbers >= 2, 'supplied list of numbers\
    \ should contain at least two numbers')\n    local smallest_difference = math.huge\n\
    \    local selected_elements = { numbers[1], numbers[2] }\n    for i = 1, #numbers\
    \ - 1 do\n        for j = i + 1, #numbers do\n            local difference = math.abs(numbers[i]\
    \ - numbers[j])\n            if difference < smallest_difference then\n      \
    \          smallest_difference = difference\n                selected_elements\
    \ = { numbers[i], numbers[j] }\n            end\n        end\n    end\n    table.sort(selected_elements)\n\
    \    return selected_elements\nend", "    local min_diff, min_smaller, min_larger\
    \ = math.huge, 0, 0\n    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers\
    \ do\n            local diff = math.abs(numbers[i] - numbers[j])\n           \
    \ if diff < min_diff then\n                min_diff, min_smaller, min_larger =\
    \ diff, numbers[i], numbers[j]\n            end\n        end\n    end\n    return\
    \ min_smaller, min_larger\nend", "    local smallest_difference = math.huge\n\
    \    local result = {numbers[1], numbers[2]}\n    for i = 1, #numbers - 1 do\n\
    \        local candidate = numbers[i + 1] - numbers[i]\n        if candidate <\
    \ smallest_difference then\n            smallest_difference = candidate\n    \
    \        result = {numbers[i], numbers[i + 1]}\n        end\n    end\n    return\
    \ result\nend", "  local smallest_diff = math.huge\n  local result_first = 0\n\
    \  local result_second = 0\n  for i = 1, #numbers do\n    for j = i+1, #numbers\
    \ do\n      local diff = math.abs(numbers[i] - numbers[j])\n      if diff < smallest_diff\
    \ then\n        smallest_diff = diff\n        result_first = numbers[i]\n    \
    \    result_second = numbers[j]\n      end\n    end\n  end\n  return {result_first,\
    \ result_second}\nend", "  if not numbers or #numbers == 0 then\n    error(\"\
    find_closest_elements() expects a non-empty table\")\n  end\n  local best_distance\
    \ = math.huge\n  local best_a, best_b\n  for i = 1, #numbers do\n    for j = i\
    \ + 1, #numbers do\n      local a, b = numbers[i], numbers[j]\n      local distance\
    \ = math.abs(a - b)\n      if distance < best_distance then\n        best_distance\
    \ = distance\n        best_a, best_b = a, b\n      end\n    end\n  end\n  if best_a\
    \ > best_b then\n    best_a, best_b = best_b, best_a\n  end\n  return best_a,\
    \ best_b\nend", "  local n = #numbers\n  assert(n >= 2, \"Less than two numbers\
    \ in array\")\n  local min_delta = numbers[2] - numbers[1]\n  local min_i, min_j\
    \ = 1, 2\n  for i = 1, n - 1 do\n    for j = i + 1, n do\n      local delta =\
    \ numbers[j] - numbers[i]\n      if delta < min_delta then\n        min_delta\
    \ = delta\n        min_i, min_j = i, j\n      end\n    end\n  end\n  return numbers[min_i],\
    \ numbers[min_j]\nend", "    assert(type(numbers) == \"table\")\n    assert(#numbers\
    \ >= 2)\n    local best_elements = {numbers[1], numbers[2]}\n    local best_distance\
    \ = math.abs(numbers[1] - numbers[2])\n    for i = 1, #numbers do\n        for\
    \ j = i + 1, #numbers do\n            local distance = math.abs(numbers[i] - numbers[j])\n\
    \            if distance < best_distance then\n                best_elements =\
    \ {numbers[i], numbers[j]}\n                best_distance = distance\n       \
    \     end\n        end\n    end\n    table.sort(best_elements)\n    return best_elements\n\
    end", "  if #numbers == 0 then\n    error(\"Table empty\")\n  end\n  if #numbers\
    \ == 1 then\n    error(\"Table with only one element\")\n  end\n  local closest_values\
    \ = {numbers[1], numbers[2]}\n  local closest_difference = math.abs(numbers[1]\
    \ - numbers[2])\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n  \
    \    local difference = math.abs(numbers[i] - numbers[j])\n      if difference\
    \ < closest_difference then\n        closest_values = {numbers[i], numbers[j]}\n\
    \        closest_difference = difference\n      end\n    end\n  end\n  return\
    \ closest_values\nend", "  assert(#numbers >= 2)\n  local closest_distance = math.huge\n\
    \  local closest_elements = {numbers[1], numbers[2]}\n  for i = 1, #numbers -\
    \ 1 do\n    for j = i + 1, #numbers do\n      local diff = math.abs(numbers[i]\
    \ - numbers[j])\n      if diff < closest_distance then\n        closest_distance\
    \ = diff\n        closest_elements = {numbers[i], numbers[j]}\n      end\n   \
    \ end\n  end\n  return closest_elements\nend", "  assert(#numbers >= 2)\n  local\
    \ first = nil\n  local second = nil\n  local closest_difference = nil\n  for i\
    \ = 1, #numbers do\n    for j = 1, #numbers do\n      if i ~= j then\n       \
    \ local a = numbers[i]\n        local b = numbers[j]\n        if first == nil\
    \ then\n          first = a\n          second = b\n          closest_difference\
    \ = math.abs(a - b)\n        else\n          local diff = math.abs(a - b)\n  \
    \        if diff < closest_difference then\n            first = a\n          \
    \  second = b\n            closest_difference = diff\n          end\n        end\n\
    \      end\n    end\n  end\n  return first, second\nend", "\tlocal diff = math.huge\n\
    \tlocal first = nil\n\tlocal second = nil\n\tfor i = 1, #numbers - 1 do\n\t\t\
    for j = i + 1, #numbers do\n\t\t\tlocal difference = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif difference < diff then\n\t\t\t\tdiff = difference\n\t\t\t\tfirst = numbers[i]\n\
    \t\t\t\tsecond = numbers[j]\n\t\t\tend\n\t\tend\n\tend\n\treturn first, second\n\
    end", "    local min_diff = math.huge\n    local a, b", "    assert(numbers ~=\
    \ nil, 'Numbers table must be supplied')\n    assert(#numbers >= 2, 'Numbers table\
    \ must contain at least two numbers')", "  local min_difference, min_number_1,\
    \ min_number_2 = math.huge, nil, nil\n  for i = 1, #numbers - 1 do\n    local\
    \ number_1, number_2 = numbers[i], numbers[i + 1]\n    local difference = math.abs(number_1\
    \ - number_2)\n    if difference < min_difference then\n      min_difference,\
    \ min_number_1, min_number_2 = difference, number_1, number_2\n    end\n  end\n\
    \  return min_number_1, min_number_2\nend", "    local smallest_difference = math.huge\n\
    \    local closest_elements = {0, 0}\n    local number_of_elements = #numbers\n\
    \    for i = 1, number_of_elements do\n        for j = i + 1, number_of_elements\
    \ do\n            local difference = math.abs(numbers[i] - numbers[j])\n     \
    \       if difference < smallest_difference then\n                smallest_difference\
    \ = difference\n                closest_elements = {numbers[i], numbers[j]}\n\
    \            end\n        end\n    end\n    return closest_elements\nend", " \
    \   local current_distance = math.huge\n    local closest_pair = {0, 0}\n    for\
    \ index, number in ipairs(numbers) do\n        local number_to_compare = numbers[index\
    \ + 1]\n        if number_to_compare then\n            local distance = math.abs(number\
    \ - number_to_compare)\n            if distance < current_distance then\n    \
    \            closest_pair = {number, number_to_compare}\n                current_distance\
    \ = distance\n            end\n        end\n    end\n    return closest_pair\n\
    end", "    local min = 0\n    local min_index = 0\n    local count = 0\n    local\
    \ closest_numbers = {}\n    local smallest_number = 0\n    local largest_number\
    \ = 0\n    local first_run = true\n    -- local diff = {}\n    -- todo: add check\
    \ for the size of the array (must be at least 2)\n    -- todo: add check for each\
    \ number in the array for being a number\n    for i, num in ipairs(numbers) do\n\
    \        if first_run then\n            min = math.abs(num - numbers[i + 1])\n\
    \            min_index = i\n            first_run = false\n        else\n    \
    \        if math.abs(num - numbers[i + 1]) < min then\n                min = math.abs(num\
    \ - numbers[i + 1])\n                min_index = i\n            end\n        end\n\
    \        --table.insert(diff, math.abs(num - numbers[i + 1]))\n    end\n    if\
    \ min_index > 0 then\n        smallest_number = numbers[min_index]\n        largest_number\
    \ = numbers[min_index + 1]\n    end\n    table.insert(closest_numbers, smallest_number)\n\
    \    table.insert(closest_numbers, largest_number)\n    return closest_numbers\n\
    end", "    assert(#numbers >= 2)\n    local smallest = math.abs(numbers[1] - numbers[2])\n\
    \    local result = {numbers[1], numbers[2]}\n    for i = 1, #numbers do\n   \
    \     for j = i + 1, #numbers do\n            local diff = math.abs(numbers[i]\
    \ - numbers[j])\n            if diff < smallest then\n                smallest\
    \ = diff\n                result = {numbers[i], numbers[j]}\n            end\n\
    \        end\n    end\n    return result\nend", "  local left, right = 1, #numbers\n\
    \  if (right <= 1) then return numbers end\n  local right_index, left_index =\
    \ right, left\n  for i=1,#numbers do\n    if (numbers[i] < numbers[left_index])\
    \ then\n      left_index = i\n    elseif (numbers[i] > numbers[right_index]) then\n\
    \      right_index = i\n    end\n  end\n  return { numbers[left_index], numbers[right_index]\
    \ }\nend", "  local minimum = nil\n  local best_pair = nil\n  for idx, n in ipairs(numbers)\
    \ do\n    local n_plus_one = numbers[idx + 1]\n    if n_plus_one then\n      local\
    \ dist = math.abs(n - n_plus_one)\n      if minimum == nil or dist < minimum then\n\
    \        minimum = dist\n        best_pair = {n, n_plus_one}\n      end\n    end\n\
    \  end\n  return best_pair\nend", "  local i = 1\n  local l = #numbers\n  local\
    \ smallest_diff = math.abs(numbers[1] - numbers[2])\n  local closest_elements\
    \ = { numbers[1], numbers[2] }\n  for i = 1, l do\n    for j = i + 1, l do\n \
    \     local diff = math.abs(numbers[i] - numbers[j])\n      if diff < smallest_diff\
    \ then\n        smallest_diff = diff\n        closest_elements = { numbers[i],\
    \ numbers[j] }\n      end\n    end\n  end\n  return closest_elements\nend", " \
    \ assert(#numbers >= 2, \"Need at least two numbers\")\n  local best_diff = math.huge\n\
    \  local best = { numbers[1], numbers[2] }\n  for i = 1, #numbers do\n    for\
    \ j = i + 1, #numbers do\n      local diff = math.abs(numbers[i] - numbers[j])\n\
    \      if diff < best_diff then\n        best_diff = diff\n        best = { numbers[i],\
    \ numbers[j] }\n      end\n    end\n  end\n  -- Sort best_pair\n  if best[1] >\
    \ best[2] then\n    best[1], best[2] = best[2], best[1]\n  end\n  return best\n\
    end", "    assert(numbers and #numbers >= 2, \"Two numbers are needed to find\
    \ the closest numbers\")\n    local min_distance = math.huge\n    local min_n1\
    \ = numbers[1]\n    local min_n2 = numbers[2]\n    for i, n1 in ipairs(numbers)\
    \ do\n        for j, n2 in ipairs(numbers) do\n            if i ~= j then\n  \
    \              local distance = math.abs(n1 - n2)\n                if distance\
    \ < min_distance then\n                    min_distance = distance\n         \
    \           min_n1 = n1\n                    min_n2 = n2\n                end\n\
    \            end\n        end\n    end\n    return {min_n1, min_n2}\nend", " \
    \ assert_type(numbers, \"table\")\n  assert(#numbers >= 2, \"Table must contain\
    \ at least two elements.\")\n  local small, large = numbers[1], numbers[2]\n \
    \ local distance = math.abs(small - large)\n  for i = 1, #numbers do\n    for\
    \ j = i + 1, #numbers do\n      local d = math.abs(numbers[i] - numbers[j])\n\
    \      if d < distance then\n        small, large = numbers[i], numbers[j]\n \
    \       distance = d\n      end\n    end\n  end\n  return small, large\nend",
  "    assert(is_array(numbers), \"find_closest_elements(numbers): numbers must be\
    \ a array.\")\n    assert(#numbers >= 2, \"find_closest_elements(numbers): numbers\
    \ must have at least two elements.\")", "    assert(type(numbers) == \"table\"\
    )\n    assert(#numbers >= 2)\n    local small, large = numbers[1], numbers[2]\n\
    \    local distance = large - small\n    for i = 2, #numbers - 1 do\n        for\
    \ j = i + 1, #numbers do\n            local current_distance = numbers[j] - numbers[i]\n\
    \            if current_distance < distance then\n                small, large\
    \ = numbers[i], numbers[j]\n                distance = current_distance\n    \
    \        end\n        end\n    end\n    return small, large\nend", "    local\
    \ result = {numbers[1], numbers[2]}\n    local distance = math.abs(numbers[1]\
    \ - numbers[2])\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n\
    \            local new_distance = math.abs(numbers[i] - numbers[j])\n        \
    \    if new_distance < distance then\n                distance = new_distance\n\
    \                result = {numbers[i], numbers[j]}\n            end\n        end\n\
    \    end\n    return result\nend", "    local current_dist, lowest_dist = math.huge,\
    \ math.huge\n    local pos_lowest_dist, current_pos_lowest_dist = nil, nil\n \
    \   local current_pos = 0\n    while current_pos < #numbers do\n        local\
    \ first_number = numbers[current_pos]\n        local search_pos = current_pos\
    \ + 1\n        while search_pos <= #numbers do\n            local dist = math.abs(first_number\
    \ - numbers[search_pos])\n            if dist < lowest_dist then\n           \
    \     lowest_dist = dist\n                pos_lowest_dist = {first_number, numbers[search_pos]}\n\
    \            end\n            search_pos = search_pos + 1\n        end\n     \
    \   current_pos = current_pos + 1\n    end\n    return pos_lowest_dist\nend",
  "    local smallest_diff = math.huge\n    local first, second = nil, nil\n    for\
    \ _,number in ipairs(numbers) do\n        for _,number2 in ipairs(numbers) do\n\
    \            if number ~= number2 then\n                local diff = math.abs(number-number2)\n\
    \                if diff < smallest_diff then\n                    smallest_diff\
    \ = diff\n                    first, second = number, number2\n              \
    \  end\n            end\n        end\n    end\n    return first, second\nend",
  "    assert(numbers and #numbers >= 2, \"Invalid input - needs at least two numbers\"\
    )\n    local min_diff = math.huge\n    local min_elem = {nil, nil}\n    local\
    \ len = #numbers\n    table.sort(numbers)\n    for i = 1, len - 1 do\n       \
    \ local d = numbers[i + 1] - numbers[i]\n        if d < min_diff then\n      \
    \      min_diff = d\n            min_elem = {numbers[i], numbers[i + 1]}\n   \
    \     end\n    end\n    return min_elem\nend", "\tlocal min_dist = math.huge\n\
    \tlocal min_pair\n\tfor i, first in ipairs(numbers) do\n\t\tfor j, second in ipairs(numbers)\
    \ do\n\t\t\tif i ~= j then\n\t\t\t\tlocal dist = math.abs(first - second)\n\t\t\
    \t\tif dist < min_dist then\n\t\t\t\t\tmin_dist = dist\n\t\t\t\t\tmin_pair = {first,\
    \ second}\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn min_pair\nend", " \
    \   local closest = nil\n    local a = nil\n    local b = nil\n    for i = 1,\
    \ #numbers do\n        for j = i + 1, #numbers do\n            local d = math.abs(numbers[i]\
    \ - numbers[j])\n            if closest == nil or d < closest then\n         \
    \       closest = d\n                a = numbers[i]\n                b = numbers[j]\n\
    \            end\n        end\n    end\n    return {math.min(a, b), math.max(a,\
    \ b)}\nend", "  if #numbers < 2 then\n    return {numbers[1], numbers[1]}\n  end\n\
    \  local current_difference = math.abs(numbers[1] - numbers[2])\n  local lowest_values\
    \ = {numbers[1], numbers[2]}\n  for i = 2, #numbers - 1 do\n    local difference\
    \ = math.abs(numbers[i] - numbers[i + 1])\n    if difference < current_difference\
    \ then\n      current_difference = difference\n      lowest_values = {numbers[i],\
    \ numbers[i + 1]}\n    end\n  end\n  if lowest_values[1] > lowest_values[2] then\n\
    \    lowest_values = {lowest_values[2], lowest_values[1]}\n  end\n  return lowest_values\n\
    end", "  local smallest_difference = math.huge\n  local smallest_difference_index\
    \ = -1\n  for i = 1, #numbers - 1 do\n    local difference = numbers[i + 1] -\
    \ numbers[i]\n    if difference < smallest_difference then\n      smallest_difference\
    \ = difference\n      smallest_difference_index = i\n    end\n  end\n  return\
    \ {numbers[smallest_difference_index], numbers[smallest_difference_index + 1]}\n\
    end", "    local size = #numbers\n    if size < 2 then\n        return nil\n \
    \   end\n    local diff = math.abs(numbers[1] - numbers[2])\n    local ids = {1,\
    \ 2}\n    for i = 1, size - 1 do\n        for j = i + 1, size do\n           \
    \ local cur_diff = math.abs(numbers[i] - numbers[j])\n            if cur_diff\
    \ < diff then\n                diff = cur_diff\n                ids = {i, j}\n\
    \            end\n        end\n    end\n    if numbers[ids[1]] < numbers[ids[2]]\
    \ then\n        return {numbers[ids[1]], numbers[ids[2]]}\n    else\n        return\
    \ {numbers[ids[2]], numbers[ids[1]]}\n    end\nend", "    assert(numbers[1], \"\
    You need to supply at least two numbers\")\n    assert(numbers[2], \"You need\
    \ to supply at least two numbers\")\n    local n1, n2 = numbers[1], numbers[2]\n\
    \    local diff = math.abs(n1 - n2)\n    for i = 1, #numbers do\n        for j\
    \ = i + 1, #numbers do\n            local new_diff = math.abs(numbers[i] - numbers[j])\n\
    \            if new_diff < diff then\n                n1, n2 = numbers[i], numbers[j]\n\
    \                diff = new_diff\n            end\n        end\n    end\n    return\
    \ {n1, n2}\nend", "    -- Ensure that the table is of size at least 2\n    if\
    \ #numbers < 2 then\n        error(\"Table of numbers is not of length 2 or more!\"\
    )\n    end", "    local min_distance = math.huge\n    local min_dist_elements\
    \ = {0, 0}\n    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n\
    \            local distance = math.abs(numbers[i] - numbers[j])\n            if\
    \ distance < min_distance then\n                min_distance = distance\n    \
    \            min_dist_elements = {numbers[i], numbers[j]}\n            end\n \
    \       end\n    end\n    return min_dist_elements\nend", "\tlocal smallest_separation\
    \ = math.huge\n\tlocal first_number, second_number\n\t\n\tfor i = 1, #numbers\
    \ do\n\t\tlocal first_number = numbers[i]\n\t\tfor j = i + 1, #numbers do\n\t\t\
    \tlocal second_number = numbers[j]\n\t\t\tlocal separation = second_number - first_number\n\
    \t\t\tif separation < smallest_separation then\n\t\t\t\tsmallest_separation =\
    \ separation\n\t\t\t\tfirst_number, second_number = first_number, second_number\n\
    \t\t\tend\n\t\tend\n\tend\n\t\n\treturn first_number, second_number\nend", "\t\
    local smallest_difference = math.huge\n\tlocal pair = {}\n\tlocal p1 = 0\n\tlocal\
    \ p2 = 0\n\tfor k, number in ipairs(numbers) do\n\t\tlocal diff = math.abs(number\
    \ - numbers[k + 1])\n\t\tif diff < smallest_difference then\n\t\t\tsmallest_difference\
    \ = diff\n\t\t\tp1 = number\n\t\t\tp2 = numbers[k + 1]\n\t\tend\n\tend\n\tpair[1]\
    \ = p1\n\tpair[2] = p2\n\treturn pair\nend", "    assert(#numbers >= 2)\n    local\
    \ min_diff = math.huge\n    local min_pos1, min_pos2\n    for i, v1 in ipairs(numbers)\
    \ do\n        for j, v2 in ipairs(numbers) do\n            if i ~= j then\n  \
    \              local diff = math.abs(v1 - v2)\n                if diff < min_diff\
    \ then\n                    min_diff = diff\n                    min_pos1 = i\n\
    \                    min_pos2 = j\n                end\n            end\n    \
    \    end\n    end\n    local ret = {numbers[min_pos1], numbers[min_pos2]}\n  \
    \  table.sort(ret)\n    return ret\nend", "  local ordered_numbers = {}\n  local\
    \ closest_elements = {}\n  local difference = math.huge\n  for i,n in ipairs(numbers)\
    \ do\n    ordered_numbers[i] = n\n  end\n  table.sort(ordered_numbers)\n  for\
    \ i,n in ipairs(ordered_numbers) do\n    if i ~= #ordered_numbers then\n     \
    \ local d = ordered_numbers[i+1] - n\n      if d < difference then\n        closest_elements\
    \ = {n, ordered_numbers[i+1]}\n        difference = d\n      end\n    end\n  end\n\
    \  return closest_elements\nend", "    local array = {}\n    local prev = nil\n\
    \    local min = math.huge\n    local a = nil\n    local b = nil\n    for _, v\
    \ in ipairs(numbers) do\n        if prev ~= nil then\n            local diff =\
    \ math.abs(v - prev)\n            if diff < min then\n                min = diff\n\
    \                a = prev\n                b = v\n            end\n        end\n\
    \        prev = v\n    end\n    return {a, b}\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
