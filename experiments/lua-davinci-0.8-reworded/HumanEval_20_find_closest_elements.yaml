name: HumanEval_20_find_closest_elements
language: lua
prompt: "-- From a supplied table of numbers (of length at least two) select and return\
  \ two that are the closest to each\n-- other and return them in order (smaller number,\
  \ larger number).\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n\
  -- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n--\
  \ {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_closest_elements\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), {3.9, 4.0})\n  \
  \  lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}), {5.0, 5.9})\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), {2.0, 2.2})\n    lu.assertEquals(candidate({1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0}), {2.0, 2.0})\n    lu.assertEquals(candidate({1.1, 2.2, 3.1,\
  \ 4.1, 5.1}), {2.2, 3.1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local smallest_distance, closest_elements = math.huge\n  local n\
    \ = #numbers\n  for i = 1, n - 1 do\n    for j = i + 1, n do\n      local distance\
    \ = numbers[j] - numbers[i]\n      if distance < smallest_distance then\n    \
    \    smallest_distance = distance\n        closest_elements = {numbers[i], numbers[j]}\n\
    \      end\n    end\n  end\n  return closest_elements\nend", "  local a = numbers[1]\n\
    \  local b = numbers[2]\n  local closest_distance = math.abs(a - b)\n  for i =\
    \ 1, #numbers do\n    for j = i + 1, #numbers do\n      local distance = math.abs(numbers[i]\
    \ - numbers[j])\n      if distance < closest_distance then\n        a = numbers[i]\n\
    \        b = numbers[j]\n        closest_distance = distance\n      end\n    end\n\
    \  end\n  if a > b then\n    return {b, a}\n  else\n    return {a, b}\n  end\n\
    end", "    assert(#numbers >= 2)\n    local closest, closest_diff = 1, math.huge\n\
    \    for i = 1, #numbers do\n        local diff = numbers[i] - numbers[i % #numbers\
    \ + 1]\n        if diff < closest_diff then\n            closest_diff = diff\n\
    \            closest = i\n        end\n    end\n    return numbers[closest], numbers[closest\
    \ % #numbers + 1]\nend", "    -- TODO: add comments and docstring\n    -- TODO:\
    \ implement this function\n    -- Hint: You don't need to do anything special\
    \ here for the case where there are duplicates,\n    --       because this is\
    \ handled by the next function\n    if (#numbers<2) then \n        return nil\n\
    \    end\n    local gap=9999\n    local i=1\n    local j=2\n    local m=0\n  \
    \  local n=0\n    while (i<=#numbers) do\n        j=i+1\n        while (j<=#numbers)\
    \ do\n            if math.abs(numbers[i]-numbers[j])<gap then\n              \
    \  gap=math.abs(numbers[i]-numbers[j])\n                m=i\n                n=j\n\
    \            end\n            j=j+1\n        end\n        i=i+1\n    end\n   \
    \ return {numbers[m],numbers[n]}\nend", "  local min_distance = math.huge\n  local\
    \ number_1, number_2\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n\
    \      local distance = math.abs(numbers[i] - numbers[j])\n      if distance <\
    \ min_distance then\n        min_distance = distance\n        number_1 = numbers[i]\n\
    \        number_2 = numbers[j]\n      end\n    end\n  end\n  return {number_1,\
    \ number_2}\nend", "\tif #numbers < 2 then\n\t\terror(\"Parameter must be at least\
    \ two elements\", 2)\n\tend\n\tlocal closest_pair = {numbers[1], numbers[2]}\n\
    \tlocal closest_distance = math.abs(numbers[1] - numbers[2])\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif distance < closest_distance then\n\t\t\t\tclosest_distance\
    \ = distance\n\t\t\t\tclosest_pair = {numbers[i], numbers[j]}\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn closest_pair\nend", "    local min_gap = nil\n    local closest_pair\
    \ = nil\n    for i, value in ipairs(numbers) do\n        for j, other_value in\
    \ ipairs(numbers) do\n            if i ~= j then\n                local gap =\
    \ math.abs(value - other_value)\n                if min_gap == nil or gap < min_gap\
    \ then\n                    min_gap = gap\n                    closest_pair =\
    \ {value, other_value}\n                end\n            end\n        end\n  \
    \  end\n    return closest_pair\nend", "    assert(#numbers >= 2)\n    local diff\
    \ = math.abs(numbers[1] - numbers[2])\n    local ret = {numbers[1], numbers[2]}\n\
    \    for i = 1, #numbers - 1 do\n        local d = math.abs(numbers[i] - numbers[i\
    \ + 1])\n        if d < diff then\n            diff = d\n            ret = {numbers[i],\
    \ numbers[i + 1]}\n        end\n    end\n    return ret\nend", "  local smallest_distance\
    \ = math.huge -- first guess at the smallest_distance\n  local best_x = nil\n\
    \  local best_y = nil\n  for i, x in ipairs(numbers) do\n    for j, y in ipairs(numbers)\
    \ do\n      if i ~= j then\n        local distance = math.abs(x - y)\n       \
    \ if distance < smallest_distance then\n          smallest_distance = distance\n\
    \          best_x = x\n          best_y = y\n        end\n      end\n    end\n\
    \  end\n  if best_x > best_y then\n    return {best_y, best_x}\n  else\n    return\
    \ {best_x, best_y}\n  end\nend", "\tlocal n = #numbers\n\tassert(n >= 2, \"need\
    \ at least two numbers\")\n\tlocal closest_pair = {numbers[1], numbers[2]}\n\t\
    local closest_distance = math.abs(numbers[1] - numbers[2])\n\tfor i = 1, n - 1\
    \ do\n\t\tfor j = i + 1, n do\n\t\t\tlocal candidate_distance = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif candidate_distance < closest_distance then\n\t\t\t\t\
    closest_distance = candidate_distance\n\t\t\t\tclosest_pair = {numbers[i], numbers[j]}\n\
    \t\t\tend\n\t\tend\n\tend\n\ttable.sort(closest_pair)\n\treturn closest_pair\n\
    end", "  local numbers = assert(numbers, \"no numbers supplied\")\n  assert(#numbers\
    \ >= 2, \"not enough numbers\")\n  local result = { numbers[1], numbers[2] }\n\
    \  local min_distance = math.abs(numbers[1] - numbers[2])\n  for i=1,#numbers-1\
    \ do\n    for j=i+1,#numbers do\n      local distance = math.abs(numbers[i] -\
    \ numbers[j])\n      if distance < min_distance then\n        min_distance = distance\n\
    \        result = { numbers[i], numbers[j] }\n      end\n    end\n  end\n  return\
    \ result\nend", "    assert(#numbers >= 2)\n    local closest = {numbers[1], numbers[2]}\n\
    \    local min_distance = math.abs(numbers[1] - numbers[2])\n    for i = 1, #numbers\
    \ - 1 do\n        for j = i + 1, #numbers do\n            local distance = math.abs(numbers[i]\
    \ - numbers[j])\n            if distance < min_distance then\n               \
    \ min_distance = distance\n                closest = {numbers[i], numbers[j]}\n\
    \            end\n        end\n    end\n    return closest\nend", "\tlocal smallest_distance,\
    \ index_of_a, index_of_b = math.huge, nil, nil\n\tfor i = 1, #numbers - 1 do\n\
    \t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif distance < smallest_distance then\n\t\t\t\tsmallest_distance = distance\n\
    \t\t\t\tindex_of_a, index_of_b = i, j\n\t\t\tend\n\t\tend\n\tend\n\treturn numbers[index_of_a],\
    \ numbers[index_of_b]\nend", "    local min_distance = math.huge\n    local closest_elements\
    \ = {}\n    for i, first_number in ipairs(numbers) do\n        for j, second_number\
    \ in ipairs(numbers) do\n            if i ~= j then\n                local distance\
    \ = math.abs(first_number - second_number)\n                if distance < min_distance\
    \ then\n                    min_distance = distance\n                    closest_elements\
    \ = {first_number, second_number}\n                end\n            end\n    \
    \    end\n    end\n    return closest_elements\nend", "\tlocal min = math.huge\n\
    \tlocal a = numbers[1]\n\tlocal b = numbers[2]\n\tfor i = 1, #numbers do\n\t\t\
    for j = i + 1, #numbers do\n\t\t\tlocal x = numbers[i]\n\t\t\tlocal y = numbers[j]\n\
    \t\t\tlocal diff = math.abs(x - y)\n\t\t\tif diff < min then\n\t\t\t\tmin = diff\n\
    \t\t\t\ta = x\n\t\t\t\tb = y\n\t\t\tend\n\t\tend\n\tend\n\treturn a, b\nend",
  "  local small, large = numbers[1], numbers[2]\n  local small_index, large_index\
    \ = 1, 2\n  local best_distance = math.abs(large - small)\n  for i = 2, #numbers\
    \ do\n    local x, y = numbers[i], numbers[i + 1]\n    if y == nil then break\
    \ end\n    local distance = math.abs(y - x)\n    if distance < best_distance then\n\
    \      small, large = x, y\n      small_index, large_index = i, i + 1\n      best_distance\
    \ = distance\n    end\n  end\n  return small, large, small_index, large_index\n\
    end", "\ttable.sort(numbers)\n\tlocal closest_difference = math.huge\n\tlocal\
    \ smallest_number = numbers[1]\n\tlocal biggest_number = numbers[1]\n\tfor i =\
    \ 2, #numbers do\n\t\tlocal this_difference = numbers[i] - numbers[i - 1]\n\t\t\
    if this_difference < closest_difference then\n\t\t\tclosest_difference = this_difference\n\
    \t\t\tsmallest_number = numbers[i - 1]\n\t\t\tbiggest_number = numbers[i]\n\t\t\
    end\n\tend\n\treturn smallest_number, biggest_number\nend", "    local closest_elements\
    \ = {numbers[1], numbers[2]}\n    local difference = math.abs(numbers[1] - numbers[2])\n\
    \    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n        \
    \    local diff = math.abs(numbers[i] - numbers[j])\n            if diff < difference\
    \ then\n                closest_elements = {numbers[i], numbers[j]}\n        \
    \        difference = diff\n            end\n        end\n    end\n    return\
    \ closest_elements\nend", "\tlocal closest_dist = math.huge\n\tlocal closest_pair\
    \ = { math.huge, math.huge }\n\tlocal numbers_size = #numbers\n\tfor i = 1, numbers_size\
    \ - 1 do\n\t\tfor j = i + 1, numbers_size do\n\t\t\tlocal diff = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif diff < closest_dist then\n\t\t\t\tclosest_dist = diff\n\
    \t\t\t\tclosest_pair = { numbers[i], numbers[j] }\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn closest_pair\nend", "    local smallest_difference = math.huge\n    local\
    \ closest_pair = {nil, nil}\n    local number_count = #numbers\n    for i = 1,\
    \ number_count do\n        local number = numbers[i]\n        local j = i + 1\n\
    \        while j <= number_count do\n            local number2 = numbers[j]\n\
    \            local difference = math.abs(number - number2)\n            if difference\
    \ < smallest_difference then\n                smallest_difference = difference\n\
    \                closest_pair = {number, number2}\n            end\n         \
    \   j = j + 1\n        end\n    end\n    return closest_pair\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
