name: HumanEval_79_decimal_to_binary
language: lua
prompt: "-- You will be given a number in decimal form and your task is to convert\
  \ it to\n-- binary format. The function should return a string, with each character\
  \ representing a binary\n-- number. Each character in the string will be '0' or\
  \ '1'.\n-- There will be an extra couple of characters 'db' at the beginning and\
  \ at the end of the string.\n-- The extra characters are there to help with the\
  \ format.\n-- Examples:\n-- >>> decimal_to_binary(15)\n-- 'db1111db'\n-- >>> decimal_to_binary(32)\n\
  -- 'db100000db'\nlocal function decimal_to_binary(decimal)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = decimal_to_binary\n\
  \    lu.assertEquals(candidate(0), 'db0db')\n    lu.assertEquals(candidate(32),\
  \ 'db100000db')\n    lu.assertEquals(candidate(103), 'db1100111db')\n    lu.assertEquals(candidate(15),\
  \ 'db1111db')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return \"db\" .. decToBin(decimal) .. \"db\"\nend", "\tlocal result\
    \ = \"db\"\n\tlocal quotient = decimal\n\tlocal remainder = 0\n\twhile quotient\
    \ ~= 0 do\n\t\tremainder = quotient % 2\n\t\tquotient = math.floor(quotient /\
    \ 2)\n\t\tresult = string.format(\"%d%s\", remainder, result)\n\tend\n\tresult\
    \ = result .. \"db\"\n\treturn result\nend", "    local binary = ''\n    while\
    \ decimal > 0 do\n        local remainder = decimal % 2\n        binary = binary\
    \ .. remainder\n        decimal = (decimal - remainder) / 2\n    end\n    binary\
    \ = 'db' .. binary .. 'db'\n    return binary\nend", "    -- Use the metatable\
    \ to convert the number to a string in binary format\n    local binary = {}\n\
    \    binary.__tostring = function(self)\n        local str = ''\n        for i\
    \ = 1, #self do\n            str = str .. self[i]\n        end\n        return\
    \ str\n    end\n    -- Get the list of bits by looping through the number of bits\n\
    \    local num_bits = math.ceil(math.log(decimal) / math.log(2))\n    for i =\
    \ num_bits, 1, -1 do\n        local num = math.pow(2, i - 1)\n        if decimal\
    \ >= num then\n            table.insert(binary, '1')\n            decimal = decimal\
    \ - num\n        else\n            table.insert(binary, '0')\n        end\n  \
    \  end\n    -- Return the string\n    return ('db%sdb'):format(binary)\nend",
  "  local binary = ''\n  while decimal > 0 do\n    local remainder = decimal % 2\n\
    \    binary = binary .. tostring(remainder)\n    decimal = math.floor(decimal\
    \ / 2)\n  end\n  return string.reverse('db' .. binary .. 'db')\nend", "    local\
    \ binary_string = \"db\"\n    if decimal == 0 then\n        binary_string = binary_string\
    \ .. \"0\"\n    else\n        while decimal > 0 do\n            binary_string\
    \ = binary_string .. math.floor(decimal % 2)\n            decimal = math.floor(decimal\
    \ / 2)\n        end\n    end\n    binary_string = binary_string .. \"db\"\n  \
    \  binary_string = string.reverse(binary_string)\n    return binary_string\nend",
  "    local result = ''\n    local remainder\n    repeat\n        remainder = decimal\
    \ % 2\n        decimal = math.floor(decimal / 2)\n        result = remainder ..\
    \ result\n    until decimal == 0\n    return 'db' .. result .. 'db'\nend", " \
    \ local bit_string = \"\"\n  for i = math.floor(math.log(decimal, 2)), 0, -1 do\n\
    \    if decimal >= 2^i then\n      bit_string = bit_string .. \"1\"\n      decimal\
    \ = decimal - 2^i\n    else\n      bit_string = bit_string .. \"0\"\n    end\n\
    \  end\n  return \"db\" .. bit_string .. \"db\"\nend", "    return string.format(\"\
    db%bdb\", decimal)\nend", "  local binary = ''\n  if decimal == 0 then return\
    \ 'db0db' end\n  while decimal > 0 do\n    local remainder = decimal % 2\n   \
    \ binary = (remainder == 0 and '0' or '1') .. binary\n    decimal = (decimal -\
    \ remainder) / 2\n  end\n  return 'db' .. binary .. 'db'\nend", "\t-- Implement\
    \ your function here\n\treturn \"\"\nend", "  local bits = {}\n  local number\
    \ = math.floor(decimal)\n  local binary = ''\n  local function get_binary(number)\n\
    \    local i = 1\n    while number > 0 do\n      bits[i] = number % 2\n      number\
    \ = math.floor(number / 2)\n      i = i + 1\n    end\n  end\n  get_binary(number)\n\
    \  for j = 1, #bits do\n    binary = binary .. tostring(bits[j])\n  end\n  return\
    \ 'db' .. binary .. 'db'\nend", "   local number = \"db\"\n   while decimal >\
    \ 0 do\n      local rest = decimal % 2\n      number = number .. tostring(rest)\n\
    \      decimal = (decimal - rest) / 2\n   end\n   number = number .. \"db\"\n\
    \   return number\nend", "\tlocal result = 'db'\n\twhile decimal > 0 do\n\t\t\
    result = result .. (decimal % 2)\n\t\tdecimal = math.floor(decimal / 2)\n\tend\n\
    \treturn result .. 'db'\nend", "    return (\"db%sdb\"):format(decimal:gsub(\"\
    .\", {[\"0\"] = \"0000\", [\"1\"] = \"0001\", [\"2\"] = \"0010\", [\"3\"] = \"\
    0011\", [\"4\"] = \"0100\", [\"5\"] = \"0101\", [\"6\"] = \"0110\", [\"7\"] =\
    \ \"0111\", [\"8\"] = \"1000\", [\"9\"] = \"1001\"}))\nend", "    return 'db'\
    \ .. decimal:reverse():gsub('%d',\n        function(d)\n            return d:byte()\
    \ - 48\n        end):gsub('%d',\n        function(d)\n            return string.char(d\
    \ + 48)\n        end):reverse() .. 'db'\nend", "  local decimal_to_binary_map\
    \ = {\n    [0]  = '0',\n    [1]  = '1',\n    [2]  = '10',\n    [3]  = '11',\n\
    \    [4]  = '100',\n    [5]  = '101',\n    [6]  = '110',\n    [7]  = '111',\n\
    \    [8]  = '1000',\n    [9]  = '1001',\n    [10] = '1010',\n    [11] = '1011',\n\
    \    [12] = '1100',\n    [13] = '1101',\n    [14] = '1110',\n    [15] = '1111',\n\
    \    [16] = '10000',\n    [17] = '10001',\n    [18] = '10010',\n    [19] = '10011',\n\
    \    [20] = '10100',\n    [21] = '10101',\n    [22] = '10110',\n    [23] = '10111',\n\
    \    [24] = '11000',\n    [25] = '11001',\n    [26] = '11010',\n    [27] = '11011',\n\
    \    [28] = '11100',\n    [29] = '11101',\n    [30] = '11110',\n    [31] = '11111',\n\
    \    [32] = '100000',\n    [33] = '100001',\n    [34] = '100010',\n    [35] =\
    \ '100011',\n    [36] = '100100',\n    [37] = '100101',\n    [38] = '100110',\n\
    \    [39] = '100111',\n    [40] = '101000',\n    [41] = '101001',\n    [42] =\
    \ '101010',\n    [43] = '101011',\n    [44] = '101100',\n    [45] = '101101',\n\
    \    [46] = '101110',\n    [47] = '101111',\n    [48] = '110000',\n    [49] =\
    \ '110001',\n    [", "\treturn 'db' .. string.format('%X', decimal) .. 'db'\n\
    end", "\tlocal bin = \"\"\n\tlocal mask = 0x80\n\t\n\t-- check for negative values\n\
    \tif (decimal < 0) then\n\t\tdecimal = decimal + 256\n\tend\n\t\n\tfor i = 1,\
    \ 8 do\n\t\tif (bit32.band(decimal, mask) == 0) then\n\t\t\tbin = bin .. \"0\"\
    \n\t\telse\n\t\t\tbin = bin .. \"1\"\n\t\tend\n\t\tmask = bit32.rshift(mask, 1)\n\
    \tend\n\t\n\treturn \"db\" .. bin .. \"db\"\nend", "  return 'db' .. toBinaryString(decimal)\
    \ .. 'db'\nend", "    local binary = \"db\"\n    while decimal > 0 do\n      \
    \  binary = binary .. tostring(decimal % 2)\n        decimal = math.floor(decimal\
    \ / 2)\n    end\n    binary = binary .. \"db\"\n    binary = string.reverse(binary)\n\
    \    return binary\nend", "\tlocal result = \"db\"\n\tlocal val = decimal\n\t\
    local bits = 0\n\twhile val > 0 do\n\t\tval = math.floor(val / 2)\n\t\tbits =\
    \ bits + 1\n\tend\n\twhile bits > 0 do\n\t\tif decimal % 2 == 0 then\n\t\t\tresult\
    \ = result .. \"0\"\n\t\telse\n\t\t\tresult = result .. \"1\"\n\t\tend\n\t\tdecimal\
    \ = math.floor(decimal / 2)\n\t\tbits = bits - 1\n\tend\n\tresult = result ..\
    \ \"db\"\n\treturn result\nend", "    local rest, binary = {}, ''\n    while decimal\
    \ > 0 do\n        rest[#rest + 1] = decimal % 2\n        decimal = math.floor(decimal\
    \ / 2)\n    end\n    while #rest > 0 do\n        binary = binary .. rest[#rest]\n\
    \        rest[#rest] = nil\n    end\n    return 'db' .. binary .. 'db'\nend",
  "  local binary_numbers = {'0', '1'}\n  local binary_string = 'db'\n  while decimal\
    \ > 0 do\n    local number = math.floor(decimal % 2)\n    binary_string = binary_numbers[number\
    \ + 1] .. binary_string\n    decimal = math.floor(decimal / 2)\n  end\n  return\
    \ binary_string .. 'db'\nend", "    local s = ''\n    while decimal ~= 0 do\n\
    \        local r = math.fmod(decimal, 2)\n        s = r .. s\n        decimal\
    \ = math.floor(decimal / 2)\n    end\n    return 'db' .. s .. 'db'\nend", "  local\
    \ binary = ''\n  local remainder\n  local done = false\n  while not done do\n\
    \    remainder = decimal % 2\n    decimal = (decimal - remainder) / 2\n    binary\
    \ = tostring(remainder) .. binary\n    if decimal == 0 then\n      done = true\n\
    \    end\n  end\n  binary = 'db' .. binary .. 'db'\n  return binary\nend", " \
    \   if decimal == 0 then\n        return 'db0db'\n    end\n    local bin = ''\n\
    \    while decimal > 0 do\n        local b = decimal % 2\n        decimal = (decimal\
    \ - b) / 2\n        bin = string.format('%s%d', bin, b)\n    end\n    return string.format('db%sdb',\
    \ bin)\nend", "  local remainder, binary, i = 0, \"\", 0\n  while decimal ~= 0\
    \ do\n    remainder = decimal % 2\n    decimal = (decimal - remainder) / 2\n \
    \   binary = tostring(remainder) .. binary\n  end\n  if #binary < 8 then\n   \
    \ binary = string.rep(\"0\", 8 - #binary) .. binary\n  end\n  return \"db\" ..\
    \ binary .. \"db\"\nend", "\tlocal neg = false\n\tif decimal < 0 then\n\t\tneg\
    \ = true\n\t\tdecimal = -decimal\n\tend\n\tlocal binary = 'db'\n\tlocal divisor\
    \ = 1\n\tlocal bit = 0\n\twhile math.floor(decimal/divisor) > 0 do\n\t\tbit =\
    \ math.floor(decimal/divisor)%2\n\t\tif bit > 0 then\n\t\t\tbinary = binary..'1'\n\
    \t\telse\n\t\t\tbinary = binary..'0'\n\t\tend\n\t\tdivisor = divisor*2\n\tend\n\
    \tif neg then\n\t\tbinary = binary..'1'\n\telse\n\t\tbinary = binary..'0'\n\t\
    end\n\tbinary = binary..'db'\n\treturn binary\nend", "\tlocal result = \"\"\n\t\
    local function helper(decimal)\n\t\tif decimal == 0 then\n\t\t\treturn nil\n\t\
    \telse\n\t\t\tlocal char = (decimal % 2) == 0 and \"0\" or \"1\"\n\t\t\tresult\
    \ = char .. result\n\t\t\treturn helper(math.floor(decimal / 2))\n\t\tend\n\t\
    end\n\thelper(decimal)\n\treturn \"db\" .. result .. \"db\"\nend", "    local\
    \ binary = 'db'\n    repeat\n        if decimal % 2 == 0 then\n            binary\
    \ = '0' .. binary\n        else\n            binary = '1' .. binary\n        end\n\
    \        decimal = math.floor(decimal / 2)\n    until decimal == 0\n    return\
    \ binary .. 'db'\nend", "   local binary = ''\n   local current = decimal\n  \
    \ while true do\n      binary = string.format('%s%s', current % 2, binary)\n \
    \     current = math.floor(current / 2)\n      if current <= 0 then\n        \
    \ break\n      end\n   end\n   return string.format('db%sdb', binary)\nend", " \
    \   local bin_str = \"db\"\n    repeat\n        local new_digit = decimal % 2\n\
    \        bin_str = new_digit .. bin_str\n        decimal = math.floor(decimal\
    \ / 2)\n    until decimal == 0\n    return bin_str .. \"db\"\nend", "\tdecimal\
    \ = tostring(decimal)\n\tif (decimal == \"0\") then\n\t\treturn \"db0db\"\n\t\
    end\n\tlocal number = \"\"\n\twhile(decimal > 0) do\n\t\tif (decimal % 2 == 0)\
    \ then\n\t\t\tnumber = \"0\" .. number\n\t\telse\n\t\t\tnumber = \"1\" .. number\n\
    \t\tend\n\t\tdecimal = math.floor(decimal / 2)\n\tend\n\treturn \"db\" .. number\
    \ .. \"db\"\nend", "    local dec = decimal\n    local lst_num = \"\"\n    local\
    \ bin = \"\"\n    while (dec > 0) do\n        lst_num = dec % 2\n        dec =\
    \ math.floor(dec / 2)\n        bin = tostring(lst_num) .. bin\n    end\n    return\
    \ 'db' .. bin .. 'db'\nend", "\tlocal value = \"db\"\n\tlocal reminder = decimal\n\
    \t\n\trepeat\n\t\tif reminder % 2 == 0 then\n\t\t\tvalue = value .. \"0\"\n\t\t\
    else\n\t\t\tvalue = value .. \"1\"\n\t\tend\n\t\treminder = math.floor(reminder\
    \ / 2)\n\tuntil reminder == 0\n\t\n\treturn value .. \"db\"\nend", "    -- [your\
    \ code here]\nend", "  local bin = 'db'\n  local rem\n  while decimal > 0 do\n\
    \    rem = decimal % 2\n    bin = bin .. tostring(rem)\n    decimal = (decimal\
    \ - rem) / 2\n  end\n  bin = bin .. 'db'\n  return bin\nend", "  local binary\
    \ = {}\n  while decimal > 0 do\n    local remainder = decimal % 2\n    table.insert(binary,\
    \ remainder)\n    decimal = (decimal - remainder) / 2\n  end\n  table.insert(binary,\
    \ 1, 'd')\n  table.insert(binary, 'b')\n  return table.concat(binary)\nend", " \
    \   local binary = ''\n    repeat\n        local remainder = decimal % 2\n   \
    \     binary = tostring(remainder) .. binary\n        decimal = (decimal - remainder)\
    \ / 2\n    until decimal == 0\n    return 'db' .. binary .. 'db'\nend", "    --\
    \ TODO: Fill me in!\nend", "  -- Decimal to binary algorithm\n  local dec_to_bin\
    \ = {'0', '1'}\n  local binary = ''\n  while decimal > 0 do\n    binary = dec_to_bin[(decimal\
    \ % 2) + 1] .. binary\n    decimal = math.floor(decimal / 2)\n  end\n  -- Prepend\
    \ extra characters\n  binary = 'db' .. binary .. 'db'\n  return binary\nend",
  "\tdecimal = string.format(\"%o\",decimal)\n\treturn 'db'..decimal..'db'\nend",
  "  local binary = ''\n  while (decimal > 0) do\n    binary = tostring(decimal %\
    \ 2) .. binary\n    decimal = math.floor(decimal / 2)\n  end\n  return 'db' ..\
    \ binary .. 'db'\nend", "  return decimal\nend", "    if decimal == 0 then\n \
    \       return 'db0db'\n    end\n    local binary = 'db'\n    while decimal >\
    \ 0 do\n        local r = decimal % 2\n        binary = binary .. tostring(r)\n\
    \        decimal = math.floor(decimal / 2)\n    end\n    binary = binary .. 'db'\n\
    \    return binary\nend", "    -- bin contains 'db' prefix and 'db' suffix\n \
    \   local bin = 'db'\n    -- append '0' or '1' characters to bin until 'decimal'\
    \ is 0\n    while decimal > 0 do\n        bin = bin .. (decimal % 2)\n       \
    \ decimal = math.floor(decimal / 2)\n    end\n    -- reverse bin and return it\n\
    \    return string.reverse(bin) .. 'db'\nend", "  -- write code here\nend", " \
    \ local sign = ''\n  if decimal < 0 then\n    sign = '-'\n    decimal = -decimal\n\
    \  end\n  local n = decimal\n  local binary = ''\n  while n > 0 do\n    local\
    \ d = n % 2\n    n = (n - d) / 2\n    binary = tostring(d) .. binary\n  end\n\
    \  return 'db' .. sign .. binary .. 'db'\nend", "    local binary_table = {}\n\
    \    while decimal > 0 do\n        local last_digit = decimal % 2\n        table.insert(binary_table,\
    \ last_digit)\n        decimal = (decimal - last_digit) / 2\n    end\n    local\
    \ binary_string = \"db\"\n    for _, v in ipairs(binary_table) do\n        binary_string\
    \ = binary_string .. tostring(v)\n    end\n    binary_string = binary_string ..\
    \ \"db\"\n    return binary_string\nend", "    local binary = ''\n    local binary_reversed\
    \ = ''\n    local remainder = nil\n    local factor = 2\n    local dividend =\
    \ decimal\n    repeat\n        remainder = dividend % factor\n        dividend\
    \ = (dividend - remainder) / factor\n        binary_reversed = binary_reversed\
    \ .. remainder\n    until dividend == 0\n    for i = 1, #binary_reversed do\n\
    \        binary = binary .. string.sub(binary_reversed, #binary_reversed - i +\
    \ 1, #binary_reversed - i + 1)\n    end\n    return 'db' .. binary .. 'db'\nend",
  "    -- Your code here\nend", "    local binary = 'db'\n    local power = 1\n  \
    \  while power <= decimal do\n        power = power * 2\n    end\n    power =\
    \ power / 2\n    while power >= 1 do\n        if power <= decimal then\n     \
    \       binary = binary .. '1'\n            decimal = decimal - power\n      \
    \  else\n            binary = binary .. '0'\n        end\n        power = power\
    \ / 2\n    end\n    return binary .. 'db'\nend", "   local binary = {}\n   local\
    \ value = decimal\n   while value > 0 do\n      local rest = value % 2\n     \
    \ value = math.floor(value / 2)\n      table.insert(binary, rest)\n   end\n  \
    \ binary = table.concat(binary):reverse()\n   binary = 'db' .. binary .. 'db'\n\
    \   return binary\nend", "\tlocal b = \"db\"\n\twhile decimal > 0 do\n\t\tlocal\
    \ rest = decimal % 2\n\t\tdecimal = (decimal - rest) / 2\n\t\tb = b .. rest\n\t\
    end\n\treturn b .. \"db\"\nend", "    local result = 'db'\n    while decimal ~=\
    \ 0 do\n        local remainder = decimal % 2\n        result = result .. tostring(remainder)\n\
    \        decimal = math.floor(decimal / 2)\n    end\n    result = result .. 'db'\n\
    \    return result\nend", "  local bin = \"\"\n  while decimal > 0 do\n    local\
    \ rem = math.floor(decimal % 2)\n    bin = rem .. bin\n    decimal = math.floor(decimal\
    \ / 2)\n  end\n  bin = \"db\" .. bin .. \"db\"\n  return bin\nend", "  local function\
    \ build_binary(decimal, binary)\n    if decimal == 0 then\n      return binary\n\
    \    else\n      local next_decimal = math.floor(decimal / 2)\n      local next_binary\
    \ = build_binary(next_decimal, binary)\n      local remainder = decimal % 2\n\
    \      return table.concat({next_binary, remainder})\n    end\n  end\n  return\
    \ 'db' .. build_binary(decimal, '') .. 'db'\nend", "  local binary = ''\n  local\
    \ idx = 1\n  while decimal > 0 do\n    local remainder = decimal % 2\n    decimal\
    \ = math.floor(decimal / 2)\n    binary = remainder .. binary\n    idx = idx +\
    \ 1\n  end\n  return 'db' .. binary .. 'db'\nend", "    local decimal = decimal\n\
    \    local result = {}\n    local pos = 1\n    local bin_digit\n    local i\n\
    \    for i = 7, 0, -1 do\n        bin_digit = (decimal >> i) & 1\n        result[pos]\
    \ = bin_digit\n        pos = pos + 1\n    end\n    return \"db\" .. table.concat(result)\
    \ .. \"db\"\nend", "  if not tonumber(decimal) then\n    return ''\n  end\n  local\
    \ binary = ''\n  while decimal > 0 do\n    binary = tostring(decimal % 2) .. binary\n\
    \    decimal = math.floor(decimal / 2)\n  end\n  binary = 'db' .. binary .. 'db'\n\
    \  return binary\nend", "  local function is_power_of_two(n)\n    -- returns true\
    \ if n is a power of two.\n    return (n & (n - 1)) == 0\n  end", "    local binary\
    \ = \"db\"\n    while decimal > 0 do\n        binary = binary .. (decimal % 2)\n\
    \        decimal = math.floor(decimal / 2)\n    end\n    binary = binary .. \"\
    db\"\n    return binary\nend", "  local binary_table = {}\n  while decimal > 0\
    \ do\n    if decimal % 2 == 0 then\n      table.insert(binary_table, 0)\n    else\n\
    \      table.insert(binary_table, 1)\n    end\n    decimal = math.floor(decimal\
    \ / 2)\n  end\n  local binary_string = \"\"\n  for i = #binary_table, 1, -1 do\n\
    \    binary_string = binary_string .. tostring(binary_table[i])\n  end\n  return\
    \ \"db\" .. binary_string .. \"db\"\nend", "    local binary = \"db\"\n    local\
    \ rem", "\treturn binary.to_array(decimal)\nend", "  -- TODO: Implement this function.\n\
    \  return ''\nend", "    return 'db' .. format('%b', decimal) .. 'db'\nend", " \
    \ assert(type(decimal) == 'number', \"Must use a number.\")\n  assert(decimal\
    \ % 1 == 0, \"Must use a whole number.\")\n  assert(decimal >= 0, \"Must use a\
    \ positive number.\")\n  local binary = ''\n  for i = 6,0,-1 do\n    local power\
    \ = 2^i\n    if decimal >= power then\n      binary = binary .. '1'\n      decimal\
    \ = decimal - power\n    else\n      binary = binary .. '0'\n    end\n  end\n\
    \  return 'db' .. binary .. 'db'\nend", "    local binary = 'db'\n    local quotient\
    \ = decimal\n    local divisor = 2\n    local remainder\n    while quotient ~=\
    \ 0 do\n        remainder = quotient % divisor\n        quotient = math.floor(quotient\
    \ / divisor)\n        binary = binary .. remainder\n    end\n    return binary\
    \ .. 'db'\nend", "  -- TODO: Implement solution.\nend", "  if decimal == 0 then\n\
    \    return 'db0db'\n  end\n  local result = 'db'\n  while decimal > 0 do\n  \
    \  result = result .. tostring(decimal % 2)\n    decimal = math.floor(decimal\
    \ / 2)\n  end\n  return result .. 'db'\nend", "    assert(decimal >= 0, 'Decimal\
    \ number cannot be negative')\n    local b = ''\n    while decimal > 0 do\n  \
    \      if decimal % 2 == 0 then\n            b = '0' .. b\n        else\n    \
    \        b = '1' .. b\n        end\n        decimal = math.floor(decimal / 2)\n\
    \    end\n    return 'db' .. b .. 'db'\nend", "    return 'db' .. tostring(decimal)\
    \ .. 'db'\nend", "    local result = \"db\"\n    repeat\n        local remainder\
    \ = decimal % 2\n        decimal = math.floor(decimal / 2)\n        result = result\
    \ .. remainder\n    until decimal == 0\n    return result .. \"db\"\nend", " \
    \   return 'db' .. string.format('%o', decimal) .. 'db'\nend", "\treturn \"db\"\
    \ .. binary_string(decimal) .. \"db\"\nend", "    -- validate decimal\n    if\
    \ decimal < 0 then\n        return \"db-1db\"\n    end", "  local result = \"\"\
    \n  while decimal > 0 do\n    local remainder = decimal % 2\n    result = remainder\
    \ .. result\n    decimal = (decimal - remainder) / 2\n  end\n  return \"db\" ..\
    \ result .. \"db\"\nend", "  local binary = \"\"\n  while decimal > 0 do\n   \
    \ binary = (decimal % 2 == 0 and \"0\" or \"1\") .. binary\n    decimal = math.floor(decimal\
    \ / 2)\n  end\n  return \"db\" .. binary .. \"db\"\nend", "    decimal = tostring(decimal)\n\
    \    return 'db' .. decimal:reverse():gsub('(%d%d?%d?)', function(d)\n       \
    \ local binary = ''\n        while d ~= '0' do\n            local m = d % 2\n\
    \            binary = tostring(m) .. binary\n            d = (d - m) / 2\n   \
    \     end\n        return binary\n    end) .. 'db'\nend", "  return 'db' .. string.format('%x',\
    \ decimal) .. 'db'\nend", "  return 'db' .. decimal:gsub('.', function(c)\n  \
    \  return c:byte()\n  end):gsub('%d%d%d', function(cc)\n    return string.char(tonumber(cc,\
    \ 8))\n  end) .. 'db'\nend", '    local binary_str = "db"', "    local remainder_stack\
    \ = Stack:new()\n    local binary_string = \"db\"", "  -- TODO: Fill out the code\
    \ for this function.\n  local binaryString = \"db\"\n  while decimal > 0 do\n\
    \    local remainder = decimal % 2\n    binaryString = binaryString .. tostring(remainder)\n\
    \    decimal = math.floor(decimal / 2)\n  end\n  return binaryString .. \"db\"\
    \nend", "  local function dec2bin(dec)\n    if dec == 0 then return '' end\n \
    \   local bit = dec % 2\n    return dec2bin(math.floor(dec / 2)) .. tostring(bit)\n\
    \  end\n  return 'db' .. dec2bin(decimal) .. 'db'\nend", "\tlocal binary = \"\
    db\"\n\tlocal temp = \"\"\n\tlocal i = 0\n\twhile (decimal > 0) do\n\t\ttemp =\
    \ temp .. tostring(decimal % 2)\n\t\tdecimal = math.floor(decimal / 2)\n\t\ti\
    \ = i + 1\n\tend\n\tfor j = 1, i do\n\t\tbinary = binary .. temp:sub(i - j + 1,\
    \ i - j + 1)\n\tend\n\tbinary = binary .. \"db\"\n\treturn binary\nend", "  local\
    \ binary = {}\n  local rest = decimal\n  repeat\n    local quotient = rest / 2\n\
    \    local next_digit = math.floor(quotient) * 2\n    local digit = rest - next_digit\n\
    \    rest = quotient\n    table.insert(binary, digit)\n  until rest == 0\n  return\
    \ string.format('db%sdb', table.concat(binary))\nend", "   -- your code here\n\
    end", "    local b = 'db'\n    while decimal > 0 do\n        local remainder =\
    \ decimal % 2\n        decimal = (decimal - remainder) / 2\n        b = ('%s%s'):format(remainder,\
    \ b)\n    end\n    return b .. 'db'\nend", "    local digits = {}\n    local db\
    \ = 'db'\n    repeat\n        local remainder = decimal % 2\n        table.insert(digits,\
    \ 1, remainder)\n        decimal = (decimal - remainder) / 2\n    until decimal\
    \ == 0\n    return db .. table.concat(digits) .. db\nend", "    -- A function\
    \ to convert the decimal number to binary, this function will be called in the\n\
    \    -- decimal_to_binary function.\n    local function convert_to_binary(num)\n\
    \        local to_binary = ''\n        local remainder = 0\n        -- Repeatedly\
    \ perform the division and modulus operations to find out the remainder.\n   \
    \     -- This will be used to find out the binary number.\n        while num ~=\
    \ 0 do\n            remainder = num % 2\n            num = math.floor(num / 2)\n\
    \            -- The binary number is in the reverse order. The remainder will\
    \ be concatenated to\n            -- the to_binary string.\n            to_binary\
    \ = to_binary .. remainder\n        end\n        return to_binary\n    end\n \
    \   -- The binary number is in the reverse order. The number will be reversed\
    \ and will be\n    -- returned.\n    return 'db' .. string.reverse(convert_to_binary(decimal))\
    \ .. 'db'\nend", "    -- your code here\nend", "    local binary = 'db'\n    while\
    \ decimal > 0 do\n        if decimal % 2 == 0 then\n            binary = binary\
    \ .. '0'\n        else\n            binary = binary .. '1'\n        end\n    \
    \    decimal = decimal / 2\n    end\n    return binary .. 'db'\nend", "  local\
    \ binary = {}\n  local db = {}\n  for i = 0, 7 do\n    local m = bit.rshift(decimal,\
    \ 7 - i)\n    local d = bit.band(m, 1)\n    binary[i + 1] = d\n  end\n  db[1]\
    \ = 'd'\n  db[2] = 'b'\n  db[9] = 'd'\n  db[10] = 'b'\n  local i = 3\n  for n\
    \ = 1, #binary do\n    if binary[n] == 1 then\n      db[i] = '1'\n    else\n \
    \     db[i] = '0'\n    end\n    i = i + 1\n  end\n  return table.concat(db)\n\
    end", "    local bn = 'db'\n    local add = nil\n    while true do\n        add\
    \ = math.fmod(decimal, 2)\n        decimal = math.floor(decimal / 2)\n       \
    \ bn = tostring(add) .. bn\n        if decimal == 0 then\n            break\n\
    \        end\n    end\n    return bn .. 'db'\nend", "    -- body\nend", "\tlocal\
    \ binary_num = {}\n\tlocal result = ''\n\tlocal i = 1\n\tlocal remain\n\twhile\
    \ decimal ~= 0 do\n\t\t-- Get the remainder of the number\n\t\tremain = decimal\
    \ % 2\n\t\t-- Add the remainder to the binary number\n\t\tbinary_num[i] = remain\n\
    \t\t-- Get the quotient of the number\n\t\tdecimal = (decimal - remain) / 2\n\t\
    \ti = i + 1\n\tend\n\t-- Add 'db' to the front and back of the binary number\n\
    \tresult = 'db'\n\t-- Add the binary number to the result\n\tfor i = #binary_num,\
    \ 1, -1 do\n\t\tresult = result .. tostring(binary_num[i])\n\tend\n\t-- Add 'db'\
    \ to the end of the binary number\n\tresult = result .. 'db'\n\treturn result\n\
    end", "  local result = ''\n  local remainder\n  while decimal > 0 do\n    remainder\
    \ = decimal % 2\n    decimal = math.floor(decimal / 2)\n    result = result ..\
    \ tostring(remainder)\n  end\n  return 'db' .. string.reverse(result) .. 'db'\n\
    end", "    local binary = \"db\"\n    while decimal > 0 do\n        local remainder\
    \ = decimal % 2\n        binary = binary .. remainder\n        decimal = math.floor(decimal\
    \ / 2)\n    end\n    binary = binary .. \"db\"\n    return binary\nend", "   \
    \ local binary = \"\"\n    while decimal ~= 0 do\n        binary = tostring(decimal\
    \ % 2) .. binary\n        decimal = math.floor(decimal / 2)\n    end\n    return\
    \ \"db\" .. binary .. \"db\"\nend", "    return (\"db%d\"):format(tonumber(decimal)):gsub(\"\
    .\", {\n        [48] = \"0000\",\n        [49] = \"0001\",\n        [50] = \"\
    0010\",\n        [51] = \"0011\",\n        [52] = \"0100\",\n        [53] = \"\
    0101\",\n        [54] = \"0110\",\n        [55] = \"0111\",\n        [56] = \"\
    1000\",\n        [57] = \"1001\",\n    }):gsub(\"^0+(%d)\", \"%1\") .. \"db\"\n\
    end", "   local binary = ''\n   local value = decimal\n   while value ~= 0 do\n\
    \      binary = tostring(value % 2) .. binary\n      value = math.floor(value\
    \ / 2)\n   end\n   binary = 'db' .. binary .. 'db'\n   return binary\nend", " \
    \  local bin = {}\n   local index = 1\n   while decimal > 0 do\n      bin[index]\
    \ = decimal % 2\n      decimal = decimal // 2\n      index = index + 1\n   end\n\
    \   bin[index] = \"db\"\n   return table.concat(bin):reverse()\nend", "    local\
    \ binary = ''\n    while decimal > 0 do\n        local digit = decimal % 2\n \
    \       binary = string.format('%s%d', binary, digit)\n        decimal = math.floor(decimal\
    \ / 2)\n    end\n    return 'db' .. binary .. 'db'\nend", "    local binary =\
    \ 'db'\n    local dec = decimal\n    local rem", "    local binary = \"db\"\n\
    \    while (decimal ~= 0) do\n        local reminder = decimal % 2\n        binary\
    \ = binary .. tostring(reminder)\n        decimal = math.floor(decimal / 2)\n\
    \    end\n    return binary .. \"db\"\nend", "    local binary = \"\"\n    repeat\n\
    \        local value = decimal % 2\n        binary = binary .. tostring(value)\n\
    \        decimal = math.floor(decimal / 2)\n    until decimal == 0\n    return\
    \ \"db\" .. string.reverse(binary) .. \"db\"\nend", "    local rt = 'db'\n   \
    \ while decimal > 0 do\n        rt = string.char(decimal % 2 + 48) .. rt\n   \
    \     decimal = math.floor(decimal / 2)\n    end\n    rt = rt .. 'db'\n    return\
    \ rt\nend", "    decimal = tonumber(decimal)\n    local result = \"\"\n    while\
    \ decimal > 0 do\n        result = result .. tostring(decimal % 2)\n        decimal\
    \ = math.floor(decimal / 2)\n    end\n    if result == \"\" then\n        result\
    \ = \"0\"\n    end\n    return \"db\" .. string.reverse(result) .. \"db\"\nend",
  "  local output = \"db\"\n  local binary = \"\"\n  local count = 1\n  local temp\
    \ = decimal", "\tlocal res = \"db\"\n\tlocal bit\n\tlocal i\n\t\n\tif decimal\
    \ == 0 then\n\t\treturn \"db0db\"\n\tend\n\t\n\twhile decimal > 0 do\n\t\tres\
    \ = res .. (decimal % 2)\n\t\tdecimal = math.floor(decimal / 2)\n\tend\n\t\n\t\
    -- reverse string\n\tfor i = 1, math.floor(#res / 2) do\n\t\tbit = res:sub(i,\
    \ i)\n\t\tres = res:sub(1, i - 1) .. res:sub(#res - i + 1, #res - i + 1) .. res:sub(i\
    \ + 1, #res - i)\n\tend\n\t\n\treturn res .. \"db\"\nend", "\tlocal binary = 'db'\n\
    \tfor _ = 1, 8 do\n\t\tbinary = binary .. ((decimal % 2 == 0) and '0' or '1')\n\
    \t\tdecimal = math.floor(decimal / 2)\n\tend\n\treturn binary .. 'db'\nend", " \
    \   local rest\n    local binary = ''\n    local rest_stack = {}", "    local\
    \ binary = {}\n    local db = 'db'\n    repeat\n        if decimal % 2 == 0 then\n\
    \            table.insert(binary, '0')\n        else\n            table.insert(binary,\
    \ '1')\n        end\n        decimal = math.floor(decimal / 2)\n    until decimal\
    \ == 0\n    return db .. table.concat(binary):reverse() .. db\nend", "\tlocal\
    \ result = 'db'\n\trepeat\n\t\tlocal remainder = decimal % 2\n\t\tresult = result\
    \ .. remainder\n\t\tdecimal = math.floor(decimal / 2)\n\tuntil decimal == 0\n\t\
    return result .. 'db'\nend", "   local result = \"\"\n   local binary_string =\
    \ \"\"\n   local index = 0\n   local current_char = 0\n   local i = 0\n   local\
    \ test = 0\n   local one = 1\n   local two = 2\n   local eight = 8\n   local sixteen\
    \ = 16\n   local thirty_two = 32\n   local sixty_four = 64\n   local hundred_twenty_eight\
    \ = 128\n   local value = 0\n   local remainder = 0\n   local powers_of_two =\
    \ {}\n   powers_of_two[0] = 1\n   powers_of_two[1] = 2\n   powers_of_two[2] =\
    \ 4\n   powers_of_two[3] = 8\n   powers_of_two[4] = 16\n   powers_of_two[5] =\
    \ 32\n   powers_of_two[6] = 64\n   powers_of_two[7] = 128\n   while decimal >\
    \ 0 do\n      value = decimal / 2\n      remainder = math.floor(value)\n     \
    \ decimal = remainder\n      index = index + 1\n      powers_of_two[index] = two\
    \ * powers_of_two[index - 1]\n   end\n   for i = index, 0, -1 do\n      test =\
    \ powers_of_two[i]\n      current_char = current_char + test\n      if decimal\
    \ >= current_char then\n         binary_string = binary_string .. \"1\"\n    \
    \     decimal = decimal - current_char\n      else\n         binary_string = binary_string\
    \ .. \"0\"\n      end\n   end\n   for i = 0, index do\n      result = result ..\
    \ \"0\"\n   end\n   result = \"db\" .. result .. binary_string .. \"db\"\n   return\
    \ result\nend", "    -- your code here\n    -- 1 <= decimal <= 127\n    local\
    \ binary_str = 'db'\n    while decimal > 0 do\n        if decimal % 2 == 0 then\n\
    \            binary_str = binary_str .. '0'\n        else\n            binary_str\
    \ = binary_str .. '1'\n        end\n        decimal = decimal / 2\n    end\n \
    \   return binary_str .. 'db'\nend", "  local reverse_result = ''\n  local quotient\
    \ = decimal\n  while quotient ~= 0 do\n    local remainder = math.floor(quotient\
    \ % 2)\n    reverse_result = reverse_result .. remainder\n    quotient = math.floor(quotient\
    \ / 2)\n  end\n  local result = 'db' .. reverse_result .. 'db'\n  return result\n\
    end", "  return \"db\" .. decimal:base(2) .. \"db\"\nend", '    local binary =
    "db"', "  local binary = 'db'\n  for _ = 1, 8 do\n    local bit = decimal % 2\n\
    \    binary = binary .. bit\n    decimal = (decimal - bit) / 2\n  end\n  return\
    \ binary .. 'db'\nend", "    return 'db' .. dec2bin(decimal) .. 'db'\nend", " \
    \ local decimal_table = {128, 64, 32, 16, 8, 4, 2, 1}\n  local binary_table =\
    \ {}\n  local binary_string = ''\n  -- This is a loop that's 8 iterations.\n \
    \ for i=1,8 do\n    if decimal >= decimal_table[i] then\n      binary_table[i]\
    \ = 1\n      decimal = decimal - decimal_table[i]\n    else\n      binary_table[i]\
    \ = 0\n    end\n  end\n  for i=1,8 do\n    binary_string = binary_string .. binary_table[i]\n\
    \  end\n  return 'db' .. binary_string .. 'db'\nend", "\treturn 'db' .. dec2bin(decimal)\
    \ .. 'db'\nend", "   local binary = \"\"\n   repeat\n      if (decimal % 2 ==\
    \ 0) then\n         binary = \"0\" .. binary\n      else\n         binary = \"\
    1\" .. binary\n      end\n      decimal = math.floor(decimal / 2)\n   until decimal\
    \ == 0\n   return \"db\" .. binary .. \"db\"\nend", "    return nil\nend", " \
    \   local binary = \"\"\n    local length = 0\n    local index = 2", "    local\
    \ str = 'db'\n    while decimal ~= 0 do\n        local remainder = decimal % 2\n\
    \        decimal = math.floor(decimal / 2)\n        str = (remainder == 0 and\
    \ '0' or '1') .. str\n    end\n    return str .. 'db'\nend", "  error(\"Not implemented!\"\
    )\nend", "\tassert(type(decimal) == \"number\", \"decimal_to_binary expects a\
    \ number\")\n\tlocal binary = \"\"\n\tif decimal == 0 then\n\t\treturn \"db0db\"\
    \n\tend\n\tlocal flag = false\n\twhile decimal > 0 do\n\t\tbinary = string.format(\"\
    %s%d\", binary, decimal % 2)\n\t\tdecimal = decimal >> 1\n\t\tflag = true\n\t\
    end\n\tif flag then\n\t\tbinary = \"db\" .. binary .. \"db\"\n\tend\n\treturn\
    \ binary\nend", "    local binary_str = 'db'\n    while decimal > 0 do\n     \
    \   if (decimal % 2) == 0 then\n            binary_str = '0' .. binary_str\n \
    \       else\n            binary_str = '1' .. binary_str\n        end\n      \
    \  decimal = math.floor(decimal / 2)\n    end\n    return binary_str .. 'db'\n\
    end", "    return 'db' .. string.format('%08d', string.reverse(decimal)) .. 'db'\n\
    end", "    if type(decimal) ~= 'number' then\n        return 'db0db'\n    end\n\
    \    local function dec_to_bin(decimal)\n        local bin = ''\n        while\
    \ decimal > 0 do\n            local rest = decimal % 2\n            decimal =\
    \ (decimal - rest) / 2\n            bin = tostring(rest) .. bin\n        end\n\
    \        return bin\n    end\n    return 'db' .. dec_to_bin(decimal) .. 'db'\n\
    end", "    -- you code here\nend", "  local binary = 'db'\n  while decimal > 0\
    \ do\n    local remainder = decimal % 2\n    binary = binary .. remainder\n  \
    \  decimal = math.floor(decimal / 2)\n  end\n  return binary .. 'db'\nend", " \
    \   -- The string, consisting of 0s and 1s\n    local binary = \"\"\n    -- The\
    \ integer value that will be converted to binary\n    local value = decimal\n\
    \    -- The remainder of the division by 2. Will be appended to binary.\n    local\
    \ remainder = 0\n    -- Keep looping until the value is 0\n    while value > 0\
    \ do\n        -- Get the remainder of the division by 2\n        remainder = value\
    \ % 2\n        -- Floor to get the integer part of the division\n        value\
    \ = math.floor(value / 2)\n        -- Append to the result\n        binary = tostring(remainder)\
    \ .. binary\n    end\n    -- Add surrounding db\n    return \"db\" .. binary ..\
    \ \"db\"\nend", "\t-- assert(type(decimal) == 'number', \"Decimal is not a number\"\
    )\n\t-- assert(decimal % 1 == 0, \"Decimal is not an integer\")\n\tlocal binary\
    \ = \"db\"\n\tlocal old_d = decimal\n\twhile decimal > 0 do\n\t\tbinary = binary\
    \ .. tostring(decimal % 2)\n\t\tdecimal = math.floor(decimal / 2)\n\tend\n\tbinary\
    \ = binary .. \"db\"\n\tbinary = string.reverse(binary)\n\treturn binary\nend",
  "  local binary = 'db'\n  local quotient = decimal\n  local remainder\n  while quotient\
    \ ~= 0 do\n    remainder = math.floor(quotient % 2)\n    quotient = math.floor(quotient\
    \ / 2)\n    binary = binary .. tostring(remainder)\n  end\n  binary = binary ..\
    \ 'db'\n  return binary\nend", "    local sign = ''\n    if decimal < 0 then\n\
    \        sign = '-'\n        decimal = -decimal\n    end\n    local rv = ''\n\
    \    while decimal > 0 do\n        rv = tostring(decimal % 2) .. rv\n        decimal\
    \ = math.floor(decimal / 2)\n    end\n    return string.format('db%s%sd', sign,\
    \ rv)\nend", "    local db = 'db'\n    local buf = {}\n    local binary = {}\n\
    \    local remainder", "  assert(type(decimal) == 'number', 'decimal_to_binary:\
    \ expecting a number')\n  local binary_string = ''\n  local done = false\n  while\
    \ not done do\n    local remainder = decimal % 2\n    binary_string = binary_string\
    \ .. remainder\n    decimal = math.floor(decimal / 2)\n    if decimal == 0 then\n\
    \      done = true\n    end\n  end\n  binary_string = 'db' .. binary_string ..\
    \ 'db'\n  return binary_string\nend", "  local binary = 'db'\n  while decimal\
    \ > 0 do\n    if decimal % 2 == 0 then\n      binary = '0' .. binary\n    else\n\
    \      binary = '1' .. binary\n    end\n    decimal = math.floor(decimal / 2)\n\
    \  end\n  return binary .. 'db'\nend", "  local binary = 'db'\n  local remain\n\
    \  repeat\n    remain = decimal % 2\n    binary = string.format('%s%d', binary,\
    \ remain)\n    decimal = math.floor(decimal / 2)\n  until decimal == 0\n  return\
    \ binary .. 'db'\nend", "    local rem = decimal % 2\n    local res = rem", " \
    \   -- Insert code here\nend", "\tlocal binary_str = 'db'\n\twhile decimal > 0\
    \ do\n\t\tbinary_str = binary_str .. tostring(decimal % 2)\n\t\tdecimal = math.floor(decimal\
    \ / 2)\n\tend\n\treturn binary_str .. 'db'\nend", "    local bin = ''\n    while\
    \ decimal > 0 do\n        local rest = decimal % 2\n        bin = tostring(rest)\
    \ .. bin\n        decimal = (decimal - rest) / 2\n    end\n    return \"db\" ..\
    \ bin .. \"db\"\nend", "\tlocal binary_reversed = {}\n\tlocal final_binary = \"\
    \"\n\tlocal i = 1\n\twhile true do\n\t\tif math.floor(decimal/2) == 0 then\n\t\
    \t\ttable.insert(binary_reversed, 1, decimal)\n\t\t\tbreak\n\t\telse\n\t\t\ttable.insert(binary_reversed,\
    \ 1, decimal%2)\n\t\t\tdecimal = math.floor(decimal/2)\n\t\tend\n\tend\n\tfor\
    \ i=1, #binary_reversed do\n\t\tfinal_binary = final_binary .. binary_reversed[i]\n\
    \tend\n\treturn \"db\" .. final_binary .. \"db\"\nend", "    -- Insert your code\
    \ here.\n    local remain\n    local bin_str = \"\"\n    while decimal > 0 do\n\
    \        remain = decimal % 2\n        decimal = math.floor(decimal / 2)\n   \
    \     bin_str = tostring(remain) .. bin_str\n    end\n    return \"db\" .. bin_str\
    \ .. \"db\"\nend", "    local binary = ''\n    while decimal > 0 do\n        binary\
    \ = tostring(decimal % 2) .. binary\n        decimal = math.floor(decimal / 2)\n\
    \    end\n    binary = 'db' .. binary .. 'db'\n    return binary\nend", "   --\
    \ your code here\n   -- you can use bit.tobit() and bit.tohex() functions\n  \
    \ -- described at: http://bitop.luajit.org/api.html\nend", "\tlocal binary = \"\
    \"\n\twhile decimal > 0 do\n\t\tbinary = binary .. tostring(decimal % 2)\n\t\t\
    decimal = math.floor(decimal / 2)\n\tend\n\treturn \"db\" .. string.reverse(binary)\
    \ .. \"db\"\nend", "    return 'db' .. string.format('%b', decimal) .. 'db'\n\
    end", "  local binary = \"db\"\n  local remainder\n  while decimal > 0 do\n  \
    \  remainder = decimal % 2\n    decimal = math.floor(decimal / 2)\n    binary\
    \ = tostring(remainder) .. binary\n  end\n  return binary .. \"db\"\nend", " \
    \ -- TODO\nend", "  local db = 'db'\n  local binary = ''\n  local quotient = decimal\n\
    \  local remainder = 0\n  local i = 0\n  local len = 0\n  if decimal == 0 then\n\
    \    return db .. '0' .. db\n  end\n  while quotient > 0 do\n    remainder = quotient\
    \ % 2\n    quotient = math.floor(quotient / 2)\n    binary = remainder .. binary\n\
    \  end\n  len = string.len(binary)\n  while i < (6 - len) do\n    binary = '0'\
    \ .. binary\n    i = i + 1\n  end\n  return db .. binary .. db\nend", "  local\
    \ binary = string.sub('db' .. string.format('%x', decimal) .. 'db', -8)\n  return\
    \ binary\nend", "  local bits = \"\"\n  while decimal > 0 do\n    local remainder\
    \ = decimal % 2\n    bits = tostring(remainder) .. bits\n    decimal = math.floor(decimal\
    \ / 2)\n  end\n  return 'db' .. bits .. 'db'\nend", "  local binary = \"\"\n \
    \ local decimal = decimal\n  local remainder = 0\n  local i = 0\n  local remainder_list\
    \ = {}\n  while i < decimal do\n    remainder = decimal % 2\n    remainder_list[i]\
    \ = remainder\n    decimal = math.floor(decimal / 2)\n    i = i + 1\n  end\n \
    \ for j = i - 1, 0, -1 do\n    binary = binary .. tostring(remainder_list[j])\n\
    \  end\n  return 'db' .. binary .. 'db'\nend", "    local rem, base = {}\n   \
    \ local i = 1\n    while decimal ~= 0 do\n        rem[i] = decimal % 2\n     \
    \   decimal = math.floor(decimal / 2)\n        i = i + 1\n    end\n    local bin\
    \ = \"\"\n    for j = i - 1, 1, -1 do\n        bin = bin .. rem[j]\n    end\n\
    \    return \"db\" .. bin .. \"db\"\nend", "    local binary = 'db'\n    while\
    \ decimal > 0 do\n        local rest = decimal % 2\n        binary = binary ..\
    \ tostring(rest)\n        decimal = (decimal - rest) / 2\n    end\n    return\
    \ binary .. 'db'\nend", "    return 'db' .. lshift(decimal, -1):to_binary() ..\
    \ 'db'\nend", "   assert(decimal >= 0, \"Expected positive integer, got: \" ..\
    \ decimal)\n   local binary = ''\n   while decimal > 0 do\n      binary = tostring(decimal\
    \ % 2) .. binary\n      decimal = floor(decimal / 2)\n   end\n   return 'db' ..\
    \ (binary ~= '' and binary or '0') .. 'db'\nend", "    -- your code here\nend",
  "  local binary = ''\n  while decimal > 0 do\n    binary = binary .. tostring(decimal\
    \ % 2)\n    decimal = math.floor(decimal / 2)\n  end\n  return 'db' .. binary\
    \ .. 'db'\nend", "  local bin = ''\n  local power = 0\n  while decimal > 0 do\n\
    \    local digit = decimal % 2^(power+1)\n    if digit > 2^power then\n      bin\
    \ = bin .. '1'\n      decimal = decimal - 2^power\n    else\n      bin = bin ..\
    \ '0'\n    end\n    power = power + 1\n  end\n  local bin = bin:reverse()\n  return\
    \ 'db' .. bin .. 'db'\nend", "  local bits = {}\n  local i = 2\n  local j = 0\n\
    \  local num = decimal\n  local flag = true\n  while flag do\n    num = math.floor(num\
    \ / 2)\n    bits[i] = decimal % 2\n    decimal = num\n    i = i + 1\n    if decimal\
    \ == 0 then\n      flag = false\n    end\n  end\n  local result = 'db'\n  while\
    \ bits[i] == nil do\n    i = i - 1\n  end\n  while j <= i - 2 do\n    j = j +\
    \ 1\n    result = result .. bits[j]\n  end\n  result = result .. 'db'\n  return\
    \ result\nend", "    return 'db' .. string.format('%b', decimal) .. 'db'\nend",
  "    local binary = \"db\"\n    while decimal > 0 do\n        local mod = decimal\
    \ % 2\n        decimal = math.floor(decimal / 2)\n        binary = mod .. binary\n\
    \    end\n    binary = binary .. \"db\"\n    return binary\nend", "  local new\
    \ = {}\n  local i = 0\n  while decimal > 0 do\n    i = i + 1\n    remainder =\
    \ decimal % 2\n    new[i] = remainder\n    decimal = (decimal - remainder) / 2\n\
    \  end\n  local bit = 'db'\n  for i = 1, #new do\n    bit = bit .. tostring(new[i])\n\
    \  end\n  bit = bit .. 'db'\n  return bit\nend", "    local binary = ''\n    while\
    \ decimal > 0 do\n        binary = binary .. (decimal % 2)\n        decimal =\
    \ decimal // 2\n    end\n    return 'db' .. binary .. 'db'\nend", "\t-- TODO:\
    \ implement the function here\nend", "    if decimal == 0 then\n        return\
    \ 'db0db'\n    end\n    local binary = 'db'\n    while decimal > 0 do\n      \
    \  local r = decimal % 2\n        binary = binary .. tostring(r)\n        decimal\
    \ = math.floor(decimal / 2)\n    end\n    binary = binary .. 'db'\n    return\
    \ binary\nend", "  local bit_mask = 0x8000\n  local binary = 'db'\n  while bit_mask\
    \ > 0 do\n    if bit_mask & decimal ~= 0 then\n      binary = binary .. '1'\n\
    \    else\n      binary = binary .. '0'\n    end\n    bit_mask = bit_mask >> 1\n\
    \  end\n  return binary .. 'db'\nend", "  local binary = 'db'\n  repeat\n    local\
    \ remainder = decimal % 2\n    binary = tostring(remainder) .. binary\n    decimal\
    \ = (decimal - remainder) / 2\n  until decimal == 0\n  return binary .. 'db'\n\
    end", "  if (decimal == 0) then\n    return 'db00000000db'\n  end\n  local binary\
    \ = \"\"\n  while (decimal > 0) do\n    local bit = decimal % 2\n    binary =\
    \ bit .. binary\n    decimal = math.floor(decimal / 2)\n  end\n  return 'db' ..\
    \ string.rep('0', 8 - #binary) .. binary .. 'db'\nend", '    local binary = "db"',
  "    return 'db' .. string.gsub(string.format('%b', decimal), '.', function(x)\n\
    \        return string.sub(x, 2)\n    end) .. 'db'\nend", "   -- first we need\
    \ to write our number in a binary format\n   local binary = dec_to_bin(decimal)\n\
    \   -- now we need to add 'db' on both sides of our number\n   binary = \"db\"\
    \ .. binary .. \"db\"\n   return binary\nend", "  local binary = \"\"\n  local\
    \ binary_number = \"\"\n  local remainder\n  local binary_number_length = 0\n\
    \  while decimal > 0 do\n    remainder = decimal % 2\n    binary = binary .. tostring(remainder)\n\
    \    decimal = (decimal - remainder) / 2\n  end\n  binary_number_length = binary:len()\n\
    \  if binary_number_length == 0 then\n    binary_number = \"db0db\"\n  else\n\
    \    for i = binary_number_length, 1, -1 do\n      binary_number = binary_number\
    \ .. binary:sub(i, i)\n    end\n    binary_number = \"db\" .. binary_number ..\
    \ \"db\"\n  end\n  return binary_number\nend", "    -- Convert the number to binary\
    \ number and return it as a string.\n    -- Each character in the string will\
    \ be '0' or '1'.\n    -- There will be an extra couple of characters 'db' at the\
    \ beginning and at the end of the string.\n    -- The extra characters are there\
    \ to help with the format.\nend", "   if decimal == 0 then\n      return \"db0db\"\
    \n   end\n   local binary = \"\"\n   while decimal > 0 do\n      binary = tostring(decimal\
    \ % 2) .. binary\n      decimal = math.floor(decimal / 2)\n   end\n   return \"\
    db\" .. binary .. \"db\"\nend", "    assert(type(decimal) == 'number', \"bad argument\
    \ #1 to 'decimal_to_binary' (number expected, got \" .. type(decimal) .. \")\"\
    )\n    if decimal == 0 then\n        return 'db0db'\n    end\n    local table\
    \ = {}\n    while decimal > 0 do\n        local rest = math.fmod(decimal, 2)\n\
    \        table[#table + 1] = rest\n        decimal = (decimal - rest) / 2\n  \
    \  end\n    return 'db' .. table.concat(table):reverse() .. 'db'\nend", "    local\
    \ bin = {}\n    local count = 0\n    repeat\n        count = count + 1\n     \
    \   bin[count] = tostring(decimal % 2)\n        decimal = math.floor(decimal /\
    \ 2)\n    until decimal == 0\n    local out = ''\n    for i = count, 1, -1 do\n\
    \        out = out .. bin[i]\n    end\n    return 'db' .. out .. 'db'\nend", "\t\
    local digits = math.ceil(math.log(decimal, 2))\n\tlocal binary = {}\n\tfor i =\
    \ 1, digits do\n\t\tlocal power = 2 ^ (digits - i)\n\t\tif decimal >= power then\n\
    \t\t\ttable.insert(binary, '1')\n\t\t\tdecimal = decimal - power\n\t\telse\n\t\
    \t\ttable.insert(binary, '0')\n\t\tend\n\tend\n\treturn string.format('db%sdb',\
    \ table.concat(binary))\nend", "  local answer = 'db'\n  while (decimal ~= 0)\
    \ do\n    -- check if the current number is even or odd\n    local remainder =\
    \ decimal % 2\n    -- we add the remainder to our answer\n    answer = tostring(remainder)\
    \ .. answer\n    -- divide the number by 2 and\n    -- round it down to the nearest\
    \ integer\n    decimal = math.floor(decimal / 2)\n  end\n  return answer .. 'db'\n\
    end", "    assert(type(decimal) == 'number')\n    assert(decimal > 0)\n    local\
    \ all_bits = ''\n    while decimal > 0 do\n        all_bits = math.fmod(decimal,\
    \ 2) .. all_bits\n        decimal = math.floor(decimal / 2)\n    end\n    all_bits\
    \ = 'db' .. all_bits .. 'db'\n    return all_bits\nend", "    -- Write your code\
    \ here\n    local remainder\n    local answer = \"\"\n    local binary = \"\"\n\
    \    local flag = true\n    if decimal == 0 then\n        binary = \"0\"\n   \
    \ end\n    while decimal > 0 do\n        remainder = decimal % 2\n        answer\
    \ = answer .. remainder\n        decimal = math.floor(decimal / 2)\n    end\n\
    \    for i = #answer, 1, -1 do\n        if answer:sub(i, i) == \"1\" then\n  \
    \          flag = false\n        end\n        if flag == false then\n        \
    \    binary = binary .. answer:sub(i, i)\n        end\n    end\n    return \"\
    db\" .. binary .. \"db\"\nend", "    local bin = ''\n    while decimal > 0 do\n\
    \        bin = bin .. (decimal % 2)\n        decimal = math.floor(decimal / 2)\n\
    \    end\n    return 'db' .. string.reverse(bin) .. 'db'\nend", "    if decimal\
    \ == 0 then\n        return \"db0db\"\n    end\n    local result = \"db\"\n  \
    \  while decimal > 0 do\n        local remainder = decimal % 2\n        decimal\
    \ = math.floor(decimal / 2)\n        result = result .. remainder\n    end\n \
    \   return result .. \"db\"\nend", "  return 'db' .. dec2bin(decimal) .. 'db'\n\
    end", "    local result = {}\n    local decimal = decimal", "    if decimal <\
    \ 0 then\n        return 'db-' .. decimal_to_binary(-decimal)\n    end\n    --\
    \ 1011 >> 1  = 10011\n    local result = 'db'\n    while decimal > 0 do\n    \
    \    result = result .. tostring(decimal % 2)\n        decimal = decimal // 2\n\
    \    end\n    return result .. 'db'\nend", "    local binary = ''\n    local bits\
    \ = 8\n    local j = 1\n    for i = bits, 1, -1 do\n        j = 2 ^ (i - 1)\n\
    \        if decimal >= j then\n            binary = binary .. '1'\n          \
    \  decimal = decimal - j\n        else\n            binary = binary .. '0'\n \
    \       end\n    end\n    return 'db' .. binary .. 'db'\nend", "    decimal =\
    \ string.format(\"%o\", decimal)\n    return 'db' .. decimal .. 'db'\nend", " \
    \   -- TODO\nend", "    -- Decimal to binary conversion by Alex Shinn.\n    local\
    \ res = {}\n    local function step(a, b)\n        if a == 0 then return b end\n\
    \        local q, r = math.floor(a / 2), a % 2\n        return step(q, r .. b)\n\
    \    end\n    return \"db\" .. step(decimal, \"\") .. \"db\"\nend", "  local binary\
    \ = {}\n  local j = 0\n  while decimal ~= 0 do\n    j = j + 1\n    binary[j] =\
    \ decimal % 2\n    decimal = math.floor(decimal / 2)\n  end\n  local res = 'db'\n\
    \  for i = j, 1, -1 do\n    res = res .. tostring(binary[i])\n  end\n  return\
    \ res .. 'db'\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
