name: HumanEval_79_decimal_to_binary
language: lua
prompt: "-- You will be given a number in decimal form and your task is to convert\
  \ it to\n-- binary format. The function should return a string, with each character\
  \ representing a binary\n-- number. Each character in the string will be '0' or\
  \ '1'.\n-- There will be an extra couple of characters 'db' at the beginning and\
  \ at the end of the string.\n-- The extra characters are there to help with the\
  \ format.\n-- Examples:\n-- >>> decimal_to_binary(15)\n-- 'db1111db'\n-- >>> decimal_to_binary(32)\n\
  -- 'db100000db'\nlocal function decimal_to_binary(decimal)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = decimal_to_binary\n\
  \    lu.assertEquals(candidate(0), 'db0db')\n    lu.assertEquals(candidate(32),\
  \ 'db100000db')\n    lu.assertEquals(candidate(103), 'db1100111db')\n    lu.assertEquals(candidate(15),\
  \ 'db1111db')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return \"db\" .. decToBin(decimal) .. \"db\"\nend", "\tlocal result\
    \ = \"db\"\n\tlocal quotient = decimal\n\tlocal remainder = 0\n\twhile quotient\
    \ ~= 0 do\n\t\tremainder = quotient % 2\n\t\tquotient = math.floor(quotient /\
    \ 2)\n\t\tresult = string.format(\"%d%s\", remainder, result)\n\tend\n\tresult\
    \ = result .. \"db\"\n\treturn result\nend", "    local binary = ''\n    while\
    \ decimal > 0 do\n        local remainder = decimal % 2\n        binary = binary\
    \ .. remainder\n        decimal = (decimal - remainder) / 2\n    end\n    binary\
    \ = 'db' .. binary .. 'db'\n    return binary\nend", "    -- Use the metatable\
    \ to convert the number to a string in binary format\n    local binary = {}\n\
    \    binary.__tostring = function(self)\n        local str = ''\n        for i\
    \ = 1, #self do\n            str = str .. self[i]\n        end\n        return\
    \ str\n    end\n    -- Get the list of bits by looping through the number of bits\n\
    \    local num_bits = math.ceil(math.log(decimal) / math.log(2))\n    for i =\
    \ num_bits, 1, -1 do\n        local num = math.pow(2, i - 1)\n        if decimal\
    \ >= num then\n            table.insert(binary, '1')\n            decimal = decimal\
    \ - num\n        else\n            table.insert(binary, '0')\n        end\n  \
    \  end\n    -- Return the string\n    return ('db%sdb'):format(binary)\nend",
  "  local binary = ''\n  while decimal > 0 do\n    local remainder = decimal % 2\n\
    \    binary = binary .. tostring(remainder)\n    decimal = math.floor(decimal\
    \ / 2)\n  end\n  return string.reverse('db' .. binary .. 'db')\nend", "    local\
    \ binary_string = \"db\"\n    if decimal == 0 then\n        binary_string = binary_string\
    \ .. \"0\"\n    else\n        while decimal > 0 do\n            binary_string\
    \ = binary_string .. math.floor(decimal % 2)\n            decimal = math.floor(decimal\
    \ / 2)\n        end\n    end\n    binary_string = binary_string .. \"db\"\n  \
    \  binary_string = string.reverse(binary_string)\n    return binary_string\nend",
  "    local result = ''\n    local remainder\n    repeat\n        remainder = decimal\
    \ % 2\n        decimal = math.floor(decimal / 2)\n        result = remainder ..\
    \ result\n    until decimal == 0\n    return 'db' .. result .. 'db'\nend", " \
    \ local bit_string = \"\"\n  for i = math.floor(math.log(decimal, 2)), 0, -1 do\n\
    \    if decimal >= 2^i then\n      bit_string = bit_string .. \"1\"\n      decimal\
    \ = decimal - 2^i\n    else\n      bit_string = bit_string .. \"0\"\n    end\n\
    \  end\n  return \"db\" .. bit_string .. \"db\"\nend", "    return string.format(\"\
    db%bdb\", decimal)\nend", "  local binary = ''\n  if decimal == 0 then return\
    \ 'db0db' end\n  while decimal > 0 do\n    local remainder = decimal % 2\n   \
    \ binary = (remainder == 0 and '0' or '1') .. binary\n    decimal = (decimal -\
    \ remainder) / 2\n  end\n  return 'db' .. binary .. 'db'\nend", "\t-- Implement\
    \ your function here\n\treturn \"\"\nend", "  local bits = {}\n  local number\
    \ = math.floor(decimal)\n  local binary = ''\n  local function get_binary(number)\n\
    \    local i = 1\n    while number > 0 do\n      bits[i] = number % 2\n      number\
    \ = math.floor(number / 2)\n      i = i + 1\n    end\n  end\n  get_binary(number)\n\
    \  for j = 1, #bits do\n    binary = binary .. tostring(bits[j])\n  end\n  return\
    \ 'db' .. binary .. 'db'\nend", "   local number = \"db\"\n   while decimal >\
    \ 0 do\n      local rest = decimal % 2\n      number = number .. tostring(rest)\n\
    \      decimal = (decimal - rest) / 2\n   end\n   number = number .. \"db\"\n\
    \   return number\nend", "\tlocal result = 'db'\n\twhile decimal > 0 do\n\t\t\
    result = result .. (decimal % 2)\n\t\tdecimal = math.floor(decimal / 2)\n\tend\n\
    \treturn result .. 'db'\nend", "    return (\"db%sdb\"):format(decimal:gsub(\"\
    .\", {[\"0\"] = \"0000\", [\"1\"] = \"0001\", [\"2\"] = \"0010\", [\"3\"] = \"\
    0011\", [\"4\"] = \"0100\", [\"5\"] = \"0101\", [\"6\"] = \"0110\", [\"7\"] =\
    \ \"0111\", [\"8\"] = \"1000\", [\"9\"] = \"1001\"}))\nend", "    return 'db'\
    \ .. decimal:reverse():gsub('%d',\n        function(d)\n            return d:byte()\
    \ - 48\n        end):gsub('%d',\n        function(d)\n            return string.char(d\
    \ + 48)\n        end):reverse() .. 'db'\nend", "  local decimal_to_binary_map\
    \ = {\n    [0]  = '0',\n    [1]  = '1',\n    [2]  = '10',\n    [3]  = '11',\n\
    \    [4]  = '100',\n    [5]  = '101',\n    [6]  = '110',\n    [7]  = '111',\n\
    \    [8]  = '1000',\n    [9]  = '1001',\n    [10] = '1010',\n    [11] = '1011',\n\
    \    [12] = '1100',\n    [13] = '1101',\n    [14] = '1110',\n    [15] = '1111',\n\
    \    [16] = '10000',\n    [17] = '10001',\n    [18] = '10010',\n    [19] = '10011',\n\
    \    [20] = '10100',\n    [21] = '10101',\n    [22] = '10110',\n    [23] = '10111',\n\
    \    [24] = '11000',\n    [25] = '11001',\n    [26] = '11010',\n    [27] = '11011',\n\
    \    [28] = '11100',\n    [29] = '11101',\n    [30] = '11110',\n    [31] = '11111',\n\
    \    [32] = '100000',\n    [33] = '100001',\n    [34] = '100010',\n    [35] =\
    \ '100011',\n    [36] = '100100',\n    [37] = '100101',\n    [38] = '100110',\n\
    \    [39] = '100111',\n    [40] = '101000',\n    [41] = '101001',\n    [42] =\
    \ '101010',\n    [43] = '101011',\n    [44] = '101100',\n    [45] = '101101',\n\
    \    [46] = '101110',\n    [47] = '101111',\n    [48] = '110000',\n    [49] =\
    \ '110001',\n    [", "\treturn 'db' .. string.format('%X', decimal) .. 'db'\n\
    end", "\tlocal bin = \"\"\n\tlocal mask = 0x80\n\t\n\t-- check for negative values\n\
    \tif (decimal < 0) then\n\t\tdecimal = decimal + 256\n\tend\n\t\n\tfor i = 1,\
    \ 8 do\n\t\tif (bit32.band(decimal, mask) == 0) then\n\t\t\tbin = bin .. \"0\"\
    \n\t\telse\n\t\t\tbin = bin .. \"1\"\n\t\tend\n\t\tmask = bit32.rshift(mask, 1)\n\
    \tend\n\t\n\treturn \"db\" .. bin .. \"db\"\nend", "  return 'db' .. toBinaryString(decimal)\
    \ .. 'db'\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
