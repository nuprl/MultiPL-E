name: HumanEval_99_closest_integer
language: lua
prompt: "-- Create a function that takes a value (string) representing a number\n\
  -- and returns the closest integer to it. If the number is equidistant\n-- from\
  \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
  -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from zero\
  \ means that if the given number is equidistant\n-- from two integers, the one you\
  \ should return is the one that is the\n-- farthest from zero. For example closest_integer(\"\
  14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\n\
  local function closest_integer(value)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
  \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
  \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
  \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- TODO: implement this function\nend", "  local number = tonumber(value)\n\
    \  if number == nil then\n    return nil\n  end\n  local result = 0\n  if number\
    \ > 0 then\n    result = math.floor(number + 0.5)\n  else\n    result = math.ceil(number\
    \ - 0.5)\n  end\n  return result\nend", "    -- remove all characters that are\
    \ not digits\n    -- and parse value to a number\n    local value = tonumber(value:gsub(\"\
    %D\", \"\"))\n    -- if it is nil, then the input was not a number\n    if not\
    \ value then\n        return 0\n    end\n    -- get the decimal part of the number\n\
    \    local decimal = value - math.floor(value)\n    -- if the decimal part is\
    \ larger than 0.5, round up\n    if decimal > 0.5 then\n        return math.ceil(value)\n\
    \    -- if the decimal part is smaller than 0.5, round down\n    elseif decimal\
    \ < 0.5 then\n        return math.floor(value)\n    -- if the decimal part is\
    \ exactly 0.5, round away from zero\n    else\n        return math.floor(value\
    \ * 0.5)\n    end\nend", "    local num = tonumber(value)\n    if num > 0 then\n\
    \        return math.floor(num + 0.5)\n    else\n        return math.ceil(num\
    \ - 0.5)\n    end\nend", "    local num = tonumber(value)\n    if not num then\n\
    \        return nil\n    end\n    return num + (num > 0 and -0.5 or 0.5)\nend",
  "  if not value then return nil end\n  return math.floor(tonumber(value) + 0.5)\n\
    end", "    return math.floor(value + 0.5)\nend", "    return math.floor(value\
    \ + 0.5)\nend", "    return math.floor(tonumber(value) + 0.5)\nend", end, "\t\
    return math.floor(value + 0.5)\nend", "  -- your code here\nend", "  return math.floor(value\
    \ + 0.5)\nend", "    return value\nend", "\treturn math.floor(tonumber(value)\
    \ + 0.5)\nend", "  local n = tonumber(value)\n  return n and math.floor(n + 0.5)\n\
    end", "  return math.floor(tonumber(value) + 0.5)\nend", "    local closest_int\
    \ = tonumber(value)\n    if (closest_int < 0) then\n        closest_int = closest_int\
    \ - 0.5\n    else\n        closest_int = closest_int + 0.5\n    end\n    return\
    \ math.floor(closest_int)\nend", "    if value == nil then\n        return nil\n\
    \    end\n    local n = tonumber(value)\n    if n == nil then\n        return\
    \ nil\n    end\n    local i = math.floor(n)\n    if n < 0 then\n        if n -\
    \ i <= i + 1 - n then\n            return i\n        else\n            return\
    \ i + 1\n        end\n    else\n        if n - i <= i + 1 - n then\n         \
    \   return i\n        else\n            return i + 1\n        end\n    end\nend",
  "    --TODO: Implement\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
