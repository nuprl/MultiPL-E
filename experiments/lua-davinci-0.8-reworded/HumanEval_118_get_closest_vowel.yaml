name: HumanEval_118_get_closest_vowel
language: lua
prompt: "-- You are given a word. Your task is to find the closest vowel that stands\
  \ between \n-- two consonants from the right side of the word (case sensitive).\n\
  -- Vowels in the beginning and ending doesn't count. Return empty string if you\
  \ didn't\n-- find any vowel met the above condition. \n-- You may assume that the\
  \ given string contains English letter only.\n-- Example:\n-- >>> get_closest_vowel('yogurt')\n\
  -- 'u'\n-- >>> get_closest_vowel('FULL')\n-- 'U'\n-- >>> get_closest_vowel('quick')\n\
  -- ''\n-- >>> get_closest_vowel('ab')\n-- ''\nlocal function get_closest_vowel(word)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_closest_vowel\n\
  \    lu.assertEquals(candidate('yogurt'), 'u')\n    lu.assertEquals(candidate('full'),\
  \ 'u')\n    lu.assertEquals(candidate('easy'), '')\n    lu.assertEquals(candidate('eAsy'),\
  \ '')\n    lu.assertEquals(candidate('ali'), '')\n    lu.assertEquals(candidate('bad'),\
  \ 'a')\n    lu.assertEquals(candidate('most'), 'o')\n    lu.assertEquals(candidate('ab'),\
  \ '')\n    lu.assertEquals(candidate('ba'), '')\n    lu.assertEquals(candidate('quick'),\
  \ '')\n    lu.assertEquals(candidate('anime'), 'i')\n    lu.assertEquals(candidate('Asia'),\
  \ '')\n    lu.assertEquals(candidate('Above'), 'o')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    -- Write your code here\n    local vowels = {'a', 'e', 'i', 'o',\
    \ 'u'}\n    for i = #word, 2, -1 do\n        local front, back = word:sub(i -\
    \ 1, i - 1), word:sub(i, i)\n        if not back:find('[aeiou]') and back:find('[A-Za-z]')\
    \ and not front:find('[aeiou]') and front:find('[A-Za-z]') then\n            return\
    \ back\n        end\n    end\n    return ''\nend", "    local vowels = {'a', 'e',\
    \ 'i', 'o', 'u'}\n    local vowels_str = 'aeiou'\n    local word_size = string.len(word)\n\
    \    local closest_vowel = ''\n    local found_vowel = false\n    local found_consonant\
    \ = false\n    local last_consonant = ''\n    local last_consonant_index = 0\n\
    \    for i = 1, word_size do\n        local char = string.sub(word, i, i)\n  \
    \      local is_vowel = string.find(vowels_str, char)\n        if is_vowel then\n\
    \            if found_consonant then\n                found_vowel = true\n   \
    \             if i - last_consonant_index < 3 then\n                    closest_vowel\
    \ = char\n                end\n            end\n        else\n            if found_vowel\
    \ then\n                last_consonant = char\n                last_consonant_index\
    \ = i\n                found_vowel = false\n            end\n        end\n   \
    \ end\n    return closest_vowel\nend", "  for i = #word - 1, 1, -1 do\n    local\
    \ right = word:sub(i, i)\n    local left = word:sub(i - 1, i - 1)\n    if is_consonant(right)\
    \ and is_consonant(left) then\n      return left\n    end\n  end\n  return ''\n\
    end", "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local is_consonant =\
    \ function(ch)\n        return not in_arr(vowels, ch)\n    end\n    local offset\
    \ = 0\n    local last_index\n    while offset < #word do\n        local index\
    \ = #word - offset\n        if is_consonant(word:sub(index, index)) then\n   \
    \         if last_index and is_consonant(word:sub(index - 1, index - 1)) then\n\
    \                return word:sub(index, index)\n            end\n            last_index\
    \ = index\n        end\n        offset = offset + 1\n    end\n    return ''\n\
    end", "\tlocal vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal ret = ''\n\tlocal index\
    \ = 0\n\tlocal state = 1\n\tlocal i = 0\n\tfor i = #word, 1, -1 do\n\t\tif state\
    \ == 1 then\n\t\t\tif table.indexof(vowels, word:sub(i, i)) ~= -1 then\n\t\t\t\
    \tstate = 2\n\t\t\tend\n\t\telseif state == 2 then\n\t\t\tif table.indexof(vowels,\
    \ word:sub(i, i)) == -1 then\n\t\t\t\tret = word:sub(i + 1, i + 1)\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn ret\nend", "    -- TODO: implement this function\n\
    end", "\tlocal vowels = \"aeiouAEIOU\"\n\tlocal consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n\tfor i = #word, 1, -1 do\n\t\tlocal char = word:sub(i, i)\n\t\tif vowels:find(char)\
    \ then\n\t\t\tif i == #word then return \"\" end\n\t\t\tif consonants:find(word:sub(i+1,\
    \ i+1)) then\n\t\t\t\treturn char\n\t\t\tend\n\t\tend\n\tend\n\treturn \"\"\n\
    end", "  local vowels = 'aeiouAEIOU'\n  local position = #word\n  while position\
    \ > 0 do\n    local char = word:sub(position, position)\n    if vowels:find(char)\
    \ then\n      local prev_char = word:sub(position - 1, position - 1)\n      if\
    \ prev_char == nil or vowels:find(prev_char) == nil then\n        return char\n\
    \      end\n    end\n    position = position - 1\n  end\n  return ''\nend", " \
    \ local vowel = \"aeiouAEIOU\"\n  local l = string.len(word)\n  for i = l,2,-1\
    \ do\n    if string.find(vowel,string.sub(word,i,i)) then\n      if not string.find(vowel,string.sub(word,i-1,i-1))\
    \ then\n        return string.sub(word,i,i)\n      end\n    end\n  end\n  return\
    \ \"\"\nend", end, "  if not word or word == '' then\n    return ''\n  end\n \
    \ local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local len = #word\n  local pos =\
    \ 0\n  local rword = string.reverse(word)\n  local left = nil\n  local right =\
    \ nil\n  local result = ''\n  for i=1, len do\n    left = string.sub(rword, i,\
    \ i)\n    right = string.sub(rword, i+1, i+1)\n    if left and right then\n  \
    \    if not contains(vowels, left) and not contains(vowels, right) then\n    \
    \    result = left\n        break\n      end\n    end\n  end\n  return result\n\
    end", "    for i = #word,1,-1 do\n        local index = word:sub(i,i)\n      \
    \  if index == 'a' or index == 'e' or index == 'i' or index == 'o' or index ==\
    \ 'u' or\n            index == 'A' or index == 'E' or index == 'I' or index ==\
    \ 'O' or index == 'U' then\n            return index\n        end\n    end\n \
    \   return ''\nend", "  if #word < 2 then\n    return ''\n  end\n  local length\
    \ = #word\n  local closest_vowel = ''\n  local length_to_vowel = length\n  for\
    \ i = length, 2, -1 do\n    local char = word:sub(i, i)\n    if char == 'a' or\
    \ char == 'e' or char == 'i' or char == 'o' or char == 'u' or\n       char ==\
    \ 'A' or char == 'E' or char == 'I' or char == 'O' or char == 'U' then\n     \
    \ if i < length_to_vowel then\n        closest_vowel = char\n        length_to_vowel\
    \ = i\n      end\n    end\n  end\n  return closest_vowel\nend", "\tlocal vowels\
    \ = {'a', 'e', 'i', 'o', 'u'}\n\tlocal consonants = {'b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'}\n\
    \tlocal closest_vowel = ''\n\tlocal closest_index = nil\n\tlocal vowel_index =\
    \ nil\n\tfor i = #word, 1, -1 do\n\t\tfor _, v in ipairs(vowels) do\n\t\t\tif\
    \ word:sub(i, i) == v then\n\t\t\t\tvowel_index = i\n\t\t\t\tbreak\n\t\t\tend\n\
    \t\tend\n\t\tif vowel_index then\n\t\t\tfor _, v in ipairs(consonants) do\n\t\t\
    \t\tif word:sub(i, i) == v then\n\t\t\t\t\tif i > vowel_index then\n\t\t\t\t\t\
    \tclosest_index = i\n\t\t\t\t\t\tclosest_vowel = word:sub(vowel_index, vowel_index)\n\
    \t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif closest_index\
    \ then\n\t\t\tbreak\n\t\tend\n\tend\n\treturn closest_vowel\nend", "  \nend",
  "  if #word < 2 then return '' end\n  local vowels = { 'a', 'e', 'i', 'o', 'u' }\n\
    \  local rev_w = string.reverse(word)\n  local prev = ''\n  for i=1,#rev_w do\n\
    \    if prev == '' then\n      if table.contains(vowels, rev_w:sub(i,i)) then\n\
    \        prev = rev_w:sub(i,i)\n      end\n    else\n      if table.contains(vowels,\
    \ rev_w:sub(i,i)) then\n        return prev\n      else\n        prev = ''\n \
    \     end\n    end\n  end\n  return ''\nend", "\t--[[\n\t-- if beginning and ending\
    \ of a word doesn't count, then split the word\n\t-- into a list of characters\
    \ and loop through the middle portion only\n\t-- return '' if the entire word\
    \ is a vowel; otherwise, return ''\n\tlocal list = {}\n\tfor c in word:gmatch(\"\
    .\") do\n\t\ttable.insert(list, c)\n\tend\n\tif #list < 3 then return '' end\n\
    \tlocal result = ''\n\tfor i = 2, #list - 1 do\n\t\tif not is_vowel(list[i]) then\n\
    \t\t\tif is_vowel(list[i-1]) and is_vowel(list[i+1]) then\n\t\t\t\tresult = list[i]\n\
    \t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn result\n\t--]]\n\t\n\t-- the\
    \ string.match() function returns the longest match and the start\n\t-- position\
    \ of the match for a given pattern\n\tlocal s, e = string.match(word, \"[^aeiouAEIOU]+([aeiouAEIOU]+)[^aeiouAEIOU]+\"\
    )\n\tif s and e then\n\t\treturn e\n\telse\n\t\treturn ''\n\tend\nend", "    --\
    \ TODO: return the closest vowel that stands between two consonants from the right\n\
    \    -- side of the word\n    -- For example, the closest vowel in yogurt is 'u'\n\
    \    -- The function is case sensitive, so the closest vowel in FULL is 'U'\n\
    \    -- The function should return empty string if no vowel stands between consonants.\n\
    \    -- For example, the closest vowel in quick is '', because there is no vowel\
    \ between\n    -- consonants.\n    -- You may assume that the given string contains\
    \ English letter only.\nend", "  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local\
    \ prev_i, prev_is_vowel, curr_i, curr_is_vowel\n  for i=1, #word do\n    prev_i\
    \ = #word - i\n    prev_is_vowel = false\n    curr_i = #word - i + 1\n    curr_is_vowel\
    \ = false\n    for _, char in ipairs(vowels) do\n      if word:sub(prev_i, prev_i)\
    \ == char then\n        prev_is_vowel = true\n      end\n      if word:sub(curr_i,\
    \ curr_i) == char then\n        curr_is_vowel = true\n      end\n    end\n   \
    \ if prev_is_vowel == false and curr_is_vowel == true then\n      return word:sub(curr_i,\
    \ curr_i)\n    end\n  end\n  return ''\nend", "    local result = ''\n    local\
    \ pos = word:len()\n    local vowel = false\n    while pos > 0 do\n        local\
    \ c = word:sub(pos, pos)\n        if string.find(c, '[aeiouAEIOU]') then\n   \
    \         if not vowel then\n                vowel = true\n            else\n\
    \                result = c\n                break\n            end\n        else\n\
    \            vowel = false\n        end\n        pos = pos - 1\n    end\n    return\
    \ result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
