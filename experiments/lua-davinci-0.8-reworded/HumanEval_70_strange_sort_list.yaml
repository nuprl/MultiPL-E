name: HumanEval_70_strange_sort_list
language: lua
prompt: "-- Given table of integers, return table in strange order.\n-- Strange sorting,\
  \ is when you start with the minimum value,\n-- then maximum of the remaining integers,\
  \ then minimum and so on.\n-- Examples:\n-- >>> strange_sort_list({1, 2, 3, 4})\n\
  -- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>>\
  \ strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5,\
  \ 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}),\
  \ {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5,\
  \ 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}),\
  \ {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3,\
  \ 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5,\
  \ -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\
  \nos.exit(lu.LuaUnit.run())"
completions: ["  local ret = {}\n  local f = false\n  local m = -math.huge\n  local\
    \ min = math.huge\n  for _, v in ipairs(lst) do\n    if v < min then\n      min\
    \ = v\n    end\n    if v > m then\n      m = v\n    end\n  end\n  while true do\n\
    \    if not f then\n      table.insert(ret, min)\n      f = true\n    else\n \
    \     table.insert(ret, m)\n      f = false\n    end\n    if min == m then\n \
    \     break\n    end\n    if not f then\n      lst[min] = 0\n      min = math.huge\n\
    \      for _, v in ipairs(lst) do\n        if v < min then\n          min = v\n\
    \        end\n      end\n    else\n      lst[m] = 0\n      m = -math.huge\n  \
    \    for _, v in ipairs(lst) do\n        if v > m then\n          m = v\n    \
    \    end\n      end\n    end\n  end\n  return ret\nend", "    return lst\nend",
  "    local ret = {}\n    local i = 1\n    local m = {}\n    local e = {}\n    local\
    \ t = {}\n    for _, v in ipairs(lst) do\n        if v < 0 then\n            e[#e\
    \ + 1] = v\n        elseif v > 0 then\n            m[#m + 1] = v\n        else\n\
    \            t[#t + 1] = v\n        end\n    end\n    local m_ = {}\n    for _,\
    \ v in ipairs(m) do\n        m_[#m_ + 1] = -v\n    end\n    local mm = {}\n  \
    \  for _, v in ipairs(m_) do\n        mm[#mm + 1] = {v, i}\n        i = i + 1\n\
    \    end\n    local mmm = {}\n    for _, v in ipairs(mm) do\n        mmm[#mmm\
    \ + 1] = v\n    end\n    local ee = {}\n    for _, v in ipairs(e) do\n       \
    \ ee[#ee + 1] = {v, i}\n        i = i + 1\n    end\n    local tt = {}\n    for\
    \ _, v in ipairs(t) do\n        tt[#tt + 1] = {v, i}\n        i = i + 1\n    end\n\
    \    table.sort(mmm, function(a, b) return a[1] < b[1] end)\n    table.sort(ee,\
    \ function(a, b) return a[1] < b[1] end)\n    table.sort(tt, function(a, b) return\
    \ a[1] < b[1] end)\n    local a = math.floor(#mmm / 2)\n    local b = math.floor(#ee\
    \ / 2)\n    local c = math.floor(#tt / 2)\n    for i = 1, a do\n        ret[#ret\
    \ + 1] = mmm[i][1]\n        ret[#ret + 1] = mmm[#mmm - i + 1][1]\n    end\n  \
    \  if a * 2 ~= #mmm then\n        ret[#ret + 1] = mmm[a + 1][1]\n", "  local sorted_lst\
    \ = {}\n  while #lst > 0 do\n    table.insert(sorted_lst, table.remove(lst, 1))\n\
    \    if #lst > 0 then\n      table.insert(sorted_lst, table.remove(lst))\n   \
    \ end\n  end\n  return sorted_lst\nend", "   local idx = 0\n   local min = 0\n\
    \   local max = 0\n   local new = {}\n   local count = 0\n   local i = 0\n   while\
    \ count < #lst do\n      min = math.min(unpack(lst))\n      idx = table.index_of(lst,\
    \ min)\n      lst[idx] = math.huge\n      table.insert(new, min)\n      count\
    \ = count + 1\n      i = i + 1\n      if i < #lst then\n         max = math.max(unpack(lst))\n\
    \         idx = table.index_of(lst, max)\n         lst[idx] = -math.huge\n   \
    \      table.insert(new, max)\n         count = count + 1\n         i = i + 1\n\
    \      end\n   end\n   return new\nend", "  -- your code here\nend", "    local\
    \ sorted = { table.remove(lst, 1) }\n    local n = #lst\n    for i = 1, n / 2\
    \ do\n        table.insert(sorted, table.remove(lst, 1))\n        table.insert(sorted,\
    \ table.remove(lst))\n    end\n    return sorted\nend", "    local lst, result\
    \ = tcopy(lst), {}\n    table.sort(lst)\n    for i = 1, #lst do\n        if i\
    \ % 2 == 1 then\n            result[#result + 1] = table.remove(lst, 1)\n    \
    \    else\n            result[#result + 1] = table.remove(lst)\n        end\n\
    \    end\n    return result\nend", "    if #lst < 2 then\n        return lst\n\
    \    end\n    local min, max = min_max(lst)\n    local l1, l2 = {}, {}\n    for\
    \ _, n in ipairs(lst) do\n        if n == min or n == max then\n            table.insert(l1,\
    \ n)\n        else\n            table.insert(l2, n)\n        end\n    end\n  \
    \  return strange_sort_list(l1) .. strange_sort_list(l2)\nend", "    local result\
    \ = {}\n    local from_min = true\n    local i = 1\n    while #lst > 0 do\n  \
    \      local min = math.min(unpack(lst))\n        local max = math.max(unpack(lst))\n\
    \        if from_min then\n            table.insert(result, min)\n           \
    \ table.remove(lst, i)\n            from_min = false\n        else\n         \
    \   table.insert(result, max)\n            table.remove(lst, i)\n            from_min\
    \ = true\n        end\n    end\n    return result\nend", "  local function function_in_function(lst,\
    \ l, r)\n    -- Find minimum and maximum values, and their positions.\n    local\
    \ n, n_pos, x, x_pos = lst[l], l, lst[l], l\n    for i = l + 1, r do\n      if\
    \ lst[i] < n then\n        n, n_pos = lst[i], i\n      end\n      if lst[i] >\
    \ x then\n        x, x_pos = lst[i], i\n      end\n    end\n    -- If some value\
    \ is not on its place (its position is different from the\n    -- current index\
    \ in table), it means we have to put it on its place.\n    -- Otherwise, we have\
    \ to put value that is on wrong place.\n    if n_pos ~= l then\n      return n,\
    \ n_pos\n    else\n      return x, x_pos\n    end\n  end\n  -- Initialize table\
    \ with minimum value on first position.\n  local n, n_pos = function_in_function(lst,\
    \ 1, #lst)\n  lst[n_pos] = lst[1]\n  lst[1] = n\n  local current_idx = 2\n  --\
    \ Loop until all values are on the right place.\n  while current_idx <= #lst do\n\
    \    n, n_pos = function_in_function(lst, current_idx, #lst)\n    -- Put value\
    \ on the current place.\n    lst[n_pos] = lst[current_idx]\n    lst[current_idx]\
    \ = n\n    current_idx = current_idx + 1\n  end\n  return lst\nend", "    local\
    \ res = {}\n    local n = 0\n    local m = 0\n    local lst_len = #lst\n    local\
    \ min_elems = {}\n    local max_elems = {}\n    for _, v in ipairs(lst) do\n \
    \       if v == min(lst) then\n            n = n + 1\n            min_elems[n]\
    \ = v\n        elseif v == max(lst) then\n            m = m + 1\n            max_elems[m]\
    \ = v\n        end\n    end\n    local s = n > m and n or m\n    for i = 1, lst_len\
    \ do\n        if i % 2 == 1 then\n            res[i] = min_elems[i / 2 + 1]\n\
    \        else\n            res[i] = max_elems[i / 2]\n        end\n    end\n \
    \   return res\nend", "    local min_value = min(lst)\n    local min_indeces =\
    \ find_all(lst, min_value)\n    local max_value = max(lst)\n    local max_indeces\
    \ = find_all(lst, max_value)\n    local sorted_list = {}\n    local minimum =\
    \ true\n    local elements_left = #lst", "    local function min_max(lst)\n  \
    \      local min_index = nil\n        local max_index = nil\n        local min\
    \ = math.huge\n        local max = -math.huge\n        for i = 1, #lst do\n  \
    \          if lst[i] < min then\n                min = lst[i]\n              \
    \  min_index = i\n            end\n            if lst[i] > max then\n        \
    \        max = lst[i]\n                max_index = i\n            end\n      \
    \  end\n        return min_index, max_index\n    end\n    local function generate_sequence(N)\n\
    \        local n = 1\n        local sequence = {}\n        for i = 1, N do\n \
    \           if i % 2 == 1 then\n                sequence[i] = n\n            else\n\
    \                sequence[i] = N - n + 1\n            end\n            n = n +\
    \ 1\n        end\n        return sequence\n    end\n    local function strange_sort(lst)\n\
    \        local res = {}\n        local N = #lst\n        local seq = generate_sequence(N)\n\
    \        local lst_copy = utils.table_copy(lst)\n        local min_index, max_index\
    \ = min_max(lst_copy)\n        res[1] = lst_copy[min_index]\n        table.remove(lst_copy,\
    \ min_index)\n        table.remove(lst_copy, max_index - 1)\n        for i = 2,\
    \ N do\n            min_index, max_index = min_max(lst_copy)\n            res[seq[i]]\
    \ = lst_copy[i % 2 == 1 and min_index or max_index]\n            table.remove(lst_copy,\
    \ min_index)\n            table.remove(lst_copy, max_index - 1)\n        end\n\
    \        return res\n    end\n    return strange_sort(lst)\nend", "    if not\
    \ lst or #lst == 0 then\n        return {}\n    end\n    local tbl = {}\n    local\
    \ len = #lst\n    table.sort(lst)\n    local is_min = true\n    for i = 1, len\
    \ do\n        local to_index = i\n        if is_min then\n            to_index\
    \ = 1\n        else\n            to_index = len - i + 1\n        end\n       \
    \ tbl[i] = lst[to_index]\n        table.remove(lst, to_index)\n        is_min\
    \ = not is_min\n    end\n    return tbl\nend", "\tlocal result = {}\n\twhile #lst\
    \ > 0 do\n\t\tlocal min_index = min_index_list(lst)\n\t\tlocal max_index = max_index_list(lst)\n\
    \t\tif min_index < max_index then\n\t\t\ttable.insert(result, lst[min_index])\n\
    \t\t\ttable.insert(result, lst[max_index])\n\t\t\ttable.remove(lst, max_index)\n\
    \t\t\ttable.remove(lst, min_index)\n\t\telse\n\t\t\ttable.insert(result, lst[max_index])\n\
    \t\t\ttable.insert(result, lst[min_index])\n\t\t\ttable.remove(lst, min_index)\n\
    \t\t\ttable.remove(lst, max_index)\n\t\tend\n\tend\n\treturn result\nend", " \
    \ local res = {}\n  while #lst > 0 do\n    -- min\n    local min = lst[1]\n  \
    \  local min_index = 1\n    for i = 2, #lst do\n      if lst[i] < min then\n \
    \       min = lst[i]\n        min_index = i\n      end\n    end\n    table.insert(res,\
    \ min)\n    table.remove(lst, min_index)\n    -- max\n    local max = lst[1]\n\
    \    local max_index = 1\n    for i = 2, #lst do\n      if lst[i] > max then\n\
    \        max = lst[i]\n        max_index = i\n      end\n    end\n    table.insert(res,\
    \ max)\n    table.remove(lst, max_index)\n  end\n  return res\nend", "  local\
    \ a = {}\n  for _, v in ipairs(lst) do\n    a[#a + 1] = v\n  end\n  local n =\
    \ #a\n  local ans = {}\n  local function aux(idx)\n    if idx > n then\n     \
    \ return\n    end\n    local mn, mnidx = a[1], 1\n    local mx, mxidx = a[1],\
    \ 1\n    for i = 2, n do\n      if a[i] < mn then\n        mn, mnidx = a[i], i\n\
    \      end\n      if a[i] > mx then\n        mx, mxidx = a[i], i\n      end\n\
    \    end\n    a[mnidx] = math.huge\n    ans[#ans + 1] = mn\n    a[mxidx] = -math.huge\n\
    \    ans[#ans + 1] = mx\n    aux(idx + 2)\n  end\n  aux(1)\n  return ans\nend",
  "  if lst[1] == nil then\n    return {}\n  end\n  local result = {}\n  local maxs\
    \ = {}\n  local mins = {}\n  local i = 1\n  local j = 1\n  local count = #lst\n\
    \  for n = 1, count do\n    if n % 2 == 1 then\n      result[n] = math.min(unpack(lst))\n\
    \      mins[i] = result[n]\n      i = i + 1\n    else\n      local max = math.max(unpack(lst))\n\
    \      if mins[i - 1] == max then\n        max = math.max(unpack(maxs))\n    \
    \  end\n      result[n] = max\n      maxs[j] = max\n      j = j + 1\n    end\n\
    \  end\n  return result\nend", "    local rsl = {}\n    local tmp = table_copy(lst)\n\
    \    local min_i = table_min_index(tmp)\n    local min = table_remove(tmp, min_i)\n\
    \    local max_i = table_max_index(tmp)\n    local max = table_remove(tmp, max_i)\n\
    \    local iter = 1\n    while min ~= nil or max ~= nil do\n        if iter %\
    \ 2 == 1 then\n            rsl[#rsl + 1] = min\n            min_i = table_min_index(tmp)\n\
    \            min = table_remove(tmp, min_i)\n        else\n            rsl[#rsl\
    \ + 1] = max\n            max_i = table_max_index(tmp)\n            max = table_remove(tmp,\
    \ max_i)\n        end\n        iter = iter + 1\n    end\n    return rsl\nend",
  "\tlocal o = {}\n\tlocal n = #lst\n\tlocal s = 1\n\twhile n > 0 do\n\t\ttable.insert(o,\
    \ table.remove(lst, s))\n\t\tn = n - 1\n\t\tif n == 0 then break end\n\t\ttable.insert(o,\
    \ table.remove(lst, n))\n\t\tn = n - 1\n\t\ts = s + 1\n\tend\n\treturn o\nend",
  "    local min = min or math.min\n    local max = max or math.max\n    local r =\
    \ {}\n    local p = 0\n    local sorted = sorted or table.sort\n    local insert\
    \ = insert or table.insert\n    sorted(lst)\n    while #lst ~= 0 do\n        if\
    \ p % 2 == 0 then\n            insert(r, min(unpack(lst)))\n        else\n   \
    \         insert(r, max(unpack(lst)))\n        end\n        for k,v in pairs(lst)\
    \ do\n            if v == r[#r] then\n                table.remove(lst, k)\n \
    \               break\n            end\n        end\n        p = p + 1\n    end\n\
    \    return r\nend", "    local res = {}\n    table.sort(lst)\n    local i, j\
    \ = 1, #lst\n    while i <= #lst do\n        res[i] = lst[i]\n        res[j] =\
    \ lst[j]\n        i = i + 1\n        j = j - 1\n    end\n    return res\nend",
  "  if #lst == 0 then\n    return {}\n  end\n  local get_next_idx = coroutine.wrap(function()\n\
    \    local idx_is_plus, min_idx = true, 1\n    while true do\n      if idx_is_plus\
    \ then\n        idx_is_plus = false\n        min_idx = min_idx + 1\n      else\n\
    \        idx_is_plus = true\n        min_idx = #lst - min_idx + 1\n      end\n\
    \      coroutine.yield(min_idx)\n    end\n  end)\n  local result = {}\n  for _\
    \ = 1, #lst do\n    local idx = get_next_idx()\n    table.insert(result, lst[idx])\n\
    \    table.remove(lst, idx)\n  end\n  return result\nend", "    local t = {}\n\
    \    local odd = true\n    local i = 1\n    while #lst > 0 do\n        local j\
    \ = odd and 1 or #lst\n        t[i] = lst[j]\n        table.remove(lst, j)\n \
    \       i = i + 1\n        odd = not odd\n    end\n    return t\nend", "  if #lst\
    \ == 0 then\n    return {}\n  end\n  local sorted = table.copy(lst)\n  table.sort(sorted)\n\
    \  local res = {}\n  local min, max = 1, #sorted\n  while min <= max do\n    table.insert(res,\
    \ sorted[min])\n    if min < max then\n      table.insert(res, sorted[max])\n\
    \    end\n    min = min + 1\n    max = max - 1\n  end\n  return res\nend", " \
    \   local a, b = {}, {}\n    while #lst > 0 do\n        table.insert(a, math.min(unpack(lst)))\n\
    \        table.remove(lst, table.index_of(lst, math.min(unpack(lst))))\n     \
    \   if #lst > 0 then\n            table.insert(b, math.max(unpack(lst)))\n   \
    \         table.remove(lst, table.index_of(lst, math.max(unpack(lst))))\n    \
    \    end\n    end\n    return table.merge(a, b)\nend", "    local res = {}\n \
    \   local lst_len = #lst\n    local lst_sorted = table.sort(lst)\n    local j\
    \ = 1\n    local k = 1\n    local res_len = 0\n    for i = 1, lst_len do\n   \
    \     res[j] = lst_sorted[i]\n        res_len = res_len + 1\n        if k % 2\
    \ == 0 then\n            j = j + 1\n        else\n            j = j - 1\n    \
    \    end\n        k = k + 1\n    end\n    if j < 0 then\n        j = j + 1\n \
    \   end\n    return table.move(res, j, res_len, 1, {})\nend", "  local res, left,\
    \ right = {}, {}, {}\n  for _, v in ipairs(lst) do\n    if #left == 0 or v < left[1]\
    \ then\n      table.insert(left, v)\n    else\n      table.insert(right, v)\n\
    \    end\n  end\n  for i = 1, #left + #right do\n    if i % 2 == 1 then\n    \
    \  table.insert(res, table.remove(left, 1))\n    else\n      table.insert(res,\
    \ table.remove(right, 1))\n    end\n  end\n  return res\nend", "  if #lst == 0\
    \ then\n    return {}\n  end\n  local sorted = {}\n  local min = math.min(unpack(lst))\n\
    \  table.insert(sorted, min)\n  table.remove(lst, index_of(lst, min))\n  local\
    \ max = math.max(unpack(lst))\n  table.insert(sorted, max)\n  table.remove(lst,\
    \ index_of(lst, max))\n  local function sort(sorted, lst)\n    if #lst == 0 then\n\
    \      return sorted\n    end\n    local min = math.min(unpack(lst))\n    table.insert(sorted,\
    \ min)\n    table.remove(lst, index_of(lst, min))\n    local max = math.max(unpack(lst))\n\
    \    table.insert(sorted, max)\n    table.remove(lst, index_of(lst, max))\n  \
    \  return sort(sorted, lst)\n  end\n  return sort(sorted, lst)\nend", "    local\
    \ result = {}\n    local tbl = {}\n    for _, v in ipairs(lst) do\n        tbl[#tbl\
    \ + 1] = v\n    end\n    table.sort(tbl)\n    local length = #tbl\n    for i=1,\
    \ length, 2 do\n        result[#result + 1] = tbl[i]\n        result[#result +\
    \ 1] = tbl[length - i + 1]\n    end\n    return result\nend", "    local result\
    \ = {}\n    if #lst == 0 then\n        return result\n    end\n    local min_value\
    \ = math.min(unpack(lst))\n    local max_value = math.max(unpack(lst))\n    local\
    \ order = true\n    while #lst > 0 do\n        local next_value\n        if order\
    \ then\n            next_value = min_value\n        else\n            next_value\
    \ = max_value\n        end\n        for i, v in ipairs(lst) do\n            if\
    \ v == next_value then\n                table.insert(result, next_value)\n   \
    \             table.remove(lst, i)\n                break\n            end\n \
    \       end\n        min_value = math.min(unpack(lst))\n        max_value = math.max(unpack(lst))\n\
    \        order = not order\n    end\n    return result\nend", "  local result\
    \ = {}\n  local reversed = false\n  local loop = true\n  local index = 0\n  local\
    \ cur_index = 1\n  local tmp = 0\n  local min = lst[1]\n  local max = lst[1]\n\
    \  while loop do\n    loop = false\n    cur_index = 1\n    min = lst[1]\n    max\
    \ = lst[1]\n    for i, v in ipairs(lst) do\n      if v < min then\n        min\
    \ = v\n        cur_index = i\n      end\n      if v > max then\n        max =\
    \ v\n      end\n    end\n    if reversed then\n      result[index + 1] = min\n\
    \      lst[cur_index] = max\n    else\n      result[index + 1] = max\n      lst[cur_index]\
    \ = min\n    end\n    index = index + 1\n    if #lst ~= 0 then\n      loop = true\n\
    \    end\n    reversed = not reversed\n  end\n  return result\nend", "    if (#lst\
    \ == 0) then\n        return {}\n    end\n    table.sort(lst)\n    local result\
    \ = {}\n    local i = 1\n    local j = #lst\n    while (i <= #lst) do\n      \
    \  result[i] = lst[i]\n        i = i + 1\n        if (i <= #lst) then\n      \
    \      result[i] = lst[j]\n            j = j - 1\n            i = i + 1\n    \
    \    end\n    end\n    return result\nend", "  local odd_numbers = []\n  local\
    \ even_numbers = []\n  for index, value in pairs(lst) do\n    if index % 2 ==\
    \ 0 then\n      even_numbers[#even_numbers + 1] = value\n    else\n      odd_numbers[#odd_numbers\
    \ + 1] = value\n    end\n  end\n  table.sort(odd_numbers)\n  table.sort(even_numbers,\
    \ function(a, b) return a > b end)\n  local result = {}\n  for index, value in\
    \ pairs(odd_numbers) do\n    result[#result + 1] = value\n    result[#result +\
    \ 1] = even_numbers[index]\n  end\n  return result\nend", "  local n = #lst\n\
    \  if n == 0 then return {} end\n  local sorted_lst = {}\n  local min_ind, max_ind\n\
    \  -- Get initial min and max indices.\n  min_ind, max_ind = 1, 1\n  for i = 2,\
    \ n do\n    if lst[i] < lst[min_ind] then min_ind = i end\n    if lst[i] > lst[max_ind]\
    \ then max_ind = i end\n  end\n  -- Sort table.\n  local cur_ind = min_ind\n \
    \ for i = 1, n do\n    sorted_lst[i] = lst[cur_ind]\n    if i % 2 == 0 then\n\
    \      cur_ind = max_ind\n      for j = 1, n do\n        if lst[j] > lst[cur_ind]\
    \ and j ~= min_ind then\n          cur_ind = j\n        end\n      end\n    else\n\
    \      cur_ind = min_ind\n      for j = 1, n do\n        if lst[j] < lst[cur_ind]\
    \ and j ~= max_ind then\n          cur_ind = j\n        end\n      end\n    end\n\
    \  end\n  return sorted_lst\nend", "\tlocal out, odd, even = {}, {}, {}\n\tfor\
    \ _, item in ipairs(lst) do\n\t\tlocal min = min_value(lst)\n\t\tlocal max = max_value(lst)\n\
    \t\tif item == min then\n\t\t\ttable.insert(out, min)\n\t\telseif item == max\
    \ then\n\t\t\ttable.insert(out, max)\n\t\tend\n\t\tlst = slice(lst, 2, -2)\n\t\
    end\n\treturn out\nend", "  if #lst == 0 then\n    return {}\n  end\n  -- \u041D\
    \u0430\u0439\u0434\u0435\u043C \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\
    \u043D\u044B\u0439 \u044D\u043B\u0435\u043C\u0435\u043D\u0442, \u043F\u0440\u043E\
    \u0434\u043E\u043B\u0436\u0438\u043C \u0441\u043E\u0440\u0442\u0438\u0440\u043E\
    \u0432\u043A\u0443 \u043E\u0442 \u043D\u0435\u0433\u043E.\n  local min_index =\
    \ 1\n  for i, v in ipairs(lst) do\n    if v < lst[min_index] then\n      min_index\
    \ = i\n    end\n  end\n  local min_val = lst[min_index]\n  table.remove(lst, min_index)\n\
    \  -- \u041F\u043E\u0441\u0442\u0440\u043E\u0438\u043C \u0441\u0442\u0440\u0430\
    \u043D\u043D\u0443\u044E \u0441\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\
    \u0443 \u043E\u0442 \u043E\u0441\u0442\u0430\u0432\u0448\u0438\u0445\u0441\u044F\
    \ \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432.\n  local sorted_remaining\
    \ = strange_sort_list(lst)\n  -- \u041F\u043E\u0441\u0442\u0440\u043E\u0438\u043C\
    \ \u0440\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442.\n  local result = {min_val}\n\
    \  for i, v in ipairs(sorted_remaining) do\n    if i % 2 == 0 then\n      table.insert(result,\
    \ 1, v)\n    else\n      table.insert(result, v)\n    end\n  end\n  return result\n\
    end", "  local result = {}\n  local lst_copy = copy_list(lst)\n  local len = #lst_copy\n\
    \  for i = 1, len do\n    local min_index = find_min_index(lst_copy)\n    local\
    \ max_index = find_max_index(lst_copy)\n    if i % 2 == 1 then\n      result[i]\
    \ = lst_copy[min_index]\n      table.remove(lst_copy, min_index)\n    else\n \
    \     result[i] = lst_copy[max_index]\n      table.remove(lst_copy, max_index)\n\
    \    end\n  end\n  return result\nend", "    local first_index, last_index, current_index,\
    \ ordered_list = 1, #lst, 1, {}\n    while (first_index <= last_index) do\n  \
    \      ordered_list[current_index] = lst[first_index]\n        ordered_list[current_index\
    \ + 1] = lst[last_index]\n        first_index = first_index + 1\n        last_index\
    \ = last_index - 1\n        current_index = current_index + 2\n    end\n    return\
    \ ordered_list\nend", "  if #lst < 2 then\n    return lst\n  end\n  table.sort(lst)\n\
    \  local result = {}\n  local pos = 1\n  local i = 1\n  local j = #lst\n  local\
    \ middle = math.floor(#lst / 2)\n  while i <= middle do\n    result[pos] = lst[i]\n\
    \    result[pos + 1] = lst[j]\n    i = i + 1\n    j = j - 1\n    pos = pos + 2\n\
    \  end\n  if pos <= #lst then\n    result[pos] = lst[i]\n  end\n  return result\n\
    end", "  local res = {}\n  while #lst > 0 do\n    local min, max = lst[1], lst[1]\n\
    \    for i = 2, #lst do\n      if lst[i] < min then\n        min = lst[i]\n  \
    \    elseif lst[i] > max then\n        max = lst[i]\n      end\n    end\n    for\
    \ i = 1, #lst do\n      if lst[i] == min then\n        table.insert(res, min)\n\
    \        table.remove(lst, i)\n        break\n      elseif lst[i] == max then\n\
    \        table.insert(res, max)\n        table.remove(lst, i)\n        break\n\
    \      end\n    end\n  end\n  return res\nend", "    local function append(t1,\
    \ t2)\n        for _, v in ipairs(t2) do\n            table.insert(t1, v)\n  \
    \      end\n        return t1\n    end", "    local sorted_list = {}\n    local\
    \ left_list = {}\n    local step = 1\n    while #lst > 0 do\n        -- Find min,\
    \ max values.\n        local min, max = lst[1], lst[1]\n        for _, v in ipairs(lst)\
    \ do\n            if v < min then\n                min = v\n            end\n\
    \            if v > max then\n                max = v\n            end\n     \
    \   end\n        -- Add value to list\n        if step % 2 == 1 then\n       \
    \     table.insert(sorted_list, min)\n        else\n            table.insert(sorted_list,\
    \ max)\n        end\n        -- Split sorted and left lists.\n        left_list\
    \ = {}\n        for _, v in ipairs(lst) do\n            if v ~= min and v ~= max\
    \ then\n                table.insert(left_list, v)\n            end\n        end\n\
    \        -- Modify lists\n        lst = left_list\n        step = step + 1\n \
    \   end\n    return sorted_list\nend", "  local ret = {}\n  local need_min = true\n\
    \  local min_num, max_num, min_idx, max_idx\n  for i = 1, #lst do\n    if need_min\
    \ then\n      min_num, min_idx = nil, nil\n      for j = 1, #lst do\n        if\
    \ not is_elem(lst[j], ret) then\n          if not min_num or lst[j] < min_num\
    \ then\n            min_num, min_idx = lst[j], j\n          end\n        end\n\
    \      end\n      need_min = false\n      table.insert(ret, min_num)\n    else\n\
    \      max_num, max_idx = nil, nil\n      for j = 1, #lst do\n        if not is_elem(lst[j],\
    \ ret) then\n          if not max_num or lst[j] > max_num then\n            max_num,\
    \ max_idx = lst[j], j\n          end\n        end\n      end\n      need_min =\
    \ true\n      table.insert(ret, max_num)\n    end\n  end\n  return ret\nend",
  "    -- YOUR CODE HERE\n    -- I choosed bubble sort.\n    -- If there are two elements\
    \ in the list, return the list in the same order.\n    if #lst == 2 then\n   \
    \     return lst\n    end\n    -- If there are more than two elements in the list,\n\
    \    -- we sort them in strange order.\n    for i = 1, #lst do\n        for j\
    \ = i + 1, #lst do\n            -- Compare two elements and find the minimum value.\n\
    \            if lst[i] > lst[j] then\n                lst[i], lst[j] = lst[j],\
    \ lst[i]\n            end\n        end\n    end\n    -- After the list is sorted\
    \ in ascending order,\n    -- we swap the first and second element in the list.\n\
    \    lst[1], lst[2] = lst[2], lst[1]\n    -- Return the strange sorted list.\n\
    \    return lst\nend", "    if #lst <= 1 then\n        return lst\n    end\n \
    \   local min, max, result = lst[1], lst[1], {}\n    for i = 1, #lst do\n    \
    \    min = math.min(min, lst[i])\n        max = math.max(max, lst[i])\n    end\n\
    \    local i, j = 1, #lst\n    local up = true\n    while i <= j do\n        if\
    \ up then\n            result[i] = min\n            min = min + 1\n          \
    \  up = false\n        else\n            result[j] = max\n            max = max\
    \ - 1\n            up = true\n        end\n        i = i + 1\n        j = j -\
    \ 1\n    end\n    return result\nend", "  -- List is empty\n  if #lst == 0 then\n\
    \    return {}\n  end", "    if #lst == 0 then\n        return {}\n    end\n \
    \   local sorted = {}\n    local sorted_len = 0\n    local cur_idx\n    local\
    \ rem_values = {}\n    for idx, val in ipairs(lst) do\n        rem_values[val]\
    \ = (rem_values[val] or 0) + 1\n    end\n    while true do\n        cur_idx =\
    \ nil\n        for idx, val in ipairs(lst) do\n            if rem_values[val]\
    \ > 0 then\n                if cur_idx == nil or lst[cur_idx] > val then\n   \
    \                 cur_idx = idx\n                end\n            end\n      \
    \  end\n        if cur_idx == nil then\n            break\n        end\n     \
    \   sorted_len = sorted_len + 1\n        sorted[sorted_len] = lst[cur_idx]\n \
    \       rem_values[lst[cur_idx]] = rem_values[lst[cur_idx]] - 1\n        if rem_values[lst[cur_idx]]\
    \ == 0 then\n            rem_values[lst[cur_idx]] = nil\n        end\n    end\n\
    \    return sorted\nend", "    local res, odd, even = {}, {}, {}\n    local max_lst,\
    \ min_lst = math.max(unpack(lst)), math.min(unpack(lst))\n    -- Find numbers\
    \ to work with.\n    for i, x in ipairs(lst) do\n        if x ~= max_lst and x\
    \ ~= min_lst then\n            if i % 2 == 0 then\n                even[#even\
    \ + 1] = x\n            else\n                odd[#odd + 1] = x\n            end\n\
    \        end\n    end\n    -- Sort numbers in the lists.\n    table.sort(odd)\n\
    \    table.sort(even)\n    -- Merge numbers into one list.\n    for i = 1, #lst\
    \ do\n        if i % 2 == 0 then\n            if #even == 0 then\n           \
    \     res[i] = max_lst\n            else\n                res[i] = even[#even]\n\
    \                even[#even] = nil\n            end\n        else\n          \
    \  if #odd == 0 then\n                res[i] = min_lst\n            else\n   \
    \             res[i] = odd[#odd]\n                odd[#odd] = nil\n          \
    \  end\n        end\n    end\n    return res\nend", "  if #lst == 0 then\n   \
    \ return {}\n  end\n  if #lst == 1 then\n    return lst\n  end\n  if #lst == 2\
    \ then\n    if lst[1] > lst[2] then\n      return {lst[2], lst[1]}\n    else\n\
    \      return lst\n    end\n  end\n  local result = {}\n  local t = {}\n  local\
    \ function init_t(t)\n    for i, v in ipairs(lst) do\n      t[i] = v\n    end\n\
    \  end\n  local function find_minimum()\n    local min = t[1]\n    local min_i\
    \ = 1\n    for i, v in ipairs(t) do\n      if v < min then\n        min = v\n\
    \        min_i = i\n      end\n    end\n    return min, min_i\n  end\n  local\
    \ function find_maximum()\n    local max = t[1]\n    local max_i = 1\n    for\
    \ i, v in ipairs(t) do\n      if v > max then\n        max = v\n        max_i\
    \ = i\n      end\n    end\n    return max, max_i\n  end\n  local function del_at(i)\n\
    \    local result = {}\n    for j, v in ipairs(t) do\n      if j ~= i then\n \
    \       table.insert(result, v)\n      end\n    end\n    return result\n  end\n\
    \  local function turn()\n    if #t == 0 then\n      return\n    end\n    if #t\
    \ == 1 then\n      table.insert(result, t[1])\n      return\n    end\n    if #t\
    \ == 2 then\n      if t[1] > t[2] then\n        table.insert(result, t[2])\n \
    \       table.insert(result, t[1])\n      else\n        table.insert(result, t[1])\n\
    \        table.insert(result, t[2])\n      end\n      return\n    end\n    local\
    \ min, min_i = find_minimum()\n    table.insert(result, min)\n    t = del_at(min_i)\n\
    \    local max, max_", "  local new_lst = {}\n  local lst1 = copy_table(lst)\n\
    \  local lst2 = copy_table(lst)\n  table.sort(lst1)\n  table.sort(lst2, function(a,\
    \ b) return a > b end)\n  for i = 1, #lst do\n    local elem = table.remove(lst1,\
    \ 1)\n    table.insert(new_lst, elem)\n    if #lst1 > 0 then\n      elem = table.remove(lst2,\
    \ 1)\n      table.insert(new_lst, elem)\n    end\n  end\n  return new_lst\nend",
  "    local result = {}\n    local start, step = 1, 1\n    while #lst > 0 do\n  \
    \      if start == 1 then\n            -- get minimal element\n            local\
    \ idx, value = get_min(lst)\n            table.insert(result, value)\n       \
    \     table.remove(lst, idx)\n            start = 2\n        else\n          \
    \  -- get maximal element\n            local idx, value = get_max(lst)\n     \
    \       table.insert(result, value)\n            table.remove(lst, idx)\n    \
    \        start = 1\n        end\n    end\n    return result\nend", "    local\
    \ ret = {}\n    local rest = {}\n    local len = #lst\n    local len_ret = 0\n\
    \    while len_ret < len do\n        local min_i = 0\n        local min_v = math.huge\n\
    \        local max_i = 0\n        local max_v = -math.huge\n        for i,v in\
    \ ipairs(lst) do\n            if v < min_v then\n                min_i = i\n \
    \               min_v = v\n            end\n            if v > max_v then\n  \
    \              max_i = i\n                max_v = v\n            end\n       \
    \ end\n        if len_ret % 2 == 0 then\n            table.insert(ret, lst[min_i])\n\
    \            table.insert(rest, lst[max_i])\n        else\n            table.insert(ret,\
    \ lst[max_i])\n            table.insert(rest, lst[min_i])\n        end\n     \
    \   table.remove(lst, min_i)\n        table.remove(lst, max_i)\n        len_ret\
    \ = len_ret + 1\n    end\n    return ret\nend", "    local res = {}\n    local\
    \ c = {}\n    local i = 0\n    local c = 0\n    local s = 1\n    local res = {}\n\
    \    local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    for k,v in pairs(lst) do\n        if v == min then\n            min = nil\n\
    \            if max == nil then\n                break\n            end\n    \
    \    elseif v == max then\n            max = nil\n            if min == nil then\n\
    \                break\n            end\n        else\n            if i == 0 then\n\
    \                c = v\n                i = i + 1\n            elseif i == 1 then\n\
    \                c = math.min(c, v)\n                i = i + 1\n            elseif\
    \ i == 2 then\n                c = math.max(c, v)\n                i = i + 1\n\
    \            elseif i == 3 then\n                c = math.min(c, v)\n        \
    \        i = i + 1\n            elseif i == 4 then\n                c = math.max(c,\
    \ v)\n                i = i + 1\n            end\n            if i == 5 then\n\
    \                i = 0\n                table.insert(res, c)\n            end\n\
    \        end\n    end\n    if i == 1 then\n        table.insert(res, c)\n    elseif\
    \ i == 3 then\n        table.insert(res, c)\n    end\n    return res\nend", " \
    \   local new_lst = {}\n    while #lst > 0 do\n        table.insert(new_lst, table.remove(lst,\
    \ 1))\n        table.insert(new_lst, table.remove(lst, #lst))\n    end\n    return\
    \ new_lst\nend", "  table.sort(lst)\n  local result = {}\n  local n = #lst\n \
    \ local i = 1\n  local begin = 1\n  local sign = 1\n  while i <= n do\n    result[i]\
    \ = lst[begin]\n    begin = begin + sign\n    sign = sign * -1\n    i = i + 1\n\
    \  end\n  return result\nend", "  local res = {}\n  local limit = #lst\n  local\
    \ min, max\n  for i = 1, limit do\n    min = min_max(lst, true)\n    max = min_max(lst,\
    \ false)\n    res[i] = min\n    i = i + 1\n    if i <= limit then\n      res[i]\
    \ = max\n    end\n  end\n  return res\nend", "    local res = {}\n    local i\
    \ = 1\n    local s = 1\n    local st = 1\n    local m = #lst\n    while i <= m\
    \ do\n        local min = math.min(unpack(lst))\n        local max = math.max(unpack(lst))\n\
    \        if s == 1 then\n            res[i] = min\n            s = 2\n       \
    \ else\n            res[i] = max\n            s = 1\n        end\n        if st\
    \ == 1 then\n            lst[min] = nil\n            st = 2\n        else\n  \
    \          lst[max] = nil\n            st = 1\n        end\n        i = i + 1\n\
    \    end\n    return res\nend\nassert(table_equal(strange_sort_list({}), {}))\n\
    assert(table_equal(strange_sort_list({5, 5, 5, 5}), {5, 5, 5, 5}))\nassert(table_equal(strange_sort_list({1,\
    \ 2, 3, 4}), {1, 4, 2, 3}))\nassert(table_equal(strange_sort_list({4, 3, 2, 1}),\
    \ {1, 4, 2, 3}))\nassert(table_equal(strange_sort_list({1, 6, 3, 8, 5, 4, 7, 2}),\
    \ {1, 8, 3, 7, 5, 6, 4, 2}))", "  -- your code here\nend", "    -- your code here\n\
    \    if #lst == 0 then\n        return {}\n    end\n    local result = {}\n  \
    \  local min = lst[1]\n    local max = lst[1]\n    for i, v in ipairs(lst) do\n\
    \        if v < min then\n            min = v\n        end\n        if v > max\
    \ then\n            max = v\n        end\n    end\n    table.insert(result, min)\n\
    \    table.insert(result, max)\n    if #lst > 2 then\n        local left = {}\n\
    \        local right = {}\n        for i, v in ipairs(lst) do\n            if\
    \ v ~= min and v ~= max then\n                table.insert(left, v)\n        \
    \    end\n        end\n        if #left % 2 == 0 then\n            for i, v in\
    \ ipairs(left) do\n                if i % 2 == 1 then\n                    table.insert(result,\
    \ v)\n                else\n                    table.insert(right, v)\n     \
    \           end\n            end\n        else\n            for i, v in ipairs(left)\
    \ do\n                if i % 2 == 0 then\n                    table.insert(result,\
    \ v)\n                else\n                    table.insert(right, v)\n     \
    \           end\n            end\n        end\n        for i, v in ipairs(right)\
    \ do\n            table.insert(result, v)\n        end\n    end\n    return result\n\
    end", "\tif #lst == 0 then\n\t\treturn {}\n\tend\n\tlocal sorted = {}\n\twhile\
    \ #lst > 0 do\n\t\tlocal min = math.min(unpack(lst))\n\t\tlocal max = math.max(unpack(lst))\n\
    \t\ttable.insert(sorted, min)\n\t\ttable.insert(sorted, max)\n\t\tlst = table_del(lst,\
    \ min)\n\t\tlst = table_del(lst, max)\n\tend\n\tif #sorted % 2 == 1 then\n\t\t\
    table.remove(sorted)\n\tend\n\treturn sorted\nend", "    -- Enter your code here\n\
    end", "    if #lst == 0 then\n        return {}\n    end\n    if #lst == 1 then\n\
    \        return lst\n    end\n    local min = math.min(unpack(lst))\n    local\
    \ max = math.max(unpack(lst))\n    local i = 1\n    local sorted = {}\n    local\
    \ min_index, max_index\n    repeat\n        min_index = table_index_of(lst, min)\n\
    \        if i % 2 == 1 then\n            sorted[i] = min\n            table.remove(lst,\
    \ min_index)\n        else\n            max_index = table_index_of(lst, max)\n\
    \            sorted[i] = max\n            table.remove(lst, max_index)\n     \
    \   end\n        i = i + 1\n    until #lst == 0\n    return sorted\nend", "  local\
    \ temp = make_copy(lst)\n  local result = {}\n  local k = 1\n  local is_odd =\
    \ true\n  while #temp > 0 do\n    if is_odd then\n      result[k] = math.min(unpack(temp))\n\
    \    else\n      result[k] = math.max(unpack(temp))\n    end\n    table.remove(temp,\
    \ table.find(temp, result[k]))\n    k = k + 1\n    is_odd = not is_odd\n  end\n\
    \  return result\nend", "    -- your implementation here\n    if not lst then\n\
    \        return nil\n    end\n    local res = {}\n    local newlst = lst\n   \
    \ while #newlst > 0 do\n        table.insert(res, math.min(unpack(newlst)))\n\
    \        table.remove(newlst, find_ind(newlst, math.min(unpack(newlst))))\n  \
    \      if #newlst > 0 then\n            table.insert(res, math.max(unpack(newlst)))\n\
    \            table.remove(newlst, find_ind(newlst, math.max(unpack(newlst))))\n\
    \        end\n    end\n    return res\nend", "    local result = {}\n    local\
    \ min_max = function(a, b)\n        if a > b then\n            return 1\n    \
    \    elseif a < b then\n            return -1\n        else\n            return\
    \ 0\n        end\n    end\n    table.sort(lst, min_max)\n    while #lst > 0 do\n\
    \        table.insert(result, table.remove(lst, 1))\n        if #lst > 0 then\n\
    \            table.insert(result, table.remove(lst))\n        end\n    end\n \
    \   return result\nend", "  local result = {}\n  local ascending = true\n  local\
    \ llen = #lst\n  local count = 0\n  while count < llen do\n    if ascending then\n\
    \      table.insert(result, table.remove(lst, 1))\n    else\n      table.insert(result,\
    \ table.remove(lst))\n    end\n    ascending = not ascending\n    count = count\
    \ + 1\n  end\n  return result\nend", "    local result = {}\n    for i,v in ipairs(lst)\
    \ do\n        result[i] = v\n    end\n    table.sort(result)\n    if #result %\
    \ 2 == 0 then\n        for i = 1, #result / 2 do\n            result[i * 2], result[#result\
    \ - i + 1] = result[#result - i + 1], result[i * 2]\n        end\n    else\n \
    \       for i = 1, #result / 2 do\n            result[(i - 1) * 2 + 1], result[#result\
    \ - i + 1] = result[#result - i + 1], result[(i - 1) * 2 + 1]\n        end\n \
    \   end\n    return result\nend", "    local max_values = {}\n    local min_values\
    \ = {}\n    local result = {}\n    for i, val in ipairs(lst) do\n        if i\
    \ % 2 == 0 then\n            table.insert(max_values, val)\n        else\n   \
    \         table.insert(min_values, val)\n        end\n    end\n    table.sort(max_values)\n\
    \    table.sort(min_values)\n    for i, val in ipairs(min_values) do\n       \
    \ result[i] = val\n    end\n    for i, val in ipairs(max_values) do\n        result[i\
    \ + #min_values] = val\n    end\n    return result\nend", "    local n, result\
    \ = #lst, {}\n    if n < 1 then return lst end\n    table.sort(lst)\n    local\
    \ is_odd, i = true, 1\n    while n > 0 do\n        local val = lst[is_odd and\
    \ 1 or n]\n        result[i] = val\n        table.remove(lst, is_odd and 1 or\
    \ n)\n        n = n - 1\n        is_odd = not is_odd\n        i = i + 1\n    end\n\
    \    return result\nend", "\tlocal rev_lst = {}\n\tlocal min = math.min(unpack(lst))\n\
    \tlocal max = math.max(unpack(lst))\n\tlocal sgn = 1\n\tlocal cnt = 1\n\tlocal\
    \ lst_len = #lst\n\trepeat\n\t\trev_lst[cnt] = max * sgn\n\t\tsgn = -sgn\n\t\t\
    min = math.min(unpack(lst))\n\t\tmax = math.max(unpack(lst))\n\t\tcnt = cnt +\
    \ 1\n\tuntil lst_len == cnt - 1\n\treturn rev_lst\nend", "\tlocal result = {}\n\
    \tlocal is_min = true\n\twhile #lst > 0 do\n\t\tlocal min = 1\n\t\tlocal max =\
    \ 1\n\t\tfor i = 1, #lst do\n\t\t\tif lst[i] < lst[min] then\n\t\t\t\tmin = i\n\
    \t\t\tend\n\t\t\tif lst[i] > lst[max] then\n\t\t\t\tmax = i\n\t\t\tend\n\t\tend\n\
    \t\tif is_min then\n\t\t\tresult[#result + 1] = lst[min]\n\t\t\ttable.remove(lst,\
    \ min)\n\t\telse\n\t\t\tresult[#result + 1] = lst[max]\n\t\t\ttable.remove(lst,\
    \ max)\n\t\tend\n\t\tis_min = not is_min\n\tend\n\treturn result\nend", "   return\
    \ lst:map(function(v)\n         local min, max = lst:min(), lst:max()\n      \
    \   lst = lst:delete_value(v)\n         return v == min and {v, max} or {v, min}\n\
    \   end):flatten()\nend", "    if #lst == 0 then\n        return {}\n    end\n\
    \    local sorted = {}\n    local sorted2 = {}\n    local n = math.floor(#lst\
    \ / 2)\n    for i = 1, n do\n        table.insert(sorted, lst[i])\n        table.insert(sorted,\
    \ lst[#lst - i + 1])\n    end\n    if #lst % 2 == 1 then\n        table.insert(sorted,\
    \ lst[n + 1])\n    end\n    if #lst > 2 then\n        for i = 1, #sorted do\n\
    \            table.insert(sorted2, sorted[i])\n        end\n        return strange_sort_list(sorted2)\n\
    \    else\n        return sorted\n    end\nend", "    local new = {}\n    local\
    \ half = #lst / 2\n    local count = 0\n    while #lst > 0 do\n        local min,\
    \ max\n        if count < half then\n            min = lst[1]\n            for\
    \ i, v in ipairs(lst) do\n                if v < min then\n                  \
    \  min = v\n                end\n            end\n            table.insert(new,\
    \ min)\n            count = count + 1\n        else\n            max = lst[1]\n\
    \            for i, v in ipairs(lst) do\n                if v > max then\n   \
    \                 max = v\n                end\n            end\n            table.insert(new,\
    \ max)\n        end\n        for i, v in ipairs(lst) do\n            if v == min\
    \ or v == max then\n                table.remove(lst, i)\n                break\n\
    \            end\n        end\n    end\n    return new\nend", "    local res =\
    \ {}\n    local first = 0\n    local last = #lst", "  local ret = {}\n  local\
    \ remaining = {table.unpack(lst)}\n  local first_max = true\n  while #remaining\
    \ > 0 do\n    local max_i = nil\n    local max_v = nil\n    for i, v in ipairs(remaining)\
    \ do\n      if max_i == nil or (first_max and v > max_v) or (not first_max and\
    \ v < max_v) then\n        max_i = i\n        max_v = v\n      end\n    end\n\
    \    table.insert(ret, max_v)\n    table.remove(remaining, max_i)\n    first_max\
    \ = not first_max\n  end\n  return ret\nend", "    local min_pos = 1\n    local\
    \ max_pos = #lst\n    local result = {}\n    for i = 1, #lst do\n        if i\
    \ % 2 == 1 then\n            result[i] = lst[min_pos]\n            min_pos = min_pos\
    \ + 1\n        else\n            result[i] = lst[max_pos]\n            max_pos\
    \ = max_pos - 1\n        end\n    end\n    return result\nend", "  if #lst ==\
    \ 0 then\n    return {}\n  end\n  local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \  local min_index = find_index(lst, min)\n  local max_index = find_index(lst,\
    \ max)\n  local new_lst = {}\n  table.insert(new_lst, min)\n  table.insert(new_lst,\
    \ max)\n  for i = 1, #lst do\n    if not (i == min_index or i == max_index) then\n\
    \      table.insert(new_lst, lst[i])\n    end\n  end\n  return new_lst\nend",
  "    local sorted = {}\n    local min_index = 1\n    local max_index = 1\n    local\
    \ min = lst[1]\n    local max = lst[1]\n    local len = #lst\n    local start\
    \ = true\n    local step = 1\n    for i = 1, len do\n        if lst[i] < min then\n\
    \            min = lst[i]\n            min_index = i\n        end\n        if\
    \ lst[i] > max then\n            max = lst[i]\n            max_index = i\n   \
    \     end\n    end\n    for i = 1, len do\n        if start then\n           \
    \ sorted[i] = min\n            start = false\n        else\n            sorted[i]\
    \ = max\n            start = true\n        end\n        if step == 1 then\n  \
    \          step = 2\n        else\n            step = 1\n        end\n    end\n\
    \    return sorted\nend", "    if #lst == 0 then\n        return {}\n    end\n\
    \    local lst1 = lst\n    local lst2 = {}\n    local min\n    local min_i\n \
    \   local max\n    local max_i\n    local function find_min_and_max()\n      \
    \  min = lst1[1]\n        min_i = 1\n        max = lst1[1]\n        max_i = 1\n\
    \        for i, v in ipairs(lst1) do\n            if v < min then\n          \
    \      min = v\n                min_i = i\n            end\n            if v >\
    \ max then\n                max = v\n                max_i = i\n            end\n\
    \        end\n    end\n    local function append_min_or_max(m)\n        if #lst1\
    \ % 2 == 0 then\n            table.insert(lst2, min)\n            table.remove(lst1,\
    \ min_i)\n        else\n            table.insert(lst2, max)\n            table.remove(lst1,\
    \ max_i)\n        end\n    end\n    repeat\n        find_min_and_max()\n     \
    \   append_min_or_max()\n    until #lst1 == 0\n    return lst2\nend", "  local\
    \ result = {}\n  local lst_copy = lst:copy()\n  local first, last = lst_copy:min(),\
    \ lst_copy:max()\n  local i = 1\n  while lst_copy:length() > 0 do\n    if i %\
    \ 2 == 1 then\n      result[i] = first\n      lst_copy:remove(first)\n      first\
    \ = lst_copy:min()\n    else\n      result[i] = last\n      lst_copy:remove(last)\n\
    \      last = lst_copy:max()\n    end\n    i = i + 1\n  end\n  return Table.from_list(result)\n\
    end", "    if #lst == 0 then\n        return {}\n    end\n    if #lst == 1 then\n\
    \        return lst\n    end\n    table.sort(lst)\n    local answer = {}\n   \
    \ local min = 1\n    local max = #lst\n    local index = 1\n    while max >= min\
    \ do\n        answer[index] = lst[min]\n        index = index + 1\n        answer[index]\
    \ = lst[max]\n        index = index + 1\n        min = min + 1\n        max =\
    \ max - 1\n    end\n    return answer\nend", "    local new = { }\n    local len\
    \ = #lst\n    for i = 1, len, 2 do\n        if i == len then\n            new[i]\
    \ = math.min(unpack(lst))\n        else\n            local a, b = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n            new[i], new[i + 1] = a, b\n        end\n\
    \        for j,v in ipairs(lst) do\n            if v == new[i] or v == new[i +\
    \ 1] then\n                table.remove(lst, j)\n                break\n     \
    \       end\n        end\n    end\n    return new\nend", "  if #lst == 0 then\n\
    \    return {}\n  end\n  local even = {}\n  local odd = {}\n  for i = 1, #lst\
    \ do\n    if i % 2 == 0 then\n      even[#even + 1] = lst[i]\n    else\n     \
    \ odd[#odd + 1] = lst[i]\n    end\n  end\n  even = quicksort(even)\n  odd = quicksort(odd)\n\
    \  local res = {}\n  for i = 1, #lst do\n    if i % 2 == 0 then\n      res[i]\
    \ = even[#even]\n      even[#even] = nil\n    else\n      res[i] = odd[#odd]\n\
    \      odd[#odd] = nil\n    end\n  end\n  return res\nend", "  if #lst == 0 then\n\
    \    return {}\n  end\n  local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \  lst = table.delete(lst, min)\n  table.insert(lst, 1, min)\n  table.insert(lst,\
    \ max)\n  return strange_sort_list(lst)\nend", "   local sort_func\n   sort_func\
    \ = function(lst)\n      if #lst == 0 then\n         return {}\n      elseif #lst\
    \ == 1 then\n         return lst\n      else\n         local sorted_list = {}\n\
    \         table.insert(sorted_list, lst[1])\n         table.insert(sorted_list,\
    \ lst[#lst])\n         table.insert(sorted_list, sort_func(remove_elem(lst, 1)))\n\
    \         table.insert(sorted_list, sort_func(remove_elem(lst, #lst)))\n     \
    \    return sorted_list\n      end\n   end\n   return sort_func(lst)\nend", " \
    \ if #lst == 0 then\n    return {}\n  end\n  local min, min_index = math.min(unpack(lst))\n\
    \  local max, max_index = math.max(unpack(lst))\n  local sorted = {min}\n  for\
    \ i = 1, #lst do\n    if i ~= min_index and i ~= max_index then\n      sorted[#sorted\
    \ + 1] = lst[i]\n    end\n  end\n  sorted[#sorted + 1] = max\n  return sorted\n\
    end", "\tlocal length = #lst\n\tlocal sorted = {}\n\tlocal sorted_index = 1\n\t\
    local max = math.max\n\tlocal min = math.min\n\tlocal remove = table.remove\n\t\
    local sorted_index = 1\n\tlocal min_index = nil\n\tlocal max_index = nil\n\tlocal\
    \ min_value = nil\n\tlocal max_value = nil\n\tlocal odd = true\n\twhile #lst >\
    \ 0 do\n\t\tmin_index, min_value = min_index_value(lst)\n\t\tmax_index, max_value\
    \ = max_index_value(lst)\n\t\tif odd then\n\t\t\tsorted[sorted_index] = min_value\n\
    \t\t\tremove(lst, min_index)\n\t\telse\n\t\t\tsorted[sorted_index] = max_value\n\
    \t\t\tremove(lst, max_index)\n\t\tend\n\t\todd = not odd\n\t\tsorted_index = sorted_index\
    \ + 1\n\tend\n\treturn sorted\nend", "  local min, max = min_max(lst)\n  local\
    \ l = table_copy(lst)\n  local res = {}\n  table.remove(l, min)\n  res[#res +\
    \ 1] = lst[min]\n  table.remove(l, max)\n  res[#res + 1] = lst[max]\n  while next(l)\
    \ do\n    min, max = min_max(l)\n    table.remove(l, min)\n    res[#res + 1] =\
    \ l[min]\n    table.remove(l, max)\n    res[#res + 1] = l[max]\n  end\n  return\
    \ res\nend", "\tlocal even, odd = {}, {}\n\tfor i, v in ipairs(lst) do\n\t\tlocal\
    \ t = (i % 2 == 0) and even or odd\n\t\tt[#t + 1] = v\n\tend\n\tlocal r = {}\n\
    \tfor i = 1, #lst do\n\t\tlocal t = (i % 2 == 0) and even or odd\n\t\tr[i] = t[#t]\n\
    \t\tt[#t] = nil\n\tend\n\treturn r\nend", "    local ret = {}\n    local _size\
    \ = #lst\n    for _iter = 1, _size, 2 do\n        local idx = _iter\n        if\
    \ idx <= _size then\n            ret[#ret + 1] = lst[idx]\n        end\n     \
    \   idx = _size - _iter + 1\n        if idx > 0 then\n            ret[#ret + 1]\
    \ = lst[idx]\n        end\n    end\n    return ret\nend\nM.strange_sort_list =\
    \ strange_sort_list", "  local f = function(acc, i)\n    local min, max = find_min_max(i)\n\
    \    table.insert(acc, min)\n    if min ~= max then\n      table.insert(acc, max)\n\
    \    end\n    return acc\n  end\n  return reduce(f, lst, {})\nend", "    local\
    \ function aux(l, r)\n        if #l == 0 or #r == 0 then\n            return l\n\
    \        end\n        return aux(r, l[1] < r[1] and {r[1], unpack(l)} or {l[1],\
    \ unpack(r)})\n    end\n    return aux(lst, {})\nend", "  -- your code here\n\
    end", "    local ret = {}\n    local lowest, highest = lst[1], lst[1]\n    local\
    \ tmp_list = {}\n    local list_len = 0\n    for i, v in ipairs(lst) do\n    \
    \    if v < lowest then\n            lowest = v\n        end\n        if v > highest\
    \ then\n            highest = v\n        end\n        list_len = list_len + 1\n\
    \        tmp_list[i] = v\n    end\n    local add_odd_el, add_even_el = true, false\n\
    \    for i = 1, list_len do\n        local el = add_odd_el and lowest or highest\n\
    \        add_odd_el = not add_odd_el\n        add_even_el = not add_even_el\n\
    \        for j, v in ipairs(tmp_list) do\n            if v == el then\n      \
    \          table.insert(ret, v)\n                table.remove(tmp_list, j)\n \
    \               break\n            end\n        end\n    end\n    return ret\n\
    end", "    if #lst <= 1 then\n        return lst\n    end\n    table.sort(lst)\n\
    \    local res = {}\n    local i = 1\n    while #lst > 0 do\n        if i % 2\
    \ == 1 then\n            res[#res + 1] = table.remove(lst, 1)\n        else\n\
    \            res[#res + 1] = table.remove(lst)\n        end\n        i = i + 1\n\
    \    end\n    return res\nend", "  if (next(lst) == nil) then\n    return {}\n\
    \  end\n  local res = {}\n  local i = 1\n  local is_odd = true\n  local pivot\
    \ = math.min(unpack(lst))\n  while (next(lst) ~= nil) do\n    res[i] = pivot\n\
    \    table.remove(lst, table.find(lst, pivot))\n    if (is_odd) then\n      pivot\
    \ = math.max(unpack(lst))\n    else\n      pivot = math.min(unpack(lst))\n   \
    \ end\n    is_odd = not is_odd\n    i = i + 1\n  end\n  return res\nend", "  --\
    \ your code here\nend", "  local ret, min, max = {}, math.min(unpack(lst)), math.max(unpack(lst))\n\
    \  while #ret < #lst do\n    table.insert(ret, min)\n    min = math.min(unpack(ret))\n\
    \    table.insert(ret, max)\n    max = math.max(unpack(ret))\n  end\n  return\
    \ ret\nend", "  if #lst == 0 then\n    return {}\n  end\n  local function get_min(src,\
    \ a, b)\n    if a <= b then\n      return a\n    else\n      return b\n    end\n\
    \  end\n  local function get_max(src, a, b)\n    if a >= b then\n      return\
    \ a\n    else\n      return b\n    end\n  end\n  local function get_min_max(src,\
    \ cmp)\n    local min = cmp(src, src[1], src[2])\n    for _, v in ipairs(src)\
    \ do\n      min = cmp(src, min, v)\n    end\n    return min\n  end\n  local function\
    \ list_to_dict(src)\n    local res = {}\n    for _, v in ipairs(src) do\n    \
    \  res[v] = true\n    end\n    return res\n  end\n  local function list_from_dict(src)\n\
    \    local res = {}\n    for k, _ in pairs(src) do\n      table.insert(res, k)\n\
    \    end\n    return res\n  end\n  local res = {}\n  local remaining = list_to_dict(lst)\n\
    \  while #res < #lst do\n    local min = get_min_max(list_from_dict(remaining),\
    \ get_min)\n    table.insert(res, min)\n    remaining[min] = nil\n    local max\
    \ = get_min_max(list_from_dict(remaining), get_max)\n    table.insert(res, max)\n\
    \    remaining[max] = nil\n  end\n  return res\nend", "    local result = {}\n\
    \    local count = #lst\n    local lower = math.min(unpack(lst))\n    local upper\
    \ = math.max(unpack(lst))\n    for _, n in ipairs(lst) do\n        if n == lower\
    \ then\n            table.insert(result, n)\n            lower = math.huge\n \
    \       elseif n == upper then\n            table.insert(result, 1, n)\n     \
    \       upper = -math.huge\n        end\n    end\n    for i = 2, count do\n  \
    \      local n = result[i]\n        if n > result[i - 1] then\n            upper\
    \ = math.min(upper, n)\n        else\n            lower = math.max(lower, n)\n\
    \        end\n    end\n    for i = 1, count do\n        if result[i] > result[i\
    \ + 1] then\n            result[i + 1] = upper\n        else\n            result[i\
    \ + 1] = lower\n        end\n    end\n    return result\nend", "  local index_list\
    \ = {}\n  local values_list = {}\n  local result = {}\n  local iterator = 0\n\
    \  local max_index\n  local temp_value", "  -- your code here\nend", "    if not\
    \ lst then\n        return {}\n    end\n    table.sort(lst)\n    local idx = 1\n\
    \    local res = {}\n    while #lst > 0 do\n        local k = #lst\n        res[idx]\
    \ = lst[k]\n        table.remove(lst, k)\n        if #lst > 0 then\n         \
    \   res[idx + 1] = lst[1]\n            table.remove(lst, 1)\n        end\n   \
    \     idx = idx + 2\n    end\n    return res\nend", "    local min = min_list(lst)\n\
    \    local max = max_list(lst)\n    local new_lst = {}\n    local i = 1\n    while\
    \ #lst > 0 do\n        local min_idx = find_item(lst, min)\n        local max_idx\
    \ = find_item(lst, max)\n        table.insert(new_lst, min)\n        table.remove(lst,\
    \ min_idx)\n        table.insert(new_lst, max)\n        table.remove(lst, max_idx)\n\
    \        min = min_list(lst)\n        max = max_list(lst)\n        i = i + 1\n\
    \    end\n    return new_lst\nend", "    local res = {}\n    local sign = 1\n\
    \    local i = 1\n    local j = #lst\n    for n = 1, #lst do\n        res[n] =\
    \ sign > 0 and lst[i] or lst[j]\n        i = i + sign\n        j = j - sign\n\
    \        sign = sign * -1\n    end\n    return res\nend", "    local res = {}\n\
    \    local asc, desc = true, false\n    local min_val, max_val\n    while #lst\
    \ > 0 do\n        if asc then\n            min_val = lst[1]\n            for _,\
    \ v in ipairs(lst) do\n                if v < min_val then\n                 \
    \   min_val = v\n                end\n            end\n            table.insert(res,\
    \ min_val)\n            for i, v in ipairs(lst) do\n                if v == min_val\
    \ then\n                    table.remove(lst, i)\n                    break\n\
    \                end\n            end\n            asc = false\n            desc\
    \ = true\n        elseif desc then\n            max_val = lst[1]\n           \
    \ for _, v in ipairs(lst) do\n                if v > max_val then\n          \
    \          max_val = v\n                end\n            end\n            table.insert(res,\
    \ max_val)\n            for i, v in ipairs(lst) do\n                if v == max_val\
    \ then\n                    table.remove(lst, i)\n                    break\n\
    \                end\n            end\n            asc = true\n            desc\
    \ = false\n        end\n    end\n    return res\nend", "  -- your code here\n\
    end", "  if #lst == 0 then\n    return {}\n  end\n  local t = {}\n  for i = 1,\
    \ #lst do\n    if i % 2 == 1 then\n      table.insert(t, math.min(unpack(lst)))\n\
    \    else\n      table.insert(t, math.max(unpack(lst)))\n    end\n    lst[index_of(lst,\
    \ t[i])] = math.huge\n  end\n  return t\nend", "  -- your code here\nend", " \
    \   local list = {}\n    local res = {}\n    local len = #lst\n    for _, v in\
    \ ipairs(lst) do\n        table.insert(list, v)\n    end\n    local i = 1\n  \
    \  local j = len\n    while i <= len or j >= 1 do\n        if i <= len then\n\
    \            table.insert(res, list[i])\n            i = i + 1\n        end\n\
    \        if j >= 1 then\n            table.insert(res, list[j])\n            j\
    \ = j - 1\n        end\n    end\n    return res\nend", "  local function iter(a,\
    \ b)\n    if #a == 0 then return b end\n    if #a == 1 then return b..a[1] end\n\
    \    local t_a = {}\n    local t_b = {}\n    local min, max\n    local min_pos,\
    \ max_pos\n    for k, v in ipairs(a) do\n      if min == nil or v < min then\n\
    \        min = v\n        min_pos = k\n      end\n      if max == nil or v > max\
    \ then\n        max = v\n        max_pos = k\n      end\n    end\n    table.remove(a,\
    \ min_pos)\n    table.remove(a, max_pos)\n    for k, v in ipairs(a) do t_a[k]\
    \ = v end\n    return iter(t_a, b..min..max)\n  end\n  local result = iter(lst,\
    \ \"\")\n  local t = {}\n  for i = 1, #result do t[i] = tonumber(result:sub(i,\
    \ i)) end\n  return t\nend", "    local result = {}\n    local min_val, max_val\
    \ = 0, 0\n    local min_index, max_index = 0, 0\n    local min_found, max_found\
    \ = false, false\n    local start_at_min = true\n    local max_vals_found = false\n\
    \    local index = 1\n    for _, val in ipairs(lst) do\n        if not min_found\
    \ then\n            min_val = val\n            min_index = index\n           \
    \ min_found = true\n        elseif not max_found then\n            if val > max_val\
    \ then\n                max_val = val\n                max_index = index\n   \
    \         end\n        end\n        index = index + 1\n    end\n    while #lst\
    \ > 0 do\n        table.insert(result, min_val)\n        table.remove(lst, min_index)\n\
    \        max_found = false\n        min_found = false\n        if start_at_min\
    \ then\n            for _, val in ipairs(lst) do\n                if not min_found\
    \ then\n                    min_val = val\n                    min_index = 1\n\
    \                    min_found = true\n                elseif not max_found then\n\
    \                    if val > max_val then\n                        max_val =\
    \ val\n                        max_index = 1\n                    end\n      \
    \          end\n                min_index = min_index + 1\n            end\n \
    \           if not max_found then\n                table.insert(result, max_val)\n\
    \                table.remove(lst, max_index)\n                max_found = true\n\
    \            end\n            start_at_min = false\n        else\n           \
    \ for _, val in ipairs(lst) do\n                if not max_found then\n      \
    \              max_val = val\n                    max_index = 1\n            \
    \        max_found = true\n                elseif not min_found then\n       \
    \             if val < min_val then\n                        min_val = val\n \
    \                       min_index = 1\n                    end\n             \
    \   end\n                max_index = max_index + 1\n            end\n        \
    \    if not min_found then\n                table.insert(result, min_val)\n  \
    \              table.remove(lst, min_index)\n                min_found = true\n\
    \            end\n           ", "  return {}\nend", "  if #lst == 0 then\n   \
    \ return {}\n  end\n  local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \  local start, stop = min, max\n  local sorted_lst = {}\n  local count = 1\n\
    \  repeat\n    table.insert(sorted_lst, start)\n    table.insert(sorted_lst, stop)\n\
    \    count = count + 1\n    if count > #lst then\n      return sorted_lst\n  \
    \  end\n    start = math.min(unpack(lst))\n    stop = math.max(unpack(lst))\n\
    \    for i, v in ipairs(lst) do\n      if v == start or v == stop then\n     \
    \   table.remove(lst, i)\n      end\n    end\n  until count > #lst\nend", "  \
    \  -- Your code here\nend", "    return strange_sort(lst)\nend", "\tlocal len\
    \ = #lst\n\tlocal i = 1\n\tlocal j = len\n\tlocal k = 1\n\tlocal res = {}\n\t\
    while i <= j do\n\t\tres[k] = math.min(lst[i], lst[j])\n\t\tk = k + 1\n\t\tres[k]\
    \ = math.max(lst[i], lst[j])\n\t\tk = k + 1\n\t\ti = i + 1\n\t\tj = j - 1\n\t\
    end\n\treturn res\nend", "  local res = {}\n  if not lst then return end\n  for\
    \ i = 1,#lst do res[i] = lst[i] end\n  local odd = true\n  local odd_end = 1\n\
    \  local even_end = #res\n  for i = 1,#res do\n    if odd then\n      res[i] =\
    \ lst[odd_end]\n      odd_end = odd_end + 1\n    else\n      res[i] = lst[even_end]\n\
    \      even_end = even_end - 1\n    end\n    odd = not odd\n  end\n  return res\n\
    end", "    local odd, even = {}, {}\n    local len = #lst\n    local len_even\
    \ = math.floor(len / 2)\n    local len_odd = len - len_even\n    for i = 1, len_even\
    \ do\n        local el = remove_max(lst)\n        table.insert(even, el)\n   \
    \ end\n    for i = 1, len_odd do\n        local el = remove_min(lst)\n       \
    \ table.insert(odd, el)\n    end\n    local new_lst = {}\n    for i = 1, len_even\
    \ do\n        local el = even[i]\n        table.insert(new_lst, el)\n        if\
    \ odd[i] then\n            table.insert(new_lst, odd[i])\n        end\n    end\n\
    \    return new_lst\nend", "    if #lst == 0 then\n        return {}\n    end\n\
    \    if #lst == 1 then\n        return lst\n    end\n    local min = math.min(unpack(lst))\n\
    \    local min_pos = table.find(lst, min)\n    table.remove(lst, min_pos)\n  \
    \  local max = math.max(unpack(lst))\n    local max_pos = table.find(lst, max)\n\
    \    table.remove(lst, max_pos)\n    return {min, max} .. strange_sort_list(lst)\n\
    end", "  local result = {}\n  for i = 1, #lst, 2 do\n    local max, max_i = 0,\
    \ 0\n    local min, min_i = math.huge, 0\n    for j = 1, #lst do\n      if lst[j]\
    \ > max and lst[j] ~= \"used\" then\n        max = lst[j]\n        max_i = j\n\
    \      end\n      if lst[j] < min and lst[j] ~= \"used\" then\n        min = lst[j]\n\
    \        min_i = j\n      end\n    end\n    result[i] = min\n    result[i + 1]\
    \ = max\n    lst[min_i] = \"used\"\n    lst[max_i] = \"used\"\n  end\n  return\
    \ result\nend", "    local sorted = {}\n    local lst = clone(lst)\n    local\
    \ min = min(lst)\n    local max = max(lst)\n    local m = min\n    local M = max\n\
    \    while #lst > 0 do\n        table.insert(sorted, m)\n        if m == min then\n\
    \            m = max\n        else\n            m = min\n        end\n       \
    \ table.insert(sorted, M)\n        if M == max then\n            M = min\n   \
    \     else\n            M = max\n        end\n        if #lst % 2 == 0 then\n\
    \            table.remove(lst, indexof(lst, min))\n            table.remove(lst,\
    \ indexof(lst, max))\n        else\n            if m == min then\n           \
    \     table.remove(lst, indexof(lst, min))\n            else\n               \
    \ table.remove(lst, indexof(lst, max))\n            end\n        end\n    end\n\
    \    return sorted\nend", "    local result = {}\n    while #lst > 0 do\n    \
    \    local min_ = math.min(unpack(lst))\n        table.insert(result, min_)\n\
    \        local i = 1\n        while i <= #lst do\n            if lst[i] == min_\
    \ then\n                table.remove(lst, i)\n            else\n             \
    \   i = i + 1\n            end\n        end\n        if #lst > 0 then\n      \
    \      local max_ = math.max(unpack(lst))\n            table.insert(result, max_)\n\
    \            local i = 1\n            while i <= #lst do\n                if lst[i]\
    \ == max_ then\n                    table.remove(lst, i)\n                else\n\
    \                    i = i + 1\n                end\n            end\n       \
    \ end\n    end\n    return result\nend", "    local result = {}\n    local copy\
    \ = lst", "    -- your code here\n    local size= 0\n    for i, v in pairs(lst)\
    \ do\n        size=size+1\n    end\n    local min=lst[1]\n    local index=1\n\
    \    for i=1, size do\n        if min > lst[i] then\n            min=lst[i]\n\
    \            index=i\n        end\n    end\n    table.remove(lst, index)\n   \
    \ table.insert(lst, 1, min)\n    local max=lst[1]\n    local index=1\n    for\
    \ i=1, size-1 do\n        if max < lst[i] then\n            max=lst[i]\n     \
    \       index=i\n        end\n    end\n    table.remove(lst, index)\n    table.insert(lst,\
    \ 2, max)\n    local min=lst[2]\n    local index=2\n    for i=2, size-1 do\n \
    \       if min > lst[i] then\n            min=lst[i]\n            index=i\n  \
    \      end\n    end\n    table.remove(lst, index)\n    table.insert(lst, 3, min)\n\
    \    local max=lst[3]\n    local index=3\n    for i=3, size-1 do\n        if max\
    \ < lst[i] then\n            max=lst[i]\n            index=i\n        end\n  \
    \  end\n    table.remove(lst, index)\n    table.insert(lst, 4, max)\n    return\
    \ lst\nend", "  local function aux(lst, res)\n    if #lst == 0 then return res\
    \ end\n    table.insert(res, table.remove(lst, 1))\n    if #lst == 0 then return\
    \ res end\n    table.insert(res, table.remove(lst, #lst))\n    return aux(lst,\
    \ res)\n  end\n  return aux(lst, {})\nend", "    if #lst == 0 then\n        return\
    \ {}\n    end\n    table.sort(lst)\n    local i = 1\n    local j = #lst\n    local\
    \ new = {}\n    while i <= j do\n        new[#new + 1] = lst[i]\n        i = i\
    \ + 1\n        if i <= j then\n            new[#new + 1] = lst[j]\n          \
    \  j = j - 1\n        end\n    end\n    return new\nend", "\t-- base case, table\
    \ is empty\n\tif #lst == 0 then\n\t\treturn {}\n\tend\n\t-- remove smallest, append\
    \ to array of results\n\tlocal small_idx = 1\n\tfor i = 2, #lst do\n\t\tif lst[i]\
    \ < lst[small_idx] then\n\t\t\tsmall_idx = i\n\t\tend\n\tend\n\tlocal new_lst\
    \ = {lst[small_idx]}\n\ttable.remove(lst, small_idx)\n\t-- go recursive with remaining\
    \ list\n\t-- append last number, to prevent recursion\n\tlocal rec = strange_sort_list(lst)\n\
    \treturn table.merge(new_lst, rec, rec[#rec])\nend", "    -- your code here\n\
    \    return lst\nend", "    local new_lst = {}\n    table.sort(lst)\n    for i\
    \ = 1, #lst, 2 do\n        new_lst[i] = lst[i]\n        new_lst[i + 1] = lst[#lst\
    \ - i + 1]\n    end\n    return new_lst\nend", "  local ret = {}\n  local min,\
    \ max\n  while true do\n    min = min_integer(lst)\n    if min == nil then\n \
    \     break\n    end\n    table.insert(ret, min)\n    lst = remove_integer(lst,\
    \ min)\n    max = max_integer(lst)\n    if max == nil then\n      break\n    end\n\
    \    table.insert(ret, max)\n    lst = remove_integer(lst, max)\n  end\n  return\
    \ ret\nend", "  local result = {}\n  local min, max\n  local new_lst = lst\n \
    \ while #new_lst > 0 do\n    -- Get min and max of the list.\n    min, max = new_lst[1],\
    \ new_lst[1]\n    for i, el in ipairs(new_lst) do\n      if el < min then\n  \
    \      min = el\n      elseif el > max then\n        max = el\n      end\n   \
    \ end\n    -- Remove min/max from new_lst.\n    for i, el in ipairs(new_lst) do\n\
    \      if el == min or el == max then\n        table.remove(new_lst, i)\n    \
    \    break\n      end\n    end\n    -- Update result.\n    table.insert(result,\
    \ min)\n    table.insert(result, max)\n  end\n  return result\nend", "    if #lst\
    \ <= 1 then\n        return lst\n    end\n    local sorted = {}\n    local lst1\
    \ = lst\n    local lst2 = {}\n    local min1, max1, min2, max2\n    for _, i in\
    \ ipairs(lst) do\n        if min1 == nil or i < min1 then\n            min1 =\
    \ i\n        end\n        if max1 == nil or i > max1 then\n            max1 =\
    \ i\n        end\n    end\n    for _, i in ipairs(lst) do\n        if i ~= min1\
    \ and i ~= max1 then\n            table.insert(lst2, i)\n        end\n    end\n\
    \    for _, i in ipairs(lst2) do\n        if min2 == nil or i < min2 then\n  \
    \          min2 = i\n        end\n        if max2 == nil or i > max2 then\n  \
    \          max2 = i\n        end\n    end\n    if min1 ~= nil then\n        table.insert(sorted,\
    \ min1)\n    end\n    if max1 ~= nil then\n        table.insert(sorted, max1)\n\
    \    end\n    if min2 ~= nil then\n        table.insert(sorted, min2)\n    end\n\
    \    if max2 ~= nil then\n        table.insert(sorted, max2)\n    end\n    return\
    \ sorted\nend", "    -- your code here\n    return {}\nend", "    local new_list\
    \ = {}\n    local length = #lst\n    local max_idx = 0\n    local min_idx = 0\n\
    \    for i = 1, length do\n        max_idx = find_max_index(lst)\n        min_idx\
    \ = find_min_index(lst)\n        table.insert(new_list, lst[min_idx])\n      \
    \  table.insert(new_list, lst[max_idx])\n        lst[min_idx] = nil\n        lst[max_idx]\
    \ = nil\n    end\n    return new_list\nend", "    local pos, neg = {}, {}\n  \
    \  local result = {}\n    for _, v in ipairs(lst) do\n        if v > 0 then\n\
    \            table.insert(pos, v)\n        else\n            table.insert(neg,\
    \ v)\n        end\n    end\n    table.sort(pos)\n    table.sort(neg)\n    for\
    \ i = 1, #lst do\n        if math.mod(i, 2) == 1 then\n            table.insert(result,\
    \ pos[1])\n            table.remove(pos, 1)\n        else\n            table.insert(result,\
    \ neg[#neg])\n            table.remove(neg, #neg)\n        end\n    end\n    return\
    \ result\nend", "  local result = {}\n  local imin, imax = 1, 1\n  local lst_size\
    \ = #lst\n  for i = 1, lst_size do\n    if lst[i] < lst[imin] then\n      imin\
    \ = i\n    end\n    if lst[i] > lst[imax] then\n      imax = i\n    end\n  end\n\
    \  result[#result + 1] = lst[imin]\n  for i = 1, lst_size - 1 do\n    if i % 2\
    \ == 0 then\n      result[#result + 1] = lst[imax]\n    else\n      result[#result\
    \ + 1] = lst[imin]\n    end\n  end\n  return result\nend", "  local s = {}\n \
    \ for _, x in ipairs(lst) do\n    table.insert(s, {x, #s})\n  end\n  table.sort(s,\
    \ function(a, b) return a[1] < b[1] end)\n  local m, p = {}, 1\n  while #s > 0\
    \ do\n    local a = s[1]\n    if a[2] % 2 == 0 then\n      table.insert(m, a[1])\n\
    \    else\n      table.insert(m, 1, a[1])\n    end\n    table.remove(s, 1)\n \
    \ end\n  return m\nend", "    local min, max = min_max(lst)\n    local res = {}\n\
    \    local cnt = #lst\n    for i = 1, cnt do\n        if i % 2 == 1 then\n   \
    \         table.insert(res, min)\n            min = next_max(lst, min)\n     \
    \   else\n            table.insert(res, max)\n            max = next_min(lst,\
    \ max)\n        end\n    end\n    return res\nend", "    if #lst == 0 then\n \
    \       return {}\n    end\n    if #lst == 1 then\n        return lst\n    end\n\
    \    local min = min_list(lst)\n    local max = max_list(lst)\n    local max_i\
    \ = pos_list(max, lst)\n    local min_i = pos_list(min, lst)\n    local max_is_first\
    \ = max_i == 1\n    local is_even = (#lst - #{min}) % 2 == 0\n    local is_odd\
    \ = (#lst - #{min}) % 2 == 1\n    local is_even_and_max_is_first = is_even and\
    \ max_is_first\n    local is_odd_and_max_is_first = is_odd and max_is_first\n\
    \    local is_even_and_max_is_not_first = is_even and not max_is_first\n    local\
    \ is_odd_and_max_is_not_first = is_odd and not max_is_first\n    local new_list\n\
    \    if is_even_and_max_is_first then\n        new_list = {min}\n        for i=1,\
    \ #lst do\n            if lst[i] ~= min and lst[i] ~= max then\n             \
    \   table.insert(new_list, lst[i])\n            end\n        end\n        table.insert(new_list,\
    \ max)\n    elseif is_odd_and_max_is_first then\n        new_list = {min}\n  \
    \      for i=1, #lst do\n            if lst[i] ~= min and lst[i] ~= max then\n\
    \                table.insert(new_list, lst[i])\n            end\n        end\n\
    \        table.insert(new_list, max)\n    elseif is_even_and_max_is_not_first\
    \ then\n        new_list = {min}\n        for i=1, #lst do\n            if lst[i]\
    \ ~= min and lst[i] ~= max then\n                table.insert(new_list, lst[i])\n\
    \            end\n        end\n        table.", "    if lst == nil or #lst ==\
    \ 0 then\n        return {}\n    end\n    lst = list.copy(lst)\n    local n =\
    \ #lst\n    local start = n % 2 == 0 and 0 or 1\n    local sign = start == 0 and\
    \ 1 or -1\n    for i = 1, n do\n        for j = i + 1, n do\n            if sign\
    \ * (lst[i] - lst[j]) > 0 then\n                lst[i], lst[j] = lst[j], lst[i]\n\
    \            end\n        end\n        sign = -sign\n    end\n    return lst\n\
    end", "    local result = {}\n    local copied_lst = copy_list(lst)\n    while\
    \ #copied_lst > 0 do\n        local min_val = min_value(copied_lst)\n        table.insert(result,\
    \ min_val)\n        copied_lst = remove_element(copied_lst, min_val)\n       \
    \ if #copied_lst > 0 then\n            local max_val = max_value(copied_lst)\n\
    \            table.insert(result, max_val)\n            copied_lst = remove_element(copied_lst,\
    \ max_val)\n        end\n    end\n    return result\nend", "  local temp = {}\n\
    \  local count = #lst\n  local result = {}\n  for _, val in ipairs(lst) do\n \
    \   temp[val] = true\n  end\n  for i = 1, count do\n    if count % 2 == 0 then\n\
    \      local min = min_key(temp)\n      result[i] = min\n      temp[min] = nil\n\
    \      local max = max_key(temp)\n      result[count - i + 1] = max\n      temp[max]\
    \ = nil\n    else\n      local min = min_key(temp)\n      result[i] = min\n  \
    \    temp[min] = nil\n      if i ~= math.floor(count / 2) + 1 then\n        local\
    \ max = max_key(temp)\n        result[count - i + 1] = max\n        temp[max]\
    \ = nil\n      end\n    end\n  end\n  return result\nend", "  local odd = {}\n\
    \  local even = {}\n  local function aux (lst, acc)\n    if lst == nil then\n\
    \      return acc\n    else\n      local mid = math.floor(#lst / 2)\n      table.insert(acc,\
    \ 1, lst[mid])\n      lst[mid] = nil\n      return aux(lst, acc)\n    end\n  end\n\
    \  local fst = aux(lst, {})\n  for i = 1, #fst do\n    if i % 2 == 0 then\n  \
    \    table.insert(even, fst[i])\n    else\n      table.insert(odd, fst[i])\n \
    \   end\n  end\n  return aux(even, aux(odd, {}))\nend", "    table.sort(lst)\n\
    \    local result = {}\n    for i = 1, #lst, 2 do\n        table.insert(result,\
    \ lst[i])\n        if i < #lst then\n            table.insert(result, lst[#lst\
    \ - i + 1])\n        end\n    end\n    return result\nend", "  -- your code here\n\
    end", "  local odd = lst[1] and #lst % 2 == 1\n  local middle = odd and #lst //\
    \ 2 + 1 or #lst // 2\n  return lst[1] and {\n    lst[1],\n    lst[middle],\n \
    \   strange_sort_list({unpack(lst, 2, middle - 1)}),\n    strange_sort_list({unpack(lst,\
    \ middle + 1)})\n  } or {}\nend", "    if #lst <= 1 then\n        return lst\n\
    \    end\n    local head = math.min(unpack(lst))\n    local tail = {}\n    for\
    \ i = 1, #lst do\n        if lst[i] ~= head then\n            table.insert(tail,\
    \ lst[i])\n        end\n    end\n    if #tail <= 1 then\n        return {head,\
    \ unpack(tail)}\n    end\n    local head2 = math.max(unpack(tail))\n    local\
    \ tail2 = {}\n    for i = 1, #tail do\n        if tail[i] ~= head2 then\n    \
    \        table.insert(tail2, tail[i])\n        end\n    end\n    return {head,\
    \ head2, unpack(strange_sort_list(tail2))}\nend", "    local min = table.min(lst)\n\
    \    local max = table.max(lst)\n    local f = true\n    local res = {}\n    for\
    \ _ = 1, #lst do\n        if f then\n            res[#res + 1] = min\n       \
    \     min = table.min(lst, function(a, b) return a > b end)\n        else\n  \
    \          res[#res + 1] = max\n            max = table.max(lst, function(a, b)\
    \ return a < b end)\n        end\n        f = not f\n    end\n    return res\n\
    end", "  local res = {}\n  local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \  local function append_to_res(val)\n    res[#res + 1] = val\n    lst[lst[val]]\
    \ = nil\n  end\n  while next(lst) do\n    append_to_res(min)\n    append_to_res(max)\n\
    \    min, max = math.min(unpack(lst)), math.max(unpack(lst))\n  end\n  return\
    \ res\nend", "    -- return {}\n    -- your code here\n    local sorted_table\
    \ = {}\n    for i = 1, math.floor(#lst / 2) do\n        local min_val = math.min(unpack(lst))\n\
    \        table.insert(sorted_table, min_val)\n        lst[min_val] = nil\n   \
    \     local max_val = math.max(unpack(lst))\n        table.insert(sorted_table,\
    \ max_val)\n        lst[max_val] = nil\n    end\n    if #lst == 1 then\n     \
    \   table.insert(sorted_table, lst[1])\n    end\n    return sorted_table\nend",
  "  local sorted_lst = {}\n  local min, max = min_max(lst)\n  table.insert(sorted_lst,\
    \ min)\n  table.insert(sorted_lst, max)\n  for i = 1, #lst - 2 do\n    min, max\
    \ = min_max(lst, sorted_lst)\n    table.insert(sorted_lst, min)\n    table.insert(sorted_lst,\
    \ max)\n  end\n  return sorted_lst\nend", "    if #lst == 0 then\n        return\
    \ {}\n    end\n    local numbers = {}\n    for _, n in ipairs(lst) do\n      \
    \  table.insert(numbers, n)\n    end\n    local sorted = {}\n    while #numbers\
    \ > 0 do\n        local min, max\n        min, max = get_min_max(numbers)\n  \
    \      table.insert(sorted, min)\n        table.insert(sorted, max)\n        remove_from_list(numbers,\
    \ min)\n        remove_from_list(numbers, max)\n    end\n    return sorted\nend",
  "    local t = {}\n    local cnt = #lst\n    local lo = 1\n    local hi = cnt\n\
    \    local rev = false\n    while cnt > 0 do\n        local v\n        if rev\
    \ then\n            v = lst[hi]\n            hi = hi - 1\n        else\n     \
    \       v = lst[lo]\n            lo = lo + 1\n        end\n        table.insert(t,\
    \ v)\n        cnt = cnt - 1\n        rev = not rev\n    end\n    return t\nend",
  "  -- your implementation here\nend", "  local lst_copy = copy_list(lst)\n  local\
    \ result = {}\n  local list_length = #lst_copy\n  for i = 1, list_length do\n\
    \    local min = min_item(lst_copy)\n    table.insert(result, min)\n    local\
    \ max = max_item(lst_copy)\n    table.insert(result, max)\n    remove_item(lst_copy,\
    \ min)\n    remove_item(lst_copy, max)\n  end\n  return result\nend", "    local\
    \ min = math.min(unpack(lst))\n    local res = {min}\n    local indices = table.icopy(lst)\n\
    \    indices[min] = -1\n    local side = true\n    local size = table.length(lst)\n\
    \    for i = 2, size do\n        local max = table.imax(indices)\n        local\
    \ min = table.imin(indices)\n        local index = side and max or min\n     \
    \   side = not side\n        res[i] = index\n        indices[index] = -1\n   \
    \ end\n    return res\nend", "  if #lst == 0 then\n    return {}\n  end\n  lst\
    \ = table.copy(lst)\n  table.sort(lst)\n  local res = {lst[1]}\n  local pos =\
    \ 2\n  local sign = 1\n  for i = 2, #lst do\n    res[i] = lst[pos]\n    pos =\
    \ pos + sign\n    if pos == #lst then\n      sign = -1\n    elseif pos == 1 then\n\
    \      sign = 1\n    end\n  end\n  return res\nend", "  local function swap(lst,\
    \ from, to)\n    local t = lst[from]\n    lst[from] = lst[to]\n    lst[to] = t\n\
    \  end", "    return ipairs(lst)\nend", "  local max, min = table.maxn(lst), table.minn(lst)\n\
    \  local is_max, res = true, {}\n  for i = 1, max do\n    table.insert(res, is_max\
    \ and max or min)\n    is_max = not is_max\n  end\n  return res\nend", "    if\
    \ not is_table(lst) then\n        return {}\n    end\n    local output = {}\n\
    \    local remaining = {}\n    local min = min(lst)\n    local max = max(lst)\n\
    \    local function get_pair()\n        local removed = remove(lst, min)\n   \
    \     if not is_table(removed) then\n            return {min, max}\n        end\n\
    \        local max_in_removed = max(removed)\n        return {min, max_in_removed}\n\
    \    end\n    while #lst > 0 do\n        local pair = get_pair()\n        output[#output\
    \ + 1] = pair[1]\n        remaining[#remaining + 1] = pair[2]\n        min = min(remaining)\n\
    \        max = max(remaining)\n    end\n    for _, v in ipairs(remaining) do\n\
    \        output[#output + 1] = v\n    end\n    return output\nend", "   local\
    \ res, len = {}, #lst\n   while len ~= 0 do\n      local min, max = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n      table.insert(res, min)\n      table.insert(res,\
    \ max)\n      for i = #lst, 1, -1 do\n         if lst[i] == min or lst[i] == max\
    \ then\n            table.remove(lst, i)\n         end\n      end\n      len =\
    \ len - 2\n   end\n   return res\nend", "    local sorted = {}\n    while #lst\
    \ > 0 do\n        table.insert(sorted, table.remove(lst, 1))\n        table.insert(sorted,\
    \ table.remove(lst))\n    end\n    return sorted\nend", "    -- your code here\n\
    \    local x = {}\n    local len = 0\n    for _, v in pairs(lst) do\n        len\
    \ = len + 1\n        x[len] = v\n    end\n    table.sort(x)\n    local y = {}\n\
    \    local i = 1\n    local j = len\n    while i <= len do\n        y[i] = x[i]\n\
    \        i = i + 1\n        if i <= len then\n            y[i] = x[j]\n      \
    \      j = j - 1\n            i = i + 1\n        end\n    end\n    return y\n\
    end", "   local function helper(l, acc)\n      if #l == 0 then return acc end\n\
    \      local min = math.min(unpack(l))\n      local idx = 1\n      while l[idx]\
    \ ~= min do idx = idx + 1 end\n      table.remove(l, idx)\n      table.insert(acc,\
    \ min)\n      local max = math.max(unpack(l))\n      idx = 1\n      while l[idx]\
    \ ~= max do idx = idx + 1 end\n      table.remove(l, idx)\n      table.insert(acc,\
    \ max)\n      return helper(l, acc)\n   end\n   return helper(lst, {})\nend",
  "  if #lst == 0 then\n    return {}\n  end\n  local result = {}\n  local asc = true\n\
    \  while #lst > 0 do\n    local min_index, max_index\n    if asc then\n      min_index\
    \ = 1\n      for index, value in ipairs(lst) do\n        if lst[min_index] > value\
    \ then\n          min_index = index\n        end\n      end\n      table.insert(result,\
    \ lst[min_index])\n      table.remove(lst, min_index)\n    else\n      max_index\
    \ = 1\n      for index, value in ipairs(lst) do\n        if lst[max_index] < value\
    \ then\n          max_index = index\n        end\n      end\n      table.insert(result,\
    \ lst[max_index])\n      table.remove(lst, max_index)\n    end\n    asc = not\
    \ asc\n  end\n  return result\nend", "    local max = table.max(lst)\n    local\
    \ min = table.min(lst)\n    local ll = #lst\n    local res = {}\n    for i = 1,\
    \ ll, 2 do\n        res[i] = min\n        res[i + 1] = max\n        table.remove(lst,\
    \ table.index_of(lst, min))\n        table.remove(lst, table.index_of(lst, max))\n\
    \        max = table.max(lst)\n        min = table.min(lst)\n    end\n    return\
    \ res\nend", "    local result = {}\n    local is_sorted = false\n    -- 1. get\
    \ minimum and maximum values\n    local min, max = lst[1], lst[1]\n    for _,\
    \ v in ipairs(lst) do\n        if v < min then\n            min = v\n        elseif\
    \ v > max then\n            max = v\n        end\n    end\n    -- 2. while not\
    \ sorted\n    while not is_sorted do\n        -- 3. get the index of minimal and\
    \ maximal values, we can have 2 values to sort\n        local mi, mi_, ma, ma_\
    \ = nil, nil, nil, nil\n        for i, v in ipairs(lst) do\n            if v ==\
    \ min then\n                if mi == nil then\n                    mi = i\n  \
    \              else\n                    mi_ = i\n                end\n      \
    \      elseif v == max then\n                if ma == nil then\n             \
    \       ma = i\n                else\n                    ma_ = i\n          \
    \      end\n            end\n        end\n        -- 4. add values to result\n\
    \        if result[#result] ~= min then\n            result[#result + 1] = min\n\
    \        end\n        if result[#result] ~= max then\n            result[#result\
    \ + 1] = max\n        end\n        -- 5. remove values from lst\n        lst[mi]\
    \ = nil\n        if mi_ ~= nil then\n            lst[mi_] = nil\n        end\n\
    \        lst[ma] = nil\n        if ma_ ~= nil then\n            lst[ma_] = nil\n\
    \        end\n        -- 6. get new min and max\n        min, max = lst[1], lst[1]\n\
    \        for _, v in ipairs(lst) do\n            if v < min then\n           \
    \     min = v\n            elseif v > max then\n                max = v\n    \
    \        end\n        end\n        -- 7. if no min and max, we are sorted\n  \
    \      if min == nil and max == nil then\n            is_sorted = true\n     \
    \   end\n    end\n    return result\nend", "  if #lst < 2 then\n    return lst\n\
    \  end\n  local i, j = 1, #lst\n  local mid = (i + j) // 2\n  local swap_min,\
    \ swap_max\n  while true do\n    swap_min = true\n    swap_max = true\n    for\
    \ k = i, mid do\n      if lst[k] > lst[k + 1] then\n        lst[k], lst[k + 1]\
    \ = lst[k + 1], lst[k]\n        swap_min = false\n      end\n    end\n    if swap_min\
    \ then\n      break\n    end\n    for k = mid + 1, j do\n      if lst[k] < lst[k\
    \ + 1] then\n        lst[k], lst[k + 1] = lst[k + 1], lst[k]\n        swap_max\
    \ = false\n      end\n    end\n    if swap_max then\n      break\n    end\n  end\n\
    \  return lst\nend", "    -- your code here\n    return {}\nend", "    local res\
    \ = {}\n    local sorted = table.sort(lst)\n    local low = 1\n    local high\
    \ = #sorted\n    local len = #sorted\n    local i = 1\n    while len > 0 do\n\
    \        res[i] = sorted[low]\n        res[i + 1] = sorted[high]\n        low\
    \ = low + 1\n        high = high - 1\n        i = i + 2\n        len = len - 2\n\
    \    end\n    return res\nend", "  local res = {}\n  local function push_max(t)\n\
    \    local max_val = math.max(unpack(t))\n    table.insert(res, max_val)\n   \
    \ table.remove_by_value(t, max_val)\n  end\n  local function push_min(t)\n   \
    \ local min_val = math.min(unpack(t))\n    table.insert(res, min_val)\n    table.remove_by_value(t,\
    \ min_val)\n  end\n  while #lst > 0 do\n    push_min(lst)\n    push_max(lst)\n\
    \  end\n  return res\nend", "  if (#lst < 2) then\n    return lst\n  end\n  local\
    \ min_i = 1\n  local max_i = 1\n  for i = 2, #lst do\n    if (lst[i] < lst[min_i])\
    \ then\n      min_i = i\n    end\n    if (lst[i] > lst[max_i]) then\n      max_i\
    \ = i\n    end\n  end\n  local j = 1\n  local lst2 = {}\n  for i = 1, #lst do\n\
    \    if (min_i == max_i) then\n      lst2[j] = lst[min_i]\n      j = j + 1\n \
    \     if (min_i < #lst) then\n        min_i = min_i + 1\n      end\n      if (max_i\
    \ > 1) then\n        max_i = max_i - 1\n      end\n    elseif (i % 2 == 1) then\n\
    \      lst2[j] = lst[min_i]\n      j = j + 1\n      if (min_i < #lst) then\n \
    \       min_i = min_i + 1\n      end\n    else\n      lst2[j] = lst[max_i]\n \
    \     j = j + 1\n      if (max_i > 1) then\n        max_i = max_i - 1\n      end\n\
    \    end\n  end\n  return lst2\nend", "    local r = {}\n    local min = math.min(unpack(lst))\n\
    \    local max = math.max(unpack(lst))\n    for i = 1, #lst do\n        if i %\
    \ 2 == 1 then\n            table.insert(r, min)\n            min = math.min(unpack(lst))\n\
    \        else\n            table.insert(r, max)\n            max = math.max(unpack(lst))\n\
    \        end\n    end\n    return r\nend", "    if #lst == 0 then\n        return\
    \ {}\n    end\n    table.sort(lst)\n    local result = {}\n    local index = 1\n\
    \    local min_index = 1\n    local max_index = #lst\n    while true do\n    \
    \    result[index] = lst[min_index]\n        min_index = min_index + 1\n     \
    \   index = index + 1\n        if min_index > max_index then\n            break\n\
    \        end\n        result[index] = lst[max_index]\n        max_index = max_index\
    \ - 1\n        index = index + 1\n        if min_index > max_index then\n    \
    \        break\n        end\n    end\n    return result\nend", "\tlocal res =\
    \ {}\n\t-- your code goes here\n\treturn res\nend", "\tlocal r = {}\n\tlocal tmp\
    \ = lst\n\t\n\ttable.sort(tmp)\n\t\n\tfor i = 1, #tmp do\n\t\tif i % 2 == 1 then\n\
    \t\t\ttable.insert(r, table.remove(tmp, 1))\n\t\telse\n\t\t\ttable.insert(r, table.remove(tmp))\n\
    \t\tend\n\tend\n\t\n\treturn r\nend", "    if (#lst < 2) then\n        return\
    \ lst\n    end\n    table.sort(lst)\n    local res = {}\n    for i=1,#lst,2 do\n\
    \        res[#res+1] = lst[i]\n        if i+1 <= #lst then\n            res[#res+1]\
    \ = lst[#lst - i + 1]\n        end\n    end\n    return res\nend", "    local\
    \ result = {}\n    table.sort(lst)\n    for i = 1, #lst, 2 do\n        result[i]\
    \ = lst[i]\n        result[i + 1] = lst[#lst - i + 1]\n    end\n    return result\n\
    end", "  local maxs = {}\n  local mins = {}\n  local result = {}\n  local to_search\
    \ = lst", "  local result = {}\n  local asc, desc = false, false\n  while (#lst\
    \ > 0) do\n    if asc == false then\n      table.insert(result, table.remove(lst,\
    \ 1))\n      asc = true\n    elseif desc == false then\n      table.insert(result,\
    \ table.remove(lst, #lst))\n      desc = true\n    else\n      asc, desc = false,\
    \ false\n    end\n  end\n  return result\nend", "  if #lst < 2 then\n    return\
    \ lst\n  end\n  local temp = {}\n  for i = 1, #lst do\n    temp[i] = lst[i]\n\
    \  end\n  local ordered = {}\n  local asc = 1\n  while #temp > 0 do\n    local\
    \ min = math.min(unpack(temp))\n    local max = math.max(unpack(temp))\n    if\
    \ asc == 1 then\n      if #temp > 1 then\n        if temp[1] == min then\n   \
    \       ordered[#ordered + 1] = table.remove(temp, 1)\n        else\n        \
    \  ordered[#ordered + 1] = table.remove(temp, 2)\n        end\n      else\n  \
    \      ordered[#ordered + 1] = table.remove(temp, 1)\n      end\n      asc = -1\n\
    \    else\n      if #temp > 1 then\n        if temp[1] == max then\n         \
    \ ordered[#ordered + 1] = table.remove(temp, 1)\n        else\n          ordered[#ordered\
    \ + 1] = table.remove(temp, 2)\n        end\n      else\n        ordered[#ordered\
    \ + 1] = table.remove(temp, 1)\n      end\n      asc = 1\n    end\n  end\n  return\
    \ ordered\nend", "  local left = {}\n  local right = {}\n  if #lst < 2 then\n\
    \    return lst\n  end\n  -- Minimum value to the left\n  local min_val = math.min(unpack(lst))\n\
    \  table.insert(left, min_val)\n  for i = 1, #lst do\n    local val = lst[i]\n\
    \    if val > min_val then\n      table.insert(right, val)\n    end\n  end\n \
    \ -- And maximum value to the right\n  local max_val = math.max(unpack(right))\n\
    \  table.insert(left, max_val)\n  for i = 1, #right do\n    local val = right[i]\n\
    \    if val < max_val then\n      table.insert(left, val)\n    end\n  end\n  --\
    \ Then sort both left and right\n  left = strange_sort_list(left)\n  right = strange_sort_list(right)\n\
    \  -- And merge them back\n  for i = 1, #right do\n    table.insert(left, right[i])\n\
    \  end\n  return left\nend", "    local function odd_even(t)\n        local odd,\
    \ even = {}, {}\n        for i, v in ipairs(t) do\n            if i % 2 == 0 then\n\
    \                even[#even + 1] = v\n            else\n                odd[#odd\
    \ + 1] = v\n            end\n        end\n        return odd, even\n    end",
  "   local list = {}\n   for i = 1, #lst do\n      list[i] = lst[i]\n   end\n   table.sort(list)\n\
    \   local result = {}\n   for i = 1, #list do\n      if i % 2 == 1 then\n    \
    \     result[#result + 1] = list[i]\n      else\n         result[#result + 1]\
    \ = list[#list - i + 1]\n      end\n   end\n   return result\nend", "    local\
    \ min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n    if min\
    \ == max then\n        return lst\n    end\n    local new_list = {min}\n    local\
    \ i = 1\n    for _ = 1, #lst - 1 do\n        if i % 2 == 0 then\n            local\
    \ min_val = math.min(unpack(lst))\n            table.insert(new_list, min_val)\n\
    \            table.remove(lst, table_index_of(lst, min_val))\n        else\n \
    \           local max_val = math.max(unpack(lst))\n            table.insert(new_list,\
    \ max_val)\n            table.remove(lst, table_index_of(lst, max_val))\n    \
    \    end\n        i = i + 1\n    end\n    return new_list\nend", "    local function\
    \ get_min_idx(lst)\n        local min_val = math.huge\n        local min_idx =\
    \ 0\n        for idx, val in ipairs(lst) do\n            if val < min_val then\n\
    \                min_val = val\n                min_idx = idx\n            end\n\
    \        end\n        return min_idx\n    end", "  -- your code here\nend", " \
    \ local res, min, max = {}, nil, nil\n  while #lst > 0 do\n    min, max = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n    res[#res + 1] = min\n    if min ~= max then\n   \
    \   res[#res + 1] = max\n    end\n    for i = #lst, 1, -1 do\n      if lst[i]\
    \ == min or lst[i] == max then\n        table.remove(lst, i)\n      end\n    end\n\
    \  end\n  return res\nend", "  if #lst == 0 then\n    return {}\n  end\n  local\
    \ result = {}\n  while #lst > 0 do\n    result[#result + 1] = table.remove(lst,\
    \ 1)\n    result[#result + 1] = table.remove(lst, #lst)\n  end\n  return result\n\
    end", "  if #lst == 0 then\n    return {}\n  end\n  local res = {}\n  local odd\
    \ = false\n  while #lst > 0 do\n    local x = table.remove(lst, 1)\n    for i,\
    \ y in ipairs(lst) do\n      if (odd and x > y) or (not odd and x < y) then\n\
    \        x = y\n        table.remove(lst, i)\n      end\n    end\n    table.insert(res,\
    \ x)\n    odd = not odd\n  end\n  return res\nend", "   local odd = {}\n   local\
    \ even = {}\n   local ret = {}\n   local min = math.min(unpack(lst))\n   local\
    \ max = math.max(unpack(lst))\n   local i = 1\n   while true do\n      if i %\
    \ 2 == 1 then\n         local idx = table.indexof(lst, min)\n         if idx then\n\
    \            table.insert(odd, min)\n            table.remove(lst, idx)\n    \
    \        min = math.min(unpack(lst))\n         end\n      else\n         local\
    \ idx = table.indexof(lst, max)\n         if idx then\n            table.insert(even,\
    \ max)\n            table.remove(lst, idx)\n            max = math.max(unpack(lst))\n\
    \         end\n      end\n      if #lst == 0 then\n         break\n      end\n\
    \      i = i + 1\n   end\n   for i = 1, #odd do\n      table.insert(ret, odd[i])\n\
    \      table.insert(ret, even[i])\n   end\n   return ret\nend", "\tlocal strange_order\
    \ = {  }\n\tlocal result = {  }\n\tif #lst == 0 then\n\t\treturn strange_order\n\
    \tend\n\tlocal index = 1\n\twhile #lst > 0 do\n\t\tlocal min_value = lst[1]\n\t\
    \tlocal min_index = 1\n\t\tfor i = 1, #lst do\n\t\t\tif lst[i] < min_value then\n\
    \t\t\t\tmin_value = lst[i]\n\t\t\t\tmin_index = i\n\t\t\tend\n\t\tend\n\t\ttable.remove(lst,\
    \ min_index)\n\t\tstrange_order[index] = min_value\n\t\tindex = index + 1\n\t\t\
    local max_value = lst[1]\n\t\tlocal max_index = 1\n\t\tfor i = 1, #lst do\n\t\t\
    \tif lst[i] > max_value then\n\t\t\t\tmax_value = lst[i]\n\t\t\t\tmax_index =\
    \ i\n\t\t\tend\n\t\tend\n\t\ttable.remove(lst, max_index)\n\t\tstrange_order[index]\
    \ = max_value\n\t\tindex = index + 1\n\tend\n\treturn strange_order\nend", " \
    \   local res = {}\n    while #lst > 0 do\n        local m = math.min(unpack(lst))\n\
    \        local i = table.index_of(lst, m)\n        table.remove(lst, i)\n    \
    \    table.insert(res, m)\n        if #lst == 0 then\n            break\n    \
    \    end\n        local M = math.max(unpack(lst))\n        local I = table.index_of(lst,\
    \ M)\n        table.remove(lst, I)\n        table.insert(res, M)\n    end\n  \
    \  return res\nend", "  -- implement here\nend", "    local len = #lst\n    if\
    \ len == 0 then\n        return {}\n    end\n    table.sort(lst)\n    local res\
    \ = {}\n    local i = 1\n    local j = len\n    while i <= len and j >= 1 do\n\
    \        res[#res + 1] = lst[i]\n        res[#res + 1] = lst[j]\n        i = i\
    \ + 1\n        j = j - 1\n    end\n    return res\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
