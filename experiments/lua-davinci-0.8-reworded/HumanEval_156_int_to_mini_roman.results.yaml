language: lua
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number > 0, \"number must be positive\")\n    assert(number <= 1000,\
    \ \"number too large\")\n    local result = \"\"\n    local i = 1\n    while number\
    \ > 0 do\n        local v = number % 10\n        local roman = integer_to_roman_digit[v]\n\
    \        local factor = roman_digit_factor[i]\n        result = roman .. result\n\
    \        i = i + 1\n        number = (number - v) / 10\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1uei27j6.lua:18:\
    \ attempt to index a nil value (global 'integer_to_roman_digit')\nstack traceback:\n\
    \t/tmp/tmp1uei27j6.lua:18: in local 'candidate'\n\t/tmp/tmp1uei27j6.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- TODO: implement.\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy82neaeb.lua:18:\
    \ expected: \"xix\"\nactual: nil\nstack traceback:\n\t/tmp/tmpy82neaeb.lua:18:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number > 0, \"Number must be positive\")\n  assert(number <= 1000, \"\
    Number must be <= 1000\")\n  local result = \"\"\n  local digit = math.floor(number\
    \ / 100)\n  number = number % 100\n  if digit == 9 then\n    result = result ..\
    \ \"cm\"\n  elseif digit >= 5 then\n    result = result .. \"d\"\n    while digit\
    \ > 5 do\n      result = result .. \"c\"\n      digit = digit - 1\n    end\n \
    \ elseif digit == 4 then\n    result = result .. \"cd\"\n  else\n    while digit\
    \ > 0 do\n      result = result .. \"c\"\n      digit = digit - 1\n    end\n \
    \ end\n  digit = math.floor(number / 10)\n  number = number % 10\n  if digit ==\
    \ 9 then\n    result = result .. \"xc\"\n  elseif digit >= 5 then\n    result\
    \ = result .. \"l\"\n    while digit > 5 do\n      result = result .. \"x\"\n\
    \      digit = digit - 1\n    end\n  elseif digit == 4 then\n    result = result\
    \ .. \"xl\"\n  else\n    while digit > 0 do\n      result = result .. \"x\"\n\
    \      digit = digit - 1\n    end\n  end\n  digit = number\n  if digit == 9 then\n\
    \    result = result .. \"ix\"\n  elseif digit >= 5 then\n    result = result\
    \ .. \"v\"\n    while digit > 5 do\n      result = result .. \"i\"\n      digit\
    \ = digit - 1\n    end\n  elseif digit == 4 then\n    result = result .. \"iv\"\
    \n  else\n    while digit > 0 do\n      result = result .. \"i\"\n      digit\
    \ = digit - 1\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3skszmqo.lua:87:\
    \ expected: \"m\"\nactual: \"dccccc\"\nstack traceback:\n\t/tmp/tmp3skszmqo.lua:87:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Validate input number\n  if number <= 0 or number > 1000 then\n    error('number\
    \ must be between 1 and 1000')\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpf3pz5qng.lua:36: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_map = {\n    M = 1000,\n    CM = 900,\n    D = 500,\n    CD = 400,\n\
    \    C = 100,\n    XC = 90,\n    L = 50,\n    XL = 40,\n    X = 10,\n    IX =\
    \ 9,\n    V = 5,\n    IV = 4,\n    I = 1\n  }\n  local roman_numerals = {}\n \
    \ local remainder = number\n  for roman, int in pairs(roman_map) do\n    while\
    \ remainder >= int do\n      table.insert(roman_numerals, roman)\n      remainder\
    \ = remainder - int\n    end\n  end\n  return table.concat(roman_numerals)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd8tsx_ib.lua:41:\
    \ expected: \"xix\"\nactual: \"XIIIIIIIII\"\nstack traceback:\n\t/tmp/tmpd8tsx_ib.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = \"\"\n  for n, f in pairs(ones) do\n    if number >= n then\n\
    \      result = result .. string.rep(f, number / n)\n      number = number % n\n\
    \    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdf82toyf.lua:13:\
    \ bad argument #1 to 'for iterator' (table expected, got nil)\nstack traceback:\n\
    \t/tmp/tmpdf82toyf.lua:13: in local 'candidate'\n\t/tmp/tmpdf82toyf.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local remainder = number\n  local results = {}\n  for _, roman_numeral in ipairs(ROMAN_NUMERALS)\
    \ do\n    local count = math.floor(remainder / roman_numeral.value)\n    if count\
    \ > 0 then\n      remainder = remainder - (count * roman_numeral.value)\n    \
    \  for i = 1, count do\n        table.insert(results, roman_numeral.letter)\n\
    \      end\n    end\n  end\n  return table.concat(results)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local map = {\n        { 'm', 1000, 0 },\n        { 'cm', 900,  1 },\n  \
    \      { 'd',  500,  0 },\n        { 'cd', 400,  1 },\n        { 'c',  100,  0\
    \ },\n        { 'xc',  90,  1 },\n        { 'l',   50,  0 },\n        { 'xl',\
    \  40,  1 },\n        { 'x',   10,  0 },\n        { 'ix',   9,  1 },\n       \
    \ { 'v',    5,  0 },\n        { 'iv',   4,  1 },\n        { 'i',    1,  0 },\n\
    \    }\n    if number < 1 or number > 1000 then\n        error(\"number should\
    \ be 1-1000\")\n    end\n    local result = \"\"\n    local pos = 1\n    while\
    \ number > 0 do\n        local item = map[pos]\n        local value = item[2]\n\
    \        local four = item[3]\n        if number >= value then\n            if\
    \ four == 1 then\n                result = result .. item[1]\n               \
    \ pos = pos + 1\n            end\n            result = result .. item[1]\n   \
    \         number = number - value\n        else\n            pos = pos + 1\n \
    \       end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpckt7o2qp.lua:53:\
    \ expected: \"xix\"\nactual: \"xixix\"\nstack traceback:\n\t/tmp/tmpckt7o2qp.lua:53:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local table = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n    {400,\
    \ 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n\
    \    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'}\n\
    \  }\n  local roman = ''\n  for _, t in ipairs(table) do\n    local num, str =\
    \ t[1], t[2]\n    while number >= num do\n      roman = roman .. str\n      number\
    \ = number - num\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local ROMAN_SYMBOLS = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n  local parts =\
    \ {}\n  local left = number\n  local repeat_count = 0\n  for base=7, 1, -2 do\n\
    \    repeat_count = left % 10\n    local lookahead = (left % 100) - repeat_count\n\
    \    if repeat_count == 9 then\n      table.insert(parts, 1, ROMAN_SYMBOLS[base+2])\n\
    \      table.insert(parts, 1, ROMAN_SYMBOLS[base])\n    elseif repeat_count >=\
    \ 5 then\n      table.insert(parts, 1, ROMAN_SYMBOLS[base+1])\n      repeat_count\
    \ = repeat_count - 5\n      while repeat_count > 0 do\n        table.insert(parts,\
    \ 1, ROMAN_SYMBOLS[base])\n        repeat_count = repeat_count - 1\n      end\n\
    \    elseif repeat_count == 4 then\n      table.insert(parts, 1, ROMAN_SYMBOLS[base+2])\n\
    \      table.insert(parts, 1, ROMAN_SYMBOLS[base+1])\n    else\n      while repeat_count\
    \ > 0 do\n        table.insert(parts, 1, ROMAN_SYMBOLS[base])\n        repeat_count\
    \ = repeat_count - 1\n      end\n    end\n    left = math.floor(left / 10)\n \
    \ end\n  return table.concat(parts)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_bd4f_qe.lua:46:\
    \ expected: \"xix\"\nactual: \"cm\"\nstack traceback:\n\t/tmp/tmp_bd4f_qe.lua:46:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  return int_to_roman(number):lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpytjlpmkm.lua:12:\
    \ attempt to call a nil value (global 'int_to_roman')\nstack traceback:\n\t/tmp/tmpytjlpmkm.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmpytjlpmkm.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local number = tostring(number)\n    local result = ''\n    local digit_map\
    \ = {\n        ['0'] = '',\n        ['1'] = 'i',\n        ['2'] = 'ii',\n    \
    \    ['3'] = 'iii',\n        ['4'] = 'iv',\n        ['5'] = 'v',\n        ['6']\
    \ = 'vi',\n        ['7'] = 'vii',\n        ['8'] = 'viii',\n        ['9'] = 'ix',\n\
    \    }\n    local power_map = {\n        [0] = '',\n        [1] = 'x',\n     \
    \   [2] = 'c',\n        [3] = 'm',\n    }\n    for index = 1, #number do\n   \
    \     local digit = string.sub(number, index, index)\n        local power = #number\
    \ - index\n        result = result .. string.rep(power_map[power], digit) .. digit_map[digit]\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpizgnua8e.lua:43:\
    \ expected: \"xix\"\nactual: \"xiix\"\nstack traceback:\n\t/tmp/tmpizgnua8e.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    return convert_to_roman(number, roman_digits)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpsbudbi08.lua:12:\
    \ attempt to call a nil value (global 'convert_to_roman')\nstack traceback:\n\t\
    /tmp/tmpsbudbi08.lua:12: in local 'candidate'\n\t/tmp/tmpsbudbi08.lua:18: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_number_table = {\n    {'', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii',\
    \ 'viii', 'ix'},\n    {'', 'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc'},\n\
    \    {'', 'c', 'cc', 'ccc', 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm'},\n    {'', 'm',\
    \ 'mm', 'mmm'}\n  }\n  local roman_string = ''\n  local digit = 0\n  while number\
    \ > 0 do\n    roman_string = roman_number_table[#roman_number_table][number %\
    \ 10] .. roman_string\n    number = math.floor(number / 10)\n    digit = digit\
    \ + 1\n  end\n  return roman_string\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpy1s3caik.lua:21:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpy1s3caik.lua:21:\
    \ in local 'candidate'\n\t/tmp/tmpy1s3caik.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local symbols = {'m', 'd', 'c', 'l', 'x', 'v', 'i'}\n    local result = ''\n\
    \    local i = 1\n    local d = 1000\n    while d > 0 do\n        local m = number\
    \ % 10\n        number = math.floor(number / 10)\n        if m ~= 0 then\n   \
    \         local q = m * d\n            if q == 900 then\n                result\
    \ = result .. symbols[i] .. symbols[i - 2]\n            elseif q == 400 then\n\
    \                result = result .. symbols[i] .. symbols[i - 1]\n           \
    \ elseif q >= 500 then\n                result = result .. symbols[i - 1] .. string.rep(symbols[i],\
    \ q / 500)\n            elseif q >= 100 then\n                result = result\
    \ .. string.rep(symbols[i], q / 100)\n            elseif q == 90 then\n      \
    \          result = result .. symbols[i + 1] .. symbols[i - 2]\n            elseif\
    \ q == 40 then\n                result = result .. symbols[i + 1] .. symbols[i\
    \ - 1]\n            elseif q >= 50 then\n                result = result .. symbols[i\
    \ - 1] .. string.rep(symbols[i + 1], q / 50)\n            elseif q >= 10 then\n\
    \                result = result .. string.rep(symbols[i + 1], q / 10)\n     \
    \       elseif q == 9 then\n                result = result .. symbols[i + 2]\
    \ .. symbols[i - 2]\n            elseif q == 4 then\n                result =\
    \ result .. symbols[i + 2] .. symbols[i - 1]\n            elseif q >= 5 then\n\
    \                result = result .. symbols[i - 1] .. string.rep(symbols[i + 2],\
    \ q / 5)\n            else\n                result = result .. string.rep(symbols[i\
    \ + 2], q)\n            end\n        end\n        i = i + 2\n        d = d / 10\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpucaof8_p.lua:26:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpucaof8_p.lua:26:\
    \ in local 'candidate'\n\t/tmp/tmpucaof8_p.lua:56: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- TODO\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfq1im78a.lua:18:\
    \ expected: \"xix\"\nactual: nil\nstack traceback:\n\t/tmp/tmpfq1im78a.lua:18:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {\n        ['M'] = 1000,\n        ['CM'] = 900,\n        ['D']\
    \ = 500,\n        ['CD'] = 400,\n        ['C'] = 100,\n        ['XC'] = 90,\n\
    \        ['L'] = 50,\n        ['XL'] = 40,\n        ['X'] = 10,\n        ['IX']\
    \ = 9,\n        ['V'] = 5,\n        ['IV'] = 4,\n        ['I'] = 1\n    }\n  \
    \  local num = number\n    local roman = ''\n    for ch, arabic in pairs(romans)\
    \ do\n        local repeats = math.floor(num / arabic)\n        roman = roman\
    \ .. string.rep(ch, repeats)\n        num = num - repeats * arabic\n    end\n\
    \    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpot58luhl.lua:40:\
    \ expected: \"xix\"\nactual: \"IVIVIVIVIII\"\nstack traceback:\n\t/tmp/tmpot58luhl.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = {}\n    local i = 1\n    while number > 0 do\n        if number\
    \ >= 10 then\n            if number >= 100 then\n                if number >=\
    \ 1000 then\n                    result[i] = 'm'\n                    number =\
    \ number - 1000\n                else\n                    result[i] = 'c'\n \
    \                   number = number - 100\n                end\n            else\n\
    \                result[i] = 'x'\n                number = number - 10\n     \
    \       end\n        else\n            if number >= 5 then\n                result[i]\
    \ = 'v'\n                number = number - 5\n            else\n             \
    \   result[i] = 'i'\n                number = number - 1\n            end\n  \
    \      end\n        i = i + 1\n    end\n    return concat(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpy5793gpf.lua:39:\
    \ attempt to call a nil value (global 'concat')\nstack traceback:\n\t/tmp/tmpy5793gpf.lua:39:\
    \ in local 'candidate'\n\t/tmp/tmpy5793gpf.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- returns the roman numeral of a given number\n  local int_to_roman = {\n\
    \    [1]='i', [2]='ii', [3]='iii', [4]='iv', [5]='v', [6]='vi', [7]='vii', [8]='viii',\
    \ [9]='ix',\n    [10]='x', [20]='xx', [30]='xxx', [40]='xl', [50]='l', [60]='lx',\
    \ [70]='lxx', [80]='lxxx', [90]='xc',\n    [100]='c', [200]='cc', [300]='ccc',\
    \ [400]='cd', [500]='d', [600]='dc', [700]='dcc', [800]='dccc', [900]='cm',\n\
    \    [1000]='m', [2000]='mm', [3000]='mmm', [4000]='mv', [5000]='v', [6000]='vm',\
    \ [7000]='vmm', [8000]='vmmm', [9000]='mx',\n  }\n  if number > 1000 then\n  \
    \  return 'm' .. ('x'):rep(number-1000)\n  else\n    local _, remainder = number:floor(1000)\n\
    \    if remainder == 0 then\n      return int_to_roman[number]\n    else\n   \
    \   local thousands, hundreds = remainder:floor(100)\n      local units = remainder\
    \ - hundreds * 100\n      return (int_to_roman[thousands*1000] or '') .. (int_to_roman[hundreds*100]\
    \ or '') .. (int_to_roman[units] or '')\n    end\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp579na0td.lua:22:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmp579na0td.lua:22:\
    \ in local 'candidate'\n\t/tmp/tmp579na0td.lua:36: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 or number > 1000 then\n    return \"\"\n  end\n  local result\
    \ = \"\"\n  if number >= 1000 then\n    result = \"m\"\n    number = number -\
    \ 1000\n  end\n  if number >= 900 then\n    result = result .. \"cm\"\n    number\
    \ = number - 900\n  end\n  if number >= 500 then\n    result = result .. \"d\"\
    \n    number = number - 500\n  end\n  if number >= 400 then\n    result = result\
    \ .. \"cd\"\n    number = number - 400\n  end\n  if number >= 100 then\n    result\
    \ = result .. (\"c\"):rep(math.floor(number / 100))\n    number = number % 100\n\
    \  end\n  if number >= 90 then\n    result = result .. \"xc\"\n    number = number\
    \ - 90\n  end\n  if number >= 50 then\n    result = result .. \"l\"\n    number\
    \ = number - 50\n  end\n  if number >= 40 then\n    result = result .. \"xl\"\n\
    \    number = number - 40\n  end\n  if number >= 10 then\n    result = result\
    \ .. (\"x\"):rep(math.floor(number / 10))\n    number = number % 10\n  end\n \
    \ if number >= 9 then\n    result = result .. \"ix\"\n    number = number - 9\n\
    \  end\n  if number >= 5 then\n    result = result .. \"v\"\n    number = number\
    \ - 5\n  end\n  if number >= 4 then\n    result = result .. \"iv\"\n    number\
    \ = number - 4\n  end\n  if number >= 1 then\n    result = result .. (\"i\"):rep(number)\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal result = ''\n\tfor key, value in pairs(mini_roman_letters) do\n\t\tlocal\
    \ letter_count = math.floor(number / value)\n\t\tif letter_count > 0 then\n\t\t\
    \tresult = result .. string.rep(key, letter_count)\n\t\t\tnumber = number - letter_count\
    \ * value\n\t\tend\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph3vy8pcr.lua:13:\
    \ bad argument #1 to 'for iterator' (table expected, got nil)\nstack traceback:\n\
    \t/tmp/tmph3vy8pcr.lua:13: in local 'candidate'\n\t/tmp/tmph3vy8pcr.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local msg = \"number must be in range (1, 1000)\"\n  assert(number >= 1 and\
    \ number <= 1000, msg)\n  local numerals = {M = 1000, D = 500, C = 100, L = 50,\
    \ X = 10, V = 5, I = 1}\n  local digits = reverse(number_to_digits(number))\n\
    \  local answer = \"\"\n  for i = 1, #digits do\n    answer = answer .. mini_roman_digits(digits[i],\
    \ i)\n  end\n  return answer\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2csvcb86.lua:15:\
    \ attempt to call a nil value (global 'number_to_digits')\nstack traceback:\n\t\
    /tmp/tmp2csvcb86.lua:15: in local 'candidate'\n\t/tmp/tmp2csvcb86.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local mini_roman_table = {\n        {1, \"i\"},\n        {4, \"iv\"},\n \
    \       {5, \"v\"},\n        {9, \"ix\"},\n        {10, \"x\"},\n        {40,\
    \ \"xl\"},\n        {50, \"l\"},\n        {90, \"xc\"},\n        {100, \"c\"},\n\
    \        {400, \"cd\"},\n        {500, \"d\"},\n        {900, \"cm\"},\n     \
    \   {1000, \"m\"}\n    }\n    local mini_roman_string = \"\"\n    while number\
    \ > 0 do\n        local digit = 1\n        while digit < 14 and number - mini_roman_table[digit][1]\
    \ < 0 do\n            digit = digit + 1\n        end\n        number = number\
    \ - mini_roman_table[digit][1]\n        mini_roman_string = mini_roman_string\
    \ .. mini_roman_table[digit][2]\n    end\n    return mini_roman_string\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7cyjbwx1.lua:42:\
    \ expected: \"xix\"\nactual: \"iiiiiiiiiiiiiiiiiii\"\nstack traceback:\n\t/tmp/tmp7cyjbwx1.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = \"\"\n  local values = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l',\
    \ 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n  local ints = {1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n  if not number or number < 1 or number > 1000\
    \ then\n    return nil\n  end\n  for i,v in ipairs(ints) do\n    while number\
    \ >= v do\n      number = number - v\n      result = result .. values[i]\n   \
    \ end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    --\n    -- Please complete the implementation of this function, using a\n\
    \    -- simple, finite, looping construct such as while, repeat, or\n    -- for\
    \ to pass the test suite.\n    --\n    -- CAUTION: We do not insist that your\
    \ implementation be very\n    -- efficient (although we certainly would encourage\
    \ you to write\n    -- efficient code if you feel so inclined), but it must always\n\
    \    -- return the correct answer.\n    --\n    local value = {1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    local roman = {'m', 'cm', 'd', 'cd',\
    \ 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n    local result = ''\n  \
    \  for i = 1, #value do\n        while number >= value[i] do\n            number\
    \ = number - value[i]\n            result = result .. roman[i]\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Assume that the input is 1 <= number <= 1000,\n    -- and convert it to\
    \ a string in the range 'i' to 'm'.\n    local mini_roman_digits = {'i', 'v',\
    \ 'x', 'l', 'c', 'd', 'm'}\n    local result = \"\"\n    local i = 7\n    repeat\n\
    \        local digit = number % 10\n        if digit == 9 then\n            result\
    \ = mini_roman_digits[i - 1] .. mini_roman_digits[i + 1] .. result\n        elseif\
    \ digit >= 5 then\n            result = mini_roman_digits[i] .. string.rep(mini_roman_digits[i\
    \ - 1], digit - 5) .. result\n        elseif digit == 4 then\n            result\
    \ = mini_roman_digits[i - 1] .. mini_roman_digits[i] .. result\n        else\n\
    \            result = string.rep(mini_roman_digits[i - 1], digit) .. result\n\
    \        end\n        number = math.floor(number / 10)\n        i = i + 2\n  \
    \  until number == 0\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpa5e2vb1w.lua:20:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpa5e2vb1w.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmpa5e2vb1w.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    number = tonumber(number)\n    if not (1 <= number and number <= 1000) then\n\
    \        return nil\n    end\n    local roman = ''\n    for _, item in ipairs(ROMAN_DIGITS)\
    \ do\n        for i = 1, item[2] do\n            roman = roman .. item[1]\n  \
    \      end\n        number = number - item[2] * item[3]\n        if number ==\
    \ 0 then\n            break\n        end\n    end\n    return roman\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    number = tonumber(number)\n    local numerals = {m = 1000, d = 500, c = 100,\
    \ l = 50, x = 10, v = 5, i = 1}\n    local values = {}\n    for symbol, value\
    \ in pairs(numerals) do\n        local amount = math.floor(number / value)\n \
    \       values[symbol] = amount\n        number = number - amount * value\n  \
    \  end\n    local groups = {\n        {'i', 'v', 'x'},\n        {'x', 'l', 'c'},\n\
    \        {'c', 'd', 'm'},\n    }\n    local result = ''\n    for _, group in ipairs(groups)\
    \ do\n        local ones = values[group[1]]\n        local fives = values[group[2]]\n\
    \        local tens = values[group[3]]\n        -- Less than 4\n        if ones\
    \ < 4 then\n            if ones == 3 then\n                result = result ..\
    \ group[1] .. group[2]\n            elseif ones == 2 then\n                result\
    \ = result .. group[1] .. group[1]\n            elseif ones == 1 then\n      \
    \          result = result .. group[1]\n            end\n        -- Between 4\
    \ and 8\n        elseif ones < 9 then\n            if ones == 8 then\n       \
    \         result = result .. group[1] .. group[3]\n            elseif ones ==\
    \ 7 then\n                result = result .. group[2] .. group[1] .. group[1]\n\
    \            elseif ones == 6 then\n                result = result .. group[2]\
    \ .. group[1]\n            elseif ones == 5 then\n                result = result\
    \ .. group[2]\n            elseif ones == 4 then\n                result = result\
    \ .. group[1] .. group[2]\n            end\n        -- 9 or 10\n        else\n\
    \            if tens == 1 then\n                result = result .. group[1] ..\
    \ group[3]\n            else\n                result = result .. group[1] .. group[1]\
    \ .. group[3]\n            end\n        end\n    end\n    return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuzy1sd7v.lua:67:\
    \ expected: \"xix\"\nactual: \"iix\"\nstack traceback:\n\t/tmp/tmpuzy1sd7v.lua:67:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = \"\"\n    for value, numeral in pairs(roman) do\n        while\
    \ number >= value do\n            result = result .. numeral\n            number\
    \ = number - value\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpufpo2er1.lua:13:\
    \ bad argument #1 to 'for iterator' (table expected, got nil)\nstack traceback:\n\
    \t/tmp/tmpufpo2er1.lua:13: in local 'candidate'\n\t/tmp/tmpufpo2er1.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(type(number) == \"number\", \"input must be a number\")\n    assert(number\
    \ > 0, \"input must be greater than 0\")\n    assert(number <= 1000, \"input must\
    \ be less than or equal to 1000\")\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpx2cfl59u.lua:35: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local table = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v',\
    \ 'iv', 'i'}\n    local arabic = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1}\n    local i = 1\n    local roman = ''\n    while number > 0 do\n \
    \       local count = math.floor(number / arabic[i])\n        number = number\
    \ - (arabic[i] * count)\n        for j = 1, count do\n            roman = roman\
    \ .. table[i]\n        end\n        i = i + 1\n    end\n    return roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(type(number) == \"number\")\n    assert(number >= 1 and number <=\
    \ 1000)\n    local s = \"\"\n    for i, d in ipairs(DIGITS) do\n        local\
    \ q, r = math.floor(number / d), number % d\n        if q == 4 then\n        \
    \    s = s .. SYMBOLS[i] .. SYMBOLS[i+1]\n        elseif q == 9 then\n       \
    \     s = s .. SYMBOLS[i] .. SYMBOLS[i+2]\n        else\n            s = s ..\
    \ SYMBOLS[i+1]:rep(q)\n        end\n        number = r\n    end\n    return s\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal nums = {1000, 500, 100, 50, 10, 5, 1}\n\tlocal roman = {'m', 'd', 'c',\
    \ 'l', 'x', 'v', 'i'}\n\tlocal buf = {}\n\tlocal remaining = number\n\tfor i,v\
    \ in ipairs(nums) do\n\t\tlocal times = math.floor(remaining / v)\n\t\tremaining\
    \ = remaining % v\n\t\tif times == 4 then\n\t\t\ttable.insert(buf, roman[i])\n\
    \t\t\ttable.insert(buf, roman[i-1])\n\t\telseif times > 0 then\n\t\t\ttable.insert(buf,\
    \ roman[i]:rep(times))\n\t\tend\n\tend\n\treturn table.concat(buf)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqyxrizz5.lua:32:\
    \ expected: \"xix\"\nactual: \"xviv\"\nstack traceback:\n\t/tmp/tmpqyxrizz5.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local digits = {}\n  local index = 1\n  while number > 0 do\n    local digit\
    \ = number % 10\n    if digit > 0 then\n      if (digit < 4) then\n        --\
    \ Prepend up to 3 I's.\n        for i = 1, digit do\n          digits[index] =\
    \ 'i'\n          index = index + 1\n        end\n      elseif (digit == 4) then\n\
    \        -- Prepend IV.\n        digits[index] = 'iv'\n        index = index +\
    \ 1\n      elseif (digit == 5) then\n        -- Prepend V.\n        digits[index]\
    \ = 'v'\n        index = index + 1\n      elseif (digit == 9) then\n        --\
    \ Prepend IX.\n        digits[index] = 'ix'\n        index = index + 1\n     \
    \ else\n        -- Prepend a V and up to 3 I's.\n        digits[index] = 'v'\n\
    \        index = index + 1\n        for i = 1, digit - 5 do\n          digits[index]\
    \ = 'i'\n          index = index + 1\n        end\n      end\n    end\n    number\
    \ = (number - digit) / 10\n  end\n  return table.concat(digits):reverse()\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpin0ewgv7.lua:53:\
    \ expected: \"xix\"\nactual: \"ixi\"\nstack traceback:\n\t/tmp/tmpin0ewgv7.lua:53:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local numeral = {}\n    local int = number\n    for _, roman in ipairs({'m',\
    \ 'd', 'c', 'l', 'x', 'v', 'i'}) do\n        local value = roman_to_int(roman)\n\
    \        if int >= value then\n            local count = math.floor(int / value)\n\
    \            int = int - count * value\n            for i = 1, count do\n    \
    \            table.insert(numeral, roman)\n            end\n        end\n    end\n\
    \    return table.concat(numeral)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpl5kivvmt.lua:15:\
    \ attempt to call a nil value (global 'roman_to_int')\nstack traceback:\n\t/tmp/tmpl5kivvmt.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpl5kivvmt.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal result = ''\n\tlocal symbols = {\n\t\t['M'] = 1000,\n\t\t['D'] = 500,\n\
    \t\t['C'] = 100,\n\t\t['L'] = 50,\n\t\t['X'] = 10,\n\t\t['V'] = 5,\n\t\t['I']\
    \ = 1\n\t}\n\tfor symbol, value in pairs(symbols) do\n\t\tlocal n = math.floor(number\
    \ / value)\n\t\tnumber = number % value\n\t\tfor _ = 1, n do\n\t\t\tresult = result\
    \ .. symbol\n\t\tend\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpspu_avbd.lua:35:\
    \ expected: \"xix\"\nactual: \"XIIIIIIIII\"\nstack traceback:\n\t/tmp/tmpspu_avbd.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number > 1000 or number < 1 then\n        return\n    end\n    local result\
    \ = \"\"\n    local m = floor(number / 1000)\n    number = number % 1000\n   \
    \ if m > 0 then\n        result = result .. string.rep(\"m\", m)\n    end\n  \
    \  local c = floor(number / 100)\n    number = number % 100\n    if c > 0 then\n\
    \        if c > 3 then\n            result = result .. \"d\"\n        else\n \
    \           result = result .. string.rep(\"c\", c)\n        end\n    end\n  \
    \  local x = floor(number / 10)\n    number = number % 10\n    if x > 0 then\n\
    \        if x > 3 then\n            result = result .. \"l\"\n        else\n \
    \           result = result .. string.rep(\"x\", x)\n        end\n    end\n  \
    \  if number > 0 then\n        if number > 3 then\n            result = result\
    \ .. \"v\"\n        else\n            result = result .. string.rep(\"i\", number)\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7_r3abe4.lua:16:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmp7_r3abe4.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp7_r3abe4.lua:52: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number >= 1 and number <= 1000, 'value out of range')\n    local roman\
    \ = ''\n    local div, mod = math.floor(number / 10), number % 10\n    roman =\
    \ roman .. string.rep('x', div)\n    if mod == 9 then\n        roman = roman ..\
    \ 'ix'\n    elseif mod == 4 then\n        roman = roman .. 'iv'\n    else\n  \
    \      div, mod = math.floor(mod / 5), mod % 5\n        roman = roman .. string.rep('v',\
    \ div)\n        roman = roman .. string.rep('i', mod)\n    end\n    return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvglo2ylf.lua:32:\
    \ expected: \"clii\"\nactual: \"xxxxxxxxxxxxxxxii\"\nstack traceback:\n\t/tmp/tmpvglo2ylf.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local mini_roman_numerals = {\n        'i', 'iv', 'v', 'ix', 'x', 'xl', 'l',\
    \ 'xc', 'c', 'cd', 'd', 'cm', 'm'\n    }\n    local mini_roman_values = {\n  \
    \      1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000\n    }\n    local\
    \ mini_roman_numeral = ''\n    local i = #mini_roman_values\n    while number\
    \ > 0 do\n        if number >= mini_roman_values[i] then\n            mini_roman_numeral\
    \ = mini_roman_numeral..mini_roman_numerals[i]\n            number = number -\
    \ mini_roman_values[i]\n        else\n            i = i - 1\n        end\n   \
    \ end\n    return mini_roman_numeral\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- For each number between 1 and 1000, generate the corresponding\n    --\
    \ roman numeral, without doing any subtraction.\n    -- The digits of the number\
    \ will be processed from left to right,\n    -- but will be printed in the opposite\
    \ order.\n    local result = {}\n    for i = 1, #digits do\n        local digit\
    \ = number % 10\n        if digit > 0 then\n            result[#result + 1] =\
    \ digits[i][digit]\n        end\n        number = math.floor(number / 10)\n  \
    \  end\n    return table.concat(result):lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3qc2wgrf.lua:17:\
    \ attempt to get length of a nil value (global 'digits')\nstack traceback:\n\t\
    /tmp/tmp3qc2wgrf.lua:17: in local 'candidate'\n\t/tmp/tmp3qc2wgrf.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman_str = ''\n\tfor key, value in pairs(Roman) do\n\t\tlocal quantity\
    \ = math.floor(number / value)\n\t\tif quantity > 0 then\n\t\t\tlocal digit =\
    \ (key):rep(quantity)\n\t\t\troman_str = roman_str .. digit\n\t\t\tnumber = number\
    \ - quantity * value\n\t\tend\n\tend\n\treturn roman_str\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplbyfbanh.lua:13:\
    \ bad argument #1 to 'for iterator' (table expected, got nil)\nstack traceback:\n\
    \t/tmp/tmplbyfbanh.lua:13: in local 'candidate'\n\t/tmp/tmplbyfbanh.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local n = number\n    while n >= 1000 do\n       \
    \ result = result .. 'm'\n        n = n - 1000\n    end\n    if n >= 900 then\n\
    \        result = result .. 'cm'\n        n = n - 900\n    end\n    if n >= 500\
    \ then\n        result = result .. 'd'\n        n = n - 500\n    end\n    if n\
    \ >= 400 then\n        result = result .. 'cd'\n        n = n - 400\n    end\n\
    \    while n >= 100 do\n        result = result .. 'c'\n        n = n - 100\n\
    \    end\n    if n >= 90 then\n        result = result .. 'xc'\n        n = n\
    \ - 90\n    end\n    if n >= 50 then\n        result = result .. 'l'\n       \
    \ n = n - 50\n    end\n    if n >= 40 then\n        result = result .. 'xl'\n\
    \        n = n - 40\n    end\n    while n >= 10 do\n        result = result ..\
    \ 'x'\n        n = n - 10\n    end\n    if n >= 9 then\n        result = result\
    \ .. 'ix'\n        n = n - 9\n    end\n    if n >= 5 then\n        result = result\
    \ .. 'v'\n        n = n - 5\n    end\n    if n >= 4 then\n        result = result\
    \ .. 'iv'\n        n = n - 4\n    end\n    while n >= 1 do\n        result = result\
    \ .. 'i'\n        n = n - 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    return not number and '' or (\n        int_to_mini_roman(number // 10) ..\
    \ ROMAN_DIGITS[number % 10]\n    )\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdblzbxoo.lua:13:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmpdblzbxoo.lua:13: in upvalue 'int_to_mini_roman'\n\
    \t/tmp/tmpdblzbxoo.lua:13: in upvalue 'int_to_mini_roman'\n\t/tmp/tmpdblzbxoo.lua:13:\
    \ in upvalue 'int_to_mini_roman'\n\t/tmp/tmpdblzbxoo.lua:13: in upvalue 'int_to_mini_roman'\n\
    \t/tmp/tmpdblzbxoo.lua:13: in upvalue 'int_to_mini_roman'\n\t/tmp/tmpdblzbxoo.lua:13:\
    \ in upvalue 'int_to_mini_roman'\n\t/tmp/tmpdblzbxoo.lua:13: in upvalue 'int_to_mini_roman'\n\
    \t/tmp/tmpdblzbxoo.lua:13: in upvalue 'int_to_mini_roman'\n\t/tmp/tmpdblzbxoo.lua:13:\
    \ in upvalue 'int_to_mini_roman'\n\t...\t(skipping 499955 levels)\n\t/tmp/tmpdblzbxoo.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpdblzbxoo.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.370 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 or number > 1000 then\n    return nil\n  end\n  local roman =\
    \ {\n    [\"M\"] = math.floor(number / 1000),\n    [\"CM\"] = math.floor((number\
    \ % 1000) / 900),\n    [\"D\"] = math.floor((number % 1000 % 900) / 500),\n  \
    \  [\"CD\"] = math.floor((number % 1000 % 900 % 500) / 400),\n    [\"C\"] = math.floor((number\
    \ % 1000 % 900 % 500 % 400) / 100),\n    [\"XC\"] = math.floor((number % 1000\
    \ % 900 % 500 % 400 % 100) / 90),\n    [\"L\"] = math.floor((number % 1000 % 900\
    \ % 500 % 400 % 100 % 90) / 50),\n    [\"XL\"] = math.floor((number % 1000 % 900\
    \ % 500 % 400 % 100 % 90 % 50) / 40),\n    [\"X\"] = math.floor((number % 1000\
    \ % 900 % 500 % 400 % 100 % 90 % 50 % 40) / 10),\n    [\"IX\"] = math.floor((number\
    \ % 1000 % 900 % 500 % 400 % 100 % 90 % 50 % 40 % 10) / 9),\n    [\"V\"] = math.floor((number\
    \ % 1000 % 900 % 500 % 400 % 100 % 90 % 50 % 40 % 10 % 9) / 5),\n    [\"IV\"]\
    \ = math.floor((number % 1000 % 900 % 500 % 400 % 100 % 90 % 50 % 40 % 10 % 9\
    \ % 5) / 4),\n    [\"I\"] = math.floor((number % 1000 % 900 % 500 % 400 % 100\
    \ % 90 % 50 % 40 % 10 % 9 % 5 % 4) / 1)\n  }\n  local result = \"\"\n  for numeral,\
    \ count in pairs(roman) do\n    for i = 1, count do\n      result = result ..\
    \ numeral\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk9xszv4z.lua:42:\
    \ expected: \"xix\"\nactual: \"IXX\"\nstack traceback:\n\t/tmp/tmpk9xszv4z.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local ret = \"\"\n    local num = number\n    local base = 0\n    local units\
    \ = {'i', 'x', 'c', 'm'}\n    local fives = {'v', 'l', 'd'}\n    for i = 1, 4\
    \ do\n        local digit = num % 10\n        if digit == 4 then\n           \
    \ ret = units[i] .. fives[i-1] .. ret\n        elseif digit == 9 then\n      \
    \      ret = units[i] .. units[i+1] .. ret\n        else\n            local five\
    \ = digit >= 5 and fives[i-1] or \"\"\n            local unit = digit % 5\n  \
    \          if unit > 0 then\n                ret = string.rep(units[i], unit)\
    \ .. five .. ret\n            else\n                ret = five .. ret\n      \
    \      end\n        end\n        num = (num - digit) / 10\n    end\n    return\
    \ ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3abz4aw4.lua:41:\
    \ expected: \"clii\"\nactual: \"cvii\"\nstack traceback:\n\t/tmp/tmp3abz4aw4.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local bignums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\
    \    local alphas = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v',\
    \ 'iv', 'i'}\n    local result = ''\n    for i, n in ipairs(bignums) do\n    \
    \    local q = number // n\n        if q > 0 then\n            result = result\
    \ .. string.rep(alphas[i], q)\n            number = number % n\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local int_to_mini_roman_map = {\n        {1000, 'm'},\n        {900, 'cm'},\n\
    \        {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90,\
    \ 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n      \
    \  {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n\
    \    local output = ''\n    for _, pair in ipairs(int_to_mini_roman_map) do\n\
    \        local num = pair[1]\n        local chr = pair[2]\n        local factor\
    \ = math.floor(number / num)\n        if factor > 0 then\n            output =\
    \ output .. chr:rep(factor)\n            number = number - factor * num\n    \
    \    end\n    end\n    return output\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    return \"\"\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpis6hcfhk.lua:18:\
    \ expected: \"xix\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpis6hcfhk.lua:18:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- your code here\n    -- ...\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa9ovgemx.lua:19:\
    \ expected: \"xix\"\nactual: nil\nstack traceback:\n\t/tmp/tmpa9ovgemx.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- just convert to uppercase\n    return string.lower(int_to_roman(number))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplgi_x7cf.lua:13:\
    \ attempt to call a nil value (global 'int_to_roman')\nstack traceback:\n\t/tmp/tmplgi_x7cf.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmplgi_x7cf.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- convert string representation of number\n  local a = tostring(number)\n\
    \  -- zero pad the number\n  local padding = 3 - #a\n  a = string.rep('0', padding)\
    \ .. a\n  -- roman literals\n  local m = {\n    ['1'] = 'i',\n    ['2'] = 'ii',\n\
    \    ['3'] = 'iii',\n    ['4'] = 'iv',\n    ['5'] = 'v',\n    ['6'] = 'vi',\n\
    \    ['7'] = 'vii',\n    ['8'] = 'viii',\n    ['9'] = 'ix'\n  }\n  local c = {\n\
    \    ['1'] = 'x',\n    ['2'] = 'xx',\n    ['3'] = 'xxx',\n    ['4'] = 'xl',\n\
    \    ['5'] = 'l',\n    ['6'] = 'lx',\n    ['7'] = 'lxx',\n    ['8'] = 'lxxx',\n\
    \    ['9'] = 'xc'\n  }\n  local d = {\n    ['1'] = 'c',\n    ['2'] = 'cc',\n \
    \   ['3'] = 'ccc',\n    ['4'] = 'cd',\n    ['5'] = 'd',\n    ['6'] = 'dc',\n \
    \   ['7'] = 'dcc',\n    ['8'] = 'dccc',\n    ['9'] = 'cm'\n  }\n  local r = d[a:sub(1,\
    \ 1)] .. c[a:sub(2, 2)] .. m[a:sub(3, 3)]\n  -- return roman numeral string\n\
    \  return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgguv57b6.lua:51:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpgguv57b6.lua:51:\
    \ in local 'candidate'\n\t/tmp/tmpgguv57b6.lua:59: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_digits = {'', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii',\
    \ 'ix'}\n    local temp = number\n    local roman_digits_index = {}\n    for i\
    \ = 1, 3 do\n        table.insert(roman_digits_index, temp % 10)\n        temp\
    \ = math.floor(temp / 10)\n    end\n    local roman_str = string.format('%s%s%s',\n\
    \        roman_digits[roman_digits_index[3] + 1],\n        roman_digits[roman_digits_index[2]\
    \ + 1],\n        roman_digits[roman_digits_index[1] + 1])\n    return roman_str\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpadc_czue.lua:29:\
    \ expected: \"xix\"\nactual: \"iix\"\nstack traceback:\n\t/tmp/tmpadc_czue.lua:29:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 or number > 1000 then\n    error('argument out of range')\n \
    \ end\n  local result = ''\n  local num_m = number / 1000\n  result = result ..\
    \ string.rep('m', num_m)\n  number = number % 1000\n  local num_c = number / 100\n\
    \  if num_c == 9 then\n    result = result .. 'cm'\n  elseif num_c >= 5 then\n\
    \    result = result .. 'd' .. string.rep('c', num_c - 5)\n  elseif num_c == 4\
    \ then\n    result = result .. 'cd'\n  else\n    result = result .. string.rep('c',\
    \ num_c)\n  end\n  number = number % 100\n  local num_x = number / 10\n  if num_x\
    \ == 9 then\n    result = result .. 'xc'\n  elseif num_x >= 5 then\n    result\
    \ = result .. 'l' .. string.rep('x', num_x - 5)\n  elseif num_x == 4 then\n  \
    \  result = result .. 'xl'\n  else\n    result = result .. string.rep('x', num_x)\n\
    \  end\n  number = number % 10\n  if number == 9 then\n    result = result ..\
    \ 'ix'\n  elseif number >= 5 then\n    result = result .. 'v' .. string.rep('i',\
    \ number - 5)\n  elseif number == 4 then\n    result = result .. 'iv'\n  else\n\
    \    result = result .. string.rep('i', number)\n  end\n  return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpt7qn6mc4.lua:17:\
    \ bad argument #2 to 'rep' (number has no integer representation)\nstack traceback:\n\
    \t/tmp/tmpt7qn6mc4.lua:17: in local 'candidate'\n\t/tmp/tmpt7qn6mc4.lua:56: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number >= 1 and number <= 1000, \"Number out of range\")\n    local\
    \ result = \"\"\n    while number > 0 do\n        local v = #mini_roman_table\n\
    \        while v > 0 do\n            local div = math.floor(number / mini_roman_table[v][1])\n\
    \            if div > 0 then\n                result = result .. string.rep(mini_roman_table[v][2],\
    \ div)\n                number = number - div * mini_roman_table[v][1]\n     \
    \           break\n            end\n            v = v - 1\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpwg_049xz.lua:15:\
    \ attempt to get length of a nil value (global 'mini_roman_table')\nstack traceback:\n\
    \t/tmp/tmpwg_049xz.lua:15: in local 'candidate'\n\t/tmp/tmpwg_049xz.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = \"\"\n    while number > 0 do\n        if number >= 1000 then\n\
    \            result = result .. \"m\"\n            number = number - 1000\n  \
    \      elseif number >= 900 then\n            result = result .. \"cm\"\n    \
    \        number = number - 900\n        elseif number >= 500 then\n          \
    \  result = result .. \"d\"\n            number = number - 500\n        elseif\
    \ number >= 400 then\n            result = result .. \"cd\"\n            number\
    \ = number - 400\n        elseif number >= 100 then\n            result = result\
    \ .. \"c\"\n            number = number - 100\n        elseif number >= 90 then\n\
    \            result = result .. \"xc\"\n            number = number - 90\n   \
    \     elseif number >= 50 then\n            result = result .. \"l\"\n       \
    \     number = number - 50\n        elseif number >= 40 then\n            result\
    \ = result .. \"xl\"\n            number = number - 40\n        elseif number\
    \ >= 10 then\n            result = result .. \"x\"\n            number = number\
    \ - 10\n        elseif number >= 9 then\n            result = result .. \"ix\"\
    \n            number = number - 9\n        elseif number >= 5 then\n         \
    \   result = result .. \"v\"\n            number = number - 5\n        elseif\
    \ number >= 4 then\n            result = result .. \"iv\"\n            number\
    \ = number - 4\n        elseif number >= 1 then\n            result = result ..\
    \ \"i\"\n            number = number - 1\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local mini_roman_set = {\n    'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x',\
    \ 'ix', 'v', 'iv', 'i'\n  }\n  local mini_roman_values = {\n    1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n  }\n  local mini_roman_str = ''\n  local\
    \ number_ = number\n  for idx, roman_numeral in ipairs(mini_roman_set) do\n  \
    \  while number_ >= mini_roman_values[idx] do\n      mini_roman_str = mini_roman_str\
    \ .. roman_numeral\n      number_ = number_ - mini_roman_values[idx]\n    end\n\
    \  end\n  return mini_roman_str\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local ones = number % 10\n    local tens = (number - ones) % 100\n    local\
    \ hundreds = (number - tens - ones) % 1000\n    local thousands = (number - hundreds\
    \ - tens - ones)\n    local result = ''\n    if thousands ~= 0 then\n        result\
    \ = result .. string.rep('m', thousands / 1000)\n    end\n    if hundreds ~= 0\
    \ then\n        result = result .. string.rep('c', hundreds / 100)\n    end\n\
    \    if tens ~= 0 then\n        result = result .. string.rep('x', tens / 10)\n\
    \    end\n    if ones ~= 0 then\n        result = result .. string.rep('i', ones)\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqvqcjv7s.lua:35:\
    \ expected: \"xix\"\nactual: \"xiiiiiiiii\"\nstack traceback:\n\t/tmp/tmpqvqcjv7s.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number > 0 and number <= 1000,\n         'int_to_mini_roman: input must\
    \ be in range [1, 1000]')\n  local roman = {}\n  repeat\n    if number >= 1000\
    \ then\n      roman[#roman + 1] = 'm'\n      number = number - 1000\n    elseif\
    \ number >= 900 then\n      roman[#roman + 1] = 'cm'\n      number = number -\
    \ 900\n    elseif number >= 500 then\n      roman[#roman + 1] = 'd'\n      number\
    \ = number - 500\n    elseif number >= 400 then\n      roman[#roman + 1] = 'cd'\n\
    \      number = number - 400\n    elseif number >= 100 then\n      roman[#roman\
    \ + 1] = 'c'\n      number = number - 100\n    elseif number >= 90 then\n    \
    \  roman[#roman + 1] = 'xc'\n      number = number - 90\n    elseif number >=\
    \ 50 then\n      roman[#roman + 1] = 'l'\n      number = number - 50\n    elseif\
    \ number >= 40 then\n      roman[#roman + 1] = 'xl'\n      number = number - 40\n\
    \    elseif number >= 10 then\n      roman[#roman + 1] = 'x'\n      number = number\
    \ - 10\n    elseif number >= 9 then\n      roman[#roman + 1] = 'ix'\n      number\
    \ = number - 9\n    elseif number >= 5 then\n      roman[#roman + 1] = 'v'\n \
    \     number = number - 5\n    elseif number >= 4 then\n      roman[#roman + 1]\
    \ = 'iv'\n      number = number - 4\n    elseif number >= 1 then\n      roman[#roman\
    \ + 1] = 'i'\n      number = number - 1\n    end\n  until number == 0\n  return\
    \ table.concat(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local ms, cm, ds, c, xm, l, x, v, m, i\n  number = math.floor(number)\n  if\
    \ number < 1 or number > 1000 then\n    return nil\n  end\n  ms = {\n    'm',\
    \ 'xm', 'xm', 'xm', 'xm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm', 'm',\
    \ 'm', 'm', 'm', 'm', 'm', 'm\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmphle6wv4d.lua:18: unfinished string near ''''m''

    '
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(1 <= number and number <= 1000, \"Number out of range\")\n  local roman\
    \ = mini_roman_table[number]\n  return roman\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpjy62fso2.lua:13:\
    \ attempt to index a nil value (global 'mini_roman_table')\nstack traceback:\n\
    \t/tmp/tmpjy62fso2.lua:13: in local 'candidate'\n\t/tmp/tmpjy62fso2.lua:20: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numeral = ''\n  local num = number\n  while num > 0 do\n    if\
    \ num >= 1000 then\n      roman_numeral = roman_numeral .. 'm'\n      num = num\
    \ - 1000\n    elseif num >= 900 then\n      roman_numeral = roman_numeral .. 'cm'\n\
    \      num = num - 900\n    elseif num >= 500 then\n      roman_numeral = roman_numeral\
    \ .. 'd'\n      num = num - 500\n    elseif num >= 400 then\n      roman_numeral\
    \ = roman_numeral .. 'cd'\n      num = num - 400\n    elseif num >= 100 then\n\
    \      roman_numeral = roman_numeral .. 'c'\n      num = num - 100\n    elseif\
    \ num >= 90 then\n      roman_numeral = roman_numeral .. 'xc'\n      num = num\
    \ - 90\n    elseif num >= 50 then\n      roman_numeral = roman_numeral .. 'l'\n\
    \      num = num - 50\n    elseif num >= 40 then\n      roman_numeral = roman_numeral\
    \ .. 'xl'\n      num = num - 40\n    elseif num >= 10 then\n      roman_numeral\
    \ = roman_numeral .. 'x'\n      num = num - 10\n    elseif num >= 9 then\n   \
    \   roman_numeral = roman_numeral .. 'ix'\n      num = num - 9\n    elseif num\
    \ >= 5 then\n      roman_numeral = roman_numeral .. 'v'\n      num = num - 5\n\
    \    elseif num >= 4 then\n      roman_numeral = roman_numeral .. 'iv'\n     \
    \ num = num - 4\n    elseif num >= 1 then\n      roman_numeral = roman_numeral\
    \ .. 'i'\n      num = num - 1\n    end\n  end\n  return roman_numeral\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local miniroman = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _,v in ipairs(miniroman) do\n    local\
    \ times = math.floor(number / v[1])\n    number = number - times * v[1]\n    result\
    \ = result .. v[2]:rep(times)\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = {}\n    local roman_symbols = {\n        [1] = {'i', 'x'},\n\
    \        [2] = {'v', 'l'},\n        [3] = {'x', 'c'},\n        [4] = {'l', 'd'},\n\
    \        [5] = {'c', 'm'},\n    }\n    for i = 1, 5 do\n        local rank = math.floor(number\
    \ % 10^i / 10^(i-1))\n        local roman_rank = (rank == 4) and (roman_symbols[i][1]\
    \ .. roman_symbols[i][2]) or\n                           (rank == 9) and (roman_symbols[i][1]\
    \ .. roman_symbols[i+1][1]) or\n                           (rank < 4) and (string.rep(roman_symbols[i][1],\
    \ rank)) or\n                           (roman_symbols[i][2] .. string.rep(roman_symbols[i][1],\
    \ rank-5))\n        roman[i] = roman_rank\n    end\n    return table.concat(roman)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb4m58gye.lua:34:\
    \ expected: \"xix\"\nactual: \"ivv\"\nstack traceback:\n\t/tmp/tmpb4m58gye.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(number > 0 and number <= 1000, 'number out of range')\n\t-- Inefficient,\
    \ but solves the problem.\n\treturn mini_roman_numeral(big_roman_numeral(number))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgrhxl9bo.lua:14:\
    \ attempt to call a nil value (global 'big_roman_numeral')\nstack traceback:\n\
    \t/tmp/tmpgrhxl9bo.lua:14: in local 'candidate'\n\t/tmp/tmpgrhxl9bo.lua:20: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local index = 1\n    local values = {1000, 500, 100, 50, 10, 5, 1}\n    local\
    \ letters = {'m', 'd', 'c', 'l', 'x', 'v', 'i'}\n    local result = ''\n    while\
    \ index <= #values do\n        while number >= values[index] do\n            result\
    \ = result .. letters[index]\n            number = number - values[index]\n  \
    \      end\n        if number >= values[index] - values[index + 2] and\n     \
    \       index + 2 <= #values then\n            result = result .. letters[index\
    \ + 2] .. letters[index]\n            number = number - values[index] + values[index\
    \ + 2]\n        end\n        index = index + 2\n    end\n    return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6cuw34g0.lua:21:\
    \ attempt to perform arithmetic on a nil value (field '?')\nstack traceback:\n\
    \t/tmp/tmp6cuw34g0.lua:21: in local 'candidate'\n\t/tmp/tmp6cuw34g0.lua:34: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(type(number) == \"number\", \"number must be a number\")\n\tassert(number\
    \ >= 1 and number <= 1000, \"number must be between 1 and 1000\")\n\tlocal romans\
    \ = {\n\t\t[1]  = \"i\",\n\t\t[5]  = \"v\",\n\t\t[10] = \"x\",\n\t\t[50] = \"\
    l\",\n\t\t[100] = \"c\",\n\t\t[500] = \"d\",\n\t\t[1000] = \"m\"\n\t}\n\tlocal\
    \ result = \"\"\n\tlocal num = number\n\tlocal place = 1000\n\twhile num > 0 do\n\
    \t\tlocal factor = math.floor(num / place)\n\t\tnum = num % place\n\t\tif factor\
    \ == 9 then\n\t\t\tresult = result .. romans[place] .. romans[place * 10]\n\t\t\
    elseif factor >= 5 then\n\t\t\tresult = result .. romans[5 * place]\n\t\t\tfor\
    \ i = 1, factor - 5 do\n\t\t\t\tresult = result .. romans[place]\n\t\t\tend\n\t\
    \telseif factor == 4 then\n\t\t\tresult = result .. romans[place] .. romans[5\
    \ * place]\n\t\telse\n\t\t\tfor i = 1, factor do\n\t\t\t\tresult = result .. romans[place]\n\
    \t\t\tend\n\t\tend\n\t\tplace = place / 10\n\tend\n\treturn result\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local function mini_roman_string(n, r1, r5, r10)\n        if n == 0 then\n\
    \            return \"\"\n        elseif n <= 3 then\n            return r1:rep(n)\n\
    \        elseif n == 4 then\n            return r1 .. r5\n        elseif n <=\
    \ 8 then\n            return r5 .. r1:rep(n - 5)\n        else\n            return\
    \ r1 .. r10\n        end\n    end\n    return ((\"%s%s%s\"):format(\n        mini_roman_string(math.floor(number\
    \ / 100), \"c\", \"d\", \"m\"),\n        mini_roman_string(math.floor(number /\
    \ 10) % 10, \"x\", \"l\", \"c\"),\n        mini_roman_string(number % 10, \"i\"\
    , \"v\", \"x\")\n    ))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb70423wh.lua:48:\
    \ expected: \"m\"\nactual: \"cm\"\nstack traceback:\n\t/tmp/tmpb70423wh.lua:48:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local mini_roman_digits = {\n    [1] = 'i',\n    [2] = 'ii',\n    [3] = 'iii',\n\
    \    [4] = 'iv',\n    [5] = 'v',\n    [6] = 'vi',\n    [7] = 'vii',\n    [8] =\
    \ 'viii',\n    [9] = 'ix',\n  }\n  local roman_numeral = {}\n  local remaining\
    \ = number\n  local num_iterations = 0\n  local iteration_tens_place = 1\n  local\
    \ chars_added = 0\n  while remaining > 0 do\n    num_iterations = num_iterations\
    \ + 1\n    iteration_tens_place = 10 ^ (num_iterations - 1)\n    chars_added =\
    \ chars_added + 1\n    local digit = remaining % 10\n    local mini_roman_digit\
    \ = mini_roman_digits[digit]\n    local num_chars_in_digit = string.len(mini_roman_digit)\n\
    \    chars_added = chars_added + num_chars_in_digit\n    roman_numeral[num_iterations]\
    \ = mini_roman_digit\n    remaining = (remaining - digit) / 10\n  end\n  local\
    \ final_roman_numeral = {}\n  local roman_numeral_index = 1\n  local roman_numeral_length\
    \ = table.getn(roman_numeral)\n  while roman_numeral_index <= roman_numeral_length\
    \ do\n    local mini_roman_digit = roman_numeral[roman_numeral_index]\n    final_roman_numeral[roman_numeral_index]\
    \ = mini_roman_digit\n    roman_numeral_index = roman_numeral_index + 1\n  end\n\
    \  return table.concat(final_roman_numeral)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfcvom7j6.lua:41:\
    \ attempt to call a nil value (field 'getn')\nstack traceback:\n\t/tmp/tmpfcvom7j6.lua:41:\
    \ in local 'candidate'\n\t/tmp/tmpfcvom7j6.lua:53: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \treturn int_to_mini_roman_map[number]\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4j8ru3mx.lua:12:\
    \ attempt to index a nil value (global 'int_to_mini_roman_map')\nstack traceback:\n\
    \t/tmp/tmp4j8ru3mx.lua:12: in local 'candidate'\n\t/tmp/tmp4j8ru3mx.lua:18: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal value = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }\n\tlocal\
    \ numeral = { 'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv',\
    \ 'i' }\n\tlocal result = \"\"\n\tfor i = 1, #value do\n\t\twhile number >= value[i]\
    \ do\n\t\t\tnumber = number - value[i]\n\t\t\tresult = result .. numeral[i]\n\t\
    \tend\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000,\n         \"int_to_mini_roman: input\
    \ number out of range\")\n  local result = \"\"\n  for i = #int_roman_map, 1,\
    \ -1 do\n    local int, roman = int_roman_map[i][1], int_roman_map[i][2]\n   \
    \ while number >= int do\n      number = number - int\n      result = result ..\
    \ roman\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgfoni6no.lua:15:\
    \ attempt to get length of a nil value (global 'int_roman_map')\nstack traceback:\n\
    \t/tmp/tmpgfoni6no.lua:15: in local 'candidate'\n\t/tmp/tmpgfoni6no.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal result = {}\n\tfor _, number_to_symbol in ipairs(numbers_to_symbols) do\n\
    \t\tlocal n = number % number_to_symbol[1]\n\t\tfor i = 1, (number - n) / number_to_symbol[1]\
    \ do\n\t\t\ttable.insert(result, 1, number_to_symbol[2])\n\t\tend\n\t\tnumber\
    \ = n\n\tend\n\treturn table.concat(result)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 or number > 1000 then\n    return nil\n  end\n  local result\
    \ = ''\n  while number > 0 do\n    if number >= 1000 then\n      result = result\
    \ .. 'm'\n      number = number - 1000\n    elseif number >= 900 then\n      result\
    \ = result .. 'cm'\n      number = number - 900\n    elseif number >= 500 then\n\
    \      result = result .. 'd'\n      number = number - 500\n    elseif number\
    \ >= 400 then\n      result = result .. 'cd'\n      number = number - 400\n  \
    \  elseif number >= 100 then\n      result = result .. 'c'\n      number = number\
    \ - 100\n    elseif number >= 90 then\n      result = result .. 'xc'\n      number\
    \ = number - 90\n    elseif number >= 50 then\n      result = result .. 'l'\n\
    \      number = number - 50\n    elseif number >= 40 then\n      result = result\
    \ .. 'xl'\n      number = number - 40\n    elseif number >= 10 then\n      result\
    \ = result .. 'x'\n      number = number - 10\n    elseif number >= 9 then\n \
    \     result = result .. 'ix'\n      number = number - 9\n    elseif number >=\
    \ 5 then\n      result = result .. 'v'\n      number = number - 5\n    elseif\
    \ number >= 4 then\n      result = result .. 'iv'\n      number = number - 4\n\
    \    elseif number >= 1 then\n      result = result .. 'i'\n      number = number\
    \ - 1\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x',\
    \ 'ix', 'v', 'iv', 'i'}\n    local roman_decimals = {1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n    local result = ''\n    local i = 1\n    while\
    \ number > 0 do\n        if number >= roman_decimals[i] then\n            number\
    \ = number - roman_decimals[i]\n            result = result .. roman_numerals[i]\n\
    \        else\n            i = i + 1\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number > 1000 then\n    return nil\n  end\n  local roman_numeral = \"\"\n\
    \  while number > 0 do\n    if number >= 1000 then\n      roman_numeral = roman_numeral\
    \ .. \"m\"\n      number = number - 1000\n    elseif number >= 900 then\n    \
    \  roman_numeral = roman_numeral .. \"cm\"\n      number = number - 900\n    elseif\
    \ number >= 500 then\n      roman_numeral = roman_numeral .. \"d\"\n      number\
    \ = number - 500\n    elseif number >= 400 then\n      roman_numeral = roman_numeral\
    \ .. \"cd\"\n      number = number - 400\n    elseif number >= 100 then\n    \
    \  roman_numeral = roman_numeral .. \"c\"\n      number = number - 100\n    elseif\
    \ number >= 90 then\n      roman_numeral = roman_numeral .. \"xc\"\n      number\
    \ = number - 90\n    elseif number >= 50 then\n      roman_numeral = roman_numeral\
    \ .. \"l\"\n      number = number - 50\n    elseif number >= 40 then\n      roman_numeral\
    \ = roman_numeral .. \"xl\"\n      number = number - 40\n    elseif number >=\
    \ 10 then\n      roman_numeral = roman_numeral .. \"x\"\n      number = number\
    \ - 10\n    elseif number >= 9 then\n      roman_numeral = roman_numeral .. \"\
    ix\"\n      number = number - 9\n    elseif number >= 5 then\n      roman_numeral\
    \ = roman_numeral .. \"v\"\n      number = number - 5\n    elseif number >= 4\
    \ then\n      roman_numeral = roman_numeral .. \"iv\"\n      number = number -\
    \ 4\n    elseif number >= 1 then\n      roman_numeral = roman_numeral .. \"i\"\
    \n      number = number - 1\n    end\n  end\n  return roman_numeral\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal t = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n\tlocal res = ''\n\tlocal p =\
    \ 0\n\twhile number > 0 do\n\t\tlocal y = number % 10\n\t\tnumber = math.floor(number\
    \ / 10)\n\t\tlocal s = ''\n\t\tif y == 4 then\n\t\t\ts = t[p + 1] .. t[p + 2]\n\
    \t\telseif y == 9 then\n\t\t\ts = t[p + 1] .. t[p + 3]\n\t\telse\n\t\t\tlocal\
    \ b = y >= 5\n\t\t\ty = y % 5\n\t\t\tif b then\n\t\t\t\ts = t[p + 2]\n\t\t\tend\n\
    \t\t\tfor i = 1, y do\n\t\t\t\ts = s .. t[p + 1]\n\t\t\tend\n\t\tend\n\t\tres\
    \ = s .. res\n\t\tp = p + 2\n\tend\n\treturn res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local table = {1000,900,500,400,100,90,50,40,10,9,5,4,1}\n    local Roman\
    \ = {'m','cm','d','cd','c','xc','l','xl','x','ix','v','iv','i'}\n    local result\
    \ = ''\n    for i=1,#table do\n        while number >= table[i] do\n         \
    \   number = number - table[i]\n            result = result .. Roman[i]\n    \
    \    end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local romans = {\n    {'i', 'v'},\n    {'x', 'l'},\n    {'c', 'd'},\n    {'m'}\n\
    \  }\n  local result = ''\n  local rest = number\n  local factor = 1\n  for i\
    \ = 1, #romans do\n    local digits = math.floor(rest / factor)\n    rest = rest\
    \ % factor\n    factor = factor * 10\n    if digits == 0 then\n      goto continue\n\
    \    end\n    if digits <= 3 then\n      result = result .. string.rep(romans[i][1],\
    \ digits)\n    elseif digits == 4 then\n      result = result .. romans[i][1]\
    \ .. romans[i][2]\n    elseif digits <= 8 then\n      result = result .. romans[i][2]\
    \ .. string.rep(romans[i][1], digits - 5)\n    else\n      result = result ..\
    \ romans[i][1] .. romans[i + 1][1]\n    end\n    ::continue::\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0eyikdt2.lua:45:\
    \ expected: \"xix\"\nactual: \"ix\"\nstack traceback:\n\t/tmp/tmp0eyikdt2.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local function int_to_roman(number)\n        local roman_map = {\n      \
    \      [1000] = 'M',\n            [900] = 'CM',\n            [500] = 'D',\n  \
    \          [400] = 'CD',\n            [100] = 'C',\n            [90] = 'XC',\n\
    \            [50] = 'L',\n            [40] = 'XL',\n            [10] = 'X',\n\
    \            [9] = 'IX',\n            [5] = 'V',\n            [4] = 'IV',\n  \
    \          [1] = 'I'\n        }\n        local roman = ''\n        for key, value\
    \ in pairs(roman_map) do\n            while number >= key do\n               \
    \ roman = roman .. value\n                number = number - key\n            end\n\
    \        end\n        return roman\n    end\n    return int_to_roman(number):lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpia6hnkz6.lua:43:\
    \ expected: \"xix\"\nactual: \"iiiiiiiiiiiiiiiiiii\"\nstack traceback:\n\t/tmp/tmpia6hnkz6.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman_numerals = {\n\t\t{ \"m\", 1000 },\n\t\t{ \"d\", 500 },\n\t\t{ \"\
    c\", 100 },\n\t\t{ \"l\", 50 },\n\t\t{ \"x\", 10 },\n\t\t{ \"v\", 5 },\n\t\t{\
    \ \"i\", 1 }\n\t}\n\tlocal roman = \"\"\n\tlocal num = number\n\tfor i = 1, #roman_numerals\
    \ do\n\t\tlocal number_of_letter = math.floor(num / roman_numerals[i][2])\n\t\t\
    for j = 1, number_of_letter do\n\t\t\troman = roman .. roman_numerals[i][1]\n\t\
    \tend\n\t\tnum = num % roman_numerals[i][2]\n\tend\n\treturn roman\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp05iunpkm.lua:36:\
    \ expected: \"xix\"\nactual: \"xviiii\"\nstack traceback:\n\t/tmp/tmp05iunpkm.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local numbers = {1000, 500, 100, 50, 10, 5, 1}\n    local num_to_mini_roman\
    \ = {\n        {'m', 'd', 'c'},\n        {'', '', 'x'},\n        {'', '', 'i'}\n\
    \    }\n    local ret = {}\n    local ret_len = 0\n    while number > 0 do\n \
    \       for i = 1, #numbers do\n            if number >= numbers[i] then\n   \
    \             number = number - numbers[i]\n                ret_len = ret_len\
    \ + 1\n                ret[ret_len] = num_to_mini_roman[i][(i + 2) / 2]\n    \
    \            break\n            end\n        end\n    end\n    return table.concat(ret)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpj2r9y5rf.lua:25:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmpj2r9y5rf.lua:25:\
    \ in local 'candidate'\n\t/tmp/tmpj2r9y5rf.lua:36: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local digits, roman_str = split_digit(number)\n    local low_roman_map =\
    \ {\n        [\"0\"] = \"\",\n        [\"1\"] = \"i\",\n        [\"2\"] = \"ii\"\
    ,\n        [\"3\"] = \"iii\",\n        [\"4\"] = \"iv\",\n        [\"5\"] = \"\
    v\",\n        [\"6\"] = \"vi\",\n        [\"7\"] = \"vii\",\n        [\"8\"] =\
    \ \"viii\",\n        [\"9\"] = \"ix\",\n    }\n    local mid_roman_map = {\n \
    \       [\"0\"] = \"\",\n        [\"1\"] = \"x\",\n        [\"2\"] = \"xx\",\n\
    \        [\"3\"] = \"xxx\",\n        [\"4\"] = \"xl\",\n        [\"5\"] = \"l\"\
    ,\n        [\"6\"] = \"lx\",\n        [\"7\"] = \"lxx\",\n        [\"8\"] = \"\
    lxxx\",\n        [\"9\"] = \"xc\",\n    }\n    local high_roman_map = {\n    \
    \    [\"0\"] = \"\",\n        [\"1\"] = \"c\",\n        [\"2\"] = \"cc\",\n  \
    \      [\"3\"] = \"ccc\",\n        [\"4\"] = \"cd\",\n        [\"5\"] = \"d\"\
    ,\n        [\"6\"] = \"dc\",\n        [\"7\"] = \"dcc\",\n        [\"8\"] = \"\
    dccc\",\n        [\"9\"] = \"cm\",\n    }\n    local roman_map = {\n        [\"\
    000\"] = low_roman_map,\n        [\"100\"] = mid_roman_map,\n        [\"200\"\
    ] = high_roman_map,\n    }\n    for k, v in pairs(digits) do\n        roman_str\
    \ = roman_str .. roman_map[k][v]\n    end\n    return roman_str\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp578lu8mj.lua:12:\
    \ attempt to call a nil value (global 'split_digit')\nstack traceback:\n\t/tmp/tmp578lu8mj.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmp578lu8mj.lua:63: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal romanNumeral = ''\n\tlocal m\t\t\t\t= (number - (number % 1000)) / 1000\t\
    \t-- The thousands's place\n\tlocal d\t\t\t\t= ((number % 1000) - ((number % 1000)\
    \ % 500)) / 500\t-- The hundreds's place\n\tlocal c\t\t\t\t= (((number % 1000)\
    \ % 500) - (((number % 1000) % 500) % 100)) / 100 -- The tens's place\n\tlocal\
    \ l\t\t\t\t= ((((number % 1000) % 500) % 100) - ((((number % 1000) % 500) % 100)\
    \ % 50)) / 50\t-- The tens's place\n\tlocal x\t\t\t\t= (((((number % 1000) % 500)\
    \ % 100) % 50) - (((((number % 1000) % 500) % 100) % 50) % 10)) / 10\t-- The tens's\
    \ place\n\tlocal v\t\t\t\t= ((((((number % 1000) % 500) % 100) % 50) % 10) - ((((((number\
    \ % 1000) % 500) % 100) % 50) % 10) % 5)) / 5\t-- The tens's place\n\tlocal i\t\
    \t\t\t= (((((((number % 1000) % 500) % 100) % 50) % 10) % 5) - (((((((number %\
    \ 1000) % 500) % 100) % 50) % 10) % 5) % 1)) / 1\t-- The tens's place\n\tlocal\
    \ currentLetter = ''\n\tlocal currentNumber = 0\n\t-- Check for M\n\tif m ~= 0\
    \ then\n\t\tcurrentLetter = 'm'\n\t\tcurrentNumber = m\n\telseif d ~= 0 then\n\
    \t\tcurrentLetter = 'd'\n\t\tcurrentNumber = d\n\telseif c ~= 0 then\n\t\tcurrentLetter\
    \ = 'c'\n\t\tcurrentNumber = c\n\telseif l ~= 0 then\n\t\tcurrentLetter = 'l'\n\
    \t\tcurrentNumber = l\n\telseif x ~= 0 then\n\t\tcurrentLetter = 'x'\n\t\tcurrentNumber\
    \ = x\n\telseif v ~= 0 then\n\t\tcurrentLetter = 'v'\n\t\tcurrentNumber = v\n\t\
    elseif i ~= 0 then\n\t\tcurrentLetter =\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp8gzd1nkr.lua:43: unexpected symbol near ''=''

    '
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local number_str = int_to_roman(number)\n  return string.lower(number_str)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptjwhdjgt.lua:12:\
    \ attempt to call a nil value (global 'int_to_roman')\nstack traceback:\n\t/tmp/tmptjwhdjgt.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmptjwhdjgt.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = { \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" }\n    local decimal_numbers\
    \ = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }\n    local roman\
    \ = \"\"\n    local i = 1\n    while number > 0 do\n        if number >= decimal_numbers[i]\
    \ then\n            roman = roman .. roman_numerals[i]\n            number = number\
    \ - decimal_numbers[i]\n        else\n            i = i + 1\n        end\n   \
    \ end\n    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\",\
    \ \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n  }\n  local decimal_numbers\
    \ = {\n    1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n  }\n  if number\
    \ < 1 or number > 1000 then\n    return nil\n  end\n  local res = ''\n  for i\
    \ = 1, 13 do\n    while number >= decimal_numbers[i] do\n      res = res .. roman_numerals[i]\n\
    \      number = number - decimal_numbers[i]\n    end\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local num = number\n    local result = ''\n    for i, v in ipairs(mini_roman_numerals)\
    \ do\n        while num >= v.num do\n            result = result .. v.sym\n  \
    \          num = num - v.num\n        end\n    end\n    return result\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal conversion = {\n\t\t{ 'i', 1 }, { 'v', 5 }, { 'x', 10 }, { 'l', 50 },\
    \ { 'c', 100 },\n\t\t{ 'd', 500 }, { 'm', 1000 }\n\t}\n\tlocal roman_numeral =\
    \ ''\n\tfor i = #conversion, 1, -1 do\n\t\tlocal letter, value = conversion[i][1],\
    \ conversion[i][2]\n\t\tlocal quotient = math.floor(number / value)\n\t\tnumber\
    \ = number % value\n\t\tfor _ = 1, quotient do\n\t\t\troman_numeral = roman_numeral\
    \ .. letter\n\t\tend\n\tend\n\treturn roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmputqyywf8.lua:31:\
    \ expected: \"xix\"\nactual: \"xviiii\"\nstack traceback:\n\t/tmp/tmputqyywf8.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal numeral = ''\n\tlocal numerals = { M = 1000, D = 500, C = 100, L = 50,\
    \ X = 10, V = 5, I = 1 }\n\tfor numeral_char, numeral_value in pairs(numerals)\
    \ do\n\t\trepeat\n\t\t\tif number >= numeral_value then\n\t\t\t\tnumeral = numeral\
    \ .. numeral_char\n\t\t\t\tnumber = number - numeral_value\n\t\t\telse\n\t\t\t\
    \tbreak\n\t\t\tend\n\t\tuntil false\n\tend\n\treturn numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb298ly53.lua:30:\
    \ expected: \"xix\"\nactual: \"IIIIIIIIIIIIIIIIIII\"\nstack traceback:\n\t/tmp/tmpb298ly53.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local results = \"\"\n    local lookup = {M = 1000, CM = 900, D = 500, CD\
    \ = 400, C = 100, XC = 90,\n        L = 50, XL = 40, X = 10, IX = 9, V = 5, IV\
    \ = 4, I = 1}\n    for value, letter in pairs(lookup) do\n        while number\
    \ >= letter do\n            results = results .. value\n            number = number\
    \ - letter\n        end\n    end\n    return results\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp0o1a6rq.lua:27:\
    \ expected: \"xix\"\nactual: \"IIIIIIIIIIIIIIIIIII\"\nstack traceback:\n\t/tmp/tmpp0o1a6rq.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = \"\"\n    for value, letter in pairs(mini_roman_symbols) do\n\
    \        local quotient = number / value\n        if quotient >= 1 then\n    \
    \        result = result .. string.rep(letter, quotient)\n            number =\
    \ number % value\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4nw22vs5.lua:13:\
    \ bad argument #1 to 'for iterator' (table expected, got nil)\nstack traceback:\n\
    \t/tmp/tmp4nw22vs5.lua:13: in local 'candidate'\n\t/tmp/tmp4nw22vs5.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal parts = {}\n\tlocal n = number\n\tlocal t = {\n\t\t[1] = {'i', 'v'},\n\
    \t\t[2] = {'x', 'l'},\n\t\t[3] = {'c', 'd'},\n\t\t[4] = {'m'}\n\t}\n\tfor i =\
    \ 1, #t do\n\t\tlocal d, r = math.modf(n / 10)\n\t\tn = d\n\t\tlocal part = ''\n\
    \t\tif r == 4 then\n\t\t\tpart = t[i][1] .. t[i][2]\n\t\telseif r == 9 then\n\t\
    \t\tpart = t[i][1] .. t[i + 1][1]\n\t\telse\n\t\t\tlocal v = t[i][1]\n\t\t\tif\
    \ r >= 5 then\n\t\t\t\tv = t[i][2]\n\t\t\t\tr = r - 5\n\t\t\tend\n\t\t\tpart =\
    \ v .. string.rep(t[i][1], r)\n\t\tend\n\t\ttable.insert(parts, part)\n\tend\n\
    \treturn table.concat(parts)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpb971p8g0.lua:34:\
    \ bad argument #2 to 'rep' (number has no integer representation)\nstack traceback:\n\
    \t/tmp/tmpb971p8g0.lua:34: in local 'candidate'\n\t/tmp/tmpb971p8g0.lua:44: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local m_roman_digits = { 'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x',\
    \ 'ix', 'v', 'iv', 'i' }\n    local m_roman_values = { 1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1 }\n    local roman_number = ''\n    for index, digit\
    \ in ipairs(m_roman_values) do\n        while number >= digit do\n           \
    \ roman_number = roman_number .. m_roman_digits[index]\n            number = number\
    \ - digit\n        end\n    end\n    return roman_number\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local function num_to_numeral(num)\n    local numeral = ''\n    while num >=\
    \ 1000 do\n      numeral = numeral .. 'm'\n      num = num - 1000\n    end\n \
    \   if num >= 900 then\n      numeral = numeral .. 'cm'\n      num = num - 900\n\
    \    end\n    if num >= 500 then\n      numeral = numeral .. 'd'\n      num =\
    \ num - 500\n    end\n    if num >= 400 then\n      numeral = numeral .. 'cd'\n\
    \      num = num - 400\n    end\n    while num >= 100 do\n      numeral = numeral\
    \ .. 'c'\n      num = num - 100\n    end\n    if num >= 90 then\n      numeral\
    \ = numeral .. 'xc'\n      num = num - 90\n    end\n    if num >= 50 then\n  \
    \    numeral = numeral .. 'l'\n      num = num - 50\n    end\n    if num >= 40\
    \ then\n      numeral = numeral .. 'xl'\n      num = num - 40\n    end\n    while\
    \ num >= 10 do\n      numeral = numeral .. 'x'\n      num = num - 10\n    end\n\
    \    if num >= 9 then\n      numeral = numeral .. 'ix'\n      num = num - 9\n\
    \    end\n    if num >= 5 then\n      numeral = numeral .. 'v'\n      num = num\
    \ - 5\n    end\n    if num >= 4 then\n      numeral = numeral .. 'iv'\n      num\
    \ = num - 4\n    end\n    while num >= 1 do\n      numeral = numeral .. 'i'\n\
    \      num = num - 1\n    end\n    return numeral\n  end\n  local numeral = num_to_numeral(number)\n\
    \  return string.lower(numeral)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal result = ''\n\t\n\tlocal arabic = {1,4,5,9,10,40,50,90,100,400,500,900,1000}\n\
    \tlocal roman = {'i','iv','v','ix','x','xl','l','xc','c','cd','d','cm','m'}\n\t\
    \n\tfor i = #arabic, 1, -1 do\n\t\twhile number >= arabic[i] do\n\t\t\tnumber\
    \ = number - arabic[i]\n\t\t\tresult = result .. roman[i]\n\t\tend\n\tend\n\t\n\
    \treturn result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- error checking\n  if type(number) ~= 'number' then\n    error(\"int_to_mini_roman:\
    \ number must be a number, was a \" .. type(number), 2)\n  end\n  if number <\
    \ 1 or number > 1000 then\n    error(\"int_to_mini_roman: number must be in the\
    \ range 1 to 1000, was \" .. number, 2)\n  end\n  -- we'll build our string in\
    \ reverse, then reverse it when we're done\n  local roman = \"\"\n  local values\
    \ = {1000, 500, 100, 50, 10, 5, 1}\n  local symbols = {'m', 'd', 'c', 'l', 'x',\
    \ 'v', 'i'}\n  local prev = 1000\n  local count = 0\n  for i, value in ipairs(values)\
    \ do\n    local symbol = symbols[i]\n    local count = floor(number / value)\n\
    \    if count > 0 then\n      for i = 1, count do\n        roman = roman .. symbol\n\
    \      end\n      number = number - (count * value)\n    end\n    if count ==\
    \ 4 and i > 1 then\n      roman = roman .. symbols[i - 1] .. symbol\n      number\
    \ = number - (prev - value)\n    end\n    prev = value\n  end\n  return roman:reverse()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpels_i4ml.lua:27:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmpels_i4ml.lua:27:\
    \ in local 'candidate'\n\t/tmp/tmpels_i4ml.lua:46: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local m = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv',\
    \ 'i'}\n  local n = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n \
    \ local roman = ''\n  while number > 0 do\n    for i,v in ipairs(n) do\n     \
    \ if number >= v then\n        roman = roman .. m[i]\n        number = number\
    \ - v\n        break\n      end\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local answer = \"\"\n  while number > 0 do\n    if number >= 1000 then\n  \
    \    answer = answer .. \"m\"\n      number = number - 1000\n    elseif number\
    \ >= 900 then\n      answer = answer .. \"cm\"\n      number = number - 900\n\
    \    elseif number >= 500 then\n      answer = answer .. \"d\"\n      number =\
    \ number - 500\n    elseif number >= 400 then\n      answer = answer .. \"cd\"\
    \n      number = number - 400\n    elseif number >= 100 then\n      answer = answer\
    \ .. \"c\"\n      number = number - 100\n    elseif number >= 90 then\n      answer\
    \ = answer .. \"xc\"\n      number = number - 90\n    elseif number >= 50 then\n\
    \      answer = answer .. \"l\"\n      number = number - 50\n    elseif number\
    \ >= 40 then\n      answer = answer .. \"xl\"\n      number = number - 40\n  \
    \  elseif number >= 10 then\n      answer = answer .. \"x\"\n      number = number\
    \ - 10\n    elseif number >= 9 then\n      answer = answer .. \"ix\"\n      number\
    \ = number - 9\n    elseif number >= 5 then\n      answer = answer .. \"v\"\n\
    \      number = number - 5\n    elseif number >= 4 then\n      answer = answer\
    \ .. \"iv\"\n      number = number - 4\n    elseif number >= 1 then\n      answer\
    \ = answer .. \"i\"\n      number = number - 1\n    end\n  end\n  return answer\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 or number > 1000 then\n    error('Number must be between 1 and\
    \ 1000')\n  end\n  local roman_numeral_map = {\n    [1] = 'i',\n    [5] = 'v',\n\
    \    [10] = 'x',\n    [50] = 'l',\n    [100] = 'c',\n    [500] = 'd',\n    [1000]\
    \ = 'm'\n  }\n  local quotient, remainder\n  local roman_numeral = ''\n  for _,\
    \ int in ipairs({1000, 100, 10, 1}) do\n    quotient = math.floor(number / int)\n\
    \    remainder = number % int\n    if quotient == 4 then\n      if int == 1000\
    \ then\n        roman_numeral = roman_numeral .. roman_numeral_map[int]\n    \
    \  else\n        roman_numeral = roman_numeral .. roman_numeral_map[int] .. roman_numeral_map[int\
    \ * 5]\n      end\n    elseif quotient == 9 then\n      if int == 1000 then\n\
    \        roman_numeral = roman_numeral .. roman_numeral_map[int]\n      else\n\
    \        roman_numeral = roman_numeral .. roman_numeral_map[int] .. roman_numeral_map[int\
    \ * 10]\n      end\n    else\n      if quotient >= 5 then\n        roman_numeral\
    \ = roman_numeral .. roman_numeral_map[int * 5]\n        quotient = quotient -\
    \ 5\n      end\n      for i = 1, quotient do\n        roman_numeral = roman_numeral\
    \ .. roman_numeral_map[int]\n      end\n    end\n    number = remainder\n  end\n\
    \  return roman_numeral\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local romans = {\n    { 1000, 'm' },\n    { 900, 'cm' },\n    { 500, 'd' },\n\
    \    { 400, 'cd' },\n    { 100, 'c' },\n    { 90, 'xc' },\n    { 50, 'l' },\n\
    \    { 40, 'xl' },\n    { 10, 'x' },\n    { 9, 'ix' },\n    { 5, 'v' },\n    {\
    \ 4, 'iv' },\n    { 1, 'i' },\n  }\n  local result = ''\n  for i, data in ipairs(romans)\
    \ do\n    while number >= data[1] do\n      result = result .. data[2]\n     \
    \ number = number - data[1]\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if type(number) ~= 'number' then\n    error('expected an integer, but got '\
    \ .. type(number), 2)\n  end\n  if number ~= math.floor(number) then\n    error('expected\
    \ an integer, but got ' .. number, 2)\n  end\n  if number < 1 or number > 1000\
    \ then\n    error('expected a number between 1 and 1000, but got ' .. number,\
    \ 2)\n  end\n  local result = ''\n  if number >= 100 then\n    local hundreds\
    \ = math.floor(number / 100)\n    number = number % 100\n    result = ROMAN_NUMERAL_MAP.hundreds[hundreds]\n\
    \  end\n  if number >= 10 then\n    local tens = math.floor(number / 10)\n   \
    \ number = number % 10\n    result = result .. ROMAN_NUMERAL_MAP.tens[tens]\n\
    \  end\n  result = result .. ROMAN_NUMERAL_MAP.units[number]\n  return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1zhbb_qh.lua:30:\
    \ attempt to index a nil value (global 'ROMAN_NUMERAL_MAP')\nstack traceback:\n\
    \t/tmp/tmp1zhbb_qh.lua:30: in local 'candidate'\n\t/tmp/tmp1zhbb_qh.lua:39: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(type(number) == \"number\", \"Function int_to_mini_roman() expects\
    \ a number as its parameter.\")\n    assert(number >= 1 and number <= 1000, \"\
    Function int_to_mini_roman() expects a number in the range of 1 to 1000 as its\
    \ parameter.\")\n    local roman = string.lower(int_to_roman(number))\n    roman\
    \ = string.gsub(roman, \"cm\", \"mcm\")\n    roman = string.gsub(roman, \"cd\"\
    , \"ccd\")\n    roman = string.gsub(roman, \"xc\", \"lxc\")\n    roman = string.gsub(roman,\
    \ \"xl\", \"lxl\")\n    roman = string.gsub(roman, \"ix\", \"vix\")\n    roman\
    \ = string.gsub(roman, \"iv\", \"viv\")\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpf0orh3rn.lua:14:\
    \ attempt to call a nil value (global 'int_to_roman')\nstack traceback:\n\t/tmp/tmpf0orh3rn.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpf0orh3rn.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local t = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv',\
    \ 'i'}\n  local a = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n \
    \ local r = ''\n  for i = 1, 13 do\n    while number >= a[i] do\n      r = r ..\
    \ t[i]\n      number = number - a[i]\n    end\n  end\n  return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Sanity check\n  if not (number >= 1 and number <= 1000) then\n    error('int_to_mini_roman\
    \ expects 1 <= number <= 1000')\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp4jmkqjb8.lua:36: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 or number > 1000 then\n        error(\"input out of range\"\
    )\n    end\n    if number == 1000 then\n        return \"m\"\n    end\n    local\
    \ s = number % 1000\n    if s == 0 then\n        return \"\"\n    end\n    local\
    \ h = math.floor(s / 100)\n    local t = math.floor((s - 100 * h) / 10)\n    local\
    \ u = s - 100 * h - 10 * t\n    local ret = \"\"\n    if h == 9 then\n       \
    \ ret = ret .. \"cm\"\n    elseif h >= 5 then\n        ret = ret .. \"d\" .. string.rep(\"\
    c\", h - 5)\n    elseif h == 4 then\n        ret = ret .. \"cd\"\n    else\n \
    \       ret = ret .. string.rep(\"c\", h)\n    end\n    if t == 9 then\n     \
    \   ret = ret .. \"xc\"\n    elseif t >= 5 then\n        ret = ret .. \"l\" ..\
    \ string.rep(\"x\", t - 5)\n    elseif t == 4 then\n        ret = ret .. \"xl\"\
    \n    else\n        ret = ret .. string.rep(\"x\", t)\n    end\n    if u == 9\
    \ then\n        ret = ret .. \"ix\"\n    elseif u >= 5 then\n        ret = ret\
    \ .. \"v\" .. string.rep(\"i\", u - 5)\n    elseif u == 4 then\n        ret =\
    \ ret .. \"iv\"\n    else\n        ret = ret .. string.rep(\"i\", u)\n    end\n\
    \    return ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  return int_to_roman(number):lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpytjlpmkm.lua:12:\
    \ attempt to call a nil value (global 'int_to_roman')\nstack traceback:\n\t/tmp/tmpytjlpmkm.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmpytjlpmkm.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local h = math.floor(number / 100)\n  number = number %\
    \ 100\n  local t = math.floor(number / 10)\n  number = number % 10\n  local u\
    \ = number\n  if h > 0 then\n    roman = roman .. get_digit(h, 'c', 'cc', 'ccc',\
    \ 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm')\n  end\n  if t > 0 then\n    roman = roman\
    \ .. get_digit(t, 'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc')\n  end\n\
    \  if u > 0 then\n    roman = roman .. get_digit(u, 'i', 'ii', 'iii', 'iv', 'v',\
    \ 'vi', 'vii', 'viii', 'ix')\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpflzuwaa1.lua:22:\
    \ attempt to call a nil value (global 'get_digit')\nstack traceback:\n\t/tmp/tmpflzuwaa1.lua:22:\
    \ in local 'candidate'\n\t/tmp/tmpflzuwaa1.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Number not in range (1 - 1000)')\n\
    \  local int_to_mini_roman_result = ''\n  local thousands, rest\n  -- Thousands\n\
    \  thousands, rest = math.floor(number / 1000), number % 1000\n  if thousands\
    \ >= 1 then\n    int_to_mini_roman_result = int_to_mini_roman_result .. 'm'\n\
    \  end\n  -- Hundreds\n  local hundreds, rest = math.floor(rest / 100), rest %\
    \ 100\n  if hundreds >= 1 then\n    if hundreds == 4 then\n      int_to_mini_roman_result\
    \ = int_to_mini_roman_result .. 'cd'\n    elseif hundreds == 9 then\n      int_to_mini_roman_result\
    \ = int_to_mini_roman_result .. 'cm'\n    elseif hundreds >= 5 then\n      int_to_mini_roman_result\
    \ = int_to_mini_roman_result .. 'd'\n      int_to_mini_roman_result = int_to_mini_roman_result\
    \ .. 'c'\n      while hundreds > 5 do\n        int_to_mini_roman_result = int_to_mini_roman_result\
    \ .. 'c'\n        hundreds = hundreds - 1\n      end\n    elseif hundreds >= 1\
    \ then\n      int_to_mini_roman_result = int_to_mini_roman_result .. 'c'\n   \
    \   while hundreds > 1 do\n        int_to_mini_roman_result = int_to_mini_roman_result\
    \ .. 'c'\n        hundreds = hundreds - 1\n      end\n    end\n  end\n  -- Tens\n\
    \  local tens, rest = math.floor(rest / 10), rest % 10\n  if tens >= 1 then\n\
    \    if tens == 4 then\n      int_to_mini_roman_result = int_to_mini_roman_result\
    \ .. 'xl'\n    elseif tens == 9 then\n      int_to_mini_roman_result = int_to_mini_roman_result\
    \ .. 'xc'\n    elseif tens >= 5 then\n      int_to_mini_roman_result = int_to_mini_roman_result\
    \ .. 'l'\n      int_to_mini_roman_\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp4ffz7h2r.lua:52: syntax error near ''lu''

    '
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(type(number) == \"number\", \"number argument is not an integer\")\n\
    \  assert(number % 1 == 0, \"number argument is not an integer\")\n  assert(number\
    \ >= 1, \"number argument is not between 1 and 1000\")\n  assert(number <= 1000,\
    \ \"number argument is not between 1 and 1000\")\n  -- convert the number to a\
    \ string first\n  local number_str = tostring(number)\n  -- the string may be\
    \ of arbitrary length (max. 3)\n  -- for each character 'c' in the string, at\
    \ position 'n',\n  -- we add as many 'i', 'x', 'c' or 'm' as necessary.\n  --\
    \ the only exception is when 'c' == '9', in which case\n  -- we add 'n' + 1 'i',\
    \ 'x', 'c' or 'm' to the result.\n  local result = \"\"\n  for i = 1, #number_str\
    \ do\n    local c = number_str:sub(i, i)\n    if c == \"9\" then\n      result\
    \ = result .. {\"i\", \"x\", \"c\", \"m\"}[i] .. {\"x\", \"c\", \"m\"}[i]\n  \
    \  else\n      -- we can have at most 3 of the same character in a row\n     \
    \ local l = tonumber(c) % 5\n      result = result .. string.rep({\"i\", \"x\"\
    , \"c\", \"m\"}[i], l)\n      if tonumber(c) >= 5 then\n        result = result\
    \ .. {\"v\", \"l\", \"d\"}[i]\n      end\n    end\n  end\n  return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpln3btd52.lua:27: unexpected symbol near ''[''

    '
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local mini_roman_digits = {\n        {'i', 'v'},\n        {'x', 'l'},\n \
    \       {'c', 'd'},\n        {'m'}\n    }\n    local function convert_digit(digit,\
    \ base)\n        local value, result = number % (base * 10), ''\n        if value\
    \ == 9 * base then\n            result = mini_roman_digits[base][1] .. mini_roman_digits[base\
    \ + 1][1]\n        elseif value >= 5 * base then\n            result = mini_roman_digits[base][2]\
    \ .. string.rep(mini_roman_digits[base][1], value - 5 * base)\n        elseif\
    \ value == 4 * base then\n            result = mini_roman_digits[base][1] .. mini_roman_digits[base][2]\n\
    \        else\n            result = string.rep(mini_roman_digits[base][1], value)\n\
    \        end\n        return result\n    end\n    local result = ''\n    for i\
    \ = 1, 3 do\n        result = convert_digit(number, 10 ^ (3 - i)) .. result\n\
    \        number = math.floor(number / 10)\n    end\n    return result\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppn9i3mug.lua:27:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmppn9i3mug.lua:27:\
    \ in local 'convert_digit'\n\t/tmp/tmppn9i3mug.lua:33: in local 'candidate'\n\t\
    /tmp/tmppn9i3mug.lua:42: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(number > 0 and number <= 1000, \"Invalid number: \" .. number)\n\tlocal\
    \ roman_digits = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n\tlocal result = \"\"\n\t\
    local digits = {number % 10, math.floor(number % 100 / 10), math.floor(number\
    \ % 1000 / 100)}\n\tfor i, digit in ipairs(digits) do\n\t\tif digit == 0 then\n\
    \t\t\tresult = result .. \" \"\n\t\telseif digit <= 3 then\n\t\t\tresult = result\
    \ .. roman_digits[2 * i - 1]:rep(digit)\n\t\telseif digit == 4 then\n\t\t\tresult\
    \ = result .. roman_digits[2 * i - 1] .. roman_digits[2 * i]\n\t\telseif digit\
    \ == 5 then\n\t\t\tresult = result .. roman_digits[2 * i]\n\t\telseif digit <=\
    \ 8 then\n\t\t\tresult = result .. roman_digits[2 * i] .. roman_digits[2 * i -\
    \ 1]:rep(digit - 5)\n\t\telseif digit == 9 then\n\t\t\tresult = result .. roman_digits[2\
    \ * i - 1] .. roman_digits[2 * i + 1]\n\t\tend\n\tend\n\treturn result:gsub(\"\
    %s+\", \"\")\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprb6668pz.lua:37:\
    \ expected: \"xix\"\nactual: \"ixx\"\nstack traceback:\n\t/tmp/tmprb6668pz.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 or number > 1000 then\n        error('Number must be between\
    \ 1 and 1000', 2)\n    end\n    -- Create reverse table of letters\n    local\
    \ letters = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n    -- Create reverse table of\
    \ digits (ones, tens, hundreds)\n    local digits = {'', '', ''}\n    local n\
    \ = number\n    local i = 3\n    while n > 0 do\n        digits[i] = n % 10\n\
    \        n = math.floor(n / 10)\n        i = i - 1\n    end\n    -- Convert each\
    \ digit\n    local result = ''\n    for i = 1, 3 do\n        local digit = digits[i]\n\
    \        local letter = letters[i * 2 - 1]\n        if digit == 0 then\n     \
    \       -- Skip\n        elseif digit <= 3 then\n            result = result ..\
    \ string.rep(letter, digit)\n        elseif digit == 4 then\n            result\
    \ = result .. letter .. letters[i * 2]\n        elseif digit == 5 then\n     \
    \       result = result .. letters[i * 2]\n        elseif digit <= 8 then\n  \
    \          result = result .. letters[i * 2] .. string.rep(letter, digit - 5)\n\
    \        elseif digit == 9 then\n            result = result .. letter .. letters[i\
    \ * 2 + 1]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppas4nr4g.lua:33:\
    \ attempt to compare string with number\nstack traceback:\n\t/tmp/tmppas4nr4g.lua:33:\
    \ in local 'candidate'\n\t/tmp/tmppas4nr4g.lua:51: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \treturn\n\t\tstring.lower(\n\t\t\tint_to_roman(number,{\n\t\t\t\t{'I','V','X'},\n\
    \t\t\t\t{'X','L','C'},\n\t\t\t\t{'C','D','M'},\n\t\t\t\t{'M'}\n\t\t\t})\n\t\t\
    )\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpq_8hhtgn.lua:14:\
    \ attempt to call a nil value (global 'int_to_roman')\nstack traceback:\n\t/tmp/tmpq_8hhtgn.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpq_8hhtgn.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1, \"i\"},\n        {5, \"v\"},\n    \
    \    {10, \"x\"},\n        {50, \"l\"},\n        {100, \"c\"},\n        {500,\
    \ \"d\"},\n        {1000, \"m\"}\n    }\n    local roman_numerals_reversed = {}\n\
    \    for i = #roman_numerals, 1, -1 do\n        roman_numerals_reversed[#roman_numerals_reversed\
    \ + 1] = roman_numerals[i]\n    end\n    local result = {}\n    for _, info in\
    \ ipairs(roman_numerals_reversed) do\n        local roman, value = info[1], info[2]\n\
    \        local digits = math.floor(number / roman)\n        if digits == 4 then\n\
    \            result[#result + 1] = value\n            result[#result + 1] = roman_numerals_reversed[i\
    \ - 1][2]\n        elseif digits == 9 then\n            result[#result + 1] =\
    \ roman_numerals_reversed[i + 1][2]\n            result[#result + 1] = roman_numerals_reversed[i\
    \ - 1][2]\n        else\n            for j = 1, digits do\n                result[#result\
    \ + 1] = value\n            end\n        end\n        number = number % roman\n\
    \    end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpud5misps.lua:31:\
    \ attempt to perform arithmetic on a nil value (global 'i')\nstack traceback:\n\
    \t/tmp/tmpud5misps.lua:31: in local 'candidate'\n\t/tmp/tmpud5misps.lua:48: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 or number > 1000 then\n    error('invalid range')\n  end\n  local\
    \ roman = ''\n  -- check for each possible mini-roman numeral\n  for _, rule in\
    \ ipairs(rules) do\n    repeat\n      if number < rule.value then\n        break\n\
    \      end\n      -- apply the rule\n      roman = roman .. rule.numeral\n   \
    \   number = number - rule.value\n    until true\n  end\n  return roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = {}\n    local numeral_values = { 1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1 }\n    local numerals = { 'm', 'cm', 'd', 'cd', 'c',\
    \ 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i' }\n    for i, v in ipairs(numeral_values)\
    \ do\n        while number >= v do\n            table.insert(result, numerals[i])\n\
    \            number = number - v\n        end\n    end\n    return table.concat(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_symbols = {\n        {'m', 1000},\n        {'cm', 900},\n   \
    \     {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc', 90},\n\
    \        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix', 9},\n\
    \        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local string\
    \ = ''\n    local index = 1\n    while number > 0 do\n        while number >=\
    \ roman_symbols[index][2] do\n            string = string .. roman_symbols[index][1]\n\
    \            number = number - roman_symbols[index][2]\n        end\n        index\
    \ = index + 1\n    end\n    return string\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number > 1000 or number < 1 then\n        return nil\n    end\n    local\
    \ romans = {}\n    local roman_numerals = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l',\
    \ 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n    local number_values = {1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    for i,numeral in ipairs(roman_numerals)\
    \ do\n        local value = number_values[i]\n        if number >= value then\n\
    \            local times = math.floor(number / value)\n            for i=1,times\
    \ do\n                table.insert(romans, numeral)\n            end\n       \
    \     number = number - (times * value)\n        end\n    end\n    return table.concat(romans)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- error check\n  if number <= 0 or number > 1000 then\n    error(number ..\
    \ \" is not in range 1 - 1000\")\n  end\n  -- process the number\n  local result\
    \ = \"\"\n  local number_to_letter = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n\
    \    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n\
    \    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n   \
    \ {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for _, pair in ipairs(number_to_letter)\
    \ do\n    while number >= pair[1] do\n      result = result .. pair[2]\n     \
    \ number = number - pair[1]\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romandigits = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix',\
    \ 'v', 'iv', 'i'}\n    local romannumerals = {1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1}\n    local romanresult = \"\"\n    for i = 1, 13 do\n  \
    \      while number >= romannumerals[i] do\n            romanresult = romanresult\
    \ .. romandigits[i]\n            number = number - romannumerals[i]\n        end\n\
    \    end\n    return romanresult\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- This is a function of the form (number -> string).\n  assert(type(number)\
    \ == \"number\", \"number must be a number\")\n  assert(number > 0, \"number must\
    \ be positive\")\n  assert(number <= 1000, \"number must be no greater than 1000\"\
    )\n  local number_as_string = tostring(number)\n  local result = \"\"\n  for i\
    \ = 1, #number_as_string do\n    local digit = tonumber(number_as_string:sub(i,\
    \ i))\n    local roman_ones = roman_char[math.pow(10, #number_as_string - i)]\n\
    \    local roman_fives = roman_char[math.pow(10, #number_as_string - i) * 5]\n\
    \    local roman_tens = roman_char[math.pow(10, #number_as_string - i) * 10]\n\
    \    if digit < 4 then\n      result = result .. string.rep(roman_ones, digit)\n\
    \    elseif digit == 4 then\n      result = result .. roman_ones .. roman_fives\n\
    \    elseif digit == 5 then\n      result = result .. roman_fives\n    elseif\
    \ digit < 9 then\n      result = result .. roman_fives .. string.rep(roman_ones,\
    \ digit - 5)\n    elseif digit == 9 then\n      result = result .. roman_ones\
    \ .. roman_tens\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptkezmusy.lua:20:\
    \ attempt to index a nil value (global 'roman_char')\nstack traceback:\n\t/tmp/tmptkezmusy.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmptkezmusy.lua:41: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal number_table = {[1] = \"i\", [2] = \"ii\", [3] = \"iii\", [4] = \"iv\"\
    , [5] = \"v\", [6] = \"vi\", [7] = \"vii\", [8] = \"viii\", [9] = \"ix\",\n\t\
    [10] = \"x\", [20] = \"xx\", [30] = \"xxx\", [40] = \"xl\", [50] = \"l\", [60]\
    \ = \"lx\", [70] = \"lxx\", [80] = \"lxxx\", [90] = \"xc\",\n\t[100] = \"c\",\
    \ [200] = \"cc\", [300] = \"ccc\", [400] = \"cd\", [500] = \"d\", [600] = \"dc\"\
    , [700] = \"dcc\", [800] = \"dccc\", [900] = \"cm\",\n\t[1000] = \"m\", [2000]\
    \ = \"mm\", [3000] = \"mmm\"}\n\tlocal result = \"\"\n\tfor _, p in pairs({\"\
    m\", \"c\", \"x\", \"i\"}) do\n\t\tlocal digit = tonumber(string.sub(number, -1))\n\
    \t\tif digit > 0 then\n\t\t\tresult = number_table[digit * 10^({\"m\", \"c\",\
    \ \"x\", \"i\"}[p] - number:sub(1, 1)):len()] .. result\n\t\tend\n\t\tnumber =\
    \ number:sub(1, -2)\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpqntecq87.lua:20: '')'' expected near ''[''

    '
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 or number > 1000 then\n    error(\"Illegal argument: \" .. number\
    \ .. \". Argument must be between 1 and 1000.\")\n  end\n  local roman = \"\"\n\
    \  local v = number\n  local m = math.floor(v / 1000)\n  v = v - m * 1000\n  roman\
    \ = roman .. string.rep(\"m\", m)\n  local d = math.floor(v / 500)\n  v = v -\
    \ d * 500\n  roman = roman .. string.rep(\"d\", d)\n  local c = math.floor(v /\
    \ 100)\n  v = v - c * 100\n  roman = roman .. string.rep(\"c\", c)\n  local l\
    \ = math.floor(v / 50)\n  v = v - l * 50\n  roman = roman .. string.rep(\"l\"\
    , l)\n  local x = math.floor(v / 10)\n  v = v - x * 10\n  roman = roman .. string.rep(\"\
    x\", x)\n  local v = math.floor(v / 5)\n  v = v - v * 5\n  roman = roman .. string.rep(\"\
    v\", v)\n  local i = v\n  roman = roman .. string.rep(\"i\", i)\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpshh_zhoi.lua:43:\
    \ expected: \"xix\"\nactual: \"x\"\nstack traceback:\n\t/tmp/tmpshh_zhoi.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number >= 1 and number <= 1000,\n            \"Invalid input: \" ..\
    \ number)\n    local buffer = {}\n    local max_roman_length = #mini_roman_symbols\n\
    \    local curr_max_length = max_roman_length\n    while number > 0 do\n     \
    \   local curr_symbol = mini_roman_symbols[curr_max_length]\n        local curr_value\
    \ = mini_roman_values[curr_max_length]\n        while number >= curr_value do\n\
    \            table.insert(buffer, curr_symbol)\n            number = number -\
    \ curr_value\n        end\n        curr_max_length = curr_max_length - 1\n   \
    \ end\n    return table.concat(buffer)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5dqu4r57.lua:15:\
    \ attempt to get length of a nil value (global 'mini_roman_symbols')\nstack traceback:\n\
    \t/tmp/tmp5dqu4r57.lua:15: in local 'candidate'\n\t/tmp/tmp5dqu4r57.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009779
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local int_to_mini_roman_map = {\n        ['1'] = 'i',\n        ['5'] = 'v',\n\
    \        ['10'] = 'x',\n        ['50'] = 'l',\n        ['100'] = 'c',\n      \
    \  ['500'] = 'd',\n        ['1000'] = 'm'\n    }\n    local function int_to_mini_roman_one_digit(num,\
    \ radix)\n        local s = ''\n        local digit = num % 10\n        num =\
    \ (num - digit) / 10\n        if digit == 9 then\n            s = int_to_mini_roman_map[tostring(radix)]\
    \ .. int_to_mini_roman_map[tostring(radix * 10)]\n        elseif digit == 4 then\n\
    \            s = int_to_mini_roman_map[tostring(radix)] .. int_to_mini_roman_map[tostring(radix\
    \ * 5)]\n        else\n            if digit >= 5 then\n                s = s ..\
    \ int_to_mini_roman_map[tostring(radix * 5)]\n                digit = digit -\
    \ 5\n            end\n            s = s .. string.rep(int_to_mini_roman_map[tostring(radix)],\
    \ digit)\n        end\n        return s, num\n    end\n    local function int_to_mini_roman_three_digits(num)\n\
    \        local s = ''\n        local r\n        r, num = int_to_mini_roman_one_digit(num,\
    \ 100)\n        s = s .. r\n        r, num = int_to_mini_roman_one_digit(num,\
    \ 10)\n        s = s .. r\n        r, num = int_to_mini_roman_one_digit(num, 1)\n\
    \        s = s .. r\n        return s\n    end\n    local s = ''\n    local r\n\
    \    r, number = int_to_mini_roman_one_digit(number, 1000)\n    s = s .. r\n \
    \   s = s .. int_to_mini_roman_three_digits(number)\n    return s\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_4yjnhbu.lua:26:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmp_4yjnhbu.lua:26:\
    \ in local 'int_to_mini_roman_one_digit'\n\t/tmp/tmp_4yjnhbu.lua:51: in local\
    \ 'candidate'\n\t/tmp/tmp_4yjnhbu.lua:60: in function 'test_humaneval'\n\nRan\
    \ 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal values = {\n\t\t{\"m\", 1000},\n\t\t{\"cm\", 900},\n\t\t{\"d\", 500},\n\
    \t\t{\"cd\", 400},\n\t\t{\"c\", 100},\n\t\t{\"xc\", 90},\n\t\t{\"l\", 50},\n\t\
    \t{\"xl\", 40},\n\t\t{\"x\", 10},\n\t\t{\"ix\", 9},\n\t\t{\"v\", 5},\n\t\t{\"\
    iv\", 4},\n\t\t{\"i\", 1}\n\t}\n\tlocal remainder = number\n\tlocal result = \"\
    \"\n\tfor _, pair in ipairs(values) do\n\t\tlocal numeral, value = unpack(pair)\n\
    \t\twhile remainder >= value do\n\t\t\tresult = result .. numeral\n\t\t\tremainder\
    \ = remainder - value\n\t\tend\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8pakbbsb.lua:30:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmp8pakbbsb.lua:30:\
    \ in local 'candidate'\n\t/tmp/tmp8pakbbsb.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 or number > 1000 then\n    return \"invalid number\"\n  end\n\
    \  local rn_dict = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"\
    },\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n\
    \    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4,\
    \ \"iv\"},\n    {1, \"i\"}\n  }\n  local roman = \"\"\n  local i = 1\n  while\
    \ number > 0 do\n    while number >= rn_dict[i][1] do\n      number = number -\
    \ rn_dict[i][1]\n      roman = roman .. rn_dict[i][2]\n    end\n    i = i + 1\n\
    \  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local numeral = \"\"\n  local numbers = {1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1}\n  local numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n  for i, n in ipairs(numbers)\
    \ do\n    while number >= n do\n      numeral = numeral .. numerals[i]\n     \
    \ number = number - n\n    end\n  end\n  return numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- We use the 'reverse' and 'concat' functions to avoid leading zeros.\n  local\
    \ result = {}\n  if number >= 1000 then\n    number = number - 1000\n    result[#result\
    \ + 1] = 'm'\n  end\n  if number >= 900 then\n    number = number - 900\n    result[#result\
    \ + 1] = 'cm'\n  end\n  if number >= 500 then\n    number = number - 500\n   \
    \ result[#result + 1] = 'd'\n  end\n  if number >= 400 then\n    number = number\
    \ - 400\n    result[#result + 1] = 'cd'\n  end\n  if number >= 100 then\n    number\
    \ = number - 100\n    result[#result + 1] = 'c'\n  end\n  if number >= 90 then\n\
    \    number = number - 90\n    result[#result + 1] = 'xc'\n  end\n  if number\
    \ >= 50 then\n    number = number - 50\n    result[#result + 1] = 'l'\n  end\n\
    \  if number >= 40 then\n    number = number - 40\n    result[#result + 1] = 'xl'\n\
    \  end\n  if number >= 10 then\n    number = number - 10\n    result[#result +\
    \ 1] = 'x'\n  end\n  if number >= 9 then\n    number = number - 9\n    result[#result\
    \ + 1] = 'ix'\n  end\n  if number >= 5 then\n    number = number - 5\n    result[#result\
    \ + 1] = 'v'\n  end\n  if number >= 4 then\n    number = number - 4\n    result[#result\
    \ + 1] = 'iv'\n  end\n  if number >= 1 then\n    number = number - 1\n    result[#result\
    \ + 1] = 'i'\n  end\n  return concat(result)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpix4ft5ck.lua:66:\
    \ attempt to call a nil value (global 'concat')\nstack traceback:\n\t/tmp/tmpix4ft5ck.lua:66:\
    \ in local 'candidate'\n\t/tmp/tmpix4ft5ck.lua:72: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local digits = reverse_string(tostring(number))\n \
    \   local length = #digits\n    for i = 1, length do\n        local digit = tonumber(digits:sub(i,\
    \ i))\n        local tens = tonumber(digits:sub(i+1, i+1))\n        local hundreds\
    \ = tonumber(digits:sub(i+2, i+2))\n        if not tens and not hundreds then\n\
    \            if digit == 0 then\n                roman = roman .. ''\n       \
    \     elseif digit == 1 then\n                roman = roman .. 'i'\n         \
    \   elseif digit == 2 then\n                roman = roman .. 'ii'\n          \
    \  elseif digit == 3 then\n                roman = roman .. 'iii'\n          \
    \  elseif digit == 4 then\n                roman = roman .. 'iv'\n           \
    \ elseif digit == 5 then\n                roman = roman .. 'v'\n            elseif\
    \ digit == 6 then\n                roman = roman .. 'vi'\n            elseif digit\
    \ == 7 then\n                roman = roman .. 'vii'\n            elseif digit\
    \ == 8 then\n                roman = roman .. 'viii'\n            elseif digit\
    \ == 9 then\n                roman = roman .. 'ix'\n            end\n        elseif\
    \ not hundreds then\n            if digit == 0 then\n                roman = roman\
    \ .. ''\n            elseif digit == 1 then\n                roman = roman ..\
    \ 'x'\n            elseif digit == 2 then\n                roman = roman .. 'xx'\n\
    \            elseif digit == 3 then\n                roman = roman .. 'xxx'\n\
    \            elseif digit == 4 then\n                roman = roman .. 'xl'\n \
    \           elseif digit == 5 then\n                roman = roman .. 'l'\n   \
    \         elseif digit == 6 then\n                roman = roman .. 'lx'\n    \
    \        elseif digit == 7 then\n                roman = roman .. 'lxx'\n    \
    \        elseif digit == 8 then\n                roman = roman .. 'lxxx'\n   \
    \         elseif digit == 9 then\n                roman = roman .. 'xc'\n    \
    \        end\n        else\n            if digit == 0 then\n               \n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpk_r8w5ik.lua:86: ''end'' expected (to close ''if'' at line
    64) near <eof>

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number > 1000 or number < 1 then\n        return nil\n    end\n    local\
    \ tmp = number\n    local table = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl',\
    \ 'x', 'ix', 'v', 'iv', 'i'}\n    local number_roman = ''\n    for i, v in ipairs(table)\
    \ do\n        while tmp >= Roman[v] do\n            tmp = tmp - Roman[v]\n   \
    \         number_roman = number_roman .. v\n        end\n    end\n    return number_roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6hxdxf28.lua:19:\
    \ attempt to index a nil value (global 'Roman')\nstack traceback:\n\t/tmp/tmp6hxdxf28.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmp6hxdxf28.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_number = {}\n    while number > 0 do\n        if number >= 1000\
    \ then\n            table.insert(roman_number, 'm')\n            number = number\
    \ - 1000\n        elseif number >= 900 then\n            table.insert(roman_number,\
    \ 'cm')\n            number = number - 900\n        elseif number >= 500 then\n\
    \            table.insert(roman_number, 'd')\n            number = number - 500\n\
    \        elseif number >= 400 then\n            table.insert(roman_number, 'cd')\n\
    \            number = number - 400\n        elseif number >= 100 then\n      \
    \      table.insert(roman_number, 'c')\n            number = number - 100\n  \
    \      elseif number >= 90 then\n            table.insert(roman_number, 'xc')\n\
    \            number = number - 90\n        elseif number >= 50 then\n        \
    \    table.insert(roman_number, 'l')\n            number = number - 50\n     \
    \   elseif number >= 40 then\n            table.insert(roman_number, 'xl')\n \
    \           number = number - 40\n        elseif number >= 10 then\n         \
    \   table.insert(roman_number, 'x')\n            number = number - 10\n      \
    \  elseif number >= 9 then\n            table.insert(roman_number, 'ix')\n   \
    \         number = number - 9\n        elseif number >= 5 then\n            table.insert(roman_number,\
    \ 'v')\n            number = number - 5\n        elseif number >= 4 then\n   \
    \         table.insert(roman_number, 'iv')\n            number = number - 4\n\
    \        elseif number >= 1 then\n            table.insert(roman_number, 'i')\n\
    \            number = number - 1\n        end\n    end\n    return table.concat(roman_number)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if type(number) ~= 'number' then\n    error('Input must be a number!')\n  end\n\
    \  if number < 1 or number > 1000 then\n    error('Input must be between 1 and\
    \ 1000!')\n  end\n  local table = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1}\n  local string = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x',\
    \ 'ix', 'v', 'iv', 'i'}\n  local result = ''\n  for i, v in ipairs(table) do\n\
    \    while number >= v do\n      number = number - v\n      result = result ..\
    \ string[i]\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local digits = {}\n  local answer = ''\n  while number ~= 0 do\n    local d\
    \ = number % 10\n    number = (number - d) / 10\n    table.insert(digits, 1, d)\n\
    \  end\n  for i = 1, #digits do\n    answer = table.concat{mini_roman_symbols[i][digits[i]],\
    \ answer}\n  end\n  return answer\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4dks7ljc.lua:20:\
    \ attempt to index a nil value (global 'mini_roman_symbols')\nstack traceback:\n\
    \t/tmp/tmp4dks7ljc.lua:20: in local 'candidate'\n\t/tmp/tmp4dks7ljc.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local string = ''\n    local n = number\n    while n > 0 do\n        if n\
    \ >= 1000 then\n            string = string .. 'm'\n            n = n - 1000\n\
    \        elseif n >= 900 then\n            string = string .. 'cm'\n         \
    \   n = n - 900\n        elseif n >= 500 then\n            string = string ..\
    \ 'd'\n            n = n - 500\n        elseif n >= 400 then\n            string\
    \ = string .. 'cd'\n            n = n - 400\n        elseif n >= 100 then\n  \
    \          string = string .. 'c'\n            n = n - 100\n        elseif n >=\
    \ 90 then\n            string = string .. 'xc'\n            n = n - 90\n     \
    \   elseif n >= 50 then\n            string = string .. 'l'\n            n = n\
    \ - 50\n        elseif n >= 40 then\n            string = string .. 'xl'\n   \
    \         n = n - 40\n        elseif n >= 10 then\n            string = string\
    \ .. 'x'\n            n = n - 10\n        elseif n >= 9 then\n            string\
    \ = string .. 'ix'\n            n = n - 9\n        elseif n >= 5 then\n      \
    \      string = string .. 'v'\n            n = n - 5\n        elseif n >= 4 then\n\
    \            string = string .. 'iv'\n            n = n - 4\n        elseif n\
    \ >= 1 then\n            string = string .. 'i'\n            n = n - 1\n     \
    \   end\n    end\n    return string\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tif number <= 0 or number > 1000 then\n\t\terror('Number must be between 1 and\
    \ 1000')\n\tend\n\t-- Create a list of the roman numeral digits from highest to\
    \ lowest (both\n\t-- ones and fives)\n\tlocal digits = {'M', 'D', 'C', 'L', 'X',\
    \ 'V', 'I'}\n\t-- Build up a list of the partial roman numerals, which will be\
    \ concatenated\n\t-- together later\n\tlocal pieces = {}\n\t-- The roman numeral\
    \ algorithm reads right to left, so we will iterate over\n\t-- the digits in reverse\
    \ order\n\tfor i = #digits, 1, -1 do\n\t\t-- Determine the number of this particular\
    \ digit in the number\n\t\tlocal digit_count = math.floor(number / (10 ^ (i -\
    \ 1)))\n\t\t-- Add the digit to the list of numerals to be concatenated, unless\
    \ we\n\t\t-- have one of the special cases\n\t\tif digit_count == 9 then\n\t\t\
    \t-- Nine is a special case, because IX should be written instead of\n\t\t\t--\
    \ VIIII\n\t\t\ttable.insert(pieces, digits[i] .. digits[i + 2])\n\t\telseif digit_count\
    \ == 4 then\n\t\t\t-- Four is a special case, because IV should be written instead\
    \ of\n\t\t\t-- IIII\n\t\t\ttable.insert(pieces, digits[i] .. digits[i + 1])\n\t\
    \telse\n\t\t\t-- If there are at least five of this digit, then we add the five\
    \ and\n\t\t\t-- then subtract five, because it has already been added\n\t\t\t\
    if digit_count >= 5 then\n\t\t\t\ttable.insert(pieces, digits[i + 1])\n\t\t\t\t\
    digit_count = digit_count - 5\n\t\t\tend\n\t\t\t-- After any special cases have\
    \ been handled, we add the remaining\n\t\t\t-- digits in this place\n\t\t\tfor\
    \ _ = 1, digit_count do\n\t\t\t\ttable.insert(pieces, digits[i])\n\t\t\tend\n\t\
    \tend\n\t\t-- After we have added the required number of this digit, we remove\
    \ it\n\t\t-- from the number\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp8cwk7iku.lua:71: ''end'' expected (to close ''for'' at line
    23) near <eof>

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local arabic = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}\n \
    \   local roman = {'i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd',\
    \ 'cm', 'm'}\n    local i = #arabic\n    local last = number\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpfczz7kt9.lua:36: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number >= 1 and number <= 1000,\n           'Number out of range')\n\
    \    local numeral = ''\n    for i, v in ipairs(roman_int_to_mini_letters) do\n\
    \        local letter, value = v[1], v[2]\n        while number >= value do\n\
    \            numeral = numeral .. letter\n            number = number - value\n\
    \        end\n    end\n    return numeral\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local numeral = {}\n    local numeral_position = 0\n    local num = number\n\
    \    local numeral_table = {\n        {num = 1000, numeral = 'm'},\n        {num\
    \ = 500, numeral = 'd'},\n        {num = 100, numeral = 'c'},\n        {num =\
    \ 50, numeral = 'l'},\n        {num = 10, numeral = 'x'},\n        {num = 5, numeral\
    \ = 'v'},\n        {num = 1, numeral = 'i'}\n    }\n    while num > 0 do\n   \
    \     local remainder = num % 10\n        if remainder < 4 then\n            for\
    \ i = 1, remainder do\n                numeral_position = numeral_position + 1\n\
    \                numeral[numeral_position] = numeral_table[7].numeral\n      \
    \      end\n        elseif remainder == 4 then\n            numeral_position =\
    \ numeral_position + 1\n            numeral[numeral_position] = numeral_table[6].numeral\n\
    \            numeral_position = numeral_position + 1\n            numeral[numeral_position]\
    \ = numeral_table[7].numeral\n        elseif remainder == 5 then\n           \
    \ numeral_position = numeral_position + 1\n            numeral[numeral_position]\
    \ = numeral_table[6].numeral\n        elseif remainder > 5 and remainder < 9 then\n\
    \            numeral_position = numeral_position + 1\n            numeral[numeral_position]\
    \ = numeral_table[6].numeral\n            for i = 1, remainder - 5 do\n      \
    \          numeral_position = numeral_position + 1\n                numeral[numeral_position]\
    \ = numeral_table[7].numeral\n            end\n        elseif remainder == 9 then\n\
    \            numeral_position = numeral_position + 1\n            numeral[numeral_position]\
    \ = numeral_table[5].numeral\n            numeral_position = numeral_position\
    \ + 1\n            numeral[numeral_position] = numeral_table[7].numeral\n    \
    \    end\n        num = math.floor(num / 10)\n        for i = 1, 7 do\n      \
    \      if num == numeral_\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp3vwwhnau.lua:55: ''then'' expected near ''lu''

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman_table = {\n\t\t[1] = 'i',\n\t\t[2] = 'ii',\n\t\t[3] = 'iii',\n\t\
    \t[4] = 'iv',\n\t\t[5] = 'v',\n\t\t[6] = 'vi',\n\t\t[7] = 'vii',\n\t\t[8] = 'viii',\n\
    \t\t[9] = 'ix',\n\t\t[10] = 'x',\n\t\t[20] = 'xx',\n\t\t[30] = 'xxx',\n\t\t[40]\
    \ = 'xl',\n\t\t[50] = 'l',\n\t\t[60] = 'lx',\n\t\t[70] = 'lxx',\n\t\t[80] = 'lxxx',\n\
    \t\t[90] = 'xc',\n\t\t[100] = 'c',\n\t\t[200] = 'cc',\n\t\t[300] = 'ccc',\n\t\t\
    [400] = 'cd',\n\t\t[500] = 'd',\n\t\t[600] = 'dc',\n\t\t[700] = 'dcc',\n\t\t[800]\
    \ = 'dccc',\n\t\t[900] = 'cm',\n\t\t[1000] = 'm',\n\t}\n\tlocal function split_number(number)\n\
    \t\tlocal t = {}\n\t\twhile number > 0 do\n\t\t\tlocal digit = number % 10\n\t\
    \t\tif digit ~= 0 then\n\t\t\t\ttable.insert(t, 1, digit)\n\t\t\tend\n\t\t\tnumber\
    \ = (number - digit) / 10\n\t\tend\n\t\treturn t\n\tend\n\tlocal ret = ''\n\t\
    local splitted = split_number(number)\n\tfor k, v in ipairs(splitted) do\n\t\t\
    local ten = 10 ^ (k - 1)\n\t\tret = ret .. roman_table[ten * v]\n\tend\n\treturn\
    \ ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqi17i82y.lua:65:\
    \ expected: \"xix\"\nactual: \"ixc\"\nstack traceback:\n\t/tmp/tmpqi17i82y.lua:65:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local out = \"\"\n  while number > 0 do\n    local roman, int = next(mini_roman)\n\
    \    while int > number do\n      roman, int = next(mini_roman, roman)\n    end\n\
    \    out = out .. roman\n    number = number - int\n  end\n  return out\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpetchgzfc.lua:14:\
    \ bad argument #1 to 'next' (table expected, got nil)\nstack traceback:\n\t/tmp/tmpetchgzfc.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpetchgzfc.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local numeral_table = {\n        {1000, 'm'},\n        {900, 'cm'},\n   \
    \     {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    local num = number\n    for i = 1, #numeral_table do\n        if num\
    \ >= numeral_table[i][1] then\n            local value = math.floor(num / numeral_table[i][1])\n\
    \            num = num - (value * numeral_table[i][1])\n            result = result\
    \ .. numeral_table[i][2]:rep(value)\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = \"\"\n  for index, key in ipairs(mini_roman_digits) do\n   \
    \ local value = mini_roman_values[index]\n    if number >= value then\n      local\
    \ n = math.floor(number / value)\n      number = number - n * value\n      for\
    \ i = 1, n do\n        result = result .. key\n      end\n    end\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number >= 1 and number <= 1000, 'number must be between 1 and 1000')\n\
    \    return table.concat(\n        table.map(\n            function(num, str)\n\
    \                return string.rep(str, math.floor(number / num))\n          \
    \  end,\n            {\n                {1000, 'm'},\n                {900, 'cm'},\n\
    \                {500, 'd'},\n                {400, 'cd'},\n                {100,\
    \ 'c'},\n                {90, 'xc'},\n                {50, 'l'},\n           \
    \     {40, 'xl'},\n                {10, 'x'},\n                {9, 'ix'},\n  \
    \              {5, 'v'},\n                {4, 'iv'},\n                {1, 'i'}\n\
    \            }\n        )\n    )\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpjj03cbht.lua:14:\
    \ attempt to call a nil value (field 'map')\nstack traceback:\n\t/tmp/tmpjj03cbht.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpjj03cbht.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        ['1'] = 'i',\n        ['2'] = 'ii',\n \
    \       ['3'] = 'iii',\n        ['4'] = 'iv',\n        ['5'] = 'v',\n        ['6']\
    \ = 'vi',\n        ['7'] = 'vii',\n        ['8'] = 'viii',\n        ['9'] = 'ix',\n\
    \        ['10'] = 'x',\n        ['20'] = 'xx',\n        ['30'] = 'xxx',\n    \
    \    ['40'] = 'xl',\n        ['50'] = 'l',\n        ['60'] = 'lx',\n        ['70']\
    \ = 'lxx',\n        ['80'] = 'lxxx',\n        ['90'] = 'xc',\n        ['100']\
    \ = 'c',\n        ['200'] = 'cc',\n        ['300'] = 'ccc',\n        ['400'] =\
    \ 'cd',\n        ['500'] = 'd',\n        ['600'] = 'dc',\n        ['700'] = 'dcc',\n\
    \        ['800'] = 'dccc',\n        ['900'] = 'cm',\n        ['1000'] = 'm',\n\
    \    }\n    local roman_numeral = ''\n    local num_str = tostring(number)\n \
    \   local size = #num_str\n    for i=1, size do\n        local digit = num_str:sub(i,\
    \ i)\n        local rep = tonumber(digit) * (10 ^ (size - i))\n        if roman_numerals[tostring(rep)]\
    \ then\n            roman_numeral = roman_numeral .. roman_numerals[tostring(rep)]\n\
    \        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe8gbicim.lua:58:\
    \ expected: \"xix\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpe8gbicim.lua:58:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local ones = {'','i','ii','iii','iv','v','vi','vii','viii','ix'}\n  local tens\
    \ = {'','x','xx','xxx','xl','l','lx','lxx','lxxx','xc'}\n  local hundreds = {'','c','cc','ccc','cd','d','dc','dcc','dccc','cm'}\n\
    \  local thousands = {'','m','mm','mmm'}\n  local roman = thousands[math.floor(number/1000)]\
    \ .. hundreds[math.floor((number%1000)/100)] .. tens[math.floor((number%100)/10)]\
    \ .. ones[number%10]\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqpvf291r.lua:16:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpqpvf291r.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpqpvf291r.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local int2mini_roman = {\n    {num = 1000, roman = 'm'},\n    {num = 900, roman\
    \ = 'cm'},\n    {num = 500, roman = 'd'},\n    {num = 400, roman = 'cd'},\n  \
    \  {num = 100, roman = 'c'},\n    {num = 90, roman = 'xc'},\n    {num = 50, roman\
    \ = 'l'},\n    {num = 40, roman = 'xl'},\n    {num = 10, roman = 'x'},\n    {num\
    \ = 9, roman = 'ix'},\n    {num = 5, roman = 'v'},\n    {num = 4, roman = 'iv'},\n\
    \    {num = 1, roman = 'i'},\n  }\n  local result = ''\n  for k, v in ipairs(int2mini_roman)\
    \ do\n    local n = floor(number / v.num)\n    if n > 0 then\n      result = result\
    \ .. v.roman:rep(n)\n      number = number - v.num * n\n    end\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8id6coyb.lua:29:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmp8id6coyb.lua:29:\
    \ in local 'candidate'\n\t/tmp/tmp8id6coyb.lua:41: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1, 'i'},\n        {4, 'iv'},\n       \
    \ {5, 'v'},\n        {9, 'ix'},\n        {10, 'x'},\n        {40, 'xl'},\n   \
    \     {50, 'l'},\n        {90, 'xc'},\n        {100, 'c'},\n        {400, 'cd'},\n\
    \        {500, 'd'},\n        {900, 'cm'},\n        {1000, 'm'}\n    }\n    local\
    \ roman_numeral = \"\"\n    while number > 0 do\n        local digit_found = false\n\
    \        for _, info in ipairs(roman_numerals) do\n            local digit, roman\
    \ = unpack(info)\n            if number >= digit then\n                roman_numeral\
    \ = roman_numeral .. roman\n                number = number - digit\n        \
    \        digit_found = true\n                break\n            end\n        end\n\
    \        if not digit_found then\n            error(\"Invalid number: \" .. number)\n\
    \        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5zh7c3d6.lua:31:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmp5zh7c3d6.lua:31:\
    \ in local 'candidate'\n\t/tmp/tmp5zh7c3d6.lua:49: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number == 0 then\n    return \"\"\n  elseif number <= 3 then\n    return\
    \ \"i\" .. int_to_mini_roman(number - 1)\n  elseif number == 4 then\n    return\
    \ \"iv\"\n  elseif number <= 8 then\n    return \"v\" .. int_to_mini_roman(number\
    \ - 5)\n  elseif number == 9 then\n    return \"ix\"\n  elseif number <= 12 then\n\
    \    return \"x\" .. int_to_mini_roman(number - 10)\n  elseif number <= 39 then\n\
    \    return \"x\" .. int_to_mini_roman(number - 10)\n  elseif number <= 49 then\n\
    \    return \"xl\" .. int_to_mini_roman(number - 40)\n  elseif number <= 89 then\n\
    \    return \"l\" .. int_to_mini_roman(number - 50)\n  elseif number <= 99 then\n\
    \    return \"xc\" .. int_to_mini_roman(number - 90)\n  elseif number <= 399 then\n\
    \    return \"c\" .. int_to_mini_roman(number - 100)\n  elseif number <= 499 then\n\
    \    return \"cd\" .. int_to_mini_roman(number - 400)\n  elseif number <= 899\
    \ then\n    return \"d\" .. int_to_mini_roman(number - 500)\n  elseif number <=\
    \ 999 then\n    return \"cm\" .. int_to_mini_roman(number - 900)\n  elseif number\
    \ <= 3999 then\n    return \"m\" .. int_to_mini_roman(number - 1000)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number == 0 then\n        return \"\"\n    elseif number >= 1000 then\n\
    \        return \"m\" .. int_to_mini_roman(number - 1000)\n    elseif number >=\
    \ 900 then\n        return \"cm\" .. int_to_mini_roman(number - 900)\n    elseif\
    \ number >= 500 then\n        return \"d\" .. int_to_mini_roman(number - 500)\n\
    \    elseif number >= 400 then\n        return \"cd\" .. int_to_mini_roman(number\
    \ - 400)\n    elseif number >= 100 then\n        return \"c\" .. int_to_mini_roman(number\
    \ - 100)\n    elseif number >= 90 then\n        return \"xc\" .. int_to_mini_roman(number\
    \ - 90)\n    elseif number >= 50 then\n        return \"l\" .. int_to_mini_roman(number\
    \ - 50)\n    elseif number >= 40 then\n        return \"xl\" .. int_to_mini_roman(number\
    \ - 40)\n    elseif number >= 10 then\n        return \"x\" .. int_to_mini_roman(number\
    \ - 10)\n    elseif number >= 9 then\n        return \"ix\" .. int_to_mini_roman(number\
    \ - 9)\n    elseif number >= 5 then\n        return \"v\" .. int_to_mini_roman(number\
    \ - 5)\n    elseif number >= 4 then\n        return \"iv\" .. int_to_mini_roman(number\
    \ - 4)\n    elseif number >= 1 then\n        return \"i\" .. int_to_mini_roman(number\
    \ - 1)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Create dictionary of roman numerals to ints.\n    local roman_to_int =\
    \ {}\n    local mini_roman_to_int = {}\n    local int_to_mini_roman = {}\n   \
    \ for _, val in ipairs(Romannumeral) do\n        local roman = val[1]\n      \
    \  local int = val[2]\n        local miniroman = val[3]\n        roman_to_int[roman]\
    \ = int\n        mini_roman_to_int[miniroman] = int\n        int_to_mini_roman[int]\
    \ = miniroman\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpjeon57tt.lua:44: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = {\n        {'I', 'V'},\n        {'X', 'L'},\n        {'C',\
    \ 'D'},\n        {'M'}\n    }\n    local s = ''\n    local n = number\n    local\
    \ i = 1\n    while n > 0 do\n        local digit = n % 10\n        local d\n \
    \       if digit == 0 then\n            d = ''\n        elseif digit < 4 then\n\
    \            d = roman[i][1]:rep(digit)\n        elseif digit == 4 then\n    \
    \        d = roman[i][1] .. roman[i][2]\n        elseif digit == 5 then\n    \
    \        d = roman[i][2]\n        elseif digit < 9 then\n            d = roman[i][2]\
    \ .. roman[i][1]:rep(digit - 5)\n        else\n            d = roman[i][1] ..\
    \ roman[i + 1][1]\n        end\n        s = d .. s\n        n = (n - digit) /\
    \ 10\n        i = i + 1\n    end\n    return s\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpedbr82is.lua:47:\
    \ expected: \"xix\"\nactual: \"XIX\"\nstack traceback:\n\t/tmp/tmpedbr82is.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 or number > 1000 then\n        return nil\n    end\n    local\
    \ roman_numerals = {\n        [1000] = 'm',\n        [900] = 'cm',\n        [500]\
    \ = 'd',\n        [400] = 'cd',\n        [100] = 'c',\n        [90] = 'xc',\n\
    \        [50] = 'l',\n        [40] = 'xl',\n        [10] = 'x',\n        [9] =\
    \ 'ix',\n        [5] = 'v',\n        [4] = 'iv',\n        [1] = 'i'\n    }\n \
    \   local roman_number = ''\n    for key, value in pairs(roman_numerals) do\n\
    \        local repeated = math.floor(number / key)\n        roman_number = roman_number\
    \ .. string.rep(value, repeated)\n        number = number - repeated * key\n \
    \   end\n    return roman_number\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7qcq3xyl.lua:42:\
    \ expected: \"xix\"\nactual: \"iiiiiiiiiiiiiiiiiii\"\nstack traceback:\n\t/tmp/tmp7qcq3xyl.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number > 0, \"Number must be positive\")\n    assert(number <= 1000,\
    \ \"Number must be <= 1000\")\n    local result = \"\"\n    local arabic_numerals\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    local roman_numerals\
    \ = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"}\n    for i = 1, #arabic_numerals do\n        while (number\
    \ >= arabic_numerals[i]) do\n            result = result .. roman_numerals[i]\n\
    \            number = number - arabic_numerals[i]\n        end\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local unit = {'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix'}\n \
    \   local ten = {'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc'}\n   \
    \ local hundred = {'c', 'cc', 'ccc', 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm'}\n \
    \   local thousand = {'m', 'mm', 'mmm'}\n    local mini_roman = ''\n    local\
    \ n = number\n    if n >= 1000 then\n        n = n - 1000\n        mini_roman\
    \ = mini_roman .. thousand[math.floor(number / 1000)]\n    end\n    if n >= 100\
    \ then\n        n = n - 100 * math.floor(n / 100)\n        mini_roman = mini_roman\
    \ .. hundred[math.floor(number / 100)]\n    end\n    if n >= 10 then\n       \
    \ n = n - 10 * math.floor(n / 10)\n        mini_roman = mini_roman .. ten[math.floor(number\
    \ / 10)]\n    end\n    if n > 0 then\n        mini_roman = mini_roman .. unit[n]\n\
    \    end\n    return mini_roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6oqee7qw.lua:28:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmp6oqee7qw.lua:28:\
    \ in local 'candidate'\n\t/tmp/tmp6oqee7qw.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tnumber = tonumber(number)\n\tassert(1 <= number and number <= 1000, \"mini-roman\
    \ numerals are only defined for 1 <= n <= 1000\")\n\tlocal romans = {\n\t\t[\"\
    \"] = {\n\t\t\t[0] = \"\",\n\t\t\t[1] = \"c\",\n\t\t\t[2] = \"cc\",\n\t\t\t[3]\
    \ = \"ccc\",\n\t\t\t[4] = \"cd\",\n\t\t\t[5] = \"d\",\n\t\t\t[6] = \"dc\",\n\t\
    \t\t[7] = \"dcc\",\n\t\t\t[8] = \"dccc\",\n\t\t\t[9] = \"cm\"\n\t\t},\n\t\t[\"\
    \"] = {\n\t\t\t[0] = \"\",\n\t\t\t[1] = \"x\",\n\t\t\t[2] = \"xx\",\n\t\t\t[3]\
    \ = \"xxx\",\n\t\t\t[4] = \"xl\",\n\t\t\t[5] = \"l\",\n\t\t\t[6] = \"lx\",\n\t\
    \t\t[7] = \"lxx\",\n\t\t\t[8] = \"lxxx\",\n\t\t\t[9] = \"xc\"\n\t\t},\n\t\t[\"\
    \"] = {\n\t\t\t[0] = \"\",\n\t\t\t[1] = \"i\",\n\t\t\t[2] = \"ii\",\n\t\t\t[3]\
    \ = \"iii\",\n\t\t\t[4] = \"iv\",\n\t\t\t[5] = \"v\",\n\t\t\t[6] = \"vi\",\n\t\
    \t\t[7] = \"vii\",\n\t\t\t[8] = \"viii\",\n\t\t\t[9] = \"ix\"\n\t\t}\n\t}\n\t\
    return romans[1][math.floor(number / 100) % 10] .. romans[2][math.floor(number\
    \ / 10) % 10] .. romans[3][number % 10]\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpd2xxkzqm.lua:52:\
    \ attempt to index a nil value (field 'integer index')\nstack traceback:\n\t/tmp/tmpd2xxkzqm.lua:52:\
    \ in local 'candidate'\n\t/tmp/tmpd2xxkzqm.lua:58: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number >= 1 and number <= 1000, \"Number must be between 1 and 1000\
    \ inclusive\")\n    local roman = \"\"\n    for _, denom in ipairs(roman_numerals)\
    \ do\n        local n, m = number % denom.value, (number - number % denom.value)\
    \ / denom.value\n        if m ~= 0 then\n            roman = roman .. denom.symbol:rep(m)\n\
    \        end\n        number = n\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local mini_roman_numbers = {\n        ['1'] = 'i',\n        ['5'] = 'v',\n\
    \        ['10'] = 'x',\n        ['50'] = 'l',\n        ['100'] = 'c',\n      \
    \  ['500'] = 'd',\n        ['1000'] = 'm'\n    }\n    if number == 0 then\n  \
    \      return ''\n    elseif number >= 1000 then\n        return mini_roman_numbers['1000']\
    \ .. int_to_mini_roman(number - 1000)\n    elseif number >= 500 then\n       \
    \ return mini_roman_numbers['500'] .. int_to_mini_roman(number - 500)\n    elseif\
    \ number >= 100 then\n        return mini_roman_numbers['100'] .. int_to_mini_roman(number\
    \ - 100)\n    elseif number >= 50 then\n        return mini_roman_numbers['50']\
    \ .. int_to_mini_roman(number - 50)\n    elseif number >= 10 then\n        return\
    \ mini_roman_numbers['10'] .. int_to_mini_roman(number - 10)\n    elseif number\
    \ >= 5 then\n        return mini_roman_numbers['5'] .. int_to_mini_roman(number\
    \ - 5)\n    elseif number >= 1 then\n        return mini_roman_numbers['1'] ..\
    \ int_to_mini_roman(number - 1)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg3b7tm08.lua:43:\
    \ expected: \"xix\"\nactual: \"xviiii\"\nstack traceback:\n\t/tmp/tmpg3b7tm08.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local mini_roman_table = {\n        {1000, 'm'},\n        {500, 'd'},\n \
    \       {100, 'c'},\n        {50, 'l'},\n        {10, 'x'},\n        {5, 'v'},\n\
    \        {1, 'i'}\n    }\n    local result = ''\n    local v\n    for i = 1, #mini_roman_table\
    \ do\n        v = math.floor(number / mini_roman_table[i][1])\n        if v ==\
    \ 9 then\n            result = result .. mini_roman_table[i][2] .. mini_roman_table[i\
    \ - 2][2]\n        elseif v >= 5 then\n            result = result .. mini_roman_table[i\
    \ - 1][2] .. string.rep(mini_roman_table[i][2], v - 5)\n        elseif v == 4\
    \ then\n            result = result .. mini_roman_table[i][2] .. mini_roman_table[i\
    \ - 1][2]\n        else\n            result = result .. string.rep(mini_roman_table[i][2],\
    \ v)\n        end\n        number = number % mini_roman_table[i][1]\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnygqtpj5.lua:42:\
    \ expected: \"xix\"\nactual: \"xviv\"\nstack traceback:\n\t/tmp/tmpnygqtpj5.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local function process_digit(digit, ones, fives, tens)\n    if digit == 0 then\n\
    \      return \"\"\n    elseif digit <= 3 then\n      return ones:rep(digit)\n\
    \    elseif digit == 4 then\n      return ones .. fives\n    elseif digit == 5\
    \ then\n      return fives\n    elseif digit <= 8 then\n      return fives ..\
    \ ones:rep(digit - 5)\n    else\n      return ones .. tens\n    end\n  end\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpf77ahdcw.lua:47: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local mapper = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10]\
    \ = \"x\",\n        [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"\
    d\",\n        [1000] = \"m\"\n    }\n    local result = \"\"\n    local num_of_m\
    \ = 0\n    local num_of_d = 0\n    local num_of_c = 0\n    local num_of_l = 0\n\
    \    local num_of_x = 0\n    local num_of_v = 0\n    local num_of_i = 0\n    local\
    \ rest = number\n    local rem\n    local quo\n    if number == 1000 then\n  \
    \      num_of_m = 1\n    else\n        while rest > 500 do\n            num_of_m\
    \ = num_of_m + 1\n            rest = rest - 1000\n        end\n        quo = math.floor(rest\
    \ / 100)\n        rem = rest % 100\n        num_of_c = quo\n        if rem >=\
    \ 90 then\n            num_of_c = num_of_c - 1\n            num_of_x = 1\n   \
    \         num_of_m = 1\n        elseif rem >= 80 then\n            num_of_c =\
    \ num_of_c - 1\n            num_of_l = 1\n            num_of_x = 1\n        elseif\
    \ rem >= 50 then\n            num_of_d = 1\n            rest = rem - 500\n   \
    \     elseif rem >= 40 then\n            num_of_c = num_of_c - 1\n           \
    \ num_of_x = 1\n            num_of_l = 1\n        elseif rem >= 10 then\n    \
    \        quo = math.floor(rem / 10)\n            rem = rem % 10\n            num_of_x\
    \ = quo\n            if rem >= 9 then\n                num_of_x = num_of_x - 1\n\
    \                num_of_i = 1\n                num_of_c = 1\n            elseif\
    \ rem >= 8 then\n                num_of_x = num_of_x - 1\n                num_of_i\
    \ = 1\n                num_of_v = 1\n            elseif rem >= 5\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpa0j11whe.lua:70: ''then'' expected near ''lu''

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if (number < 1) or (number > 1000) then\n        return nil\n    end\n  \
    \  local roman_numeral = \"\"\n    for i = 1, #values do\n        local n = math.floor(number\
    \ / values[i])\n        number = number % values[i]\n        roman_numeral = roman_numeral\
    \ .. roman_digits[i]:rep(n)\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbqyl8127.lua:16:\
    \ attempt to get length of a nil value (global 'values')\nstack traceback:\n\t\
    /tmp/tmpbqyl8127.lua:16: in local 'candidate'\n\t/tmp/tmpbqyl8127.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(number > 0 and number <= 1000, \"Number out of range: \" .. number)\n\
    \tlocal numeral = \"\"\n\tlocal k, v\n\tfor k, v in ipairs(mini_roman_tbl) do\n\
    \t\twhile number >= v[1] do\n\t\t\tnumeral = numeral .. v[2]\n\t\t\tnumber = number\
    \ - v[1]\n\t\tend\n\tend\n\treturn numeral\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: 'E

    Tests with errors:

    ------------------

    1) test_humaneval

    attempt to index a nil value

    stack traceback:


    Ran 1 tests in 0.000 seconds, 0 successes, 1 error

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if not number or number < 1 or number > 1000 then\n        return nil\n \
    \   end\n    local result = ''\n    local remaining = number\n    while remaining\
    \ > 0 do\n        if remaining >= 1000 then\n            result = result .. 'm'\n\
    \            remaining = remaining - 1000\n        elseif remaining >= 900 then\n\
    \            result = result .. 'cm'\n            remaining = remaining - 900\n\
    \        elseif remaining >= 500 then\n            result = result .. 'd'\n  \
    \          remaining = remaining - 500\n        elseif remaining >= 400 then\n\
    \            result = result .. 'cd'\n            remaining = remaining - 400\n\
    \        elseif remaining >= 100 then\n            result = result .. 'c'\n  \
    \          remaining = remaining - 100\n        elseif remaining >= 90 then\n\
    \            result = result .. 'xc'\n            remaining = remaining - 90\n\
    \        elseif remaining >= 50 then\n            result = result .. 'l'\n   \
    \         remaining = remaining - 50\n        elseif remaining >= 40 then\n  \
    \          result = result .. 'xl'\n            remaining = remaining - 40\n \
    \       elseif remaining >= 10 then\n            result = result .. 'x'\n    \
    \        remaining = remaining - 10\n        elseif remaining >= 9 then\n    \
    \        result = result .. 'ix'\n            remaining = remaining - 9\n    \
    \    elseif remaining >= 5 then\n            result = result .. 'v'\n        \
    \    remaining = remaining - 5\n        elseif remaining >= 4 then\n         \
    \   result = result .. 'iv'\n            remaining = remaining - 4\n        elseif\
    \ remaining >= 1 then\n            result = result .. 'i'\n            remaining\
    \ = remaining - 1\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local i = 1\n  while number > 0 do\n    local a = number\
    \ % 10\n    local sym = digits[i][a + 1]\n    if sym ~= nil then\n      roman\
    \ = sym .. roman\n    else\n      local s = {'m', 'c', 'x', 'i'}\n      for j\
    \ = 1, a do\n        roman = s[i] .. roman\n      end\n    end\n    number = (number\
    \ - a) / 10\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplcprh_rv.lua:16:\
    \ attempt to index a nil value (global 'digits')\nstack traceback:\n\t/tmp/tmplcprh_rv.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmplcprh_rv.lua:34: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local mini_roman_table = {\n    {'i', 'v'},\n    {'x', 'l'},\n    {'c', 'd'},\n\
    \    {'m'}\n  }\n  -- Note: number is set here to the number of digits of the\n\
    \  -- original argument.\n  number = math.ceil(math.log10(number + 1))\n  local\
    \ mini_roman = ''\n  for i = 1, number do\n    local digit = math.floor(num %\
    \ 10)\n    num = math.floor(num / 10)\n    if digit == 0 then\n      -- Nothing\
    \ to do.\n    elseif digit <= 3 then\n      mini_roman = string.rep(mini_roman_table[i][1],\
    \ digit) .. mini_roman\n    elseif digit == 4 then\n      mini_roman = mini_roman_table[i][1]\
    \ .. mini_roman_table[i][2] .. mini_roman\n    elseif digit == 5 then\n      mini_roman\
    \ = mini_roman_table[i][2] .. mini_roman\n    elseif digit <= 8 then\n      mini_roman\
    \ = mini_roman_table[i][2] .. string.rep(mini_roman_table[i][1], digit - 5) ..\
    \ mini_roman\n    else\n      mini_roman = mini_roman_table[i][1] .. mini_roman_table[i\
    \ + 1][1] .. mini_roman\n    end\n  end\n  return mini_roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpz93fohy4.lua:23:\
    \ attempt to perform arithmetic on a nil value (global 'num')\nstack traceback:\n\
    \t/tmp/tmpz93fohy4.lua:23: in local 'candidate'\n\t/tmp/tmpz93fohy4.lua:45: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    return int_to_roman(number):lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3o_j9877.lua:12:\
    \ attempt to call a nil value (global 'int_to_roman')\nstack traceback:\n\t/tmp/tmp3o_j9877.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmp3o_j9877.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local m = {\n    'i',\n    'ii',\n    'iii',\n    'iv',\n    'v',\n    'vi',\n\
    \    'vii',\n    'viii',\n    'ix'\n  }\n  local c = {\n    'x',\n    'xx',\n\
    \    'xxx',\n    'xl',\n    'l',\n    'lx',\n    'lxx',\n    'lxxx',\n    'xc'\n\
    \  }\n  local d = {\n    'c',\n    'cc',\n    'ccc',\n    'cd',\n    'd',\n  \
    \  'dc',\n    'dcc',\n    'dccc',\n    'cm'\n  }\n  local result = {}\n  if number\
    \ > 999 then\n    local n = math.floor(number / 1000)\n    for i = 1, n do\n \
    \     table.insert(result, 'm')\n    end\n    number = number % 1000\n  end\n\
    \  if number > 99 then\n    local n = math.floor(number / 100)\n    for i = 1,\
    \ n do\n      table.insert(result, d[math.random(9)])\n    end\n    number = number\
    \ % 100\n  end\n  if number > 9 then\n    local n = math.floor(number / 10)\n\
    \    for i = 1, n do\n      table.insert(result, c[math.random(9)])\n    end\n\
    \    number = number % 10\n  end\n  if number > 0 then\n    local n = number\n\
    \    for i = 1, n do\n      table.insert(result, m[math.random(9)])\n    end\n\
    \  end\n  return table.concat(result)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj8v56jln.lua:79:\
    \ expected: \"xix\"\nactual: \"xxixviviiiixviiiiviiii\"\nstack traceback:\n\t\
    /tmp/tmpj8v56jln.lua:79: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- convert to mini roman\n\tlocal symbols = {'m', 'cm', 'd', 'cd', 'c', 'xc',\
    \ 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n\tlocal values = {1000, 900, 500, 400,\
    \ 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\t\n\tlocal mini_roman = ''\n\tlocal index\
    \ = 1\n\twhile number > 0 do\n\t\tlocal count = math.floor(number / values[index])\n\
    \t\tnumber = number - (count * values[index])\n\t\tmini_roman = mini_roman ..\
    \ symbols[index]:rep(count)\n\t\tindex = index + 1\n\tend\n\t\n\treturn mini_roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    for i = 1, #romans do\n        local n = number / values[i]\n\
    \        if n >= 1.0 then\n            number = number - values[i] * math.floor(n)\n\
    \            roman = roman .. romans[i]:rep(math.floor(n))\n        end\n    end\n\
    \    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpwsfa0_i4.lua:13:\
    \ attempt to get length of a nil value (global 'romans')\nstack traceback:\n\t\
    /tmp/tmpwsfa0_i4.lua:13: in local 'candidate'\n\t/tmp/tmpwsfa0_i4.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local m = {\n        ['1'] = 'i',\n        ['5'] = 'v',\n        ['10'] =\
    \ 'x',\n        ['50'] = 'l',\n        ['100'] = 'c',\n        ['500'] = 'd',\n\
    \        ['1000'] = 'm'\n    }\n    local str = ''\n    local quotient = number\n\
    \    local digit_i = 0\n    local digit\n    while quotient > 0 do\n        digit\
    \ = math.mod(quotient, 10)\n        digit_i = digit_i + 1\n        if digit ==\
    \ 9 then\n            str = str .. m[1*10^(digit_i-1)] .. m[1*10^digit_i]\n  \
    \      elseif digit == 4 then\n            str = str .. m[1*10^(digit_i-1)] ..\
    \ m[5*10^(digit_i-1)]\n        elseif digit >= 5 then\n            str = str ..\
    \ m[5*10^(digit_i-1)] .. m[1*10^(digit_i-1)]*(digit-5)\n        else\n       \
    \     str = str .. m[1*10^(digit_i-1)]*digit\n        end\n        quotient =\
    \ math.floor(quotient/10)\n    end\n    return str\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdqvcd5k2.lua:26:\
    \ attempt to call a nil value (field 'mod')\nstack traceback:\n\t/tmp/tmpdqvcd5k2.lua:26:\
    \ in local 'candidate'\n\t/tmp/tmpdqvcd5k2.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n    {400,\
    \ 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n\
    \    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'}\n\
    \  }\n  local roman_string = ''\n  local remainder = number\n  for i, v in ipairs(roman)\
    \ do\n    local times, symbol = v[1], v[2]\n    local quotient = remainder //\
    \ times\n    remainder = remainder % times\n    roman_string = roman_string ..\
    \ symbol:rep(quotient)\n  end\n  return roman_string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numeral_map = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500,\
    \ 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n\
    \    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n\
    \    {1, 'i'}\n  }\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp9ug1f0wk.lua:47: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {\n        {1000, 'm'},\n        {900, 'cm'},\n        {500,\
    \ 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n    \
    \    {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_numeral\
    \ = ''\n    while number > 0 do\n        for _, v in ipairs(romans) do\n     \
    \       if number >= v[1] then\n                roman_numeral = roman_numeral\
    \ .. v[2]\n                number = number - v[1]\n                break\n   \
    \         end\n        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'number out of range')\n  local romans\
    \ = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n\
    \    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n\
    \    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'},\n  }\n  local result\
    \ = ''\n  for i = 1, #romans do\n    local arabic, roman = unpack(romans[i])\n\
    \    while number >= arabic do\n      number = number - arabic\n      result =\
    \ result .. roman\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7z5n2t_u.lua:30:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmp7z5n2t_u.lua:30:\
    \ in local 'candidate'\n\t/tmp/tmp7z5n2t_u.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local m = {\n        {'', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii',\
    \ 'ix'},\n        {'', 'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc'},\n\
    \        {'', 'c', 'cc', 'ccc', 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm'},\n     \
    \   {'', 'm', 'mm', 'mmm', 'mv', 'v', 'vm', 'vmm', 'vmmm', 'mx'},\n    }\n   \
    \ local result = ''\n    local d = 0\n    repeat\n        d = d + 1\n        local\
    \ digit = number % 10\n        result = m[d][digit] .. result\n        number\
    \ = (number - digit) / 10\n    until number == 0\n    return result\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvd39vbgz.lua:32:\
    \ expected: \"xix\"\nactual: \"viii\"\nstack traceback:\n\t/tmp/tmpvd39vbgz.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 or number > 1000 then\n        return nil\n    end\n    local\
    \ result = ''\n    if number >= 1000 then\n        result = result .. ('m'):rep(math.floor(number\
    \ / 1000))\n        number = number % 1000\n    end\n    if number >= 900 then\n\
    \        result = result .. 'cm'\n        number = number % 900\n    end\n   \
    \ if number >= 500 then\n        result = result .. 'd'\n        number = number\
    \ % 500\n    end\n    if number >= 400 then\n        result = result .. 'cd'\n\
    \        number = number % 400\n    end\n    if number >= 100 then\n        result\
    \ = result .. ('c'):rep(math.floor(number / 100))\n        number = number % 100\n\
    \    end\n    if number >= 90 then\n        result = result .. 'xc'\n        number\
    \ = number % 90\n    end\n    if number >= 50 then\n        result = result ..\
    \ 'l'\n        number = number % 50\n    end\n    if number >= 40 then\n     \
    \   result = result .. 'xl'\n        number = number % 40\n    end\n    if number\
    \ >= 10 then\n        result = result .. ('x'):rep(math.floor(number / 10))\n\
    \        number = number % 10\n    end\n    if number >= 9 then\n        result\
    \ = result .. 'ix'\n        number = number % 9\n    end\n    if number >= 5 then\n\
    \        result = result .. 'v'\n        number = number % 5\n    end\n    if\
    \ number >= 4 then\n        result = result .. 'iv'\n        number = number %\
    \ 4\n    end\n    if number >= 1 then\n        result = result .. ('i'):rep(number)\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local output = \"\"\n    for n=1,#romans do\n        local d, m = divmod(number,\
    \ r_nums[n])\n        number = d\n        if m > 0 then\n            output =\
    \ output .. romans[n]:rep(m)\n        end\n    end\n    return output\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxhvsq2uc.lua:13:\
    \ attempt to get length of a nil value (global 'romans')\nstack traceback:\n\t\
    /tmp/tmpxhvsq2uc.lua:13: in local 'candidate'\n\t/tmp/tmpxhvsq2uc.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 or number > 1000 then return 'Invalid input.' end\n    local\
    \ result = ''\n    for numeral, integer in pairs(numeral_table) do\n        while\
    \ number >= integer do\n            result = result .. numeral\n            number\
    \ = number - integer\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbithfiro.lua:14:\
    \ bad argument #1 to 'for iterator' (table expected, got nil)\nstack traceback:\n\
    \t/tmp/tmpbithfiro.lua:14: in local 'candidate'\n\t/tmp/tmpbithfiro.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- Handle negative number\n\tif number < 0 then\n\t\treturn string.format('-%s',\
    \ int_to_mini_roman(-number))\n\tend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpwibzi83d.lua:36: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local numeral = \"\"\n    local numeral_table = {\n        {1000, \"m\"},\n\
    \        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n     \
    \   {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"\
    xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n    \
    \    {4, \"iv\"},\n        {1, \"i\"}\n    }\n    for i = 1, #numeral_table do\n\
    \        while number >= numeral_table[i][1] do\n            numeral = numeral\
    \ .. numeral_table[i][2]\n            number = number - numeral_table[i][1]\n\
    \        end\n    end\n    return numeral\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local rom_numerals = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix',\
    \ 'v', 'iv', 'i'}\n  local roman_digits = {1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1}\n  local result = ''\n  local i = 1\n  while number > 0 do\n\
    \    local digit = roman_digits[i]\n    if number >= digit then\n      result\
    \ = result .. rom_numerals[i]\n      number = number - digit\n    else\n     \
    \ i = i + 1\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(number > 0, \"number must be positive\")\n\tassert(number <= 1000, \"\
    number too large\")\n\tlocal int_to_mini_roman_lookup = {\n\t\t[1] = \"i\", [2]\
    \ = \"ii\", [3] = \"iii\", [4] = \"iv\", [5] = \"v\",\n\t\t[6] = \"vi\", [7] =\
    \ \"vii\", [8] = \"viii\", [9] = \"ix\", [10] = \"x\",\n\t\t[20] = \"xx\", [30]\
    \ = \"xxx\", [40] = \"xl\", [50] = \"l\",\n\t\t[60] = \"lx\", [70] = \"lxx\",\
    \ [80] = \"lxxx\", [90] = \"xc\", [100] = \"c\",\n\t\t[200] = \"cc\", [300] =\
    \ \"ccc\", [400] = \"cd\", [500] = \"d\",\n\t\t[600] = \"dc\", [700] = \"dcc\"\
    , [800] = \"dccc\", [900] = \"cm\", [1000] = \"m\"\n\t}\n\tlocal number_string\
    \ = tostring(number)\n\tlocal result = {}\n\tfor i = 1, #number_string do\n\t\t\
    local char = number_string:sub(i, i)\n\t\tif char ~= \"0\" then\n\t\t\tresult[#result\
    \ + 1] = int_to_mini_roman_lookup[tonumber(char) * 10^(#number_string - i)]\n\t\
    \tend\n\tend\n\treturn table.concat(result)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 or number > 1000 then\n    error('number out of range (1-1000)')\n\
    \  end\n  local s = ''\n  local n = number\n  if n >= 1000 then\n    s = s ..\
    \ string.rep('m', math.floor(n / 1000))\n    n = n % 1000\n  end\n  if n >= 900\
    \ then\n    s = s .. 'cm'\n    n = n - 900\n  end\n  if n >= 500 then\n    s =\
    \ s .. 'd'\n    n = n - 500\n  end\n  if n >= 400 then\n    s = s .. 'cd'\n  \
    \  n = n - 400\n  end\n  if n >= 100 then\n    s = s .. string.rep('c', math.floor(n\
    \ / 100))\n    n = n % 100\n  end\n  if n >= 90 then\n    s = s .. 'xc'\n    n\
    \ = n - 90\n  end\n  if n >= 50 then\n    s = s .. 'l'\n    n = n - 50\n  end\n\
    \  if n >= 40 then\n    s = s .. 'xl'\n    n = n - 40\n  end\n  if n >= 10 then\n\
    \    s = s .. string.rep('x', math.floor(n / 10))\n    n = n % 10\n  end\n  if\
    \ n >= 9 then\n    s = s .. 'ix'\n    n = n - 9\n  end\n  if n >= 5 then\n   \
    \ s = s .. 'v'\n    n = n - 5\n  end\n  if n >= 4 then\n    s = s .. 'iv'\n  \
    \  n = n - 4\n  end\n  if n >= 1 then\n    s = s .. string.rep('i', n)\n  end\n\
    \  return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if type(number) ~= \"number\" then\n        error(\"bad argument #1 to 'int_to_mini_roman'\
    \ (number expected, got \" .. type(number) .. \")\")\n    end\n    if number >\
    \ 1000 or number < 1 then\n        error(\"bad argument #1 to 'int_to_mini_roman'\
    \ (expected 1-1000, got \" .. number .. \")\")\n    end\n    if number < 10 then\n\
    \        return convert_numerals[number]\n    end\n    local mag = math.floor(math.log10(number))\n\
    \    local rounding = math.pow(10, mag)\n    local rounded = math.floor(number\
    \ / rounding) * rounding\n    local mini_roman = convert_numerals[rounded]\n \
    \   local rest = number - rounded\n    if rest > 0 then\n        mini_roman =\
    \ mini_roman .. int_to_mini_roman(rest)\n    end\n    return mini_roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqya8yk5r.lua:24:\
    \ attempt to index a nil value (global 'convert_numerals')\nstack traceback:\n\
    \t/tmp/tmpqya8yk5r.lua:24: in local 'candidate'\n\t/tmp/tmpqya8yk5r.lua:35: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = \"\"\n  local num_table = { 1000, 500, 100, 50, 10, 5, 1 }\n\
    \  local num_letter = { \"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"i\" }\n  local\
    \ num_count = 1\n  while number > 0 do\n    if number == 0 then\n      break\n\
    \    end\n    local mult = number / num_table[num_count]\n    if mult >= 1 then\n\
    \      result = result .. num_letter[num_count]\n      number = number - num_table[num_count]\n\
    \    elseif num_count < 7 and (number + num_table[num_count + 1]) / num_table[num_count]\
    \ >= 1 then\n      result = result .. num_letter[num_count + 1] .. num_letter[num_count]\n\
    \      number = number + num_table[num_count + 1] - num_table[num_count]\n   \
    \   num_count = num_count + 1\n    else\n      num_count = num_count + 1\n   \
    \ end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp01ea6zb7.lua:38:\
    \ expected: \"xix\"\nactual: \"xvxiv\"\nstack traceback:\n\t/tmp/tmp01ea6zb7.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 or number > 1000 then\n    return error(\"1 <= num <= 1000\"\
    , 2)\n  end\n  local mini_roman_numerals = {\n    M = 1000, CM = 900, D = 500,\
    \ CD = 400,\n    C = 100, XC = 90, L = 50, XL = 40,\n    X = 10, IX = 9, V = 5,\
    \ IV = 4, I = 1\n  }\n  local mini_roman_numeral_strs = {}\n  for numeral, value\
    \ in pairs(mini_roman_numerals) do\n    local count = math.floor(number / value)\n\
    \    number = number - count * value\n    table.insert(mini_roman_numeral_strs,\
    \ string.rep(numeral, count))\n  end\n  return table.concat(mini_roman_numeral_strs)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2_zqanih.lua:32:\
    \ expected: \"xix\"\nactual: \"XIX\"\nstack traceback:\n\t/tmp/tmp2_zqanih.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {\n        { value = 1000, roman = 'm' },\n        { value\
    \ = 900, roman = 'cm' },\n        { value = 500, roman = 'd' },\n        { value\
    \ = 400, roman = 'cd' },\n        { value = 100, roman = 'c' },\n        { value\
    \ = 90, roman = 'xc' },\n        { value = 50, roman = 'l' },\n        { value\
    \ = 40, roman = 'xl' },\n        { value = 10, roman = 'x' },\n        { value\
    \ = 9, roman = 'ix' },\n        { value = 5, roman = 'v' },\n        { value =\
    \ 4, roman = 'iv' },\n        { value = 1, roman = 'i' },\n    }\n    local num\
    \ = number\n    local result = \"\"\n    for _, rom in ipairs(romans) do\n   \
    \     local div = math.floor(num / rom.value)\n        result = result .. rom.roman:rep(div)\n\
    \        num = num - rom.value * div\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman, digits, roman_digits = '', {}, {['1'] = 'i', ['5'] = 'v', ['10']\
    \ = 'x', ['50'] = 'l', ['100'] = 'c', ['500'] = 'd', ['1000'] = 'm'}\n\tfor digit\
    \ in tostring(number):gmatch('.') do\n\t\tdigits[#digits+1] = digit\n\tend\n\t\
    for i = 1, #digits do\n\t\troman = ('%s%s'):format(roman, ('i'):rep(digits[i]):gsub('i{4,}',\
    \ 'i'..roman_digits[5^i]):gsub('i{3}', roman_digits[5^i]):gsub('i{2}', roman_digits[5^i]):gsub('i',\
    \ roman_digits[5^i]):gsub('v', roman_digits[5^i]))\n\tend\n\treturn roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplylcd_d1.lua:17:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmplylcd_d1.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmplylcd_d1.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \treturn 'x'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3y7frlfq.lua:18:\
    \ expected: \"xix\"\nactual: \"x\"\nstack traceback:\n\t/tmp/tmp3y7frlfq.lua:18:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    return roman.int_to_roman(number):lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpd66jyb69.lua:12:\
    \ attempt to index a nil value (global 'roman')\nstack traceback:\n\t/tmp/tmpd66jyb69.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmpd66jyb69.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 or number > 1000 then\n        return nil\n    end\n    local\
    \ roman = \"\"\n    local num_processed = number\n    local digit_representations\
    \ = {\n        {1000, \"m\"},\n        {500, \"d\"},\n        {100, \"c\"},\n\
    \        {50, \"l\"},\n        {10, \"x\"},\n        {5, \"v\"},\n        {1,\
    \ \"i\"}\n    }\n    for i, digit_repr in ipairs(digit_representations) do\n \
    \       local digit, roman_digit = digit_repr[1], digit_repr[2]\n        local\
    \ quotient = math.floor(num_processed / digit)\n        if quotient >= 1 then\n\
    \            num_processed = num_processed - quotient * digit\n            roman\
    \ = roman .. string.rep(roman_digit, quotient)\n        end\n    end\n    -- rule:\
    \ subtract \"i\" from \"v\" and \"x\"\n    roman = string.gsub(roman, \"iv\",\
    \ \"i\u207B\")\n    roman = string.gsub(roman, \"ix\", \"i\u207B\")\n    -- rule:\
    \ subtract \"x\" from \"l\" and \"c\"\n    roman = string.gsub(roman, \"xl\",\
    \ \"x\u207B\")\n    roman = string.gsub(roman, \"xc\", \"x\u207B\")\n    -- rule:\
    \ subtract \"c\" from \"d\" and \"m\"\n    roman = string.gsub(roman, \"cd\",\
    \ \"c\u207B\")\n    roman = string.gsub(roman, \"cm\", \"c\u207B\")\n    -- rule:\
    \ subtract \"i\" from \"v\" and \"x\"\n    roman = string.gsub(roman, \"i\u207B\
    \", \"\u207B\")\n    roman = string.gsub(roman, \"x\u207B\", \"\u207B\")\n   \
    \ roman = string.gsub(roman, \"c\u207B\", \"\u207B\")\n    return roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnhb3ks2t.lua:53:\
    \ expected: \"xix\"\nactual: \"xviiii\"\nstack traceback:\n\t/tmp/tmpnhb3ks2t.lua:53:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_chars = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n    local result\
    \ = ''\n    local num_magnitude = math.ceil(math.log10(number))\n    local i\n\
    \    for i = num_magnitude, 1, -1 do\n        local place_value = 10^(i - 1)\n\
    \        local digit = math.floor(number / place_value)\n        local digit_string\
    \ = ''\n        if digit == 0 then\n            digit_string = ''\n        elseif\
    \ digit == 4 then\n            digit_string = roman_chars[2 * i - 1] .. roman_chars[2\
    \ * i]\n        elseif digit == 5 then\n            digit_string = roman_chars[2\
    \ * i]\n        elseif digit == 9 then\n            digit_string = roman_chars[2\
    \ * i - 1] .. roman_chars[2 * i + 1]\n        else\n            local j\n    \
    \        for j = 1, digit % 5 do\n                digit_string = digit_string\
    \ .. roman_chars[2 * i - 1]\n            end\n            if digit > 5 then\n\
    \                digit_string = roman_chars[2 * i] .. digit_string\n         \
    \   end\n        end\n        result = result .. digit_string\n        number\
    \ = number - place_value * digit\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplwfc1frt.lua:51:\
    \ expected: \"i\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmplwfc1frt.lua:51:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = {}\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            table.insert(roman, 'm')\n            num = num\
    \ - 1000\n        elseif num >= 900 then\n            table.insert(roman, 'cm')\n\
    \            num = num - 900\n        elseif num >= 500 then\n            table.insert(roman,\
    \ 'd')\n            num = num - 500\n        elseif num >= 400 then\n        \
    \    table.insert(roman, 'cd')\n            num = num - 400\n        elseif num\
    \ >= 100 then\n            table.insert(roman, 'c')\n            num = num - 100\n\
    \        elseif num >= 90 then\n            table.insert(roman, 'xc')\n      \
    \      num = num - 90\n        elseif num >= 50 then\n            table.insert(roman,\
    \ 'l')\n            num = num - 50\n        elseif num >= 40 then\n          \
    \  table.insert(roman, 'xl')\n            num = num - 40\n        elseif num >=\
    \ 10 then\n            table.insert(roman, 'x')\n            num = num - 10\n\
    \        elseif num >= 9 then\n            table.insert(roman, 'ix')\n       \
    \     num = num - 9\n        elseif num >= 5 then\n            table.insert(roman,\
    \ 'v')\n            num = num - 5\n        elseif num >= 4 then\n            table.insert(roman,\
    \ 'iv')\n            num = num - 4\n        elseif num >= 1 then\n           \
    \ table.insert(roman, 'i')\n            num = num - 1\n        end\n    end\n\
    \    return table.concat(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal result = ''\n\t-- 'numerals' is an array of arabic numbers.\n\t-- Each\
    \ arabic number has a corresponding roman numeral.\n\t-- Roman numerals are stored\
    \ in an array so that we can easily\n\t-- replace a sequence of roman numerals\
    \ with a smaller roman numeral.\n\t-- For example, the roman numeral for '40'\
    \ is 'XL',\n\t-- which can be obtained by replacing the 'XX' roman numeral\n\t\
    -- with the 'XL' roman numeral.\n\tlocal numerals = {\n\t\t{ 1, 'i' },\n\t\t{\
    \ 4, 'iv' },\n\t\t{ 5, 'v' },\n\t\t{ 9, 'ix' },\n\t\t{ 10, 'x' },\n\t\t{ 40, 'xl'\
    \ },\n\t\t{ 50, 'l' },\n\t\t{ 90, 'xc' },\n\t\t{ 100, 'c' },\n\t\t{ 400, 'cd'\
    \ },\n\t\t{ 500, 'd' },\n\t\t{ 900, 'cm' },\n\t\t{ 1000, 'm' }\n\t}\n\tlocal i\
    \ = #numerals\n\twhile i > 0 do\n\t\t-- Find the largest arabic number that is\
    \ less than or equal to 'number'.\n\t\t-- Then append its corresponding roman\
    \ numeral to 'result'.\n\t\t-- Each time we do this, 'number' is decremented.\n\
    \t\tif number >= numerals[i][1] then\n\t\t\tresult = result .. numerals[i][2]\n\
    \t\t\tnumber = number - numerals[i][1]\n\t\telse\n\t\t\ti = i - 1\n\t\tend\n\t\
    end\n\treturn result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {\n        { 1, 'i' },\n        { 5, 'v' },\n        { 10,\
    \ 'x' },\n        { 50, 'l' },\n        { 100, 'c' },\n        { 500, 'd' },\n\
    \        { 1000, 'm' }\n    }\n    local result = ''\n    for i = #romans, 1,\
    \ -1 do\n        local value, char = romans[i][1], romans[i][2]\n        local\
    \ remainder = number % value\n        number = (number - remainder) / value\n\
    \        if (number == 4) then\n            result = result .. char .. romans[i\
    \ + 1][2]\n            number = 0\n        elseif (number == 9) then\n       \
    \     result = result .. char .. romans[i + 2][2]\n            number = 0\n  \
    \      else\n            result = result .. char:rep(number)\n        end\n  \
    \  end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkdg4vct4.lua:42:\
    \ expected: \"xix\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpkdg4vct4.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number > 1000 then return \"M\" .. int_to_mini_roman(number - 1000) end\n\
    \  if number > 900 then return \"CM\" .. int_to_mini_roman(number - 900) end\n\
    \  if number > 500 then return \"D\" .. int_to_mini_roman(number - 500) end\n\
    \  if number > 400 then return \"CD\" .. int_to_mini_roman(number - 400) end\n\
    \  if number > 100 then return \"C\" .. int_to_mini_roman(number - 100) end\n\
    \  if number > 90 then return \"XC\" .. int_to_mini_roman(number - 90) end\n \
    \ if number > 50 then return \"L\" .. int_to_mini_roman(number - 50) end\n  if\
    \ number > 40 then return \"XL\" .. int_to_mini_roman(number - 40) end\n  if number\
    \ > 10 then return \"X\" .. int_to_mini_roman(number - 10) end\n  if number >\
    \ 9 then return \"IX\" .. int_to_mini_roman(number - 9) end\n  if number > 5 then\
    \ return \"V\" .. int_to_mini_roman(number - 5) end\n  if number > 4 then return\
    \ \"IV\" .. int_to_mini_roman(number - 4) end\n  if number > 1 then return \"\
    I\" .. int_to_mini_roman(number - 1) end\n  return \"\"\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp4jow72_.lua:31:\
    \ expected: \"xix\"\nactual: \"XVIII\"\nstack traceback:\n\t/tmp/tmpp4jow72_.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 or number > 1000 then\n        error(\"Number must be in range\
    \ [1, 1000].\")\n    end\n    local roman = \"\"\n    local order = { 1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }\n    local digits = { \"m\", \"\
    cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\"\
    , \"i\" }\n    for i = 1, #order do\n        while number >= order[i] do\n   \
    \         roman = roman .. digits[i]\n            number = number - order[i]\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local mini_roman_table = {\n        {'m', 1000},\n\
    \        {'d', 500},\n        {'c', 100},\n        {'l', 50},\n        {'x', 10},\n\
    \        {'v', 5},\n        {'i', 1}\n    }\n    for i, pair in ipairs(mini_roman_table)\
    \ do\n        local letter, value = pair[1], pair[2]\n        if number == value\
    \ then\n            roman = letter\n            break\n        elseif number >\
    \ value then\n            local repeats = math.floor(number / value)\n       \
    \     local subtrahend = value\n            if i > 1 then\n                local\
    \ next_value = mini_roman_table[i - 1][2]\n                if number >= value\
    \ - next_value then\n                    subtrahend = value - next_value\n   \
    \                 roman = mini_roman_table[i - 1][1] .. letter\n             \
    \   end\n            end\n            roman = roman .. string.rep(letter, repeats\
    \ - 1)\n            number = number - repeats * subtrahend\n        end\n    end\n\
    \    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpag9nmgm5.lua:47:\
    \ expected: \"xix\"\nactual: \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"\
    \nstack traceback:\n\t/tmp/tmpag9nmgm5.lua:47: in function 'test_humaneval'\n\n\
    Ran 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1660009780
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n\
    -- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local romans = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n  local digits = {}\n \
    \ local num = number\n  local output = ''\n  for k = 1, 3 do\n    digits[k] =\
    \ num % 10\n    num = math.floor(num / 10)\n  end\n  for k = 3, 1, -1 do\n   \
    \ local digit = digits[k]\n    local flag = true\n    while flag do\n      local\
    \ roman = romans[k * 2 - 1]\n      if digit == 9 then\n        roman = romans[k\
    \ * 2 - 1] .. romans[k * 2 + 1]\n      elseif digit == 4 then\n        roman =\
    \ romans[k * 2 - 1] .. romans[k * 2]\n      elseif digit >= 5 then\n        roman\
    \ = romans[k * 2] .. romans[k * 2 - 1]:rep(digit - 5)\n      else\n        roman\
    \ = romans[k * 2 - 1]:rep(digit)\n      end\n      output = output .. roman\n\
    \      flag = false\n    end\n  end\n  return output\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb_hbk5ta.lua:57:\
    \ expected: \"m\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpb_hbk5ta.lua:57:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1660009780
