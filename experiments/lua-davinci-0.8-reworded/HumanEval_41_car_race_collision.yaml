name: HumanEval_41_car_race_collision
language: lua
prompt: "-- Imagine a road that's a perfectly straight infinitely long line.\n-- n\
  \ cars are driving left to right;  simultaneously, a different set of n cars\n--\
  \ are driving right to left.   The two sets of cars start out being very far from\n\
  -- each other.  All cars move in the same speed.  Two cars are said to collide\n\
  -- when a car that's moving left to right hits a car that's moving right to left.\n\
  -- However, the cars are infinitely sturdy and strong; as a result, they continue\
  \ moving\n-- in their trajectory as if they did not collide.\n-- This function outputs\
  \ the number of such collisions.\nlocal function car_race_collision(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = car_race_collision\n\
  \    lu.assertEquals(candidate(2), 4)\n    lu.assertEquals(candidate(3), 9)\n  \
  \  lu.assertEquals(candidate(4), 16)\n    lu.assertEquals(candidate(8), 64)\n  \
  \  lu.assertEquals(candidate(10), 100)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal collisions = 0\n\tfor x = 1, n do\n\t\tfor y = 1, n do\n\t\t\
    \tif y > x then\n\t\t\t\tcollisions = collisions + 1\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn collisions\nend", "    local colliders = 0\n    for i = 1, n do\n   \
    \     for j = 1, n do\n            colliders = colliders + 1\n        end\n  \
    \  end\n    return colliders\nend", "\tlocal speed = 5 -- constant speed\n\tlocal\
    \ x = 0 -- starting position of 1st set of cars\n\tlocal y = 10^10 -- starting\
    \ position of 2nd set of cars\n\tlocal t = 0 -- time\n\tlocal d = 0 -- distance\
    \ to cover\n\tlocal collision = 0 -- total number of collisions", "  return n*(n-1)/2\n\
    end", "  local r = 1\n  local l = n\n  local rl = 0\n  for i = 1, n do\n    if\
    \ r > l then\n      break\n    end\n    rl = rl + l\n    r = r + 1\n    l = l\
    \ - 1\n  end\n  return rl\nend", "    return (n*(n-1))/2\nend", "\tlocal cars_left\
    \ = {};\n\tlocal cars_right = {};\n\tfor i = 1, n do\n\t\tcars_left[i] = 0;\n\t\
    \tcars_right[i] = 1;\n\tend\n\t\n\tlocal num_collisions = 0;\n\tlocal i = 1;\n\
    \tlocal j = 1;\n\t\n\twhile i <= n or j <= n do\n\t\tif cars_left[i] <= cars_right[j]\
    \ then\n\t\t\tnum_collisions = num_collisions + 1;\n\t\t\ti = i + 1;\n\t\telse\n\
    \t\t\tj = j + 1;\n\t\tend\n\tend\n\t\n\treturn num_collisions;\nend", "    return\
    \ n * (n - 1) / 2\nend", "  assert(n >= 1)\n  local left_to_right = {}\n  local\
    \ right_to_left = {}\n  for i = 1, n do\n    table.insert(left_to_right, math.random())\n\
    \    table.insert(right_to_left, math.random())\n  end\n  table.sort(left_to_right)\n\
    \  table.sort(right_to_left)\n  local i = 1\n  local j = 1\n  local cnt = 0\n\
    \  while i <= n and j <= n do\n    if left_to_right[i] < right_to_left[j] then\n\
    \      cnt = cnt + 1\n      i = i + 1\n    else\n      j = j + 1\n    end\n  end\n\
    \  return cnt\nend", "  -- YOUR CODE HERE\nend", "  local left_to_right = {}\n\
    \  local right_to_left = {}\n  local collisions = 0\n  for i = 1, n do\n    left_to_right[i]\
    \ = 1\n    right_to_left[i] = 1\n  end\n  while true do\n    local first_car =\
    \ nil\n    local second_car = nil\n    for i = 1, n do\n      if left_to_right[i]\
    \ > 0 then\n        first_car = i\n        break\n      end\n    end\n    if first_car\
    \ == nil then\n      break\n    end\n    for i = n, 1, -1 do\n      if right_to_left[i]\
    \ > 0 then\n        second_car = i\n        break\n      end\n    end\n    assert(second_car\
    \ ~= nil)\n    if first_car == second_car then\n      collisions = collisions\
    \ + 1\n      left_to_right[first_car] = 0\n      right_to_left[second_car] = 0\n\
    \    else\n      left_to_right[first_car] = left_to_right[first_car] + 1\n   \
    \   right_to_left[second_car] = right_to_left[second_car] + 1\n    end\n  end\n\
    \  return collisions\nend\nassert(car_race_collision(0) == 0)\nassert(car_race_collision(1)\
    \ == 1)\nassert(car_race_collision(2) == 2)\nassert(car_race_collision(3) == 3)\n\
    assert(car_race_collision(4) == 5)\nassert(car_race_collision(5) == 8)\nassert(car_race_collision(6)\
    \ == 13)\nassert(car_race_collision(7) == 21)\nassert(car_race_collision(8) ==\
    \ 34)\nassert(car_race_collision(9) == 55)\nassert(car_race_collision(10) == 89)\n\
    assert(car_race_collision(11) == 144)\nassert(car_race_collision(12) == 233)\n\
    assert(car_race_collision(13) == 377)\n", "\tlocal heading_right = { }\n\tlocal\
    \ heading_left = { }\n\tfor i = 1, n do\n\t\theading_right[i] = { x = -i }\n\t\
    \theading_left[i] = { x = i }\n\tend\n\t\n\t-- Collisions can only happen at x\
    \ = 0\n\twhile true do\n\t\tlocal changed = false\n\t\t\n\t\tfor i = 1, n do\n\
    \t\t\tif heading_right[i].x == 0 then\n\t\t\t\tprint \"collision\"\n\t\t\t\treturn\n\
    \t\t\tend\n\t\t\tif heading_left[i].x == 0 then\n\t\t\t\tprint \"collision\"\n\
    \t\t\t\treturn\n\t\t\tend\n\t\t\t\n\t\t\tif heading_right[i].x > 0 then\n\t\t\t\
    \theading_right[i].x = heading_right[i].x - 1\n\t\t\t\tchanged = true\n\t\t\t\
    end\n\t\t\tif heading_left[i].x < 0 then\n\t\t\t\theading_left[i].x = heading_left[i].x\
    \ + 1\n\t\t\t\tchanged = true\n\t\t\tend\n\t\tend\n\t\t\n\t\tif not changed then\
    \ break end\n\tend\nend", "  local n = n or 10\n  local cars = {}\n  for i = 1,\
    \ n do\n    local car = {x = 0, y = i * -5}\n    table.insert(cars, car)\n  end\n\
    \  local cars2 = {}\n  for i = 1, n do\n    local car = {x = 100, y = i * -5}\n\
    \    table.insert(cars2, car)\n  end\n  local t = 0\n  local collided = 0\n  while\
    \ true do\n    t = t + 1\n    local c1 = cars[1]\n    local c2 = cars2[1]\n  \
    \  c1.x = c1.x + 1\n    c2.x = c2.x - 1\n    if c1.x >= c2.x then\n      collided\
    \ = collided + 1\n      print('Collision at time ' .. t)\n    end\n    if c1.x\
    \ >= 100 then\n      break\n    end\n  end\n  return collided\nend", "  -- example:\
    \ n = 4\n  local collisions = 0;\n  local car_right_to_left = 0;\n  local car_left_to_right\
    \ = n-1;\n  while car_right_to_left < n do\n    collisions = collisions + car_left_to_right;\n\
    \    car_right_to_left = car_right_to_left + 1;\n    car_left_to_right = car_left_to_right\
    \ - 1;\n  end;\n  return collisions;\nend;", "    -- TODO\nend", "  local num_collisions\
    \ = 0\n  local cars_left = {}\n  local cars_right = {}\n  for i = 1, n do\n  \
    \  cars_left[i] = 1\n    cars_right[i] = 1\n  end\n  local i = 1\n  local j =\
    \ 1\n  while i <= n and j <= n do\n    if cars_left[i] == 1 and cars_right[j]\
    \ == 1 then\n      num_collisions = num_collisions + 1\n      i = i + 1\n    \
    \  j = j + 1\n    elseif cars_left[i] == 1 then\n      i = i + 1\n    elseif cars_right[j]\
    \ == 1 then\n      j = j + 1\n    end\n  end\n  return num_collisions\nend", " \
    \   local start_line = {}\n    local end_line = {}\n    local start_line_len =\
    \ 0\n    local end_line_len = 0\n    local collisions = 0\n    for i = 1, n do\n\
    \        start_line[i] = i\n        end_line[i] = n + i\n        start_line_len\
    \ = start_line_len + 1\n        end_line_len = end_line_len + 1\n    end\n   \
    \ if n == 0 then\n        return 0\n    end\n    for i = 1, n do\n        local\
    \ start_line_car = table.remove(start_line, 1)\n        local end_line_car = table.remove(end_line,\
    \ 1)\n        while end_line_car > start_line_car do\n            table.insert(start_line,\
    \ start_line_car)\n            start_line_car = table.remove(start_line, 1)\n\
    \            collisions = collisions + 1\n        end\n        start_line_len\
    \ = start_line_len - 1\n        end_line_len = end_line_len - 1\n        if start_line_len\
    \ > 0 then\n            table.insert(start_line, start_line_car)\n           \
    \ start_line_len = start_line_len + 1\n        end\n        if end_line_len >\
    \ 0 then\n            table.insert(end_line, end_line_car)\n            end_line_len\
    \ = end_line_len + 1\n        end\n    end\n    return collisions\nend", "  local\
    \ l = {}\n  local r = {}\n  local result = 0\n  for i = 1, n do\n    l[i] = i\n\
    \    r[i] = i\n  end\n  local i = 1\n  local j = 1\n  while i <= n and j <= n\
    \ do\n    if l[i] < r[j] then\n      result = result + 1\n      i = i + 1\n  \
    \  else\n      j = j + 1\n    end\n  end\n  return result\nend", "  return n *\
    \ (n - 1) / 2\nend", "    if n == 0 then\n        return 0\n    end\n    local\
    \ l = {}\n    local r = {}\n    for i = 1, n do\n        local li = math.random(10000)\
    \ * -1\n        table.insert(l, li)\n        local ri = math.random(10000)\n \
    \       table.insert(r, ri)\n    end\n    table.sort(l)\n    table.sort(r)\n \
    \   local prev_r = 0\n    local result = 0\n    for i = 1, n do\n        local\
    \ li = l[i]\n        if li < prev_r then\n            result = result + 1\n  \
    \      end\n        prev_r = r[i]\n    end\n    return result\nend", "    local\
    \ cars = {};\n    local c = 0;\n    local sign = 1;\n    while true do\n     \
    \   local s = #cars;\n        for i = 1, n do\n            cars[s + i] = sign;\n\
    \        end\n        sign = -sign;\n        for i = 1, #cars do\n           \
    \ for j = i + 1, #cars do\n                if cars[i] * cars[j] < 0 then\n   \
    \                 c = c + 1;\n                end\n            end\n        end\n\
    \        if #cars > 10 then\n            return c;\n        end\n    end\nend",
  "  -- TODO: fill in the code\nend", "  local num_collisions = 0\n  for i = 1,n do\n\
    \    for j = 1,n do\n      if i == j then\n        num_collisions = num_collisions\
    \ + 1\n      end\n    end\n  end\n  return num_collisions\nend", "    if n <=\
    \ 1 then\n        return 0\n    end\n    local n_left = n\n    local n_right =\
    \ n\n    local num_collisions = 0\n    local car_id = 0\n    while n_left > 0\
    \ or n_right > 0 do\n        local l_moving_right = car_id % 2 == 0\n        car_id\
    \ = car_id + 1\n        if l_moving_right then\n            n_left = n_left -\
    \ 1\n        else\n            n_right = n_right - 1\n        end\n        if\
    \ l_moving_right and n_right > 0 then\n            num_collisions = num_collisions\
    \ + 1\n        end\n    end\n    return num_collisions\nend", "   -- We are going\
    \ to do a simulation of the race.\n   -- We need to remember the cars going left\
    \ to right and the cars going right to left.\n   -- They are going to start very\
    \ far from each other, so we are going to implement\n   -- these cars as a singly\
    \ linked list that ends with a sentinel object.\n   -- The list of cars going\
    \ left to right will be stored in a local variable\n   -- called l2r (left to\
    \ right).  The list of cars going right to left will be stored\n   -- in a local\
    \ variable called r2l (right to left).\n   -- For each car going left to right,\
    \ we remember the car's place on the road as a coordinate\n   -- in the range\
    \ [0, 1).  This coordinate will be stored in each car's 'x' field.\n   -- For\
    \ each car going right to left, we remember the car's place on the road as a coordinate\n\
    \   -- in the range (0, 1].  This coordinate will be stored in each car's 'x'\
    \ field.\n   -- Each car object will also have a 'next' field, which stores the\
    \ next car in the list.\n   -- We will also need a sentinel object called END,\
    \ which will be the 'next' field of the last\n   -- car in the list.  (The last\
    \ car in the list will be the car that's closest to the opposite\n   -- direction's\
    \ cars.)\n   -- All cars' 'next' field will be nil, except for the last car's\
    \ 'next' field, which will be END.\n   -- All cars will have a 'x' field in the\
    \ range [0, 1).\n   --\n   -- We will do the simulation in discrete steps.  In\
    \ each step, we will move each car in the\n   -- list of cars going left to right\
    \ by a small amount of time, say T.  We will then move each\n   -- car in the\
    \ list of cars going right to left by the same amount of time T.  After we move\n\
    \   -- each car, we will check to see if the cars going left to right and the\
    \ cars going right to left\n   -- collide.  We do this until the cars going left\
    \ to right and the cars going right to left\n   -- are very far from each other.\
    \  (We will define \"very far\" below.)\n   --", "  local left, right = {}, {}\n\
    \  for i = 1, n do\n    table.insert(left, i)\n    table.insert(right, i)\n  end\n\
    \  local collisions = 0\n  for _, l in ipairs(left) do\n    for _, r in ipairs(right)\
    \ do\n      if l == r then\n        collisions = collisions + 1\n      end\n \
    \   end\n  end\n  return collisions\nend", '    local collisions = 0', "  if n\
    \ < 2 then\n    return 0\n  end\n  local coll = 0\n  local ldist = n\n  local\
    \ rdist = 0\n  while ldist > 0 and rdist < n do\n    if ldist == rdist then\n\
    \      coll = coll + 1\n    end\n    ldist = ldist - 1\n    rdist = rdist + 1\n\
    \  end\n  return coll\nend", "    local left_to_right = {}\n    local right_to_left\
    \ = {}\n    for i = 1, n do\n        table.insert(left_to_right, i)\n        table.insert(right_to_left,\
    \ n - i + 1)\n    end\n    for _, ltr in ipairs(left_to_right) do\n        for\
    \ _, rtl in ipairs(right_to_left) do\n            if ltr == rtl then\n       \
    \         return 1\n            end\n        end\n    end\n    return 0\nend",
  "  if n <= 0 then return 0 end\n  local left_to_right = 1\n  local right_to_left\
    \ = 1\n  local count = 0\n  while left_to_right <= n and right_to_left <= n do\n\
    \    if left_to_right == right_to_left then\n      count = count + 1\n      left_to_right\
    \ = left_to_right + 1\n      right_to_left = right_to_left + 1\n    elseif left_to_right\
    \ < right_to_left then\n      left_to_right = left_to_right + 1\n    else\n  \
    \    right_to_left = right_to_left + 1\n    end\n  end\n  return count\nend",
  "    local left_to_right = {} -- cars going left to right\n    local right_to_left\
    \ = {} -- cars going right to left\n    for i = 1, n do\n        left_to_right[i]\
    \ = i\n        right_to_left[i] = n + 1 - i\n    end\n    local cnt = 0\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            if left_to_right[i] == right_to_left[j]\
    \ then\n                cnt = cnt + 1\n            end\n        end\n    end\n\
    \    return cnt\nend", "  local sorted = table_sort(n)\n  local new_table = {}\n\
    \  for i = 1, #sorted do\n    if new_table[sorted[i]] then\n      new_table[sorted[i]]\
    \ = new_table[sorted[i]] + 1\n    else\n      new_table[sorted[i]] = 1\n    end\n\
    \  end\n  local result = 0\n  for k, v in pairs(new_table) do\n    result = result\
    \ + v * (v - 1) / 2\n  end\n  return result\nend", "  local collisions = 0\n \
    \ for i = 1, n do\n    for j = 1, n do\n      if i - j > 0 then\n        collisions\
    \ = collisions + 1\n      end\n    end\n  end\n  return collisions\nend", "  local\
    \ cars = {}\n  for i = 1, n do\n    cars[i] = {x = i - 1, dx = 1}\n  end\n  for\
    \ i = 1, n do\n    cars[n + i] = {x = -i, dx = -1}\n  end\n  local t = 0\n  local\
    \ collisions = 0\n  while true do\n    local min_t = nil\n    local min_cars =\
    \ {}\n    for _, car in ipairs(cars) do\n      if car.x * car.dx < 0 then\n  \
    \      local t1 = -car.x / car.dx\n        if min_t == nil or t1 < min_t then\n\
    \          min_t = t1\n          min_cars = {car}\n        elseif t1 == min_t\
    \ then\n          table.insert(min_cars, car)\n        end\n      end\n    end\n\
    \    if min_t == nil then\n      break\n    end\n    collisions = collisions +\
    \ #min_cars\n    for _, car in ipairs(min_cars) do\n      car.x = car.x + car.dx\
    \ * min_t\n    end\n    t = t + min_t\n  end\n  return collisions\nend", "   \
    \ -- Assume n is positive.\n    -- Assume n is an integer.\n    -- Assume each\
    \ car is at least one meter away from all other cars.\n    -- Assume there are\
    \ no cars standing still.\n    -- Assume all cars move at the same speed.\n  \
    \  -- Assume all cars moving left to right start at exactly the same location.\n\
    \    -- Assume all cars moving right to left start at exactly the same location.\n\
    \    local x = 0\n    local y = 0\n    local count = 0\n    for i = 1, n do\n\
    \        -- x is the distance of the i-th car moving left to right from the start\n\
    \        -- y is the distance of the i-th car moving right to left from the end\n\
    \        -- x + y is the distance between the two cars, so if it's negative, they\n\
    \        -- collide and then they move apart.\n        if x + y < 0 then\n   \
    \         count = count + 1\n        end\n        x = x + 1\n        y = y - 1\n\
    \    end\n    return count\nend", "   -- Find all of the positions in the left-to-right\
    \ direction.\n   local positions_left = {}\n   for i = 1, n do\n      table.insert(positions_left,\
    \ i)\n   end\n   -- Do the same thing for the right-to-left direction.\n   local\
    \ positions_right = {}\n   for i = 1, n do\n      table.insert(positions_right,\
    \ n + i)\n   end\n   -- Now, we just brute-force our way.\n   local num_collisions\
    \ = 0\n   for left = 1, n do\n      for right = 1, n do\n         if positions_left[left]\
    \ == positions_right[right] then\n            num_collisions = num_collisions\
    \ + 1\n         end\n      end\n   end\n   return num_collisions\nend", "  --\
    \  YOUR CODE HERE\nend", "   local a,b,c,d=0,0,0,0\n   a = n\n   while a > 0 do\n\
    \      b = n\n      while b > 0 do\n         c = n\n         while c > 0 do\n\
    \            d = n\n            while d > 0 do\n               a = a - 1\n   \
    \            b = b - 1\n               c = c - 1\n               d = d - 1\n \
    \           end\n         end\n      end\n   end\n   return a + b + c + d\nend",
  "    return n * (n - 1) / 2\nend", "    -- This is my solution.  For this problem,\
    \ an O(n^2) solution is not too bad.\n    local n_left_car = n\n    local n_right_car\
    \ = n\n    local n_collision = 0\n    for i = 1, n_left_car do\n        for j\
    \ = 1, n_right_car do\n            n_collision = n_collision + 1\n        end\n\
    \    end\n    return n_collision\nend", "  local n = n or 1\n  local collisions\
    \ = 0\n  local cars_left_to_right = {}\n  local cars_right_to_left = {}\n  local\
    \ current_time = 0\n  local car_speed = 1\n  local left_to_right_lane = 5\n  local\
    \ right_to_left_lane = 6\n  local road_length = 100", "  local l_to_r_cars = {}\n\
    \  local r_to_l_cars = {}\n  for i = 1, n do\n    l_to_r_cars[i] = i\n    r_to_l_cars[i]\
    \ = n + 1 - i\n  end\n  local collisions = 0\n  local i, j = 1, 1\n  while i <=\
    \ n and j <= n do\n    if l_to_r_cars[i] < r_to_l_cars[j] then\n      collisions\
    \ = collisions + j - 1\n      i = i + 1\n    else\n      j = j + 1\n    end\n\
    \  end\n  return collisions\nend", "    local function car_race_collision_helper(start,finish,\
    \ increment, left_to_right)\n        local num_collisions = 0\n        for i =\
    \ start, finish, increment do\n            for j = start, finish, increment do\n\
    \                if (i ~= j) and (left_to_right ~= (i < j)) then\n           \
    \         num_collisions = num_collisions + 1\n                end\n         \
    \   end\n        end\n        return num_collisions\n    end\n    return car_race_collision_helper(1,\
    \ n, 1, true) + car_race_collision_helper(n, 1, -1, false)\nend", "   local collisions\
    \ = 0\n   local function f(n1, n2)\n      if n1 == 0 or n2 == 0 then\n       \
    \  return 0\n      else\n         return n1 + n2 - 1 + f(n1 - 1, n2 - 1)\n   \
    \   end\n   end\n   return f(n, n)\nend", "    local t = math.sqrt(n)\n    return\
    \ math.floor(t)\nend", "    -- Similar to the counter-clockwise rotation problem,\
    \ we can place the cars\n    -- on a circle, and visualize the right-to-left cars\
    \ as cars moving counter-clockwise\n    -- and the left-to-right cars as cars\
    \ moving clockwise.  The two cars will\n    -- collide when the clockwise car\
    \ overtakes the counter-clockwise car.\n    -- We can use the strategy described\
    \ in the rotation problem to see where\n    -- all the counter-clockwise cars\
    \ will end up after 1 second, and see if any\n    -- of the clockwise cars will\
    \ end up in those spots.\n    -- Similarly, we can see where all the clockwise\
    \ cars will end up after 1 second,\n    -- and see if any of the counter-clockwise\
    \ cars will end up in those spots.\n    -- By doing this, we will have found all\
    \ the pairs of cars that will collide.\n    -- We can just count the number of\
    \ such pairs.\n    local function rotate_ccw(v) return v[1] + v[2] * 1i end\n\
    \    local function rotate_cw(v) return v[1] - v[2] * 1i end\n    local counter_clockwise_cars\
    \ = {}\n    local clockwise_cars = {}\n    for i = 1, n do\n        -- Let the\
    \ counter-clockwise cars have speed i.\n        -- We will let the clockwise cars\
    \ have speed -i.\n        -- This will ensure that two counter-clockwise cars\
    \ will never collide,\n        -- and two clockwise cars will never collide.\n\
    \        table.insert(counter_clockwise_cars, {0, i})\n        table.insert(clockwise_cars,\
    \ {0, -i})\n    end\n    local function find_collisions(cars)\n        local collisions\
    \ = {}\n        for i = 1, #cars do\n            local car_position = rotate_ccw(cars[i])\n\
    \            local rotated_cars = {}\n            for j = 1, #cars do\n      \
    \          table.insert(rotated_cars, rotate_ccw(cars[j]))\n            end\n\
    \            for j = 1, #rotated_cars do\n                if j ~= i and rotated_cars[j]\
    \ == car_position then\n                    table.insert(collisions, {j,", " \
    \   -- Create a variable for the number of collisions, initialized to 0.\n   \
    \ local collisions = 0\n    -- For all integers from 1 to n, inclusively...\n\
    \    for i = 1, n do\n        -- Set a variable `is_collision` to true if i is\
    \ even, or false if i is odd.\n        local is_collision = (i % 2 == 0)\n   \
    \     -- If there is a collision...\n        if is_collision then\n          \
    \  -- Increment the number of collisions by 1.\n            collisions = collisions\
    \ + 1\n        end\n    end\n    -- When the loop terminates, return the number\
    \ of collisions.\n    return collisions\nend", "  local function f(i,j)\n    --if\
    \ i == nil or j == nil then return 0 end\n    if i == 0 or j == 0 then return\
    \ 0 end\n    local r = f(i,j-1) + f(i-1,j) + i - 1\n    --print('f('..i..','..j..')='..r)\n\
    \    return r\n  end\n  return f(n,n)\nend", "    -- use bit-wise `and` to check\
    \ even/odd\n    local sum = 0\n    for i = 1, n do\n        if i % 2 == 1 then\n\
    \            sum = sum + (n - i + 1)\n        end\n    end\n    return sum\nend",
  "    local left_cars = {}\n    local right_cars = {}\n    for i = 1, n do\n    \
    \    left_cars[i] = true\n        right_cars[i] = true\n    end\n    local collision_counter\
    \ = 0\n    local i, j = 1, 1\n    while i <= n and j <= n do\n        if left_cars[i]\
    \ and right_cars[j] then\n            collision_counter = collision_counter +\
    \ 1\n            left_cars[i] = false\n            right_cars[j] = false\n   \
    \     end\n        i = i + 1\n        j = j + 1\n    end\n    return collision_counter\n\
    end", "    -- TODO\n    local passed_left = 0\n    local passed_right = 0\n  \
    \  local collisions = 0\n    for i = 1, n do\n        passed_left = passed_left\
    \ + 1\n        for j = 1, n do\n            if i == j then\n                passed_right\
    \ = passed_right + 1\n            end\n        end\n        collisions = collisions\
    \ + passed_right\n    end\n    return collisions\nend", "    local count = 0\n\
    \    while true do\n        if n == 0 then\n            return count\n       \
    \ end\n        count = count + n - 1\n        n = n - 1\n    end\nend", "  local\
    \ cars = {}\n  local collision = 0\n  for i = 1, n do\n    cars[i] = i\n  end\n\
    \  for i = 1, n do\n    for j = i + 1, n do\n      local x = cars[i]\n      local\
    \ y = cars[j]\n      if (x - y) % (i - j) == 0 then\n        collision = collision\
    \ + 1\n      end\n    end\n  end\n  return collision\nend", "  -- A better solution\
    \ exists for this problem than the below naive solution.\n  -- That is: two cars\
    \ are _guaranteed_ to collide if and only if they start at\n  -- the same position.\
    \  That is, if two cars start at coordinates (10, 10) and\n  -- (-10, -10), then\
    \ they're guaranteed to collide.\n  -- However, if two cars start at (10, -10)\
    \ and (-10, 10), then they're guaranteed\n  -- not to collide (why is this?).\n\
    \  -- These two observations imply that the naive solution is sufficient.\n  local\
    \ car_positions = {}\n  for i = 1, n do\n    car_positions[i] = {i, n + i}\n \
    \ end\n  local collisions = 0\n  for i = 1, n do\n    for j = i + 1, n do\n  \
    \    local left_car = car_positions[i]\n      local right_car = car_positions[j]\n\
    \      if left_car[1] == right_car[2] then\n        collisions = collisions +\
    \ 1\n      end\n    end\n  end\n  return collisions\nend", "   -- TODO\nend",
  "  assert(n>=0 and n==math.floor(n), \"assertion failed: car_race_collision(n):\
    \ n must be a non-negative integer\")\n  if n == 0 then return 0 end\n  if n ==\
    \ 1 then return 0 end\n  return n-1\nend", "   local cars = {};\n   for i = 1,\
    \ n do\n      cars[i] = true;\n   end\n   local number_of_collisions = 0;\n  \
    \ local i = 1;\n   local j = n;\n   while i <= n and j >= 1 do\n      if cars[i]\
    \ and cars[j] then\n         number_of_collisions = number_of_collisions + 1;\n\
    \      end\n      i = i + 1;\n      j = j - 1;\n   end\n   return number_of_collisions;\n\
    end", "    if n <= 0 then\n        return 0\n    end\n    local cars = {}\n  \
    \  local collisions = 0\n    local function add_car(origin, direction)\n     \
    \   local car = {origin=origin, direction=direction}\n        for i=1,n do\n \
    \           if direction == \"left\" then\n                if cars[i].direction\
    \ == \"right\" and cars[i].origin >= origin then\n                    collisions\
    \ = collisions + 1\n                end\n            else\n                if\
    \ cars[i].direction == \"left\" and cars[i].origin <= origin then\n          \
    \          collisions = collisions + 1\n                end\n            end\n\
    \        end\n        table.insert(cars, car)\n    end\n    add_car(math.huge,\
    \ \"left\")\n    add_car(-math.huge, \"right\")\n    for i=2,n do\n        add_car(math.huge,\
    \ \"left\")\n        add_car(-math.huge, \"right\")\n    end\n    return collisions\n\
    end\nassert(car_race_collision(2) == 1)\nassert(car_race_collision(4) == 4)\n\
    assert(car_race_collision(100) == 4950)\nassert(car_race_collision(0) == 0)\n\
    print(\"car_race_collision done\")", "  return n * (n - 1) / 2\nend", "  if n\
    \ < 1 then\n    return 0\n  end\n  return n - 1\nend", "  local left = {}\n  local\
    \ right = {}\n  for i = 1, n do\n    left[i] = true\n    right[i] = true\n  end\n\
    \  local collision = 0\n  while (n ~= 0) do\n    n = n - 1\n    if left[n] and\
    \ right[n] then\n      collision = collision + 1\n    end\n  end\n  return collision\n\
    end", "    local n = n or 10\n    local car_left_to_right = {}\n    local car_right_to_left\
    \ = {}\n    local range = {0, n * 2}\n    for i = 1, n do\n        car_left_to_right[i]\
    \ = {n - i}\n        car_right_to_left[i] = {n + i}\n    end\n    local colls\
    \ = 0\n    while true do\n        local print_table = {}\n        for i = 1, n\
    \ do\n            local car = car_left_to_right[i]\n            car[1] = car[1]\
    \ + 1\n            if car[1] == car_right_to_left[i][1] then\n               \
    \ colls = colls + 1\n            end\n            for j = 1, n do\n          \
    \      print_table[car[1]] = print_table[car[1]] or {}\n                if i ==\
    \ j then\n                    print_table[car[1]][1] = '->'\n                else\n\
    \                    print_table[car[1]][1] = print_table[car[1]][1] or '  '\n\
    \                end\n            end\n        end\n        for i = 1, n do\n\
    \            local car = car_right_to_left[i]\n            car[1] = car[1] - 1\n\
    \            for j = 1, n do\n                print_table[car[1]] = print_table[car[1]]\
    \ or {}\n                if i == j then\n                    print_table[car[1]][2]\
    \ = '<-'\n                else\n                    print_table[car[1]][2] = print_table[car[1]][2]\
    \ or '  '\n                end\n            end\n        end\n        for i =\
    \ range[1], range[2] do\n            if print_table[i] then\n                print(string.format('%3d\
    \ | %s %s', i, print_table[i][1] or '  ', print_table[i][2] or '  '))\n      \
    \      end\n        end\n        range[1] = range[1] - 1\n        range[2] = range[2]\
    \ + 1\n        print", "  if n < 1 then\n    return 0\n  end\n  local left_to_right\
    \ = {}\n  local right_to_left = {}\n  for i = 1, n do\n    table.insert(left_to_right,\
    \ math.random())\n    table.insert(right_to_left, math.random())\n  end\n  table.sort(left_to_right)\n\
    \  table.sort(right_to_left)\n  local collisions = 0\n  local left_index = 1\n\
    \  local right_index = 1\n  while left_index <= n and right_index <= n do\n  \
    \  local left_to_right_value = left_to_right[left_index]\n    local right_to_left_value\
    \ = right_to_left[right_index]\n    if left_to_right_value < right_to_left_value\
    \ then\n      left_index = left_index + 1\n    elseif left_to_right_value > right_to_left_value\
    \ then\n      right_index = right_index + 1\n    else\n      collisions = collisions\
    \ + 1\n      left_index = left_index + 1\n      right_index = right_index + 1\n\
    \    end\n  end\n  return collisions\nend", "  -- We use the Disjoint-Set Data\
    \ Structure to solve this problem.\n  -- For example, suppose we have a total\
    \ of three cars, two moving left to right\n  -- and one moving right to left.\n\
    \  --            ___    ___\n  --         --/   \\--/   \\--\n  --      ---/ \
    \       \\---\n  --   ---/             \\---\n  --  -/                  \\-\n\
    \  --\n  -- Then the road can be viewed as a cycle\n  --   ___    ___\n  -- --/\
    \   \\--/   \\--\n  --  \\      /\n  --   \\    /\n  --    \\  /\n  --     \\\
    /\n  -- If a car moving right to left turns right, it is equivalent to another\
    \ car\n  -- moving left to right making a left turn.\n  -- If a car moving right\
    \ to left turns left, it is equivalent to another car\n  -- moving left to right\
    \ making a right turn.\n  -- Thus if there is n cars moving left to right, we\
    \ can simulate it by having 2n cars\n  -- moving around this cycle.\n  -- For\
    \ the 2n cars, we make the following observations.\n  --\n  -- 1. When a car moves\
    \ to the right, it is making a left turn.\n  -- 2. When a car moves to the left,\
    \ it is making a right turn.\n  -- 3. When a car collides with another car, it\
    \ is equivalent to both cars making a right turn.\n  --\n  -- We can determine\
    \ the number of collision by counting the number of times\n  -- we made a right\
    \ turn.\n  --\n  -- Now, we can map the cars that moves in a cycle to a disjoint-set\
    \ data structure.\n  -- Let's suppose we have a total of 5 cars.\n  --\n  -- \
    \  ___    ___\n  -- --/   \\--/   \\--\n  --  \\      /\n  --   \\    /\n  --\
    \    \\  /\n  --     \\/\n  --\n  -- We will construct the disjoint-set data structure\
    \ as follows:\n  --\n  -- a  b  c  d  e\n  -- |  |  |  |  |\n  -- |  |  |  | \
    \ |\n ", "  local num_collisions = 0\n  local x = { }\n  local y = { }\n  local\
    \ v = { }\n  local u = { }\n  for i = 1, n do\n    x[i] = randi(1, 1000000)\n\
    \    y[i] = x[i] + randi(1, 10000)\n    v[i] = randg(1, 2)\n    u[i] = randg(1,\
    \ 2)\n  end\n  for i = 1, n do\n    local j = i - 1\n    while y[i] > x[j] do\n\
    \      j = j - 1\n    end\n    num_collisions = num_collisions + (i - j - 1)\n\
    \  end\n  for i = 1, n do\n    local j = i + 1\n    while x[i] > y[j] do\n   \
    \   j = j + 1\n    end\n    num_collisions = num_collisions + (j - i - 1)\n  end\n\
    \  return num_collisions\nend", "  return n * (n - 1) / 2\nend", "    -- Corner\
    \ case:  if there's only 1 car on the road, then there's no collision.\n    if\
    \ n == 1 then\n        return 0\n    end", "   -- now consider a list of cars\
    \ that are moving from left to right\n   -- and a list of cars that are moving\
    \ from right to left.\n   -- each car is represented by a pair of values that\
    \ stands for\n   -- the car's initial position and its speed\n   local left_cars\
    \ = {}\n   local right_cars = {}\n   for i = 1, n do\n      local p = math.random(1,\
    \ 10)\n      local q = math.random(1, 10)\n      local s = math.random(1, 10)\n\
    \      table.insert(left_cars, { p, s })\n      table.insert(right_cars, { q,\
    \ s })\n   end\n   -- to find all collisions, sort the cars by their position\n\
    \   -- then scan through the cars, one by one, and compare the car with its\n\
    \   -- predecessor and its successor.\n   -- for each car that collides with another\
    \ car, remove the collided car\n   -- from the list of cars.\n   -- then repeat\
    \ the process.\n   -- in the end, the list of cars is empty.\n   -- the total\
    \ number of times cars were removed from the list is the number\n   -- of collisions.\n\
    \   --\n   -- to sort the lists of cars, we can use built-in table.sort() function.\n\
    \   -- but, first, we have to put a function in place to compare two cars.\n \
    \  -- that function is the below compare_cars() function.\n   -- use the following\
    \ URL to learn more about table.sort():\n   -- https://www.lua.org/manual/5.3/manual.html#pdf-table.sort\n\
    \   local function compare_cars(c1, c2)\n      -- c1 and c2 are pairs of values,\
    \ representing cars.\n      -- c1[1] and c2[1] are the positions of the cars.\n\
    \      -- c1[2] and c2[2] are the speeds of the cars.\n      --\n      -- we want\
    \ to compare two cars by their positions.\n      -- if c1[1] < c2[1], we return\
    \ true.\n      -- if c1[1] > c2[1], we return false.\n      -- if c1[1] == c2[1],\
    \ and c", "  -- TODO: Implement this function\nend", "    -- It is easier to think\
    \ of this as a left-to-right problem.\n    -- It suffices to consider n cars starting\
    \ at coordinates 1, 2, ... n,\n    -- and n cars starting at coordinates -1, -2,\
    \ ... -n.\n    -- The cars in the right-to-left movement will have the same coordinates\n\
    \    -- as the cars that are moving left to right.\n    -- If a car starting at\
    \ coordinate x will collide with another car starting\n    -- at coordinate y\
    \ if and only if x < 0 and y > 0.\n    -- Thus, the cars that will collide are\
    \ the cars that start at coordinate 1, 2, ... n,\n    -- and the cars that start\
    \ at coordinate -1, -2, ... -n.\n    -- There are 2n such cars, and each such\
    \ car can collide with n cars.\n    -- Hence, the number of collisions is the\
    \ number of such cars times the number of\n    -- other cars each can collide\
    \ with.\n    return 2 * n * n\nend", "    return 0;\nend", "    return n*(n-1)/2\n\
    end", "    return n * (n - 1) / 2\nend", "   local coll = 0\n   local i = 1\n\
    \   local j = n\n   while i <= n and j >= 1 do\n      if i == j then\n       \
    \  coll = coll + 1\n      else\n         coll = coll + 2\n      end\n      i =\
    \ i + 1\n      j = j - 1\n   end\n   return coll\nend", "   if n < 2 then\n  \
    \    return 0\n   end\n   local left_to_right = {}\n   local right_to_left = {}\n\
    \   local i\n   for i = 1, n do\n      left_to_right[i] = n + i\n      right_to_left[i]\
    \ = i\n   end\n   local l_pos = 1\n   local r_pos = 1\n   local collision = 0\n\
    \   while true do\n      local l = left_to_right[l_pos]\n      local r = right_to_left[r_pos]\n\
    \      if l == r then\n         collision = collision + 1\n         left_to_right[l_pos]\
    \ = nil\n         right_to_left[r_pos] = nil\n         l_pos = l_pos + 1\n   \
    \      r_pos = r_pos + 1\n         if l_pos > n or r_pos > n then\n          \
    \  break\n         end\n      elseif l < r then\n         left_to_right[l_pos]\
    \ = nil\n         l_pos = l_pos + 1\n         if l_pos > n then\n            break\n\
    \         end\n      else\n         right_to_left[r_pos] = nil\n         r_pos\
    \ = r_pos + 1\n         if r_pos > n then\n            break\n         end\n \
    \     end\n   end\n   return collision\nend", "    local left_to_right = {}\n\
    \    local right_to_left = {}\n    for i = 1, n do\n        left_to_right[i] =\
    \ true\n        right_to_left[i] = true\n    end\n    local collision_count =\
    \ 0\n    while #left_to_right ~= 0 or #right_to_left ~= 0 do\n        for k =\
    \ #left_to_right, 1, -1 do\n            left_to_right[k] = left_to_right[k] +\
    \ 1\n            for j = #right_to_left, 1, -1 do\n                if left_to_right[k]\
    \ == right_to_left[j] then\n                    table.remove(left_to_right, k)\n\
    \                    table.remove(right_to_left, j)\n                    collision_count\
    \ = collision_count + 1\n                    break\n                end\n    \
    \        end\n        end\n        for k = #right_to_left, 1, -1 do\n        \
    \    right_to_left[k] = right_to_left[k] - 1\n            for j = #left_to_right,\
    \ 1, -1 do\n                if left_to_right[j] == right_to_left[k] then\n   \
    \                 table.remove(left_to_right, j)\n                    table.remove(right_to_left,\
    \ k)\n                    collision_count = collision_count + 1\n            \
    \        break\n                end\n            end\n        end\n    end\n \
    \   return collision_count\nend", "    -- compute distance between the two sets\
    \ of cars when they first meet.\n    local a = math.sqrt(n)", "  assert(n > 0)\n\
    \  local collisions = 0\n  local left_to_right_cars = 1\n  local right_to_left_cars\
    \ = 1\n  while left_to_right_cars <= n or right_to_left_cars <= n do\n    if left_to_right_cars\
    \ <= n and right_to_left_cars <= n then\n      -- both sets of cars still have\
    \ elements left\n      if left_to_right_cars == right_to_left_cars then\n    \
    \    collisions = collisions + 1\n        left_to_right_cars = left_to_right_cars\
    \ + 1\n        right_to_left_cars = right_to_left_cars + 1\n      elseif left_to_right_cars\
    \ < right_to_left_cars then\n        left_to_right_cars = left_to_right_cars +\
    \ 1\n      elseif left_to_right_cars > right_to_left_cars then\n        right_to_left_cars\
    \ = right_to_left_cars + 1\n      end\n    elseif left_to_right_cars <= n then\n\
    \      -- only the left-to-right cars still have elements left\n      left_to_right_cars\
    \ = left_to_right_cars + 1\n    elseif right_to_left_cars <= n then\n      --\
    \ only the right-to-left cars still have elements left\n      right_to_left_cars\
    \ = right_to_left_cars + 1\n    end\n  end\n  return collisions\nend\nassert(car_race_collision(1)\
    \ == 1)\nassert(car_race_collision(2) == 3)\nassert(car_race_collision(3) == 6)\n\
    assert(car_race_collision(4) == 10)\nassert(car_race_collision(5) == 15)\nassert(car_race_collision(6)\
    \ == 21)\nassert(car_race_collision(7) == 28)\nassert(car_race_collision(8) ==\
    \ 36)\nassert(car_race_collision(9) == 45)\nassert(car_race_collision(10) == 55)\n\
    assert(car_race_collision(11) == 66", "    if n < 1 then return 0 end\n    local\
    \ car = 1\n    local cnt = 0\n    while car <= n do\n        local ncar = 1\n\
    \        while ncar <= n do\n            if car == ncar then\n               \
    \ ncar = ncar + 1\n            else\n                cnt = cnt + 1\n         \
    \   end\n        end\n        car = car + 1\n    end\n    return cnt\nend", " \
    \   local sum = 0\n    -- The key is the distance from the left end of the road;\
    \ the value is the\n    -- number of cars driving in that direction.\n    local\
    \ cars = {}\n    for i = 1, n do\n        cars[n + 1 - i] = cars[n + 1 - i] or\
    \ 0\n        cars[n + 1 - i] = cars[n + 1 - i] + 1\n        sum = sum + i - 1\n\
    \    end\n    for i = 1, n do\n        cars[i] = cars[i] or 0\n        cars[i]\
    \ = cars[i] + 1\n        sum = sum + i - 1\n    end\n    local collisions = 0\n\
    \    for i = 1, n do\n        collisions = collisions + cars[i] * (cars[i] - 1)\
    \ / 2\n    end\n    return collisions, sum\nend", '  local n1, n2 = n, n', " \
    \   local result = 0\n    local i = 0\n    while i < n do\n        result = result\
    \ + 2 * i\n        i = i + 1\n    end\n    return result\nend", "    local rt\
    \ = 0\n    for i = 1, n do\n        for j = 1, n do\n            if i < j then\n\
    \                rt = rt + 1\n            end\n        end\n    end\n    return\
    \ rt\nend", "  return n * (n - 1) / 2;\nend", "  local collisions = 0\n  for i\
    \ = 1,n-1 do\n    for j = i+1,n do\n      if i + j == n + 1 then\n        collisions\
    \ = collisions + 1\n      end\n    end\n  end\n  return collisions\nend", "  \
    \  local line = Line:new()\n    for i = 1, n do\n        line:add_car('left')\n\
    \        line:add_car('right')\n    end\n    return line:count_collisions()\n\
    end", "    if not n then return 0 end\n    local m = n\n    local r = 0\n    while\
    \ n >= 1 do\n        r = r + m\n        n = n - 1\n        m = m - 1\n    end\n\
    \    return r\nend", "    local n_col = 0\n    for i = 1, n do\n        if math.random(2)\
    \ == 1 then\n            n_col = n_col + 1\n        end\n    end\n    return n_col\n\
    end", "    -- make sure n is an integer\n    n = math.floor(n)\n    -- If n is\
    \ negative, then return 0.\n    if n <= 0 then\n        return 0\n    end\n  \
    \  -- The number of collisions is n * (n - 1) / 2.\n    return n * (n - 1) / 2\n\
    end", "  if type(n) ~= \"number\" then\n    error(\"Argument must be a number\"\
    )\n  end\n  if n < 1 then\n    error(\"Argument must be positive\")\n  end\n \
    \ return n * (n - 1) / 2\nend", "    return n * (n - 1) / 2\nend", "  assert(type(n)\
    \ == \"number\" and n >= 0)\n  if n == 0 then return 0 end\n  -- These are the\
    \ directions of the cars\n  local lr, rl = true, false\n  -- These are the cars\n\
    \  local cars = {\n    {dir = lr, pos = -n},\n    {dir = lr, pos = -n+1},\n  \
    \  {dir = lr, pos = -n+2},\n    {dir = lr, pos = -n+3},\n    {dir = lr, pos =\
    \ -n+4},\n    {dir = lr, pos = -n+5},\n    {dir = lr, pos = -n+6},\n    {dir =\
    \ lr, pos = -n+7},\n    {dir = lr, pos = -n+8},\n    {dir = lr, pos = -n+9},\n\
    \    {dir = rl, pos = n},\n    {dir = rl, pos = n-1},\n    {dir = rl, pos = n-2},\n\
    \    {dir = rl, pos = n-3},\n    {dir = rl, pos = n-4},\n    {dir = rl, pos =\
    \ n-5},\n    {dir = rl, pos = n-6},\n    {dir = rl, pos = n-7},\n    {dir = rl,\
    \ pos = n-8},\n    {dir = rl, pos = n-9},\n  }\n  local count = 0\n  for i = 1,\
    \ #cars-1 do\n    for j = i+1, #cars do\n      if cars[i].dir ~= cars[j].dir and\
    \ cars[i].pos == cars[j].pos then\n        count = count + 1\n      end\n    end\n\
    \  end\n  return count\nend", "  local function recurse(left, right)\n    if left\
    \ == 0 then\n      return 0\n    elseif left == 1 then\n      return right\n \
    \   else\n      return recurse(left-1, right+1) + left-1\n    end\n  end\n  return\
    \ recurse(n, 0)\nend", "    return ((n * (n - 1)) / 2)\nend", "    local collisions\
    \ = 0\n    for leftcar = 1, n do\n        for rightcar = 1, n do\n           \
    \ -- the cars are moving towards each other.\n            -- there will be a collision\
    \ when their distances are the same.\n            if leftcar == n + 1 - rightcar\
    \ then\n                collisions = collisions + 1\n            end\n       \
    \ end\n    end\n    return collisions\nend", "    -- TODO\nend", "   local r =\
    \ 0\n   local l = 0\n   local num_left = 0\n   local num_right = 0\n   while (l\
    \ <= n and r <= n) do\n      if r < l then\n         num_right = num_right + 1\n\
    \         r = r + 1\n      elseif l < r then\n         num_left = num_left + 1\n\
    \         l = l + 1\n      else\n         r = r + 1\n         l = l + 1\n    \
    \  end\n      r = r + num_right\n      l = l + num_left\n   end\n   return (l-1)\
    \ - (r-1)\nend", "  local num = 0\n  local table = {}\n  for i = 1, n do\n   \
    \ table[i] = 0\n  end\n  for i = 1, n do\n    for j = i+1, n do\n      num = num\
    \ + 1\n      table[num] = 1\n    end\n  end\n  return num, table\nend", "  return\
    \ math.floor(n * (n - 1) / 2)\nend", "    -- If n is negative, we have no cars\
    \ (on either side) to move.\n    if n < 0 then\n        return 0\n    end", " \
    \  local left_to_right_cars, right_to_left_cars = {}, {}\n   local ix = 1\n  \
    \ for i = -n, 0 do\n      left_to_right_cars[ix] = i\n      ix = ix + 1\n   end\n\
    \   ix = 1\n   for i = 0, n do\n      right_to_left_cars[ix] = i\n      ix = ix\
    \ + 1\n   end\n   -- function to compare cars\n   local function compare_cars(car1,\
    \ car2)\n      if car1 > car2 then\n         return true\n      else\n       \
    \  return false\n      end\n   end\n   -- sort cars\n   table.sort(left_to_right_cars,\
    \ compare_cars)\n   table.sort(right_to_left_cars, compare_cars)\n   local ix_left_to_right\
    \ = 1\n   local ix_right_to_left = 1\n   local num_collisions = 0\n   while ix_left_to_right\
    \ <= n and ix_right_to_left <= n do\n      local left_to_right_car = left_to_right_cars[ix_left_to_right]\n\
    \      local right_to_left_car = right_to_left_cars[ix_right_to_left]\n      if\
    \ left_to_right_car == right_to_left_car then\n         num_collisions = num_collisions\
    \ + 1\n         ix_left_to_right = ix_left_to_right + 1\n         ix_right_to_left\
    \ = ix_right_to_left + 1\n      elseif left_to_right_car < right_to_left_car then\n\
    \         ix_left_to_right = ix_left_to_right + 1\n      else\n         ix_right_to_left\
    \ = ix_right_to_left + 1\n      end\n   end\n   return num_collisions\nend", " \
    \  return math.floor(n*(n-1)/2)\nend", "   return (n * (n - 1)) / 2\nend", " \
    \  local left_to_right = 0\n   local right_to_left = 0\n   local function cars_collision()\n\
    \      while left_to_right > 0 and right_to_left > 0 do\n         left_to_right,\
    \ right_to_left = left_to_right - 1, right_to_left - 1\n      end\n   end\n  \
    \ while left_to_right < n or right_to_left < n do\n      if left_to_right < n\
    \ then\n         left_to_right = left_to_right + 1\n         cars_collision()\n\
    \      end\n      if right_to_left < n then\n         right_to_left = right_to_left\
    \ + 1\n         cars_collision()\n      end\n   end\n   return n - (left_to_right\
    \ + right_to_left)\nend", "    local left_cars = {}\n    local right_cars = {}\n\
    \    for i = 1, n do\n        left_cars[i] = {i * (1 / n)}\n        right_cars[i]\
    \ = {(i - 1) * (1 / n)}\n    end\n    local collisions = 0\n    while true do\n\
    \        local done = true\n        for i = 1, n do\n            local left_car\
    \ = left_cars[i]\n            local right_car = right_cars[i]\n            if\
    \ left_car[1] + left_car[2] < right_car[1] + right_car[2] then\n             \
    \   collisions = collisions + 1\n                done = false\n            end\n\
    \            left_car[1] = left_car[1] + left_car[2]\n            right_car[1]\
    \ = right_car[1] + right_car[2]\n        end\n        if done then\n         \
    \   break\n        end\n    end\n    return collisions\nend", "  local a, b =\
    \ init(n), init(n)\n  local a_stopped, b_stopped = {}, {}\n  local a_stopped_count,\
    \ b_stopped_count = 0, 0\n  for k = 1, n * 2 do\n    for _, t in ipairs({a, b})\
    \ do\n      local stopped = t[t.pos]\n      if stopped then\n        t[t.pos]\
    \ = nil\n        t[stopped] = nil\n        t.stopped[t.pos] = true\n        t.stopped_count\
    \ = t.stopped_count + 1\n      end\n      t.pos = t.pos + t.dir\n    end\n   \
    \ if a[b.pos] then\n      a[b.pos] = true\n      b[a.pos] = true\n    end\n  end\n\
    \  return b.stopped_count\nend", "    local collisions = 0\n    local left_to_right_cars\
    \ = {}\n    local right_to_left_cars = {}\n    local cars_arrived = {}\n    local\
    \ total_cars = 0\n    local is_right_to_left = false\n    for i = 0, n do\n  \
    \      if math.random() > 0.5 then\n            is_right_to_left = false\n   \
    \     else\n            is_right_to_left = true\n        end\n        total_cars\
    \ = total_cars + 1\n        if is_right_to_left then\n            right_to_left_cars[total_cars]\
    \ = i\n        else\n            left_to_right_cars[total_cars] = i\n        end\n\
    \    end\n    for i = 1, total_cars do\n        if cars_arrived[i] == nil then\n\
    \            for j = i + 1, total_cars do\n                if left_to_right_cars[i]\
    \ ~= nil and right_to_left_cars[j] ~= nil then\n                    if left_to_right_cars[i]\
    \ == right_to_left_cars[j] then\n                        collisions = collisions\
    \ + 1\n                        cars_arrived[i] = true\n                      \
    \  cars_arrived[j] = true\n                    end\n                end\n    \
    \        end\n        end\n    end\n    return collisions\nend", "  -- A given\
    \ car has a left and right component.  Each component is its\n  -- position on\
    \ the left/right side of the imaginary road.  The left component\n  -- starts\
    \ at -1;  the right component starts at 1.  Each component moves at\n  -- speed\
    \ 0.5.  A collision occurs when the left component moves past the\n  -- right\
    \ component.\n  local left = -1\n  local right = 1\n  local steps = 0\n  while\
    \ left < right do\n    left = left + 0.5\n    right = right - 0.5\n    steps =\
    \ steps + 1\n  end\n  -- Now we have a collision.  Let's run more steps until\
    \ the left component\n  -- moves past the right component again.\n  while left\
    \ > right do\n    left = left + 0.5\n    right = right - 0.5\n    steps = steps\
    \ + 1\n  end\n  return steps\nend", '    local l, r = 0, 0', "   local cars_moving_left\
    \  = {};  -- table with keys 1,2,...,n\n   local cars_moving_right = {};  -- table\
    \ with keys 1,2,...,n\n   for i=1,n do\n      cars_moving_left[i]  = i;\n    \
    \  cars_moving_right[i] = i;\n   end\n   local num_collisions = 0;\n   for i=1,n\
    \ do\n      if cars_moving_left[i] > 0 then\n         for j=1,n do\n         \
    \   if cars_moving_right[j] > 0 then\n               if cars_moving_left[i] ==\
    \ cars_moving_right[j] then\n                  num_collisions = num_collisions\
    \ + 1;\n                  cars_moving_left[i] = -1;\n                  cars_moving_right[j]\
    \ = -1;\n               end\n            end\n         end\n      end\n   end\n\
    \   return num_collisions;\nend", "   -- local old_seed = math.randomseed()\n\
    \   local old_seed = 0\n   local seed = 0\n   for seed = 1, n*2 do\n      math.randomseed(seed)\n\
    \      if math.random(1,n*2) <= n then\n         break\n      end\n   end\n  \
    \ math.randomseed(old_seed)\n   local x = math.random(1,n)\n   local y = math.random(1,n)\n\
    \   local collisions = 0\n   while true do\n      if x == y then\n         collisions\
    \ = collisions + 1\n      end\n      x = x + 1\n      y = y - 1\n      if x >\
    \ n and y < 1 then\n         break\n      end\n   end\n   return collisions\n\
    end", "  return n*(n-1)/2\nend", "    local left_to_right = {}\n    local right_to_left\
    \ = {}\n    local i\n    for i = 1, n do\n        left_to_right[i] = i - 1\n \
    \       right_to_left[i] = i - 1\n    end\n    local collisions = 0\n    while\
    \ true do\n        local all_left_to_right_equal = true\n        local all_right_to_left_equal\
    \ = true\n        for i = 1, n do\n            left_to_right[i] = left_to_right[i]\
    \ + 1\n            right_to_left[i] = right_to_left[i] - 1\n            if all_left_to_right_equal\
    \ and left_to_right[i] ~= left_to_right[1] then\n                all_left_to_right_equal\
    \ = false\n            end\n            if all_right_to_left_equal and right_to_left[i]\
    \ ~= right_to_left[1] then\n                all_right_to_left_equal = false\n\
    \            end\n        end\n        if all_left_to_right_equal and all_right_to_left_equal\
    \ then\n            return collisions\n        end\n        collisions = collisions\
    \ + 1\n    end\nend", "   local count = 0\n   for i = 1, n do\n      for j = 1,\
    \ n do\n         if i < j then\n            count = count + 1\n         end\n\
    \      end\n   end\n   return count\nend", "   local car_pos_left = {}\n   local\
    \ car_pos_right = {}\n   local collision_count = 0\n   for i = 1, n do\n     \
    \ car_pos_left[i] = i\n      car_pos_right[i] = n + i\n   end\n   while true do\n\
    \      local i = 1\n      while i <= n do\n         if car_pos_left[i] > car_pos_right[i]\
    \ then\n            car_pos_left[i] = car_pos_left[i] - 1\n            car_pos_right[i]\
    \ = car_pos_right[i] + 1\n            collision_count = collision_count + 1\n\
    \         else\n            i = i + 1\n         end\n      end\n      for i =\
    \ 1, n do\n         car_pos_left[i] = car_pos_left[i] + 1\n         car_pos_right[i]\
    \ = car_pos_right[i] - 1\n      end\n      if car_pos_left[1] >= car_pos_right[1]\
    \ then\n         break\n      end\n   end\n   return collision_count\nend", " \
    \  local num_collisions = 0\n   local left_cars = {}\n   local right_cars = {}\n\
    \   for i = 1, n do\n      left_cars[i] = i\n      right_cars[i] = n + 1 - i\n\
    \   end\n   for i = 1, n do\n      for j = 1, n do\n         if left_cars[i] ==\
    \ right_cars[j] then\n            num_collisions = num_collisions + 1\n      \
    \   end\n      end\n   end\n   return num_collisions\nend", "  local num_collisions\
    \ = 0\n  for i = 1,n do\n    if a[i] ~= 0 then\n      for j = 1,n do\n       \
    \ if a[j] ~= 0 then\n          if (a[i] < b[j]) then\n            if (a[i] + i\
    \ > b[j] - j) then\n              num_collisions = num_collisions + 1\n      \
    \      end\n          else\n            if (a[i] + i < b[j] - j) then\n      \
    \        num_collisions = num_collisions + 1\n            end\n          end\n\
    \        end\n      end\n    end\n  end\n  return num_collisions\nend", "    if\
    \ n < 2 then\n        return 0\n    end\n    -- 2 * n * n - n - n * (n - 1) /\
    \ 2 = n * n - n\n    return n * n - n\nend", "  local left = utils.hashtable()\n\
    \  local right = utils.hashtable()\n  local collisions = 0\n  for i = 1, n do\n\
    \    left[i] = i\n    right[i] = i\n  end\n  local i = 1\n  local j = 1\n  while\
    \ i <= n and j <= n do\n    --print(\"i,j\", i, j)\n    if left[i] == right[j]\
    \ then\n      --print(\"left[i]\", left[i], \"right[j]\", right[j])\n      collisions\
    \ = collisions + 1\n      i = i + 1\n      j = j + 1\n    elseif left[i] < right[j]\
    \ then\n      i = i + 1\n    else\n      j = j + 1\n    end\n  end\n  return collisions\n\
    end", "    return n * (n - 1)\nend", "  return math.pow(n, 2)\nend", "   assert(type(n)\
    \ == \"number\" and n > 0, \"parameter n must be a positive number\")\n   return\
    \ n * (n - 1)\nend", "  if n==0 then return 0 end\n  return (n-1) + car_race_collision(n-1)\n\
    end", "    local c = 0\n    for x = 1, n - 1 do\n        c = c + x\n    end\n\
    \    return c\nend", "    local ncollisions = 0\n    local ncarl, ncarr = n, n",
  "   -- g = left-to-right cars;  h = right-to-left cars.\n   -- driver_id = driver's\
    \ name\n   -- cars_speed = speed of the cars, in meters/second\n   -- cars_location\
    \ = the cars' locations along the road\n   local g = {}\n   local h = {}\n   local\
    \ count = 0\n   for i = 1, n do\n      g[i] = {}\n      g[i].driver_id = \"g\"\
    \ .. i\n      g[i].cars_speed = 50 + math.random(200)\n      g[i].cars_location\
    \ = -50000 - math.random(100000)\n      h[i] = {}\n      h[i].driver_id = \"h\"\
    \ .. i\n      h[i].cars_speed = 50 + math.random(200)\n      h[i].cars_location\
    \ = 50000 + math.random(100000)\n   end\n   -- simulate race\n   for t = 1, 9000\
    \ do\n      for i = 1, n do\n         g[i].cars_location = g[i].cars_location\
    \ + g[i].cars_speed\n         h[i].cars_location = h[i].cars_location - h[i].cars_speed\n\
    \      end\n      for i = 1, n do\n         for j = 1, n do\n            if h[i].cars_location\
    \ <= g[j].cars_location then\n               print(h[i].driver_id .. \" collided\
    \ with \" .. g[j].driver_id)\n               count = count + 1\n            end\n\
    \         end\n      end\n   end\n   return count\nend", "    return 0\nend",
  "  local left_to_right = {}\n  local right_to_left = {}\n  for i = 1, n do\n   \
    \ left_to_right[i] = { start = -i }\n    right_to_left[i] = { start = i }\n  end\n\
    \  for i = 1, n do\n    local car = left_to_right[i]\n    for j = 1, n do\n  \
    \    if car.start + j == right_to_left[j].start then\n        car.collision =\
    \ true\n        right_to_left[j].collision = true\n      end\n    end\n  end\n\
    \  local collision_count = 0\n  for i = 1, n do\n    local car = left_to_right[i]\n\
    \    if car.collision then\n      collision_count = collision_count + 1\n    end\n\
    \  end\n  return collision_count\nend", "    local collision_num = 0\n    local\
    \ cars_l2r = {}\n    local cars_r2l = {}\n    for i = 1, n do\n        cars_l2r[i]\
    \ = i\n        cars_r2l[i] = n + 1 - i\n    end\n    for i = 1, n do\n       \
    \ for j = 1, n do\n            if cars_l2r[i] == cars_r2l[j] then\n          \
    \      collision_num = collision_num + 1\n            end\n        end\n    end\n\
    \    return collision_num\nend", "   local collisions = 0\n   local prev_positions\
    \ = {}\n   local current_positions = {}\n   local right_to_left = {}\n   for i\
    \ = 1, n do\n      current_positions[i] = 0\n      prev_positions[i] = 0\n   \
    \   right_to_left[i] = false\n   end\n   for i = 1, n do\n      current_positions[i]\
    \ = math.random()\n      prev_positions[i] = 0\n      right_to_left[i] = false\n\
    \   end\n   local time = 0\n   while true do\n      -- advance time\n      time\
    \ = time + math.random()", "   local r = 1\n   local l = n*2\n   while n > 0 do\n\
    \      n = n - 1\n      if n % 2 == 0 then\n         r = r + 1\n      else\n \
    \        l = l - 1\n      end\n   end\n   return r-l\nend", "  local collisions\
    \ = 0\n  for i = 1, n do\n    for j = 1, n do\n      collisions = collisions +\
    \ 1\n    end\n  end\n  return collisions\nend", '    local result = 0', "    local\
    \ ret = 0\n    local map = {}\n    for i = 1, n do\n        table.insert(map,\
    \ {x = i})\n    end\n    for i = 1, n do\n        local j = #map\n        while\
    \ j > 0 do\n            if map[j].x == 0 then\n                table.remove(map,\
    \ j)\n            else\n                map[j].x = map[j].x - 1\n            end\n\
    \            j = j - 1\n        end\n        table.insert(map, {x = n})\n    \
    \    local k = 1\n        while k <= #map do\n            if map[k].x == 0 then\n\
    \                ret = ret + 1\n                table.remove(map, k)\n       \
    \     else\n                k = k + 1\n            end\n        end\n    end\n\
    \    return ret\nend", "  local count = 0\n  local tbl = {}\n  for i = 1,n do\n\
    \    tbl[i] = i\n  end\n  for i = 1,n do\n    for j = 1,n do\n      if i == j\
    \ then\n        count = count + 1\n      end\n    end\n  end\n  return count\n\
    end", "    local cars = {}\n    local collisions = 0\n    local function add_car(direction,\
    \ pos)\n        cars[pos] = cars[pos] or {}\n        cars[pos][direction] = true\n\
    \        if cars[pos]['r'] and cars[pos]['l'] then\n            collisions = collisions\
    \ + 1\n        end\n    end\n    for i = 1, n do\n        add_car('l', 0)\n  \
    \      add_car('r', math.huge)\n    end\n    return collisions\nend", "  local\
    \ result = 0\n  for i = 1, n do\n    for j = 1, n do\n      if i < j then\n  \
    \      result = result + 1\n      end\n    end\n  end\n  return result\nend",
  "   -- This is a pretty silly way to do it, but it's meant as an example\n   local\
    \ cars_l2r = {} -- from left to right\n   local cars_r2l = {} -- from right to\
    \ left\n   for i = 1, n do\n      cars_l2r[i] = i\n      cars_r2l[i] = i\n   end\n\
    \   for i = 1, n do\n      for j = 1, n do\n         if cars_l2r[i] == cars_r2l[j]\
    \ then\n            print(\"collision\", cars_l2r[i])\n         end\n      end\n\
    \   end\nend", "  if (n < 2) then\n    return 0\n  end\n  local result = 0\n \
    \ for i = 2, n do\n    result = result + (i - 1)\n  end\n  return result\nend",
  "    print('car_race_collision1:',n)\n    if n == 0 then\n        return 0\n   \
    \ else\n        return 1 + car_race_collision(n-1)\n    end\nend", "    local\
    \ rtos_v, rtos_p, rtos_q, rtos_m, rtos_i, rtos_j\n    local stor_v, stor_p, stor_q,\
    \ stor_m, stor_i, stor_j\n    local sum = 0\n    rtos_p = 0\n    rtos_q = 1\n\
    \    rtos_v = 0\n    rtos_m = 1\n    rtos_i = 1\n    stor_p = 0\n    stor_q =\
    \ 1\n    stor_v = 0\n    stor_m = 1\n    stor_i = 1\n    while rtos_q < n * 2\
    \ do\n        rtos_v = rtos_v + rtos_m\n        rtos_i = rtos_i + 1\n        rtos_j\
    \ = rtos_j + 1\n        if rtos_j >= 2 * rtos_q then\n            rtos_j = rtos_j\
    \ - 2 * rtos_q\n            rtos_p = rtos_p + rtos_q\n            rtos_q = rtos_q\
    \ + rtos_q\n            rtos_m = -rtos_m\n        end\n        stor_v = stor_v\
    \ + stor_m\n        stor_i = stor_i + 1\n        stor_j = stor_j + 1\n       \
    \ if stor_j >= 2 * stor_q then\n            stor_j = stor_j - 2 * stor_q\n   \
    \         stor_p = stor_p + stor_q\n            stor_q = stor_q + stor_q\n   \
    \         stor_m = -stor_m\n        end\n        if rtos_p == stor_p then\n  \
    \          sum = sum + 1\n        end\n    end\n    return sum\nend", "    local\
    \ total_collisions = 0\n    for i = 1, n do\n        for j = 1, n do\n       \
    \     if i == j then\n                total_collisions = total_collisions + 1\n\
    \            end\n        end\n    end\n    return total_collisions\nend", " \
    \ assert(type(n) == \"number\")\n  if n == 0 then return 0 end\n  return (n-1)\
    \ * n / 2 -- math.choose(n, 2)\nend", "    -- the answer is n * (n - 1) / 2\n\
    \    return n * (n - 1) / 2\nend", "  local function f()\n    local sum = 0\n\
    \    for i = 1, n do\n      for j = 1, n do\n        if i == j then sum = sum\
    \ + 1 end\n      end\n    end\n    return sum\n  end\n  return f\nend", "  local\
    \ l = bit.rshift(n, 1)\n  if n % 2 == 0 then\n    return l*(l+1)\n  else\n   \
    \ return l*(l+1) + l + 1\n  end\nend", "  print(\"=== Begin car_race_collision(\"\
    , n, \")...\")\n  return math.floor(2*n / (1+math.sqrt(5)))\nend", "  assert(n\
    \ > 0)\n  local left_to_right = {}\n  local right_to_left = {}\n  for i = 1, n\
    \ do\n    left_to_right[i] = math.random()\n    right_to_left[i] = math.random()\n\
    \  end\n  table.sort(left_to_right)\n  table.sort(right_to_left)\n  local left_to_right_index\
    \ = 1\n  local right_to_left_index = 1\n  local number_of_collisions = 0\n  while\
    \ left_to_right_index <= n and right_to_left_index <= n do\n    if left_to_right[left_to_right_index]\
    \ > right_to_left[right_to_left_index] then\n      left_to_right_index = left_to_right_index\
    \ + 1\n    else\n      number_of_collisions = number_of_collisions + 1\n     \
    \ right_to_left_index = right_to_left_index + 1\n    end\n  end\n  return number_of_collisions\n\
    end", "    local left = {}\n    local right = {}\n    for i = 1, n do\n      \
    \  left[i] = i\n        right[i] = i\n    end\n    local collisions = 0\n    while\
    \ left[1] and right[1] do\n        if left[1] > right[1] then\n            collisions\
    \ = collisions + 1\n        end\n        table.remove(left, 1)\n        table.remove(right,\
    \ 1)\n    end\n    return collisions\nend", "  -- Note: The time complexity is\
    \ O(n^2).  This can be improved to O(n).\n  local count = 0\n  for i = 1, n do\n\
    \    for j = 1, n do\n      if (i - j) % (2 * n) == 0 then\n        count = count\
    \ + 1\n      end\n    end\n  end\n  return count\nend", "    local to_the_right,\
    \ to_the_left = {}, {}\n    for i = 1, n do\n        to_the_right[i] = true\n\
    \        to_the_left[i] = true\n    end\n    local t, cur_right, cur_left = 0,\
    \ 0, 0\n    while true do\n        if cur_right <= cur_left then\n           \
    \ t = t + 1\n            cur_right = t * n\n            cur_left = cur_left +\
    \ 1\n        else\n            cur_left = t * n\n            cur_right = cur_right\
    \ + 1\n        end\n        if cur_right == cur_left then\n            return\
    \ t\n        end\n    end\nend", "    local arr = {}\n    local index = 0\n  \
    \  while index <= n do\n        if index ~= 0 then\n            if arr[index]\
    \ == nil then\n                arr[index] = 1\n            else\n            \
    \    arr[index] = arr[index] + 1\n            end\n        end\n        index\
    \ = index + 1\n    end\n    local sum = 0\n    for i, v in pairs(arr) do\n   \
    \     sum = sum + v\n    end\n    return sum\nend", "   local l={}; local r={};\n\
    \   for i=1,n do\n      l[i]=math.random();\n      r[i]=math.random();\n   end\n\
    \   table.sort(l);\n   table.sort(r);\n   local collisions=0;\n   local i=1;\n\
    \   local j=1;\n   while (i<=n) and (j<=n) do\n      if l[i]<r[j] then\n\t collisions=collisions+1;\n\
    \t i=i+1;\n      else\n\t j=j+1;\n      end\n   end\n   return collisions;\nend",
  "    assert(n >= 0)\n    if n == 0 then\n        return 0\n    end\n    local steps\
    \ = 1\n    local left_cars = 1\n    local right_cars = n - 1\n    while left_cars\
    \ < right_cars do\n        local new_left_cars = left_cars + right_cars\n    \
    \    local new_right_cars = right_cars - left_cars\n        steps = steps + 1\n\
    \        left_cars = new_left_cars\n        right_cars = new_right_cars\n    end\n\
    \    return steps\nend", "  -- C(i, j) = number of collisions in a race of i left-to-right\
    \ cars and j right-to-left cars\n  -- C(0, 0) = 0\n  -- C(i, 0) = 0 for all i\
    \ > 0\n  -- C(0, j) = 0 for all j > 0\n  -- C(i, j) = (i * j) + C(i-1, j) + C(i,\
    \ j-1) - C(i-1, j-1)\n  local C = {}", "  local N=n;\n  local i=0;\n  local j=0;\n\
    \  while N>0 do\n    if i < N then\n      i=i+1;\n    end\n    if j < N then\n\
    \      j=j+1;\n    end\n    if i==j then\n      return N;\n    end\n    N=N-1;\n\
    \  end\n  return 0;\nend", "  if n == 0 then\n    return 0\n  else\n    return\
    \ car_race_collision(n-1) + n-1\n  end\nend", "  return math.floor(n * (n - 1)\
    \ / 2)\nend", "   local x = 0\n   local y = 0\n   local k = 0\n   for i = 1, n\
    \ do\n      if i < n/2 then\n         x = x + 1\n      else\n         x = x -\
    \ 1\n      end\n      if i > n/2 then\n         y = y + 1\n      else\n      \
    \   y = y - 1\n      end\n      if x == y then\n         k = k + 1\n      end\n\
    \   end\n   return k\nend", "    return n*(n-1)/2\nend", "    assert(n>=0 and\
    \ n<=10^9, \"Parameter must be in [0,10^9]\")\n    return math.floor(n/2)\nend",
  "   -- Write your code here\nend", "    local l = {}\n    local r = {}\n    local\
    \ l_size = 0\n    local r_size = 0\n    local collision = 0\n    local input =\
    \ io.read(\"*n\")\n    while (input ~= nil) do\n        if (input > 0) then\n\
    \            l_size = l_size + 1\n            l[l_size] = input\n        else\n\
    \            r_size = r_size + 1\n            r[r_size] = -input\n        end\n\
    \        input = io.read(\"*n\")\n    end\n    local l_index = 1\n    local r_index\
    \ = 1\n    while (l_index <= l_size and r_index <= r_size) do\n        if (l[l_index]\
    \ <= r[r_index]) then\n            collision = collision + r_index - 1\n     \
    \       l_index = l_index + 1\n        else\n            r_index = r_index + 1\n\
    \        end\n    end\n    return collision + (l_size - l_index + 1) * r_size\n\
    end", "    if n == 0 then\n        return 0\n    end\n    if n == 1 then\n   \
    \     return 0\n    end\n    if n == 2 then\n        return 1\n    end\n    return\
    \ n + car_race_collision(n - 1)\nend", "    local count = 0\n    local function\
    \ f(k)\n        if k > n then\n            return\n        end\n        if k >=\
    \ (n/2 + 1) then\n            count = count + 1\n        end\n        f(k + 1)\n\
    \    end\n    f(1)\n    return count\nend", "  local rightToLeft = {}\n  local\
    \ leftToRight = {}\n  local collision = 0\n  -- Initially all cars are moving\
    \ right to left\n  for i = 1, n do\n    rightToLeft[i] = i\n  end\n  -- make all\
    \ cars move left to right\n  for i = 1, n do\n    -- pick a random number from\
    \ 1 to n\n    local from = math.random(1, n)\n    local to = from + 1\n    if\
    \ leftToRight[to] then\n      collision = collision + 1\n    else\n      leftToRight[to]\
    \ = rightToLeft[from]\n      rightToLeft[from] = nil\n    end\n  end\n  return\
    \ collision\nend", "    local n = n\n    local col = 0\n    for i = 1, n do\n\
    \        for j = n, 1, -1 do\n            if i == j then col = col + 1 end\n \
    \       end\n    end\n    return col\nend", "  if n==1 then return 0 end\n  return\
    \ 2*(n-1) + car_race_collision(n-1)\nend", "  return n * (n - 1) / 2\nend", " \
    \ -- two cars moving in the same direction do not collide\n  -- in particular,\
    \ a car moving in one direction does not collide with a car\n  -- moving in the\
    \ opposite direction, so the number of collisions is\n  --   n -1 + n -1 = 2*n\
    \ - 2\n  -- we check this observation by returning the correct expression\n  --\
    \ and using a comment to do the computation of 2*n - 2\n  return 2*n - 2\nend",
  "    -- write your code here\nend", "    -- TODO\n    -- Hint: If you go through\
    \ the cars from least to greatest,\n    --       it is easier to handle collisions.\n\
    \    -- Hint: What is the relationship between the number of cars moving left\
    \ to right\n    --       and the number of cars moving right to left?\nend", " \
    \   local num_collisions = 0\n    local left_car_positions = {}\n    local right_car_positions\
    \ = {}\n    for i = 1, n do\n        left_car_positions[i] = i\n        right_car_positions[i]\
    \ = n + i\n    end\n    while true do\n        local move_left = true\n      \
    \  for i = 1, n do\n            local left_car_position = left_car_positions[i]\n\
    \            local right_car_position = right_car_positions[i]\n            if\
    \ left_car_position > right_car_position then\n                num_collisions\
    \ = num_collisions + 1\n                move_left = false\n                break\n\
    \            end\n        end\n        if move_left then\n            for i =\
    \ 1, n do\n                left_car_positions[i] = left_car_positions[i] + 1\n\
    \                right_car_positions[i] = right_car_positions[i] - 1\n       \
    \     end\n        else\n            for i = 1, n do\n                left_car_positions[i]\
    \ = left_car_positions[i] - 1\n                right_car_positions[i] = right_car_positions[i]\
    \ + 1\n            end\n        end\n        local all_done = true\n        for\
    \ i = 1, n do\n            local left_car_position = left_car_positions[i]\n \
    \           local right_car_position = right_car_positions[i]\n            if\
    \ left_car_position <= right_car_position then\n                all_done = false\n\
    \                break\n            end\n        end\n        if all_done then\n\
    \            break\n        end\n    end\n    return num_collisions\nend", " \
    \   return n * (n - 1) / 2\nend", "    if n <= 0 then\n        return 0\n    end\n\
    \    return n - 1\nend", "    local count = 0\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            if j > i then\n                count = count + 1\n\
    \            end\n        end\n    end\n    return count\nend", "  -- TODO:\n\
    \  return 0\nend", "   return n\nend", "  local count = 0\n  for i = 1, n do\n\
    \    for j = 1, n do\n      if i < j then\n        count = count + 1\n      end\n\
    \    end\n  end\n  return count\nend", "  return (n * (n - 1)) / 2\nend", "  local\
    \ total_collisions = 0\n  local x = 1\n  local y = n+1\n  for i=1,n do\n    local\
    \ collisions = math.abs(i-x) + math.abs(n+i-y)\n    total_collisions = total_collisions\
    \ + collisions\n    x = x + 1\n    y = y - 1\n  end\n  return total_collisions\n\
    end", "    local function merge(left, right)\n        local i, j = 1, 1\n    \
    \    local res = {}\n        while i <= #left and j <= #right do\n           \
    \ if left[i] <= right[j] then\n                res[#res + 1] = left[i]\n     \
    \           i = i + 1\n            else\n                res[#res + 1] = right[j]\n\
    \                j = j + 1\n            end\n        end\n        for k = i, #left\
    \ do\n            res[#res + 1] = left[k]\n        end\n        for k = j, #right\
    \ do\n            res[#res + 1] = right[k]\n        end\n        return res\n\
    \    end", "   local cars = Array(n)\n   local cars_from_right = Array(n)\n  \
    \ local num_collisions = 0\n   for i = 1, n do\n      cars[i] = n-i\n      cars_from_right[i]\
    \ = n-i\n   end\n   for i = 1, n do\n      for j = 1, n do\n         if cars[i]\
    \ == cars_from_right[j] then\n            num_collisions = num_collisions + 1\n\
    \         end\n      end\n   end\n   return num_collisions\nend", "    local collisions\
    \ = 0\n    local right_to_left = { }\n    local left_to_right = { }\n    for i\
    \ = 1, n do\n        right_to_left[i] = i\n        left_to_right[i] = i\n    end\n\
    \    local i = 1\n    local j = 1\n    local moving_to_left = false\n    while\
    \ i <= n and j <= n do\n        if moving_to_left then\n            local x =\
    \ left_to_right[i]\n            if x < right_to_left[j] then\n               \
    \ i = i + 1\n            else\n                collisions = collisions + 1\n \
    \               j = j + 1\n            end\n        else\n            local x\
    \ = right_to_left[j]\n            if x < left_to_right[i] then\n             \
    \   j = j + 1\n            else\n                collisions = collisions + 1\n\
    \                i = i + 1\n            end\n        end\n        moving_to_left\
    \ = not moving_to_left\n    end\n    return collisions\nend", "   return n * (n\
    \ - 1)\nend", "    -- First, generate the two sets of cars.\n    local left_to_right\
    \ = {}\n    local right_to_left = {}\n    for i = 1, n do\n        left_to_right[i]\
    \ = i\n        right_to_left[i] = n + 1 - i\n    end", "    local function cal(n)\n\
    \        local sum = 0\n        for i = 1, n do\n            sum = sum + i\n \
    \       end\n        return sum\n    end\n    return cal(n) * 2\nend", "  local\
    \ mid = math.floor(n/2)\n  if n % 2 == 0 then\n    return car_race_collision(mid)\
    \ + car_race_collision(mid)\n  else\n    return mid + car_race_collision(mid)\n\
    \  end\nend", "  local counter = 0\n  while true do\n    -- advance cars\n   \
    \ -- check for collisions\n    break\n  end\n  return counter\nend", "  -- ???????????????\n\
    end", "   --[[\n   -- algorithm has time complexity O(n^2)\n   local c = 0\n \
    \  for i = 1, n do\n      for j = 1, n do\n         if (i < j) then\n        \
    \    c = c + 1\n         end\n      end\n   end\n   --]]\n   -- algorithm has\
    \ time complexity O(n)\n   -- 1. remove unnecessary computation; we don't need\
    \ to iterate over\n   --    both sets of cars because the cars in one set don't\
    \ collide with\n   --    cars in the same set.\n   -- 2. iterate from n down to\
    \ 1.  For example, when n = 5, the number of\n   --    possible collision pairs\
    \ is 5 + 4 + 3 + 2 + 1 = 15.\n   local c = 0\n   for i = n, 1, -1 do\n      c\
    \ = c + i\n   end\n   return c\nend", "   local cars = {}\n   for i = 1, n do\n\
    \      cars[i] = 1\n   end\n   for i = n+1, 2*n do\n      cars[i] = -1\n   end\n\
    \   local cars_in_place = 0\n   local collisions = 0\n   local i = 1\n   while\
    \ cars_in_place < 2*n do\n      local j = i\n      if cars[i] == 0 then\n    \
    \     j = i + 1\n      end\n      local d = cars[j]\n      cars[j] = 0\n     \
    \ local new_pos = j + d\n      if cars[new_pos] ~= 0 then\n         collisions\
    \ = collisions + 1\n      end\n      cars[new_pos] = d\n      cars_in_place =\
    \ cars_in_place + 1\n      i = i + 1\n   end\n   return collisions\nend", "  \
    \ assert(is_nonnegative_integer(n))\n   local function f(p, q)\n      -- p, q:\
    \ each is a nonnegative integer\n      -- return: nonnegative integer\n      --\
    \   number of collisions at the given positions\n      local dp, dq = p-q, q-p\n\
    \      if dp >= 0 and dq >= 0 then\n         return 0\n      elseif (dp < 0 and\
    \ dq < 0) or (dp >= 0 and dq < 0) then\n         return 1\n      else\n      \
    \   return 2\n      end\n   end", "   local left_to_right = {}\n   local right_to_left\
    \ = {}\n   local collisions = 0\n   local i\n   for i = 1, n do\n      left_to_right[i]\
    \ = true\n      right_to_left[i] = true\n   end\n   while next(left_to_right)\
    \ ~= nil and next(right_to_left) ~= nil do\n      for i, left in pairs(left_to_right)\
    \ do\n         if right_to_left[i] then\n            collisions = collisions +\
    \ 1\n            right_to_left[i] = nil\n         end\n      end\n      for i,\
    \ right in pairs(right_to_left) do\n         if left_to_right[i] then\n      \
    \      collisions = collisions + 1\n            left_to_right[i] = nil\n     \
    \    end\n      end\n   end\n   return collisions\nend", "    local count = 0\n\
    \    local set1 = {}\n    local set2 = {}\n    local pos1 = {}\n    local pos2\
    \ = {}\n    for i = 1, n do\n        table.insert(set1, i)\n        table.insert(set2,\
    \ i)\n        table.insert(pos1, i)\n        table.insert(pos2, i)\n    end\n\
    \    pos1 = table.shuffle(pos1)\n    pos2 = table.shuffle(pos2)\n    for i = 1,\
    \ n do\n        for j = 1, n do\n            if pos1[i] == pos2[j] then\n    \
    \            count = count + 1\n            end\n        end\n    end\n    return\
    \ count\nend", "  local left = {}\n  local right = {}\n  for i = 1, n do\n   \
    \ left[i] = math.random()\n    right[i] = math.random()\n  end\n  table.sort(left)\n\
    \  table.sort(right)\n  local cnt = 0\n  for i = 1, n do\n    for j = 1, n do\n\
    \      if left[i] > right[j] then\n        cnt = cnt + 1\n      end\n    end\n\
    \  end\n  return cnt\nend", "    -- Returns the number of collisions amongst the\
    \ first n cars\n    local function racing_collision(a, b)\n        local left_right\
    \ = {}\n        local right_left = {}\n        for i = 1, #a do\n            local\
    \ a_i = a[i]\n            for j = 1, #b do\n                local b_j = b[j]\n\
    \                if a_i > b_j then\n                    local collision = a_i\
    \ - b_j\n                    left_right[collision] = true\n                else\n\
    \                    local collision = b_j - a_i\n                    right_left[collision]\
    \ = true\n                end\n            end\n        end\n        return #left_right,\
    \ #right_left\n    end", "    -- Both directions are organized into a heap\n \
    \   local left_to_right = MinHeap:new(n)\n    local right_to_left = MinHeap:new(n)",
  "    local collision_count = 0\n    for i = 1, n do\n        for j = n + 1, 2 *\
    \ n do\n            if 2 * n - i + 1 == j then\n                collision_count\
    \ = collision_count + 1\n            end\n        end\n    end\n    return collision_count\n\
    end", "    local moving_left, moving_right = {}, {}\n    for i = 1, n do\n   \
    \     local start = math.random(1, 2)\n        local car = { start = start, position\
    \ = 0 }\n        if start == 1 then\n            moving_left[#moving_left + 1]\
    \ = car\n        else\n            moving_right[#moving_right + 1] = car\n   \
    \     end\n    end\n    local time = 0\n    local n_collisions = 0\n    while\
    \ #moving_left ~= 0 or #moving_right ~= 0 do\n        time = time + 1\n      \
    \  for _, car in ipairs(moving_left) do\n            car.position = car.position\
    \ + 1\n        end\n        for _, car in ipairs(moving_right) do\n          \
    \  car.position = car.position - 1\n        end\n        local i, j = 1, 1\n \
    \       while i <= #moving_left and j <= #moving_right do\n            local left,\
    \ right = moving_left[i], moving_right[j]\n            if left.position == right.position\
    \ then\n                n_collisions = n_collisions + 1\n                table.remove(moving_left,\
    \ i)\n                table.remove(moving_right, j)\n            elseif left.position\
    \ < right.position then\n                i = i + 1\n            else\n       \
    \         j = j + 1\n            end\n        end\n    end\n    return n_collisions\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
