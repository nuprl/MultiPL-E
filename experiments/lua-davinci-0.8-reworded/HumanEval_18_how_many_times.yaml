name: HumanEval_18_how_many_times
language: lua
prompt: "-- Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa',\
  \ 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string,\
  \ substring)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = how_many_times\n\
  \    lu.assertEquals(candidate('', 'x'), 0)\n    lu.assertEquals(candidate('xyxyxyx',\
  \ 'x'), 4)\n    lu.assertEquals(candidate('cacacacac', 'cac'), 4)\n    lu.assertEquals(candidate('john\
  \ doe', 'john'), 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal count = 0\n\tfor str in string:gmatch(substring) do\n\t\tcount\
    \ = count + 1\n\tend\n\treturn count\nend", "    if substring == '' then\n   \
    \     return 0\n    end\n    if string == '' then\n        return 0\n    end\n\
    \    local count = 0\n    while true do\n        local i = string.find(string,\
    \ substring, 1, true)\n        if i == nil then\n            break\n        end\n\
    \        count = count + 1\n        string = string.sub(string, i + #substring)\n\
    \    end\n    return count\nend", "  local count = 0\n  local from = 1\n  local\
    \ to = 0\n  while from do\n    from, to = string.find(string, substring, from)\n\
    \    if from then\n      count = count + 1\n      from = to + 1\n    end\n  end\n\
    \  return count\nend", "  if string == '' or substring == '' then\n    return\
    \ 0\n  end\n  local substring_length = #substring\n  local count = 0\n  while\
    \ #string > 0 do\n    local start, stop = string:find(substring)\n    if start\
    \ == nil then\n      break\n    end\n    count = count + 1\n    string = string:sub(stop\
    \ + 1)\n  end\n  return count\nend", "  return string.gsub(string, substring,\
    \ '')\nend", "    local count = 0\n    local pos = 0\n    while true do\n    \
    \    pos = string:find(substring, pos + 1)\n        if not pos then\n        \
    \    break\n        end\n        count = count + 1\n    end\n    return count\n\
    end", "  local count = 0\n  local found_at = 1\n  local string_length = #string\n\
    \  local substring_length = #substring\n  local last_found_at = 1\n  while found_at\
    \ do\n    found_at = string.find(string, substring, last_found_at)\n    if found_at\
    \ then\n      count = count + 1\n      last_found_at = found_at + substring_length\n\
    \    end\n  end\n  return count\nend", "\tlocal count = 0\n\tlocal from = 1\n\t\
    repeat\n\t\tfrom = string.find(string, substring, from, true)\n\t\tif from ~=\
    \ nil then\n\t\t\tcount = count + 1\n\t\t\tfrom = from + 1\n\t\tend\n\tuntil from\
    \ == nil\n\treturn count\nend", "  local count = 0\n  local from  = 1\n  while\
    \ true do\n    local start, finish = string.find(string, substring, from, true)\n\
    \    if start == nil then\n      break\n    end\n    count = count + 1\n    from\
    \  = finish + 1\n  end\n  return count\nend", "  local times = 0\n  local from\
    \ = 1\n  while from <= #string do\n    local start, finish = string:find(substring,\
    \ from)\n    if start ~= nil then\n      times = times + 1\n      from = finish\
    \ + 1\n    else\n      from = from + 1\n    end\n  end\n  return times\nend",
  "    local times = 0\n    local pos = 0\n    local slen = string.len(string)\n \
    \   local sublen = string.len(substring)\n    while pos <= slen do\n        local\
    \ next_pos = string.find(string, substring, pos)\n        if next_pos then\n \
    \           times = times + 1\n            pos = next_pos + sublen\n        else\n\
    \            break\n        end\n    end\n    return times\nend", "    if string\
    \ == '' or substring == '' then\n        return 0\n    end\n    local n = 0\n\
    \    local from = 1\n    while true do\n        local next_from = string.find(string,\
    \ substring, from, true)\n        if next_from == nil then\n            break\n\
    \        end\n        n = n + 1\n        from = next_from + 1\n    end\n    return\
    \ n\nend", "    return count(string:gmatch(substring))\nend", "    local count\
    \ = 0\n    for _ in string:gmatch(substring) do\n        count = count + 1\n \
    \   end\n    return count\nend", "  local count = 0\n  local pos = 0\n  while\
    \ true do\n    pos = string.find(string, substring, pos + 1)\n    if not pos then\n\
    \      break\n    end\n    count = count + 1\n  end\n  return count\nend", " \
    \   local count = 0\n    local from = 1\n    local to = #substring\n    repeat\n\
    \        local result = string:find(substring, from, true)\n        if result\
    \ then\n            count = count + 1\n            from = result + 1\n       \
    \ end\n    until not result\n    return count\nend", "    local cnt = 0\n    local\
    \ lsub = string.len(substring)\n    if lsub > 0 then\n        local idx = string.find(string,\
    \ substring, 1, true)\n        while idx do\n            cnt = cnt + 1\n     \
    \       idx = string.find(string, substring, idx + lsub, true)\n        end\n\
    \    end\n    return cnt\nend", "    local times = 0\n    for start, stop in string:gmatch(substring)\
    \ do\n        times = times + 1\n    end\n    return times\nend", "  local count\
    \ = 0\n  local substring_length = #substring\n  for i = 1, #string do\n    if\
    \ string:sub(i, i + substring_length - 1) == substring then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "    local count = 0\n    local start\
    \ = 1\n    while true do\n        local pos = string:find(substring, start, true)\n\
    \        if not pos then\n            break\n        end\n        count = count\
    \ + 1\n        start = pos + 1\n    end\n    return count\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
