name: HumanEval_112_reverse_delete
language: lua
prompt: "-- Task\n-- We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n-- then check if the result\
  \ string is palindrome.\n-- A string is called palindrome if it reads the same backward\
  \ as forward.\n-- You should return a table containing the result string and true/false\
  \ for the check.\n-- Example\n-- >>> reverse_delete('abcde', 'ae')\n-- {'bcd', false}\n\
  -- >>> reverse_delete('abcdef', 'b')\n-- {'acdef', false}\n-- >>> reverse_delete('abcdedcba',\
  \ 'ab')\n-- {'cdedc', true}\nlocal function reverse_delete(s, c)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n\
  \    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef',\
  \ 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc',\
  \ true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a',\
  \ 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba',\
  \ true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n\
  \    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma',\
  \ 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tfor i = 1, #c do\n\t\ts = s:gsub(c:sub(i, i), '')\n\tend\n\tlocal\
    \ tmp = s:reverse()\n\treturn {s, s == tmp}\nend", "  local r = ''\n  for i =\
    \ 1, #s do\n    local c = s:sub(i, i)\n    if not c:find(c) then\n      r = r\
    \ .. c\n    end\n  end\n  return {r, r == r:reverse()}\nend", "    -- your code\
    \ here\nend", "  local res = {}\n  for i=1, #s do\n    local char = s:sub(i, i)\n\
    \    if not c:find(char) then\n      table.insert(res, char)\n    end\n  end\n\
    \  local str = table.concat(res)\n  local palindrome = str == str:reverse()\n\
    \  return {str, palindrome}\nend", "  local str, palindrome = {}, {}\n  for i=1,\
    \ string.len(s) do\n    local ch = string.sub(s, i, i)\n    local c1 = string.find(c,\
    \ ch)\n    if not c1 then\n      table.insert(str, ch)\n    end\n  end\n  for\
    \ i=1, string.len(str) do\n    local ch = string.sub(str, i, i)\n    table.insert(palindrome,\
    \ ch)\n  end\n  local rev_str = string.reverse(str)\n  local rev_palindrome =\
    \ string.reverse(palindrome)\n  if rev_str == rev_palindrome then\n    return\
    \ {str, true}\n  else\n    return {str, false}\n  end\nend", "    local result\
    \ = ''\n    for i = 1, #s do\n        local ch = s:sub(i, i)\n        if not c:find(ch)\
    \ then\n            result = result .. ch\n        end\n    end\n    return {result,\
    \ result == result:reverse()}\nend", "  local res = {}\n  for i = 1, #s do\n \
    \   if s:find(s:sub(i, i), 1, true) then\n      table.insert(res, s:sub(i, i))\n\
    \    end\n  end\n  return {table.concat(res), res == table.reverse(res)}\nend",
  "    local t = {}\n    for i = 1, #s do\n        local ch = s:sub(i, i)\n      \
    \  if not c:find(ch) then\n            t[#t + 1] = ch\n        end\n    end\n\
    \    s = table.concat(t)\n    local function is_palindrome(s)\n        local half\
    \ = math.floor(#s / 2)\n        for i = 1, half do\n            if s:sub(i, i)\
    \ ~= s:sub(#s - i + 1, #s - i + 1) then\n                return false\n      \
    \      end\n        end\n        return true\n    end\n    return {s, is_palindrome(s)}\n\
    end", "\tlocal new_s = s:gsub('['..c..']', '')\n\treturn {new_s, new_s:reverse()\
    \ == new_s}\nend", "  for i = 1, #c do\n    s = s:gsub(c:sub(i, i), '')\n  end\n\
    \  return {s, s == s:reverse()}\nend", "    local s2 = s:gsub('['..c..']', '')\n\
    \    return {s2, s2:reverse() == s2}\nend", "    local res = ''\n    for i = 1,\
    \ #s do\n        if not c:find(s:sub(i, i)) then\n            res = res .. s:sub(i,\
    \ i)\n        end\n    end\n    return {res, res == res:reverse()}\nend", "  local\
    \ out = {}\n  local t = {}\n  for i = 1, #s do\n    if string.find(c, s:sub(i,\
    \ i)) then\n      t[i] = 0\n    else\n      t[i] = 1\n    end\n  end\n  for i\
    \ = 1, #s do\n    if t[i] == 1 then\n      table.insert(out, s:sub(i, i))\n  \
    \  end\n  end\n  out = table.concat(out)\n  local reverse_out = string.reverse(out)\n\
    \  local result = {}\n  if out == reverse_out then\n    table.insert(result, out)\n\
    \    table.insert(result, true)\n  else\n    table.insert(result, out)\n    table.insert(result,\
    \ false)\n  end\n  return result\nend", "    -- your code here\nend", "  for i\
    \ = 1, #c do\n    s = s:gsub(c:sub(i, i), '')\n  end\n  local function is_palindrome(s)\n\
    \    local len = #s\n    for i = 1, len / 2 do\n      if s:sub(i, i) ~= s:sub(len\
    \ - i + 1, len - i + 1) then\n        return false\n      end\n    end\n    return\
    \ true\n  end\n  return {s, is_palindrome(s)}\nend", "    local s_clean = {}\n\
    \    for i = 1, #s do\n        local char = s:sub(i, i)\n        if not c:find(char)\
    \ then\n            s_clean[#s_clean + 1] = char\n        end\n    end\n    s_clean\
    \ = table.concat(s_clean)\n    local s_reverse = s_clean:reverse()\n    return\
    \ {s_clean, s_clean == s_reverse}\nend", "    -- your code here\nend", "    --\
    \ your code here\nend", "  return {s:gsub(c, ''), false}\nend", "  -- your code\
    \ here\nend", "    local res = \"\"\n    for i = 1, #s do\n        local match\
    \ = false\n        for j = 1, #c do\n            if s:sub(i, i) == c:sub(j, j)\
    \ then\n                match = true\n                break\n            end\n\
    \        end\n        if not match then\n            res = res .. s:sub(i, i)\n\
    \        end\n    end\n    return {res, res == string.reverse(res)}\nend", " \
    \ return {'', true}\nend", "  -- your code here\nend", "  s = s:gsub('['..c..']',\
    \ '')\n  local is_palindrome = s == s:reverse()\n  return {s, is_palindrome}\n\
    end", "    local t = {}\n    for i = 1, #s do\n        local found = false\n \
    \       for j = 1, #c do\n            if s:sub(i, i) == c:sub(j, j) then\n   \
    \             found = true\n                break\n            end\n        end\n\
    \        if not found then\n            t[#t + 1] = s:sub(i, i)\n        end\n\
    \    end\n    return {table.concat(t), is_palindrome(table.concat(t))}\nend",
  "    for i = 1, string.len(c) do\n        local temp = string.match(s, c:sub(i,\
    \ i))\n        while temp do\n            s = string.gsub(s, temp, '')\n     \
    \       temp = string.match(s, c:sub(i, i))\n        end\n    end\n    local res\
    \ = string.reverse(s)\n    return {s, res == s}\nend", "    local letters = {}\n\
    \    for i = 1, string.len(s) do\n        local letter = string.sub(s, i, i)\n\
    \        local contains = false\n        for j = 1, string.len(c) do\n       \
    \     if string.sub(c, j, j) == letter then\n                contains = true\n\
    \                break\n            end\n        end\n        if not contains\
    \ then\n            table.insert(letters, letter)\n        end\n    end\n    local\
    \ result = {}\n    for _, v in ipairs(letters) do\n        table.insert(result,\
    \ v)\n    end\n    local result_s = table.concat(result)\n    local is_palindrome\
    \ = result_s == string.reverse(result_s)\n    return {result_s, is_palindrome}\n\
    end", "    local result = {}\n    -- traverse each character of s and c,\n   \
    \ -- and if any character of s is equal to any character of c\n    -- then delete\
    \ the character from s,\n    -- and finally add the final character to the result\n\
    \    for i = 1, #s do\n        local is_same = false\n        for j = 1, #c do\n\
    \            if s:sub(i, i) == c:sub(j, j) then\n                is_same = true\n\
    \                break\n            end\n        end\n        if not is_same then\n\
    \            table.insert(result, s:sub(i, i))\n        end\n    end\n    -- join\
    \ all the result characters\n    local final_result = table.concat(result)\n \
    \   local is_palindrome = true\n    -- traverse each character of final result,\n\
    \    -- and if any character of final result\n    -- is not equal to its corresponding\
    \ reverse character,\n    -- then the final result is not palindrome,\n    --\
    \ and break the loop\n    for i = 1, #final_result do\n        if final_result:sub(i,\
    \ i) ~= final_result:sub(#final_result - i + 1, #final_result - i + 1) then\n\
    \            is_palindrome = false\n            break\n        end\n    end\n\
    \    return {final_result, is_palindrome}\nend", "  local t = {}\n  for i = 1,\
    \ string.len(s) do\n    local char = string.sub(s, i, i)\n    if not string.find(c,\
    \ char) then\n      table.insert(t, char)\n    end\n  end\n  return {table.concat(t),\
    \ table.concat(t) == string.reverse(table.concat(t))}\nend", "  -- your code here\n\
    end", end, "    local t = {false}\n    for i = 1, #s do\n        local j = 1\n\
    \        local l = #c\n        while j <= l do\n            if s[i] == c[j] then\n\
    \                s = s:sub(1, i - 1) .. s:sub(i + 1)\n                break\n\
    \            end\n            j = j + 1\n        end\n    end\n    t[1] = s\n\
    \    local i = 1\n    local j = #s\n    while i <= j do\n        if s[i] ~= s[j]\
    \ then\n            return t\n        end\n        i = i + 1\n        j = j -\
    \ 1\n    end\n    t[2] = true\n    return t\nend", "    local s1 = s:gsub('['..c..']',\
    \ '')\n    local s2 = s1:reverse()\n    return {s1, s1 == s2}\nend", "  local\
    \ result = s:gsub('['..c..']', '')\n  local reverse = result:reverse()\n  return\
    \ {result, result == reverse}\nend", "  -- your code here\nend", "    local function\
    \ is_palindrome(str)\n        local i, len = 1, #str\n        while i < len do\n\
    \            if str:sub(i, i) ~= str:sub(len, len) then\n                return\
    \ false\n            end\n            i = i + 1\n            len = len - 1\n \
    \       end\n        return true\n    end", "  -- your code here\nend", "    local\
    \ t = {}\n    for i = 1, #s do\n        t[i] = s:sub(i, i)\n    end\n    for _,\
    \ v in ipairs(t) do\n        if c:find(v) then\n            table.remove(t, _)\n\
    \        end\n    end\n    return {table.concat(t), table.concat(t) == table.concat(reverse(t))}\n\
    end", "  local result = s:gsub('['..c..']', '')\n  return {result, result:reverse()\
    \ == result}\nend", "    local result = {}\n    for i = 1, #s do\n        local\
    \ flag = false\n        for j = 1, #c do\n            if s[i] == c[j] then\n \
    \               flag = true\n                break\n            end\n        end\n\
    \        if not flag then\n            table.insert(result, s[i])\n        end\n\
    \    end\n    local str = table.concat(result)\n    return {str, str == string.reverse(str)}\n\
    end", "    local s_array = {}\n    for char in s:gmatch('.') do\n        s_array[#s_array\
    \ + 1] = char\n    end\n    local c_array = {}\n    for char in c:gmatch('.')\
    \ do\n        c_array[#c_array + 1] = char\n    end\n    for i = 1, #s_array do\n\
    \        for j = 1, #c_array do\n            if s_array[i] == c_array[j] then\n\
    \                table.remove(s_array, i)\n                i = i - 1\n       \
    \         break\n            end\n        end\n    end\n    local result = table.concat(s_array)\n\
    \    local check = true\n    for i = 1, #s_array do\n        if s_array[i] ~=\
    \ s_array[#s_array - i + 1] then\n            check = false\n            break\n\
    \        end\n    end\n    return {result, check}\nend", "    local b = {}\n \
    \   for i = 1, #s do\n        local f = false\n        for j = 1, #c do\n    \
    \        if s:sub(i, i) == c:sub(j, j) then\n                f = true\n      \
    \          break\n            end\n        end\n        if not f then\n      \
    \      b[#b + 1] = s:sub(i, i)\n        end\n    end\n    s = table.concat(b)\n\
    \    local p = true\n    for i = 1, #s / 2 do\n        if s:sub(i, i) ~= s:sub(#s\
    \ - i + 1, #s - i + 1) then\n            p = false\n            break\n      \
    \  end\n    end\n    return {s, p}\nend", "  local t = {}\n  for i = 1, #s do\n\
    \    if c:find(s:sub(i, i)) then\n      t[#t + 1] = s:sub(i, i)\n    end\n  end\n\
    \  for i = 1, #t do\n    s = s:gsub(t[i], '')\n  end\n  return {s, s == s:reverse()}\n\
    end", "    -- ... some code here\nend\nreverse_delete('abcde', 'ae')\nreverse_delete('abcdef',\
    \ 'b')\nreverse_delete('abcdedcba', 'ab')", "\tlocal newstr = ''\n\tfor char in\
    \ s:gmatch(\".\") do\n\t\tif not c:find(char) then\n\t\t\tnewstr = newstr .. char\n\
    \t\tend\n\tend\n\treturn {newstr, newstr == newstr:reverse()}\nend", "    local\
    \ new_string = ''\n    for i = 1, #s do\n        local letter = s:sub(i, i)\n\
    \        if not c:find(letter) then\n            new_string = new_string .. letter\n\
    \        end\n    end\n    local check_string = ''\n    for i = #new_string, 1,\
    \ -1 do\n        local letter = new_string:sub(i, i)\n        check_string = check_string\
    \ .. letter\n    end\n    return {new_string, check_string == new_string}\nend",
  "  local res, flag = s:gsub('['..c..']', ''), true\n  local str_len = res:len()\n\
    \  if str_len % 2 == 0 then\n    for i = 1, str_len/2 do\n      if res:sub(i,\
    \ i) ~= res:sub(str_len-i+1, str_len-i+1) then\n        flag = false\n       \
    \ break\n      end\n    end\n  else\n    for i = 1, math.floor(str_len/2) do\n\
    \      if res:sub(i, i) ~= res:sub(str_len-i+1, str_len-i+1) then\n        flag\
    \ = false\n        break\n      end\n    end\n  end\n  return {res, flag}\nend",
  "  local new_s = ''\n  for i = 1, #s do\n    local char = s:sub(i, i)\n    if not\
    \ c:find(char) then\n      new_s = new_s .. char\n    end\n  end\n  return {new_s,\
    \ new_s == string.reverse(new_s)}\nend", "  return nil\nend", "    local result\
    \ = {}\n    local str = \"\"\n    for i = 1, string.len(s) do\n        local tmp\
    \ = string.sub(s, i, i)\n        if string.find(c, tmp) == nil then\n        \
    \    str = str .. tmp\n        end\n    end\n    result[1] = str\n    if str ==\
    \ string.reverse(str) then\n        result[2] = true\n    else\n        result[2]\
    \ = false\n    end\n    return result\nend", "  local t = {}\n  for i = 1, string.len(s)\
    \ do\n    local letter = string.sub(s, i, i)\n    local is_equal = false\n   \
    \ for j = 1, string.len(c) do\n      if letter == string.sub(c, j, j) then\n \
    \       is_equal = true\n        break\n      end\n    end\n    if not is_equal\
    \ then\n      table.insert(t, letter)\n    end\n  end\n  local s_rev = table.concat(t)\n\
    \  local is_palindrome = s_rev == string.reverse(s_rev)\n  return {s_rev, is_palindrome}\n\
    end", "    -- ...\nend", "\tlocal s, c = s:gsub('['..c..']', ''), { c:match((c:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]',\
    \ '%%%1'))) }\n\treturn { s, (s:gsub('.', function(c)\n\t\tfor _, v in ipairs(c)\
    \ do if v == c then return '' end end\n\tend)) == (s:reverse()) }\nend", "  --\
    \ your code here\nend", "    local t = {}\n    local i = 1\n    while i <= #s\
    \ do\n        if not c:find(s:sub(i, i), 1, true) then\n            t[#t + 1]\
    \ = s:sub(i, i)\n        end\n        i = i + 1\n    end\n    local res = table.concat(t)\n\
    \    local pal = true\n    i = 1\n    while i <= #res / 2 do\n        if res:sub(i,\
    \ i) ~= res:sub(#res - i + 1, #res - i + 1) then\n            pal = false\n  \
    \          break\n        end\n        i = i + 1\n    end\n    return {res, pal}\n\
    end", "  -- TODO: Implement the task\nend", "    local has_c = false\n    local\
    \ res = {}\n    for k, v in ipairs(s) do\n        if c:find(v) == nil then\n \
    \           table.insert(res, v)\n        else\n            has_c = true\n   \
    \     end\n    end\n    return table.concat(res), has_c and table.concat(res)\
    \ ~= table.concat(res, \"\", 1, #res)\nend", "    for i = 1, #c do\n        s\
    \ = s:gsub(c:sub(i, i), '')\n    end\n    return {s, s == s:reverse()}\nend",
  "  local t = {false}\n  local reverse_string\n  local result_string\n  local s_table\
    \ = {}\n  local c_table = {}\n  for k in string.gmatch(s, \"%S\") do\n    table.insert(s_table,\
    \ k)\n  end\n  for k in string.gmatch(c, \"%S\") do\n    table.insert(c_table,\
    \ k)\n  end\n  for k in pairs(s_table) do\n    for i in pairs(c_table) do\n  \
    \    if s_table[k] == c_table[i] then\n        table.remove(s_table, k)\n    \
    \  end\n    end\n  end\n  for i = 1, math.floor(#s_table / 2) do\n    reverse_string\
    \ = s_table[i]\n    s_table[i] = s_table[#s_table - i + 1]\n    s_table[#s_table\
    \ - i + 1] = reverse_string\n  end\n  result_string = table.concat(s_table)\n\
    \  if result_string == s then\n    t[1] = true\n  end\n  table.insert(t, 1, result_string)\n\
    \  return t\nend", "    local str = {}\n    for i = 1, #s do\n        if not c:find(s:sub(i,\
    \ i)) then\n            table.insert(str, s:sub(i, i))\n        end\n    end\n\
    \    local newStr = table.concat(str)\n    local palindrome = true\n    for i\
    \ = 1, #newStr / 2 do\n        if newStr:sub(i, i) ~= newStr:sub(#newStr - i +\
    \ 1, #newStr - i + 1) then\n            palindrome = false\n            break\n\
    \        end\n    end\n    return {newStr, palindrome}\nend", "  -- your code\
    \ here\nend", "    return {string.gsub(s, \"[\" .. c .. \"]\", \"\"), string.gsub(s,\
    \ \"[\" .. c .. \"]\", \"\") == string.reverse(string.gsub(s, \"[\" .. c .. \"\
    ]\", \"\"))}\nend", "    local t = {}\n    for i = 1, string.len(s) do\n     \
    \   if not string.find(c, string.sub(s, i, i)) then\n            table.insert(t,\
    \ string.sub(s, i, i))\n        end\n    end\n    return {table.concat(t), t[1]\
    \ == t[#t]}\nend", "    -- body\nend", "    local a, b = {}, {}\n    local t =\
    \ {}\n    for i = 1, #s do\n        if string.find(c, s:sub(i, i)) then\n    \
    \        a[#a + 1] = s:sub(i, i)\n        else\n            b[#b + 1] = s:sub(i,\
    \ i)\n        end\n    end\n    for i = 1, #b do\n        t[#t + 1] = b[i]\n \
    \   end\n    for i = #a, 1, -1 do\n        t[#t + 1] = a[i]\n    end\n    local\
    \ result = table.concat(t)\n    local t = {}\n    local rev = string.reverse(result)\n\
    \    if result == rev then\n        t[1] = result\n        t[2] = true\n    else\n\
    \        t[1] = result\n        t[2] = false\n    end\n    return t\nend", " \
    \   local t = {}\n    for i = 1, #s do\n        local letter = s:sub(i, i)\n \
    \       if not c:find(letter) then\n            table.insert(t, letter)\n    \
    \    end\n    end\n    s = table.concat(t)\n    return {s, s == s:reverse()}\n\
    end", "    return {string.gsub(s, c, ''), string.reverse(string.gsub(s, c, ''))\
    \ == string.gsub(s, c, '')}\nend", "    local t = {false}\n    local r = ''\n\
    \    for i = 1, #s do\n        local found = false\n        for j = 1, #c do\n\
    \            if c:sub(j, j) == s:sub(i, i) then\n                found = true\n\
    \                break\n            end\n        end\n        if not found then\n\
    \            r = r .. s:sub(i, i)\n        end\n    end\n    t[1] = r\n    local\
    \ len = #r\n    local flag = true\n    for i = 1, len/2 do\n        if r:sub(i,\
    \ i) ~= r:sub(len - i + 1, len - i + 1) then\n            flag = false\n     \
    \       break\n        end\n    end\n    t[2] = flag\n    return t\nend", "  \
    \  if type(s) ~= 'string' or type(c) ~= 'string' then\n        return\n    end\n\
    \    local new_s = ''\n    for i = 1, #s do\n        local char = s:sub(i, i)\n\
    \        if not c:find(char) then\n            new_s = new_s .. char\n       \
    \ end\n    end\n    local s_reversed = ''\n    for i = #new_s, 1, -1 do\n    \
    \    s_reversed = s_reversed .. new_s:sub(i, i)\n    end\n    return {new_s, new_s\
    \ == s_reversed}\nend", "    local set = {}\n    for i = 1, #c do\n        set[c:sub(i,\
    \ i)] = true\n    end\n    local t = {}\n    for i = 1, #s do\n        if not\
    \ set[s:sub(i, i)] then\n            t[#t + 1] = s:sub(i, i)\n        end\n  \
    \  end\n    s = table.concat(t)\n    return {s, s == s:reverse()}\nend", "   \
    \ for i = 1, #c do\n        s = s:gsub(c:sub(i, i), '')\n    end\n    local reverse\
    \ = string.reverse(s)\n    return {s, s == reverse}\nend", "  s = s:gsub('['..c..']',\
    \ '')\n  return {s, s == s:reverse()}\nend", "    -- your code here\nend", " \
    \   local result = {}\n    result[1] = s:gsub('['..c..']', '')\n    result[2]\
    \ = result[1] == result[1]:reverse()\n    return result\nend", "\t-- your code\
    \ here\nend", "    -- your code here\nend", "    -- your code here\nend", "  return\
    \ {string.gsub(s, c, ''), string.gsub(s, c, '') == string.reverse(string.gsub(s,\
    \ c, ''))}\nend", "\t-- body\nend", "    local chars = {}\n    for c in c:gmatch\"\
    .\" do\n        chars[c] = true\n    end\n    local result = {}\n    for c in\
    \ s:gmatch\".\" do\n        if not chars[c] then\n            table.insert(result,\
    \ c)\n        end\n    end\n    local result = table.concat(result)\n    return\
    \ { result, result == result:reverse() }\nend", "    local t = {}\n    local res\
    \ = {}\n    for i = 1, #s do\n        t[s:sub(i, i)] = true\n    end\n    for\
    \ i = 1, #c do\n        t[c:sub(i, i)] = nil\n    end\n    for k, _ in pairs(t)\
    \ do\n        res[#res + 1] = k\n    end\n    local str = table.concat(res)\n\
    \    return {str, str == str:reverse()}\nend", "  for i=1,#c do\n    s = s:gsub(c:sub(i,i),'')\n\
    \  end\n  return {s, s:reverse() == s}\nend", "  -- your code here\nend", "  local\
    \ str = s:gsub(c, '')\n  return {str, str == str:reverse()}\nend", "  s = s:gsub(\"\
    [\"..c..\"]\", \"\")\n  local res = true\n  for i = 1, #s / 2 do\n    if s:sub(i,\
    \ i) ~= s:sub(#s - i + 1, #s - i + 1) then\n      res = false\n      break\n \
    \   end\n  end\n  return {s, res}\nend", "    local function remove_all(source,\
    \ char)\n        while true do\n            local position = source:find(char)\n\
    \            if position then\n                source = source:sub(1, position\
    \ - 1) .. source:sub(position + 1)\n            else\n                break\n\
    \            end\n        end\n        return source\n    end\n    for i = 1,\
    \ #c do\n        s = remove_all(s, c:sub(i, i))\n    end\n    local is_palindrome\
    \ = true\n    for i = 1, #s do\n        if s:sub(i, i) ~= s:sub(#s - i + 1, #s\
    \ - i + 1) then\n            is_palindrome = false\n            break\n      \
    \  end\n    end\n    return {s, is_palindrome}\nend", "  local d = {}\n  for i\
    \ = 1, s:len() do\n    local ch = s:sub(i, i)\n    if not c:find(ch) then d[#d\
    \ + 1] = ch end\n  end\n  local res = d:reverse():concat()\n  return { res, res\
    \ == res:reverse() }\nend", "    -- body\nend", "    local rs = s:gsub('['..c..']',\
    \ '')\n    local bool = rs == rs:reverse()\n    return {rs, bool}\nend", "   \
    \ local remove_list = {}\n    for i=1, #c do\n        remove_list[c:sub(i, i)]\
    \ = true\n    end\n    local res = {}\n    for i=1, #s do\n        if not remove_list[s:sub(i,\
    \ i)] then\n            res[#res + 1] = s:sub(i, i)\n        end\n    end\n  \
    \  return {table.concat(res), res[1] == res[#res]}\nend", "\tlocal t = {}\n\t\
    for i = 1, #s do\n\t\tlocal k = s:sub(i, i)\n\t\tlocal check = 0\n\t\tfor j =\
    \ 1, #c do\n\t\t\tif k == c:sub(j, j) then\n\t\t\t\tcheck = 1\n\t\t\tend\n\t\t\
    end\n\t\tif check == 0 then\n\t\t\ttable.insert(t, k)\n\t\tend\n\tend\n\tlocal\
    \ res = table.concat(t)\n\tlocal reverse = res:reverse()\n\tif res == reverse\
    \ then\n\t\treturn {res, true}\n\telse\n\t\treturn {res, false}\n\tend\nend",
  "    c = c:gsub('.', function(x) return '['..x..']' end)\n    s = s:gsub(c, '')\n\
    \    local r = s:reverse()\n    local p = s:gsub('.', function(x) return '['..x..']'\
    \ end)\n    return {r, r:match(p) and true or false}\nend", "    local set = {}\n\
    \    for ch in string.gmatch(c, '.') do\n        set[ch] = true\n    end\n   \
    \ local res = {}\n    for ch in string.gmatch(s, '.') do\n        if not set[ch]\
    \ then\n            table.insert(res, ch)\n        end\n    end\n    return {table.concat(res),\
    \ res == reverse(res)}\nend", "    local s2 = s:gsub(c, '')\n    local res = {s2,\
    \ s2 == s2:reverse()}\n    return res\nend", "  -- TODO: Implement the function\
    \ here\nend", "    -- your code here\nend", "  local str = ''\n  for i = 1, #s\
    \ do\n    if not c:find(s:sub(i, i)) then\n      str = str .. s:sub(i, i)\n  \
    \  end\n  end\n  return {str, str == str:reverse()}\nend", "  -- your code here\n\
    end", "    local t = {}\n    for i = 1, #s do\n        t[#t + 1] = s:sub(i, i)\n\
    \    end\n    for i = 1, #c do\n        for k, v in ipairs(t) do\n           \
    \ if v == c:sub(i, i) then\n                table.remove(t, k)\n            end\n\
    \        end\n    end\n    local res = table.concat(t)\n    return {res, res ==\
    \ res:reverse()}\nend", "  local s2 = \"\"\n  for i = 1, #s do\n    if not string.find(c,\
    \ s:sub(i, i)) then\n      s2 = s2 .. s:sub(i, i)\n    end\n  end\n  local s3\
    \ = \"\"\n  for i = #s2, 1, -1 do\n    s3 = s3 .. s2:sub(i, i)\n  end\n  return\
    \ {s2, s2 == s3}\nend", "    local result = s:gsub(c, '')\n    local bool = result\
    \ == string.reverse(result) and true or false\n    return {result, bool}\nend",
  "    -- your code here\nend", "    local t = {}\n    for i = 1, #s do\n        local\
    \ char = s:sub(i, i)\n        if not c:find(char) then t[#t + 1] = char end\n\
    \    end\n    local reverse = table.concat(t)\n    local original = table.concat(t,\
    \ \"\", #t, 1)\n    return {reverse, reverse == original}\nend", end, "  local\
    \ t = {}\n  local result = ''\n  for i = 1, #s do\n    t[i] = s:sub(i, i)\n  end\n\
    \  for i = 1, #c do\n    for j = 1, #t do\n      if c:sub(i, i) == t[j] then\n\
    \        t[j] = ''\n      end\n    end\n  end\n  for i = 1, #t do\n    result\
    \ = result .. t[i]\n  end\n  return {result, result == result:reverse()}\nend",
  "    local r = s:gsub('['..c..']', '')\n    return {r, r:reverse() == r}\nend",
  "  s = s:gsub('['..c..']', '')\n  local len = #s\n  for i = 1, len do\n    if s:sub(i,\
    \ i) ~= s:sub(len - i + 1, len - i + 1) then\n      return {s, false}\n    end\n\
    \  end\n  return {s, true}\nend", "    -- :local s string\n    -- :local c string\n\
    \    -- :local result string\n    local result = \"\"\n    for i = 1, #s do\n\
    \        if c:find(s:sub(i, i)) == nil then\n            result = result .. s:sub(i,\
    \ i)\n        end\n    end\n    return {result, result == result:reverse()}\n\
    end", "\treturn {s:gsub('['..c..']', ''), s:gsub('['..c..']', '') == s:gsub('['..c..']',\
    \ ''):reverse()}\nend", "    local r = {}\n    for i = 1, #s do\n        local\
    \ x = s:sub(i, i)\n        if c:find(x) == nil then\n            r[#r + 1] = x\n\
    \        end\n    end\n    local s2 = table.concat(r)\n    return {s2, s2 == s2:reverse()}\n\
    end", "    s = string.gsub(s, \"[\" .. c .. \"]\", \"\")\n    local b = false\n\
    \    for i = 1, math.floor(#s / 2) do\n        if s:sub(i, i) ~= s:sub(#s - i\
    \ + 1, #s - i + 1) then\n            b = false\n            break\n        else\n\
    \            b = true\n        end\n    end\n    return {s, b}\nend", "    local\
    \ t = {}\n    local p = false\n    for i = 1, #s do\n        local char = s:sub(i,\
    \ i)\n        if not c:find(char) then\n            table.insert(t, char)\n  \
    \      end\n    end\n    s = table.concat(t)\n    if s == s:reverse() then\n \
    \       p = true\n    end\n    return {s, p}\nend", "    local result = {}\n \
    \   local reverse_s = s:reverse()\n    for i = 1, #s do\n        for j = 1, #c\
    \ do\n            if s:sub(i, i) == c:sub(j, j) then\n                table.insert(result,\
    \ reverse_s:sub(i, i))\n            end\n        end\n    end\n    table.insert(result,\
    \ true)\n    return result\nend", "    -- Your code here\nend", "  -- your code\
    \ here\nend", "    return {s:gsub('['..c..']', ''), s:gsub('['..c..']', '') ==\
    \ s:gsub('['..c..']', ''):reverse()}\nend", "    local char = {}\n    for i =\
    \ 1, #c do\n        char[c:sub(i, i)] = true\n    end\n    local s1 = \"\"\n \
    \   for i = 1, #s do\n        if not char[s:sub(i, i)] then\n            s1 =\
    \ s1 .. s:sub(i, i)\n        end\n    end\n    local s2 = s1:reverse()\n    local\
    \ ret = {}\n    if s1 == s2 then\n        ret[1] = s1\n        ret[2] = true\n\
    \    else\n        ret[1] = s1\n        ret[2] = false\n    end\n    return ret\n\
    end", "  -- write your code here\nend", "  -- body\nend", "    local t = {}\n\
    \    for i = 1, #s do\n        if not string.find(c, s:sub(i, i)) then\n     \
    \       table.insert(t, s:sub(i, i))\n        end\n    end\n    local r = table.concat(t)\n\
    \    local isPalindrome = r == string.reverse(r)\n    return {r, isPalindrome}\n\
    end", "    return {s:gsub('['..c..']', ''), s:gsub('['..c..']', '') == s:gsub('['..c..']',\
    \ ''):reverse()}\nend", "    local t = {}\n    local n = 1\n    local i = 1\n\
    \    while i <= #s do\n        local b = false\n        for j = 1, #c do\n   \
    \         if s:sub(i, i) == c:sub(j, j) then\n                b = true\n     \
    \           break\n            end\n        end\n        if not b then\n     \
    \       t[n] = s:sub(i, i)\n            n = n + 1\n        end\n        i = i\
    \ + 1\n    end\n    local result = table.concat(t)\n    local res = {}\n    res[1]\
    \ = result\n    res[2] = is_palindrome(result)\n    return res\nend", "  -- your\
    \ code here\nend", "    for i = 1, #c do\n        s = s:gsub(c:sub(i, i), '')\n\
    \    end\n    local function check_palindrome(p)\n        local n = #p\n     \
    \   for i = 1, n // 2 do\n            if p:sub(i, i) ~= p:sub(n - i + 1, n - i\
    \ + 1) then\n                return false\n            end\n        end\n    \
    \    return true\n    end\n    return {s, check_palindrome(s)}\nend", "  return\
    \ {remove_chars(s, c), is_palindrome(remove_chars(s, c))}\nend", "  -- Write your\
    \ code here\n  if type(s) ~= 'string' or type(c) ~= 'string' then\n    return\
    \ nil\n  end\n  local t = {}\n  local c_table = {}\n  for i = 1, #c do\n    local\
    \ index = c:sub(i, i)\n    c_table[index] = true\n  end\n  for i = 1, #s do\n\
    \    local index = s:sub(i, i)\n    if not c_table[index] then\n      table.insert(t,\
    \ index)\n    end\n  end\n  s = table.concat(t)\n  local r_s = s:reverse()\n \
    \ return {s, s == r_s}\nend", "    local set = {}\n    for i=1,#c do\n       \
    \ set[c:sub(i,i)] = true\n    end\n    s = s:gsub('['..c..']', '')\n    local\
    \ first, last = 1, #s\n    while first <= last do\n        if s:sub(first, first)\
    \ ~= s:sub(last, last) then\n            return {s, false}\n        end\n    \
    \    first = first + 1\n        last = last - 1\n    end\n    return {s, true}\n\
    end", "    return {string.gsub(s, '[^' .. c .. ']', ''), string.gsub(s, '[^' ..\
    \ c .. ']', '') == string.reverse(string.gsub(s, '[^' .. c .. ']', ''))}\nend",
  "    c = c:gsub('.', '%%%1')\n    local r = s:gsub(c, '')\n    return {r, r == r:reverse()}\n\
    end", "    local t = {}\n    for i = 1, #s do\n        local r = true\n      \
    \  for j = 1, #c do\n            if s:sub(i, i) == c:sub(j, j) then\n        \
    \        r = false\n                break\n            end\n        end\n    \
    \    if r then\n            t[#t + 1] = s:sub(i, i)\n        end\n    end\n  \
    \  local p = true\n    for i = 1, #t do\n        if t[i] ~= t[#t - i + 1] then\n\
    \            p = false\n            break\n        end\n    end\n    return {\
    \ table.concat(t), p }\nend", "    -- Write your code here\n    return {'', false}\n\
    end", "  -- your code here\nend", "    return {s:gsub('['..c..']', ''), s:gsub('['..c..']',\
    \ '') == s:gsub('['..c..']', ''):reverse()}\nend", "  --\nend", "\tlocal t = {}\n\
    \tfor i = 1, #s do\n\t\tif not c:find(s:sub(i, i), 1, true) then\n\t\t\tt[#t +\
    \ 1] = s:sub(i, i)\n\t\tend\n\tend\n\tlocal result = table.concat(t)\n\treturn\
    \ {result, result == result:reverse()}\nend", "    --\nend", "    local t = {}\n\
    \    for i = 1, #s do\n        local v = s:sub(i, i)\n        if not c:find(v)\
    \ then\n            t[#t + 1] = v\n        end\n    end\n    local res = table.concat(t)\n\
    \    return {res, res == res:reverse()}\nend", "\t--[[ body ]]\nend", "  local\
    \ set_c = {}\n  for i=1,#c do\n    set_c[c:sub(i,i)] = true\n  end\n  local t\
    \ = {}\n  for i=1,#s do\n    if not set_c[s:sub(i,i)] then\n      t[#t+1] = s:sub(i,i)\n\
    \    end\n  end\n  local s = table.concat(t)\n  return {s, s:reverse() == s}\n\
    end", "    local t, count = {}, 0\n    for i = 1, #s do\n        if not c:find(s:sub(i,\
    \ i)) then\n            t[#t + 1] = s:sub(i, i)\n        else\n            count\
    \ = count + 1\n        end\n    end\n    local result = table.concat(t)\n    return\
    \ {result, result == result:reverse()}, count\nend", "\tlocal tbl = {}\n\tlocal\
    \ check = false\n\tfor i = 1, #s do\n\t\tif not c:find(s:sub(i, i)) then\n\t\t\
    \ttable.insert(tbl, s:sub(i, i))\n\t\tend\n\tend\n\ts = table.concat(tbl)\n\t\
    for i = 1, #s do\n\t\tif s:sub(i, i) ~= s:sub(#s - i + 1, #s - i + 1) then\n\t\
    \t\tcheck = false\n\t\t\tbreak\n\t\telse\n\t\t\tcheck = true\n\t\tend\n\tend\n\
    \treturn {s, check}\nend", "    local function delete(s, c)\n        local set\
    \ = {}\n        for i = 1, #c do\n            set[c:sub(i, i)] = true\n      \
    \  end\n        local t = {}\n        for i = 1, #s do\n            if not set[s:sub(i,\
    \ i)] then\n                t[#t + 1] = s:sub(i, i)\n            end\n       \
    \ end\n        return table.concat(t)\n    end\n    local function is_palindrome(s)\n\
    \        return s == s:reverse()\n    end\n    return {delete(s, c), is_palindrome(delete(s,\
    \ c))}\nend", "  for i = 1, #c do\n    local str = string.gsub(s, c:sub(i, i),\
    \ '')\n    s = str\n  end\n  local t = {str, str == string.reverse(str)}\n  return\
    \ t\nend", "    return {string.gsub(s, c, ''), string.gsub(s, c, '') == string.reverse(string.gsub(s,\
    \ c, ''))}\nend", "  local t={}\n  for i=1,#s do\n    t[i]=s:sub(i,i)\n  end\n\
    \  for i=1,#t do\n    for j=1,#c do\n      if t[i]==c:sub(j,j) then\n        table.remove(t,i)\n\
    \        i=i-1\n        break\n      end\n    end\n  end\n  local s=''\n  for\
    \ i=1,#t do\n    s=s..t[i]\n  end\n  local t={}\n  t[1]=s\n  t[2]=s==s:reverse()\n\
    \  return t\nend", "    return {}\nend", "    local t = {}\n    for i = 1, #s\
    \ do\n        local char = s:sub(i, i)\n        if not c:find(char) then\n   \
    \         table.insert(t, char)\n        end\n    end\n    local str = table.concat(t)\n\
    \    return {str, str == str:reverse()}\nend", "    local res = {}\n    local\
    \ m = {}\n    for i = 1, #c do\n        m[c:sub(i, i)] = true\n    end\n    for\
    \ i = 1, #s do\n        if not m[s:sub(i, i)] then\n            table.insert(res,\
    \ s:sub(i, i))\n        end\n    end\n    return {table.concat(res), table.concat(res)\
    \ == table.concat(res, '', #res, 1)}\nend", "    local del = {}\n    for i=1,#c\
    \ do\n        del[c:sub(i,i)] = true\n    end\n    local t = {}\n    for i=1,#s\
    \ do\n        if not del[s:sub(i,i)] then\n            t[#t+1] = s:sub(i,i)\n\
    \        end\n    end\n    local r = table.concat(t)\n    return {r, r == r:reverse()}\n\
    end", "    local str = \"\"\n    for i = 1, #s do\n        local found = false\n\
    \        for j = 1, #c do\n            if s:sub(i, i) == c:sub(j, j) then\n  \
    \              found = true\n                break\n            end\n        end\n\
    \        if not found then\n            str = str .. s:sub(i, i)\n        end\n\
    \    end\n    local reverse_str = \"\"\n    for i = #str, 1, -1 do\n        reverse_str\
    \ = reverse_str .. str:sub(i, i)\n    end\n    return {str, str == reverse_str}\n\
    end", "  local t = {}\n  for i = 1, #s do\n    if not string.find(c, s:sub(i,\
    \ i)) then\n      table.insert(t, s:sub(i, i))\n    end\n  end\n  return {table.concat(t),\
    \ table.concat(t) == string.reverse(table.concat(t))}\nend", "    -- your code\
    \ here\nend", "  local result = string.gsub(s, '[' .. c .. ']', '')\n  local res_copy\
    \ = result\n  local reversed = ''\n  while #res_copy > 0 do\n    reversed = reversed\
    \ .. string.sub(res_copy, -1)\n    res_copy = string.sub(res_copy, 1, -2)\n  end\n\
    \  return {reversed, result == reversed}\nend", "  local t = {}\n  for i = 1,\
    \ s:len() do\n    t[i] = s:sub(i, i)\n  end\n  for i = 1, #t do\n    if c:find(t[i])\
    \ then\n      table.remove(t, i)\n      i = i - 1\n    end\n  end\n  local st\
    \ = table.concat(t)\n  local result = {st, st == st:reverse()}\n  return result\n\
    end", "    s = s:gsub('['..c..']', '')\n    return {s, s:reverse() == s}\nend",
  end, "\t-- body\nend", "  local result = {}\n  for i=1, #s do\n    local current_char\
    \ = s:sub(i, i)\n    if not c:find(current_char) then\n      table.insert(result,\
    \ current_char)\n    end\n  end\n  return { table.concat(result), table.concat(result)\
    \ == table.concat(result, \"\", #result, 1, -1) }\nend", "    local result = {}\n\
    \    local r = {}\n    local t = {}\n    local is_palindrome = false\n    local\
    \ i = 0\n    local j = 0\n    local j_len = 0\n    local s_len = 0\n    local\
    \ c_len = 0\n    local c_lst = {}\n    for i = 1, #s do\n        result[i] = s:sub(i,\
    \ i)\n    end\n    for i = 1, #c do\n        c_lst[i] = c:sub(i, i)\n    end\n\
    \    for i = 1, #result do\n        for j = 1, #c_lst do\n            if result[i]\
    \ == c_lst[j] then\n                table.remove(result, i)\n                break\n\
    \            end\n        end\n    end\n    s_len = #result\n    j_len = s_len\n\
    \    for i = 1, s_len do\n        r[i] = result[i]\n    end\n    for i = 1, s_len\
    \ do\n        t[i] = result[j_len]\n        j_len = j_len - 1\n    end\n    for\
    \ i = 1, s_len do\n        if r[i] == t[i] then\n            is_palindrome = true\n\
    \        else\n            is_palindrome = false\n            break\n        end\n\
    \    end\n    return {result, is_palindrome}\nend", "    local chars = {}\n  \
    \  for i = 1, #s do\n        if not chars[s:sub(i, i)] then\n            chars[s:sub(i,\
    \ i)] = true\n        end\n    end\n    for i = 1, #c do\n        if chars[c:sub(i,\
    \ i)] then\n            chars[c:sub(i, i)] = nil\n        end\n    end\n    local\
    \ result = {}\n    for i = 1, #s do\n        if chars[s:sub(i, i)] then\n    \
    \        table.insert(result, s:sub(i, i))\n        end\n    end\n    return {table.concat(result),\
    \ result[1] == result[#result]}\nend", "    local t = {}\n    local b = true\n\
    \    for i = 1, #s do\n        if c:find(s:sub(i, i)) then\n            b = false\n\
    \        else\n            table.insert(t, s:sub(i, i))\n        end\n    end\n\
    \    return table.concat(t), b\nend", end, "    return {remove_chars(s, c), is_palindrome(remove_chars(s,\
    \ c))}\nend", "  return {'', true}\nend", "  local x = s:gsub(c, '')\n  local\
    \ y = string.reverse(x)\n  if x == y then\n    return {x, true}\n  else\n    return\
    \ {x, false}\n  end\nend\nreverse_delete('abcde', 'ae')", "    local t = {}\n\
    \    for i = 1, string.len(s) do\n        local str = string.sub(s, i, i)\n  \
    \      local flag = false\n        for j = 1, string.len(c) do\n            if\
    \ str == string.sub(c, j, j) then\n                flag = true\n             \
    \   break\n            end\n        end\n        if not flag then\n          \
    \  table.insert(t, str)\n        end\n    end\n    local rs = table.concat(t)\n\
    \    local str1 = string.reverse(rs)\n    local str2 = rs\n    local b = false\n\
    \    if str1 == str2 then\n        b = true\n    end\n    return {rs, b}\nend",
  "    local t = {}\n    for i = 1, #s do\n        if c:find(s:sub(i, i)) == nil then\n\
    \            t[#t + 1] = s:sub(i, i)\n        end\n    end\n    local str = table.concat(t)\n\
    \    local is_palindrome = true\n    for i = 1, #str / 2 do\n        if str:sub(i,\
    \ i) ~= str:sub(#str - i + 1, #str - i + 1) then\n            is_palindrome =\
    \ false\n            break\n        end\n    end\n    return {str, is_palindrome}\n\
    end", "    -- body\nend", "  local new = {}\n  local chars = {}\n  local function\
    \ include(value)\n    for i = 1, #c do\n      if value == c:sub(i, i) then\n \
    \       return true\n      end\n    end\n    return false\n  end\n  for i = 1,\
    \ #s do\n    if not include(s:sub(i, i)) then\n      table.insert(new, s:sub(i,\
    \ i))\n    end\n  end\n  s = table.concat(new)\n  for i = 1, #s do\n    table.insert(chars,\
    \ s:sub(i, i))\n  end\n  local reverse_chars = {}\n  for i = #chars, 1, -1 do\n\
    \    table.insert(reverse_chars, chars[i])\n  end\n  local reverse_s = table.concat(reverse_chars)\n\
    \  if s == reverse_s then\n    return {s, true}\n  else\n    return {s, false}\n\
    \  end\nend", "    local t = {}\n    local t2 = {}\n    local m = 0\n    for i=1,\
    \ #s do\n        if string.find(c, s:sub(i, i)) == nil then\n            t[#t+1]\
    \ = s:sub(i, i)\n        end\n    end\n    for i=1, #t do\n        t2[#t2+1] =\
    \ t[#t-i+1]\n    end\n    for i=1, #t do\n        if t[i] == t2[i] then\n    \
    \        m = m + 1\n        end\n    end\n    if m == #t then\n        return\
    \ {table.concat(t), true}\n    else\n        return {table.concat(t), false}\n\
    \    end\nend", "  return {string.gsub(s, \"[\" .. c .. \"]\", \"\"), (string.gsub(s,\
    \ \"[\" .. c .. \"]\", \"\") == string.reverse(string.gsub(s, \"[\" .. c .. \"\
    ]\", \"\")))}\nend", "    return {s:gsub('['..c..']', ''), s:gsub('['..c..']',\
    \ '') == s:gsub('['..c..']', ''):reverse()}\nend", "  -- your code here\nend",
  "  local new_string = ''\n  for i = 1, #s do\n    if c:find(s:sub(i, i)) == nil\
    \ then\n      new_string = new_string .. s:sub(i, i)\n    end\n  end\n  return\
    \ {new_string, new_string == new_string:reverse()}\nend", "    -- Your code here\n\
    end", "  -- body\nend", "    local t = {}\n    for i = 1, #s do\n        local\
    \ si = s:sub(i, i)\n        if c:find(si) == nil then\n            table.insert(t,\
    \ si)\n        end\n    end\n    local s2 = table.concat(t)\n    local ok = true\n\
    \    for i = 1, #s2 / 2 do\n        if s2:sub(i, i) ~= s2:sub(#s2 - i + 1, #s2\
    \ - i + 1) then\n            ok = false\n            break\n        end\n    end\n\
    \    return {s2, ok}\nend", "    -- your code here\nend", "    local t = {}\n\
    \    local res = ''\n    for i = 1, string.len(s) do\n        if not string.find(c,\
    \ string.sub(s, i, i)) then\n            table.insert(t, string.sub(s, i, i))\n\
    \        end\n    end\n    for i = string.len(t), 1, -1 do\n        res = res\
    \ .. t[i]\n    end\n    return {res, res == s}\nend", "  local table = {}\n  local\
    \ i = 0\n  local result = ''\n  while i < string.len(s) do\n    local ch = string.sub(s,\
    \ i, i)\n    if ch == string.sub(c, 1, 1) or ch == string.sub(c, 2, 2) then\n\
    \      i = i + 1\n    else\n      table[i] = ch\n      i = i + 1\n    end\n  end\n\
    \  for j = 0, string.len(s) - 1 do\n    result = result .. table[j]\n  end\n \
    \ local palindrome = true\n  for j = 0, string.len(result) - 1 do\n    if result[j]\
    \ ~= result[string.len(result) - j] then\n      palindrome = false\n    end\n\
    \  end\n  return {result, palindrome}\nend", "    return {s:gsub('['..c..']',\
    \ ''), s:gsub('['..c..']', '') == s:gsub('['..c..']', ''):reverse()}\nend", " \
    \   -- body\nend", "    local result_table = {}\n    local result_string = ''\n\
    \    local c_table = {}\n    local counter = 0\n    -- fill c_table with chars\
    \ from c string\n    for i in c:gmatch('.') do\n        c_table[counter] = i\n\
    \        counter = counter + 1\n    end\n    -- if s is a single char string\n\
    \    if #s == 1 then\n        result_string = s\n        for i = 0, #c_table do\n\
    \            if s == c_table[i] then\n                result_string = ''\n   \
    \         end\n        end\n    else\n        for i = 0, #s do\n            local\
    \ counter = 0\n            for j = 0, #c_table do\n                if s:sub(i\
    \ + 1, i + 1) == c_table[j] then\n                    counter = counter + 1\n\
    \                end\n            end\n            if counter == 0 then\n    \
    \            result_string = result_string .. s:sub(i + 1, i + 1)\n          \
    \  end\n        end\n    end\n    result_table[0] = result_string\n    result_table[1]\
    \ = is_palindrome(result_string)\n    return result_table\nend", "  -- your code\
    \ here\nend", "  local str = {}\n  for i = 1, #s do\n    local found = false\n\
    \    for _, v in ipairs(c) do\n      if s:sub(i, i) == v then\n        found =\
    \ true\n        break\n      end\n    end\n    if not found then table.insert(str,\
    \ s:sub(i, i)) end\n  end\n  return table.concat(str), str[1] == str[#str]\nend",
  end, "    local t = {}\n    for i = 1, #s do\n        local flag = false\n     \
    \   for j = 1, #c do\n            if s:sub(i, i) == c:sub(j, j) then\n       \
    \         flag = true\n                break\n            end\n        end\n \
    \       if not flag then\n            table.insert(t, s:sub(i, i))\n        end\n\
    \    end\n    local r = table.concat(t)\n    local len = #r\n    local flag =\
    \ true\n    for i = 1, math.floor(len / 2) do\n        if r:sub(i, i) ~= r:sub(len\
    \ - i + 1, len - i + 1) then\n            flag = false\n            break\n  \
    \      end\n    end\n    return {r, flag}\nend", "    local arr = {}\n    for\
    \ i=1,#s do\n        local char = s:sub(i,i)\n        if not c:find(char) then\n\
    \            table.insert(arr, char)\n        end\n    end\n    return arr, arr[1]\
    \ == arr[#arr]\nend", "  local t = {}\n  local n = 1\n  for i = 1, #s do\n   \
    \ if not c:find(s:sub(i, i), 1, true) then\n      t[n] = s:sub(i, i)\n      n\
    \ = n + 1\n    end\n  end\n  local ss = table.concat(t)\n  local check = ss ==\
    \ ss:reverse()\n  return {ss, check}\nend", "    -- definition of string.gsub\n\
    \    -- string.gsub(s, pattern, replacement [, number])\n    -- return the string\
    \ s with all (or the first n, if given) occurrences of the pattern replaced by\
    \ replacement\n    local result = string.gsub(s, c, '')\n    local reverse = string.reverse(result)\n\
    \    return {reverse, result == reverse}\nend", "  -- delete equal chars\n  local\
    \ r, cnt = s:gsub(c, '')\n  -- check for palindrome\n  local palindrome = true\n\
    \  for i = 1, #r/2 do\n    if r:sub(i, i) ~= r:sub(-i, -i) then\n      palindrome\
    \ = false\n      break\n    end\n  end\n  return {r, palindrome}\nend", "    --\
    \ your code goes here\nend", "  if #s < 1 then return {s, true} end\n  if #c <\
    \ 1 then return {s, true} end\n  local a = {}\n  for i = 1, #s do\n    a[#a +\
    \ 1] = s:sub(i, i)\n  end\n  for i = 1, #c do\n    local ch = c:sub(i, i)\n  \
    \  for i = #a, 1, -1 do\n      if a[i] == ch then\n        table.remove(a, i)\n\
    \      end\n    end\n  end\n  local s = table.concat(a)\n  local x = 1\n  local\
    \ y = #s\n  local check = true\n  while x < y do\n    if s:sub(x, x) ~= s:sub(y,\
    \ y) then\n      check = false\n      break\n    end\n    x = x + 1\n    y = y\
    \ - 1\n  end\n  return {s, check}\nend", "  local s1 = {}\n  for i = 1, #s do\n\
    \    local skip = false\n    for j = 1, #c do\n      if string.sub(s, i, i) ==\
    \ string.sub(c, j, j) then\n        skip = true\n        break\n      end\n  \
    \  end\n    if not skip then\n      table.insert(s1, string.sub(s, i, i))\n  \
    \  end\n  end\n  local s2 = {}\n  for i = #s1, 1, -1 do\n    table.insert(s2,\
    \ s1[i])\n  end\n  local s3 = table.concat(s2)\n  local result = {s3, false}\n\
    \  if s3 == table.concat(s1) then\n    result[2] = true\n  end\n  return result\n\
    end", "  local chars = {}\n  for char in c:gmatch('.') do\n    chars[char] = true\n\
    \  end\n  local result = ''\n  for char in s:gmatch('.') do\n    if not chars[char]\
    \ then\n      result = result .. char\n    end\n  end\n  return { result, result\
    \ == result:reverse() }\nend", "    for i = 1, #c do\n        s = s:gsub(c:sub(i,\
    \ i), '')\n    end\n    return {s, s == s:reverse()}\nend", "  for i = 1, #c do\n\
    \    s = s:gsub(c:sub(i, i), '')\n  end\n  return {s, s == s:reverse()}\nend",
  "    local r = s:gsub('['..c..']', '')\n    return {r, r:reverse() == r}\nend",
  "    local x = s:gsub('['..c..']', '')\n    local y = x:reverse()\n    return {x,\
    \ x == y}\nend", "  return table.pack(s:gsub(\"[\"..c..\"]\",\"\"):gsub(\"()(.)\"\
    , function(a,b) return b..a end), s:gsub(\"[\"..c..\"]\",\"\") == s:gsub(\"[\"\
    ..c..\"]\",\"\"):gsub(\"()(.)\", function(a,b) return b..a end))\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
