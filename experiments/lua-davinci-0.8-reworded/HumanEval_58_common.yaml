name: HumanEval_58_common
language: lua
prompt: "-- Return sorted unique common elements for two tables.\n-- >>> common({1,\
  \ 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n-- {1, 5, 653}\n-- >>> common({5,\
  \ 3, 2, 8}, {3, 2})\n-- {2, 3}\nlocal function common(l1, l2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = common\n\
  \    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}),\
  \ {1, 5, 653})\n    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})\n \
  \   lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})\n    lu.assertEquals(candidate({4,\
  \ 3, 2, 8}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local r, h = {}, {}\n  for _, v in ipairs(l1) do\n    h[v] = true\n\
    \  end\n  for _, v in ipairs(l2) do\n    if h[v] then\n      table.insert(r, v)\n\
    \    end\n  end\n  return r\nend", "  local lookup = {}\n  for _, v in ipairs(l1)\
    \ do\n    lookup[v] = true\n  end\n  local res = {}\n  for _, v in ipairs(l2)\
    \ do\n    if lookup[v] then\n      table.insert(res, v)\n    end\n  end\n  table.sort(res)\n\
    \  return res\nend", "  local s = {}\n  for k in pairs(l1) do s[k] = true end\n\
    \  for k in pairs(l2) do\n    if s[k] then s[k] = nil end\n  end\n  local keys\
    \ = {}\n  for k in pairs(s) do table.insert(keys, k) end\n  table.sort(keys)\n\
    \  return keys\nend", "    local t = {}\n    for _, v in ipairs(l1) do\n     \
    \   if mem(l2, v) then\n            insert(t, v)\n        end\n    end\n    return\
    \ sort(t)\nend", "    local ret = { }\n    if #l1 == 0 or #l2 == 0 then\n    \
    \    return ret\n    end\n    local h = { }\n    for _, v in ipairs(l1) do\n \
    \       h[v] = true\n    end\n    for _, v in ipairs(l2) do\n        if h[v] then\n\
    \            ret[#ret + 1] = v\n        end\n    end\n    table.sort(ret)\n  \
    \  return ret\nend", "    local lookup = {}\n    for _, v in ipairs(l1) do\n \
    \       lookup[v] = true\n    end\n    local out = {}\n    for _, v in ipairs(l2)\
    \ do\n        if lookup[v] then\n            out[#out + 1] = v\n        end\n\
    \    end\n    return sort(out)\nend", "    local r = {}\n    local t = {}\n  \
    \  for _, v in ipairs(l1) do\n        t[v] = true\n    end\n    for _, v in ipairs(l2)\
    \ do\n        if t[v] then\n            table.insert(r, v)\n        end\n    end\n\
    \    table.sort(r)\n    return r\nend", "    local res = {}\n    for _, v in ipairs(l1)\
    \ do\n        for _, v2 in ipairs(l2) do\n            if v == v2 then\n      \
    \          table.insert(res, v)\n            end\n        end\n    end\n    table.sort(res)\n\
    \    return uniq(res)\nend", "    local ret = {}\n    for _, v in ipairs(l1) do\n\
    \        for _, v2 in ipairs(l2) do\n            if v == v2 then\n           \
    \     table.insert(ret, v)\n            end\n        end\n    end\n    return\
    \ table.unpack(table.sort(ret))\nend", "\tlocal common = {}\n\tfor _, e in ipairs(l1)\
    \ do\n\t\tif has(l2, e) then\n\t\t\tcommon[#common + 1] = e\n\t\tend\n\tend\n\t\
    return uniq(common)\nend", "\tlocal common_tbl = {}\n\tfor i = 1, #l1 do\n\t\t\
    for j = 1, #l2 do\n\t\t\tif l1[i] == l2[j] then\n\t\t\t\ttable.insert(common_tbl,\
    \ l1[i])\n\t\t\tend\n\t\tend\n\tend\n\treturn unique(common_tbl)\nend", "  local\
    \ c = {}\n  for i = 1, #l1 do\n    local v = l1[i]\n    if sorted_index(l2, v)\
    \ then\n      table.insert(c, v)\n    end\n  end\n  return c\nend", "\tif l1 and\
    \ l2 then\n\t\tlocal a, b, c = {}, {}, {}\n\t\tfor k, v in pairs(l1) do a[v] =\
    \ true end\n\t\tfor k, v in pairs(l2) do b[v] = true end\n\t\tfor k, v in pairs(a)\
    \ do if b[k] then c[#c+1] = k end end\n\t\tsort(c)\n\t\treturn c\n\tend\nend",
  "    return sortedkeys(keyfilter(l1, l2))\nend", "  local common = {}\n  for k,\
    \ v in pairs(l1) do\n    if l2[v] then\n      common[v] = true\n    end\n  end\n\
    \  local list = {}\n  for k, v in pairs(common) do\n    table.insert(list, k)\n\
    \  end\n  table.sort(list)\n  return list\nend", "  if not l1 or not l2 then return\
    \ end\n  local t, c = {}, {}\n  for i, v in ipairs(l1) do t[v] = true end\n  for\
    \ i, v in ipairs(l2) do if t[v] then table.insert(c, v) end end\n  table.sort(c)\n\
    \  return c\nend", "  local u = {}\n  for _, v in ipairs(l1) do\n    if elem(v,\
    \ l2) then\n      u[#u + 1] = v\n    end\n  end\n  return sorted(u)\nend", " \
    \ local result = {}\n  local hash = {}\n  for _, v in ipairs(l1) do\n    hash[v]\
    \ = true\n  end\n  for _, v in ipairs(l2) do\n    if hash[v] then\n      table.insert(result,\
    \ v)\n    end\n  end\n  table.sort(result)\n  return result\nend", "    local\
    \ c = {}\n    for _, e in ipairs(l1) do\n        if contains(l2, e) then\n   \
    \         table.insert(c, e)\n        end\n    end\n    return unique(c)\nend",
  "  local ret = {}\n  for i = 1, #l1 do\n    for j = 1, #l2 do\n      if l1[i] ==\
    \ l2[j] then\n        table.insert(ret, l1[i])\n      end\n    end\n  end\n  return\
    \ unique(ret)\nend", "    local x = {}\n    local a = {}\n    for i, v in ipairs(l1)\
    \ do\n        a[v] = true\n    end\n    for i, v in ipairs(l2) do\n        if\
    \ a[v] then\n            table.insert(x, v)\n        end\n    end\n    table.sort(x)\n\
    \    return x\nend", "  assert(l1 and l2, 'Two tables are expected')\n  local\
    \ t = {}\n  for _, v in ipairs(l1) do\n    if contains(l2, v) then\n      if not\
    \ contains(t, v) then\n        t[#t + 1] = v\n      end\n    end\n  end\n  sort(t)\n\
    \  return t\nend", "  local lookup = {}\n  for _, v in ipairs(l1) do\n    lookup[v]\
    \ = true\n  end\n  local ret = {}\n  for _, v in ipairs(l2) do\n    if lookup[v]\
    \ then\n      table.insert(ret, v)\n    end\n  end\n  return ret\nend", "    local\
    \ t = {}\n    for i = 1, #l1 do\n        local val = l1[i]\n        for j = 1,\
    \ #l2 do\n            if val == l2[j] then\n                t[#t + 1] = val\n\
    \                break\n            end\n        end\n    end\n    table.sort(t)\n\
    \    return t\nend", "    local d1, d2 = {}, {}\n    for _, v in ipairs(l1) do\
    \ d1[v] = true end\n    for _, v in ipairs(l2) do d2[v] = true end\n    local\
    \ l3 = {}\n    for k, _ in pairs(d1) do\n        if d2[k] then table.insert(l3,\
    \ k) end\n    end\n    return l3\nend", "    local result = {}\n    for k, v in\
    \ pairs(l1) do\n        if l2[v] then\n            result[#result + 1] = v\n \
    \       end\n    end\n    table.sort(result)\n    return result\nend", "    local\
    \ seen = {}\n    local ret = {}\n    for _, v in ipairs(l1) do\n        if not\
    \ seen[v] then\n            seen[v] = true\n            table.insert(ret, v)\n\
    \        end\n    end\n    for _, v in ipairs(l2) do\n        if seen[v] then\n\
    \            table.insert(ret, v)\n        end\n    end\n    return sort(ret)\n\
    end", "  local res = {}\n  local lookup = {}\n  for i = 1, #l1 do\n    lookup[l1[i]]\
    \ = true\n  end\n  for i = 1, #l2 do\n    if lookup[l2[i]] then\n      table.insert(res,\
    \ l2[i])\n    end\n  end\n  return res\nend", "  local t = {}\n  for _,v in ipairs(l1)\
    \ do\n    if contains(l2, v) then\n      t[#t+1] = v\n    end\n  end\n  return\
    \ uniq(t)\nend", "  local l3 = {}\n  for _, v in ipairs(l1) do\n    if utils.contains(l2,\
    \ v) then\n      table.insert(l3, v)\n    end\n  end\n  return utils.unique(l3)\n\
    end", "  local ret = {}\n  local set = {}\n  local iter = pairs(l1)\n  for value\
    \ in iter do\n    if set[value] == nil then\n      set[value] = true\n    end\n\
    \  end\n  iter = pairs(l2)\n  for value in iter do\n    if set[value] == true\
    \ then\n      ret[#ret + 1] = value\n    end\n  end\n  return sorted(ret)\nend",
  "  local r = {}\n  for _, v in ipairs(l1) do\n    for _, v2 in ipairs(l2) do\n \
    \     if v == v2 then\n        table.insert(r, v)\n      end\n    end\n  end\n\
    \  return unique(r)\nend", "  local t, k = {}, 1\n  for _,v in ipairs(l1) do\n\
    \    if contains(l2, v) then\n      t[k] = v\n      k = k + 1\n    end\n  end\n\
    \  sort(t)\n  return t\nend", "  local hash = {}\n  local common = {}\n  for _,\
    \ v in ipairs(l1) do\n    hash[v] = v\n  end\n  for _, v in ipairs(l2) do\n  \
    \  if hash[v] then\n      table.insert(common, v)\n    end\n  end\n  return common\n\
    end", "    local ret = {}\n    if l1 and l2 then\n        for _,v in ipairs(l1)\
    \ do\n            for _,v2 in ipairs(l2) do\n                if v == v2 then\n\
    \                    table.insert(ret, v)\n                    break\n       \
    \         end\n            end\n        end\n    end\n    table.sort(ret)\n  \
    \  return ret\nend", "  local t1 = unique(l1)\n  local t2 = unique(l2)\n  local\
    \ t = {}\n  for _,v in ipairs(t1) do\n    if lookup(t2, v) then t[#t+1] = v end\n\
    \  end\n  table.sort(t)\n  return t\nend", "  local res = {}\n  for i = 1, #l1\
    \ do\n    for j = 1, #l2 do\n      if l1[i] == l2[j] then\n        table.insert(res,\
    \ l1[i])\n      end\n    end\n  end\n  return unique(res)\nend", "    local t\
    \ = {}\n    for _, v in ipairs(l1) do\n        if elem(v, l2) then\n         \
    \   t[#t + 1] = v\n        end\n    end\n    return sort(t)\nend", "    local\
    \ ret = {}\n    local m = {}\n    for _, v in ipairs(l1) do\n        m[v] = (m[v]\
    \ or 0) + 1\n    end\n    for _, v in ipairs(l2) do\n        if m[v] and m[v]\
    \ > 0 then\n            table.insert(ret, v)\n            m[v] = m[v] - 1\n  \
    \      end\n    end\n    return ret\nend", "    local seen = {}\n    local res\
    \ = {}\n    for _, v in ipairs(l1) do\n        if not seen[v] then\n         \
    \   table.insert(res, v)\n            seen[v] = true\n        end\n    end\n \
    \   local seen = {}\n    local res2 = {}\n    for _, v in ipairs(l2) do\n    \
    \    if seen[v] then\n            table.insert(res2, v)\n        end\n       \
    \ seen[v] = true\n    end\n    local seen = {}\n    local result = {}\n    for\
    \ _, v in ipairs(res) do\n        if not seen[v] then\n            table.insert(result,\
    \ v)\n            seen[v] = true\n        end\n    end\n    for _, v in ipairs(res2)\
    \ do\n        if not seen[v] then\n            table.insert(result, v)\n     \
    \       seen[v] = true\n        end\n    end\n    table.sort(result)\n    return\
    \ result\nend", "\tlocal res = {}\n\tlocal found = {}\n\tfor i = 1, #l1 do\n\t\
    \tlocal n = l1[i]\n\t\tif not found[n] then\n\t\t\tfound[n] = true\n\t\t\tfor\
    \ j = 1, #l2 do\n\t\t\t\tif n == l2[j] then\n\t\t\t\t\tres[#res + 1] = n\n\t\t\
    \t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tsort(res)\n\treturn res\n\
    end", "\tlocal r = {}\n\tfor i=1, #l1 do\n\t\tfor j=1, #l2 do\n\t\t\tif l1[i]\
    \ == l2[j] then\n\t\t\t\tr[#r+1] = l1[i]\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ sort(r)\nend", "  local result = {}\n  local seen = {}\n  for _, v in ipairs(l1)\
    \ do\n    seen[v] = true\n  end\n  for _, v in ipairs(l2) do\n    if seen[v] then\n\
    \      table.insert(result, v)\n    end\n  end\n  table.sort(result)\n  return\
    \ result\nend", "    return utils.dictionary_values(intersect(utils.dictionary_of(l1),\
    \ utils.dictionary_of(l2)))\nend", "    local s = {}\n    local r = {}\n    for\
    \ _, v in ipairs(l1) do\n        s[v] = true\n    end\n    for _, v in ipairs(l2)\
    \ do\n        if s[v] then\n            table.insert(r, v)\n        end\n    end\n\
    \    table.sort(r)\n    return r\nend", "    local t = {}\n    for i = 1, #l1\
    \ do\n        for j = 1, #l2 do\n            if l1[i] == l2[j] then\n        \
    \        table.insert(t, l1[i])\n            end\n        end\n    end\n    return\
    \ unique(t)\nend", "    local u1 = unique(l1)\n    local u2 = unique(l2)\n   \
    \ local t = {}\n    for i, x in ipairs(u1) do\n        for j, y in ipairs(u2)\
    \ do\n            if x == y then\n                t[#t + 1] = x\n            end\n\
    \        end\n    end\n    return t\nend", "    return {unique(sort(l1, l2))}\n\
    end", "\tlocal l12 = {}\n\tfor _, v in ipairs(l1) do\n\t\tif contains(l2, v) then\n\
    \t\t\tl12[#l12 + 1] = v\n\t\tend\n\tend\n\treturn sort(unique(l12))\nend", " \
    \ if not l1 or not l2 then return {} end\n  local l1key = l1.key or key or 'k'\n\
    \  local l2key = l2.key or key or 'k'\n  if type(l1) == 'table' and type(l2) ==\
    \ 'table' then\n    local t = {}\n    for _, v in pairs(l1) do\n      if type(v)\
    \ == 'table' and v[l1key] and t[v[l1key]] == nil then\n        for _, v2 in pairs(l2)\
    \ do\n          if type(v2) == 'table' and v2[l2key] and v2[l2key] == v[l1key]\
    \ then\n            t[v[l1key]] = v[l1key]\n          end\n        end\n     \
    \ end\n    end\n    return s(t)\n  end\nend", "\tlocal result = {}\n\tlocal s1\
    \ = set(l1)\n\tlocal s2 = set(l2)\n\tlocal size1 = #s1\n\tlocal size2 = #s2\n\t\
    for i = 1, size1 do\n\t\tlocal v1 = s1[i]\n\t\tfor j = 1, size2 do\n\t\t\tlocal\
    \ v2 = s2[j]\n\t\t\tif v1 == v2 then\n\t\t\t\tresult[#result + 1] = v1\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn result\nend", "    if not l1 or not l2 then return\
    \ {} end\n    local r = {}\n    for k1, v1 in pairs(l1) do\n        for k2, v2\
    \ in pairs(l2) do\n            if v1 == v2 then\n                r[#r + 1] = v1\n\
    \            end\n        end\n    end\n    return unique(r)\nend", "  return\
    \ map(l1, function(e)\n    if contains(l2, e) then\n      return e\n    end\n\
    \  end)\nend", "  assert(type(l1) == 'table', 'Incorrect first argument type')\n\
    \  assert(type(l2) == 'table', 'Incorrect second argument type')\n  local c =\
    \ {}\n  for _, v in ipairs(l1) do\n    for _, x in ipairs(l2) do\n      if v ==\
    \ x then\n        c[#c + 1] = v\n      end\n    end\n  end\n  local function compare(a,\
    \ b)\n    return a < b\n  end\n  table.sort(c, compare)\n  local k = 1\n  while\
    \ k < #c do\n    if c[k] == c[k + 1] then\n      table.remove(c, k)\n    else\n\
    \      k = k + 1\n    end\n  end\n  return c\nend", "    local t = {}\n    for\
    \ _,v in ipairs(l1) do\n        for _,v2 in ipairs(l2) do\n            if v ==\
    \ v2 then\n                t[#t+1] = v\n            end\n        end\n    end\n\
    \    return unique(t)\nend", "    local r = {}\n    if l1 and l2 then\n      \
    \  for _, v in ipairs(l1) do\n            for _, v2 in ipairs(l2) do\n       \
    \         if v == v2 then\n                    r[#r + 1] = v\n               \
    \     break\n                end\n            end\n        end\n    end\n    return\
    \ unique(r)\nend", "  local res = {}\n  local a1 = {}\n  local a2 = {}\n  for\
    \ _, v in ipairs(l1) do\n    a1[v] = true\n  end\n  for _, v in ipairs(l2) do\n\
    \    a2[v] = true\n  end\n  for k, _ in pairs(a1) do\n    if a2[k] then\n    \
    \  table.insert(res, k)\n    end\n  end\n  table.sort(res)\n  return res\nend",
  "    local x = {}\n    local y = {}\n    local ret = {}\n    for _, i in ipairs(l1)\
    \ do\n        x[i] = true\n    end\n    for _, i in ipairs(l2) do\n        if\
    \ x[i] then\n            y[i] = true\n        end\n    end\n    for i in pairs(y)\
    \ do\n        ret[#ret + 1] = i\n    end\n    table.sort(ret)\n    return ret\n\
    end", "\tlocal result = {}\n\tfor _, v in ipairs(l1) do\n\t\tif inTable(l2, v)\
    \ then\n\t\t\tresult[#result + 1] = v\n\t\tend\n\tend\n\tsort(result)\n\treturn\
    \ result\nend", "    local common_set = {}\n    local sorted_set = {}\n    for\
    \ _, v in ipairs(l1) do\n        if check_in(v, l2) then\n            common_set[v]\
    \ = true\n        end\n    end\n    for k in pairs(common_set) do\n        table.insert(sorted_set,\
    \ k)\n    end\n    table.sort(sorted_set)\n    return sorted_set\nend", "  local\
    \ r = {}\n  for _,v in ipairs(l1) do\n    if is_in(v, l2) then\n      r[#r+1]\
    \ = v\n    end\n  end\n  if #r > 0 then\n    return sort(r)\n  end\nend\nM.common\
    \ = common", "  local l3 = {}\n  local s  = {}\n  for _, e in ipairs(l1) do\n\
    \    if l3[e] == nil then\n      table.insert(s, e)\n      l3[e] = true\n    end\n\
    \  end\n  for _, e in ipairs(l2) do\n    if l3[e] == nil then\n      table.insert(s,\
    \ e)\n      l3[e] = true\n    end\n  end\n  return setmetatable(s, Set)\nend",
  "    local uv = {}\n    local c = {}\n    for _, v in ipairs(l1) do\n        uv[v]\
    \ = true\n    end\n    for _, v in ipairs(l2) do\n        if uv[v] then\n    \
    \        uv[v] = nil\n            table.insert(c, v)\n        end\n    end\n \
    \   return c\nend", "  local common = {}\n  for _, x in ipairs(l1) do\n    for\
    \ _, y in ipairs(l2) do\n      if x == y then\n        common[#common + 1] = x\n\
    \      end\n    end\n  end\n  local sorted = {}\n  for _, x in ipairs(common)\
    \ do\n    if not sorted[x] then\n      sorted[#sorted + 1] = x\n      sorted[x]\
    \ = true\n    end\n  end\n  return sorted\nend", "  local u = unique(insert_all(copy(l1),\
    \ l2))\n  local r = {}\n  for _, v in ipairs(u) do\n    if contains(l1, v) and\
    \ contains(l2, v) then\n      table.insert(r, v)\n    end\n  end\n  return r\n\
    end", "\tlocal tab = {}\n\tfor _, v in ipairs(l1) do\n\t\tif contains(l2, v) then\n\
    \t\t\ttab[#tab + 1] = v\n\t\tend\n\tend\n\tsort(tab)\n\treturn tab\nend", "  local\
    \ l3 = {}\n  for i, v in ipairs(l1) do\n    if contains(l2, v) then\n      table.insert(l3,\
    \ v)\n    end\n  end\n  table.sort(l3)\n  return l3\nend", "  local t1 = type(l1)\n\
    \  local t2 = type(l2)\n  assert(t1 == \"table\" and t2 == \"table\",\n    \"\
    common(): both arguments must be tables.\")\n  assert(#l1 >= 1 and #l2 >= 1,\n\
    \    \"common(): both arguments must have at least one element.\")\n  local out\
    \ = {}\n  for i = 1, #l1 do\n    for j = 1, #l2 do\n      if l1[i] == l2[j] then\n\
    \        t_insert(out, l1[i])\n      end\n    end\n  end\n  sort(out)\n  return\
    \ out\nend", "  local set1 = {}\n  local set2 = {}\n  for _, value in ipairs(l1)\
    \ do\n    set1[value] = true\n  end\n  for _, value in ipairs(l2) do\n    set2[value]\
    \ = true\n  end\n  local result = {}\n  for value in pairs(set1) do\n    if set2[value]\
    \ then\n      table.insert(result, value)\n    end\n  end\n  table.sort(result)\n\
    \  return result\nend", "  local res = {}\n  for i = 1, #l1 do\n    for j = 1,\
    \ #l2 do\n      if l1[i] == l2[j] then\n        table.insert(res, l1[i])\n   \
    \   end\n    end\n  end\n  table.sort(res)\n  return res\nend", "  local r = {}\n\
    \  for k, v in pairs(l1) do\n    if l2[v] then r[v] = true end\n  end\n  local\
    \ rr = {}\n  for k, v in pairs(r) do\n    rr[#rr+1] = k\n  end\n  return rr\n\
    end", "\tlocal t1 = {}\n\tlocal t2 = {}\n\tfor _, v in ipairs(l1) do\n\t\tt1[v]\
    \ = true\n\tend\n\tfor _, v in ipairs(l2) do\n\t\tt2[v] = true\n\tend\n\tlocal\
    \ t = {}\n\tfor k, _ in pairs(t1) do\n\t\tif t2[k] then\n\t\t\tt[#t + 1] = k\n\
    \t\tend\n\tend\n\ttable.sort(t)\n\treturn t\nend", "    local d1, d2 = {}, {}\n\
    \    for _, v in ipairs(l1) do d1[v] = true end\n    for _, v in ipairs(l2) do\
    \ d2[v] = true end\n    local res = {}\n    for v in pairs(d1) do\n        if\
    \ d2[v] then table.insert(res, v) end\n    end\n    table.sort(res)\n    return\
    \ res\nend", "    local ret = {}\n    local i = 1\n    local j = 1\n    local\
    \ last = math.max(#l1, #l2)\n    while i <= #l1 and j <= #l2 do\n        if l1[i]\
    \ == l2[j] then\n            ret[#ret + 1] = l1[i]\n            i = i + 1\n  \
    \          j = j + 1\n        elseif l1[i] < l2[j] then\n            i = i + 1\n\
    \        else\n            j = j + 1\n        end\n    end\n    return ret\nend",
  "    local m = {}\n    local r = {}\n    local max, min\n    if #l1 < #l2 then\n\
    \        min = l1\n        max = l2\n    else\n        min = l2\n        max =\
    \ l1\n    end\n    for i, v in ipairs(min) do\n        m[v] = true\n    end\n\
    \    for i, v in ipairs(max) do\n        if m[v] == true then\n            table.insert(r,\
    \ v)\n        end\n    end\n    return r\nend", "  local list = {}\n  local count\
    \ = 0\n  local i1, i2 = 1, 1\n  while i1 <= #l1 and i2 <= #l2 do\n    if l1[i1]\
    \ == l2[i2] then\n      count = count + 1\n      list[count] = l1[i1]\n      i1\
    \ = i1 + 1\n      i2 = i2 + 1\n    elseif l1[i1] < l2[i2] then\n      i1 = i1\
    \ + 1\n    else\n      i2 = i2 + 1\n    end\n  end\n  return list\nend", "   \
    \ local t = {}\n    for i = 1, #l1 do\n        for j = 1, #l2 do\n           \
    \ if l1[i] == l2[j] then\n                t[#t + 1] = l1[i]\n            end\n\
    \        end\n    end\n    return sorted_unique(t)\nend", "  local i, j, result\
    \ = 1, 1, {}\n  l1, l2 = sorted(l1), sorted(l2)\n  while i <= #l1 and j <= #l2\
    \ do\n    if l1[i] == l2[j] then\n      result[#result + 1] = l1[i]\n      i,\
    \ j = i + 1, j + 1\n    elseif l1[i] < l2[j] then\n      i = i + 1\n    else\n\
    \      j = j + 1\n    end\n  end\n  return result\nend", "  local keys = {}\n\
    \  local res = {}\n  for _, v in ipairs(l1) do\n    keys[v] = true\n  end\n  for\
    \ _, v in ipairs(l2) do\n    if keys[v] then\n      table.insert(res, v)\n   \
    \ end\n  end\n  table.sort(res)\n  return res\nend", "    local a, b = {}, {}\n\
    \    for k in pairs(l1) do a[k] = true end\n    for k in pairs(l2) do b[k] = true\
    \ end\n    local r = {}\n    for k in pairs(a) do\n        if b[k] then r[#r+1]\
    \ = k end\n    end\n    sort(r)\n    return r\nend", "    -- This function is\
    \ implemented using a linked list, so the length of\n    -- the result is the\
    \ length of the shorter list.\n    local list = setmetatable({}, {__index = {\n\
    \        n = 0,\n        nxt = nil,\n        val = nil,\n    }})\n    local ptr\
    \ = list\n    for _, i in ipairs(l1) do\n        -- Insert value into sorted position\
    \ in linked list.\n        local val = i\n        local prev = nil\n        while\
    \ ptr ~= nil and ptr.val < val do\n            prev = ptr\n            ptr = ptr.nxt\n\
    \        end\n        if ptr == nil or ptr.val ~= val then\n            -- Don't\
    \ insert duplicate values.\n            if prev == nil then\n                --\
    \ Insert value at head of list.\n                local new = {\n             \
    \       n = 1,\n                    nxt = list,\n                    val = val,\n\
    \                }\n                setmetatable(new, {__index = list})\n    \
    \            list = new\n            else\n                -- Insert value after\
    \ previous element.\n                local new = {\n                    n = prev.n\
    \ + 1,\n                    nxt = prev.nxt,\n                    val = val,\n\
    \                }\n                prev.nxt = new\n            end\n        end\n\
    \    end\n    local res = {}\n    local ptr = list\n    for _, i in ipairs(l2)\
    \ do\n        -- Iterate through list, checking for values less than i.\n    \
    \    while ptr ~= nil and ptr.val < i do\n            ptr = ptr.nxt\n        end\n\
    \        if ptr ~= nil and ptr.val == i then\n            -- Only include values\
    \ for which i == ptr.val.\n            table.insert(res, i)\n        end\n   \
    \ end\n    return res\nend", "    local r, s = {}, {}\n    for _, v in ipairs(l1)\
    \ do if not s[v] then s[v] = true; r[#r+1] = v end end\n    for _, v in ipairs(l2)\
    \ do if s[v] then s[v] = nil; r[#r+1] = v end end\n    return r\nend", "  local\
    \ r = {}\n  for _, v in ipairs(l1) do\n    for _, v2 in ipairs(l2) do\n      if\
    \ v == v2 then\n        r[#r + 1] = v\n      end\n    end\n  end\n  table.sort(r)\n\
    \  return r\nend", "  local t = {}\n  for _, k in ipairs(l1) do\n    if contains(l2,\
    \ k) then\n      table.insert(t, k)\n    end\n  end\n  return sort(t)\nend", " \
    \ if #l1 == 0 or #l2 == 0 then return {} end\n  local uniq1 = unique(l1)\n  local\
    \ uniq2 = unique(l2)\n  local common = {}\n  for i = 1, #uniq1 do\n    local val\
    \ = uniq1[i]\n    for j = 1, #uniq2 do\n      if val == uniq2[j] then table.insert(common,\
    \ val) end\n    end\n  end\n  return common\nend", "  local t = {}\n  for k, v\
    \ in pairs(l1) do\n    t[v] = true\n  end\n  for k, v in pairs(l2) do\n    if\
    \ t[v] then\n      t[v] = nil\n      t[#t + 1] = v\n    end\n  end\n  table.sort(t)\n\
    \  return t\nend", "  local result = {}\n  for _, v in ipairs(l1) do\n    if contains(l2,\
    \ v) then\n      insert(result, v)\n    end\n  end\n  return sort(unique(result))\n\
    end", "  local r = {}\n  for _, v in ipairs(l1) do\n    if find(l2, v) then\n\
    \      r[#r + 1] = v\n    end\n  end\n  table.sort(r)\n  return r\nend", "   \
    \ local res = {}\n    for _, v in ipairs(l1) do\n        if indexOf(l2, v) ~=\
    \ -1 then\n            append(res, v)\n        end\n    end\n    return sort(res)\n\
    end", "    local t = {}\n    for _, v in ipairs(l1) do\n        if contains(l2,\
    \ v) then\n            insert(t, v)\n        end\n    end\n    return unique(t)\n\
    end", "\treturn sorted_set(intersect(keys(l1), keys(l2)))\nend", "    local ret\
    \ = {}\n    for k, v in pairs(l1) do\n        if l2[v] then\n            ret[v]\
    \ = true\n        end\n    end\n    return to_array(ret)\nend", "    return remove_duplicates(intersect(l1,\
    \ l2))\nend", "    local ret = {}\n    for _, v in ipairs(l1) do\n        for\
    \ _, v2 in ipairs(l2) do\n            if v == v2 then\n                table.insert(ret,\
    \ v)\n            end\n        end\n    end\n    table.sort(ret)\n    return ret\n\
    end", "  assert(type(l1) == 'table' and type(l2) == 'table', 'common: must be\
    \ invoked with two tables')\n  local t = {}\n  for i=1,#l1 do\n    t[l1[i]] =\
    \ true\n  end\n  local res = {}\n  for i=1,#l2 do\n    if t[l2[i]] then\n    \
    \  res[#res+1] = l2[i]\n    end\n  end\n  sort(res)\n  return res\nend", "  local\
    \ r = {}\n  local seen = {}\n  for _, v in ipairs(l1) do seen[v] = v end\n  for\
    \ _, v in ipairs(l2) do\n    if seen[v] then r[#r+1] = v end\n  end\n  return\
    \ sort(r)\nend", "  local t = {}\n  local f = {}\n  for _, v in ipairs(l1) do\n\
    \    t[v] = true\n  end\n  for _, v in ipairs(l2) do\n    if t[v] then f[#f+1]\
    \ = v end\n  end\n  sort(f)\n  return f\nend", "  local t = {}\n  for _, v in\
    \ ipairs(l1) do\n    if v ~= nil and l2[v] then\n      t[#t+1] = v\n    end\n\
    \  end\n  return t\nend", "    local ret = {}\n    local found = {}\n    for _,\
    \ v in ipairs(l1) do\n        if not found[v] then\n            for _, v2 in ipairs(l2)\
    \ do\n                if v == v2 then\n                    ret[#ret + 1] = v\n\
    \                    found[v] = true\n                    break\n            \
    \    end\n            end\n        end\n    end\n    table.sort(ret)\n    return\
    \ ret\nend", "\tlocal result = {}\n\tfor i = 1, #l1 do\n\t\tfor j = 1, #l2 do\n\
    \t\t\tif l1[i] == l2[j] then\n\t\t\t\tif not contains(result, l1[i]) then\n\t\t\
    \t\t\ttable.insert(result, l1[i])\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\
    return result\nend", "  assert(type(l1) == 'table', 'Tried to find common elements\
    \ in a non-table')\n  assert(type(l2) == 'table', 'Tried to find common elements\
    \ in a non-table')\n  local ret = {}\n  local s = {}\n  for _,v in ipairs(l1)\
    \ do\n    if not s[v] then\n      s[v] = true\n      table.insert(ret, v)\n  \
    \  end\n  end\n  for _,v in ipairs(l2) do\n    if s[v] then\n      s[v] = nil\n\
    \      table.insert(ret, v)\n    end\n  end\n  table.sort(ret)\n  return ret\n\
    end", "    local l = {}\n    for _, v in ipairs(l1) do\n        if contains(l2,\
    \ v) then\n            l[#l + 1] = v\n        end\n    end\n    return sort(l)\n\
    end", "\tlocal l = {}\n\tlocal all = #l1 > #l2 and l1 or l2\n\tlocal min = #l1\
    \ > #l2 and l2 or l1\n\tfor _, v in ipairs(min) do\n\t\tif table.find(all, v)\
    \ then\n\t\t\ttable.insert(l, v)\n\t\tend\n\tend\n\ttable.sort(l)\n\treturn l\n\
    end", "\tlocal t1 = {}\n\tlocal t2 = {}\n\tlocal result = {}\n\tfor _, x in ipairs(l1)\
    \ do\n\t\tt1[x] = true\n\tend\n\tfor _, x in ipairs(l2) do\n\t\tt2[x] = true\n\
    \tend\n\tfor k, _ in pairs(t1) do\n\t\tif t2[k] then\n\t\t\ttable.insert(result,\
    \ k)\n\t\tend\n\tend\n\ttable.sort(result)\n\treturn result\nend", "    return\
    \ set_index(l1) * set_index(l2)\nend", "  local r = {}\n  for i,v in ipairs(l1)\
    \ do\n    if not is_in(r, v) and is_in(l2, v) then\n      table.insert(r, v)\n\
    \    end\n  end\n  return r\nend", "    local res = {}\n    for _, v in ipairs(l1)\
    \ do\n        if contains(l2, v) then\n            res[#res + 1] = v\n       \
    \ end\n    end\n    return res\nend", "  local ret = {}\n  local uniq = {}\n \
    \ for _, v in ipairs(l1) do\n    if not uniq[v] then\n      uniq[v] = true\n \
    \     ret[#ret + 1] = v\n    end\n  end\n  for _, v in ipairs(l2) do\n    if uniq[v]\
    \ then\n      uniq[v] = nil\n      ret[#ret + 1] = v\n    end\n  end\n  table.sort(ret)\n\
    \  return ret\nend", "    local d1, d2 = {}, {}\n    for _, v in ipairs(l1) do\
    \ d1[v] = true end\n    for _, v in ipairs(l2) do d2[v] = true end\n    local\
    \ d3 = {}\n    for i, v in pairs(d1) do\n        if d2[i] then d3[#d3 + 1] = i\
    \ end\n    end\n    return utils.sort(d3)\nend", "    local result = {}\n    for\
    \ k, v in pairs(l1) do\n        if l2[v] then\n            result[v] = v\n   \
    \     end\n    end\n    local keys = {}\n    for k, _ in pairs(result) do\n  \
    \      table.insert(keys, k)\n    end\n    table.sort(keys)\n    local values\
    \ = {}\n    for _, k in ipairs(keys) do\n        table.insert(values, result[k])\n\
    \    end\n    return values\nend", "  local ret = {}\n  local map = {}\n  for\
    \ _, v in ipairs(l1) do\n    if not map[v] then\n      map[v] = true\n      table.insert(ret,\
    \ v)\n    end\n  end\n  for _, v in ipairs(l2) do\n    if map[v] then\n      map[v]\
    \ = nil\n      table.insert(ret, v)\n    end\n  end\n  table.sort(ret)\n  return\
    \ ret\nend", "    local function cmp_value(v1, v2)\n        return v1 < v2\n \
    \   end\n    local function common_list(list)\n        local values = {}\n   \
    \     for _, v in ipairs(list) do\n            if values[v] then\n           \
    \     values[v] = values[v] + 1\n            else\n                values[v] =\
    \ 1\n            end\n        end\n        local common = {}\n        for value,\
    \ count in pairs(values) do\n            if count > 1 then\n                table.insert(common,\
    \ value)\n            end\n        end\n        table.sort(common, cmp_value)\n\
    \        return common\n    end\n    return common_list(l1) + common_list(l2)\n\
    end", "    local t = {}\n    for i,v in ipairs(l1) do\n        for j,w in ipairs(l2)\
    \ do\n            if v == w then\n                table.insert(t, v)\n       \
    \     end\n        end\n    end\n    return unique(t)\nend", "    local t = {}\n\
    \    local c = {}\n    for _,v in ipairs(l1) do\n        t[v] = true\n    end\n\
    \    for _,v in ipairs(l2) do\n        if t[v] then\n            table.insert(c,\
    \ v)\n        end\n    end\n    table.sort(c)\n    return c\nend", "    return\
    \ setmetatable(\n        d.uniq(l1) & d.uniq(l2),\n        d.readonly_mt\n   \
    \ )\nend", "\tlocal r = {}\n\tfor _, v in ipairs(l1) do\n\t\tif index(l2, v) then\n\
    \t\t\tr[#r + 1] = v\n\t\tend\n\tend\n\treturn sort(r)\nend", "  return sort(unique(intersect(l1,\
    \ l2)))\nend", "\tlocal s = set()\n\tfor _, l in ipairs({l1, l2}) do\n\t\tfor\
    \ _, v in ipairs(l) do\n\t\t\ts[v] = true\n\t\tend\n\tend\n\tlocal r = {}\n\t\
    for k in pairs(s) do\n\t\tr[#r+1] = k\n\tend\n\ttable.sort(r)\n\treturn r\nend",
  "    local t1 = {}\n    local t2 = {}\n    local result = {}\n    local has_value\n\
    \    for _, v in ipairs(l1) do t1[v] = true end\n    for _, v in ipairs(l2) do\
    \ t2[v] = true end\n    for k in pairs(t1) do\n        has_value = false\n   \
    \     for k2 in pairs(t2) do\n            if k == k2 then\n                has_value\
    \ = true\n                break\n            end\n        end\n        if has_value\
    \ then\n            table.insert(result, k)\n        end\n    end\n    return\
    \ sorted(result)\nend", "  local out = {}\n  local h = {}\n  local i = 1\n  for\
    \ _, n in pairs(l1) do\n    if i > #l2 then break end\n    if n == l2[i] then\n\
    \      out[#out + 1] = n\n      i = i + 1\n    elseif n > l2[i] then\n      i\
    \ = i + 1\n    end\n  end\n  return out\nend", "  return keys(intersect(l1, l2))\n\
    end", "  return iter(l1)\n    :map(function(v) return _contains(l2, v) and v end)\n\
    \    :filter(id)\n    :sort()\n    :uniq()\n    :totable()\nend", "    local list\
    \ = {}\n    for _, v in ipairs(l1) do\n        list[v] = true\n    end\n    for\
    \ _, v in ipairs(l2) do\n        if list[v] then\n            list[v] = nil\n\
    \            list[#list + 1] = v\n        end\n    end\n    sort(list)\n    return\
    \ list\nend", "  local t = {}\n  for k, v in pairs(l1) do t[v] = true end\n  for\
    \ k, v in pairs(l2) do if t[v] then t[v] = nil end end\n  local r = {}\n  for\
    \ k, v in pairs(t) do r[#r + 1] = k end\n  sort(r)\n  return r\nend", "  assertTable(l1)\n\
    \  assertTable(l2)\n  local hash = {}\n  local res = {}\n  for _, v in ipairs(l1)\
    \ do\n    hash[v] = true\n  end\n  for _, v in ipairs(l2) do\n    if hash[v] then\n\
    \      res[#res + 1] = v\n    end\n  end\n  return sort(res)\nend", "\tlocal ret\
    \ = {}\n\tfor _, v in ipairs(l1) do\n\t\tfor _, v2 in ipairs(l2) do\n\t\t\tif\
    \ v == v2 then\n\t\t\t\tret[#ret + 1] = v\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ table.sort(table.unique(ret))\nend", "  local t1 = map(l1, true)\n  local t2\
    \ = map(l2, true)\n  local t = {}\n  for key, val in pairs(t1) do\n    if t2[key]\
    \ then\n      t[#t + 1] = key\n    end\n  end\n  sort(t)\n  return t\nend", " \
    \   if #l1 > #l2 then\n        l1, l2 = l2, l1\n    end\n    local r = {}\n  \
    \  for _, v in ipairs(l1) do\n        if table_util.contains(l2, v) then\n   \
    \         table.insert(r, v)\n        end\n    end\n    table.sort(r)\n    return\
    \ set(r)\nend", "  local t = {}\n  for i, v in ipairs(l1) do\n    if l2[v] then\
    \ t[#t+1] = v end\n  end\n  table.sort(t)\n  return t\nend", "    local all =\
    \ {}\n    for _, v in ipairs(l1) do\n        all[v] = true\n    end\n    for _,\
    \ v in ipairs(l2) do\n        if all[v] then\n            all[v] = v\n       \
    \ end\n    end\n    local res = {}\n    for _, v in pairs(all) do\n        if\
    \ v then\n            table.insert(res, v)\n        end\n    end\n    table.sort(res)\n\
    \    return res\nend", "    local r = {}\n    for _, v in ipairs(l1) do\n    \
    \    if contains(l2, v) then\n            r[#r + 1] = v\n        end\n    end\n\
    \    return r\nend", "  return set(l1):intersection(l2):values()\nend", "  return\
    \ set(l1):intersection(l2):totable()\nend", "    local set = {}\n    local r =\
    \ {}\n    local n = 1\n    for _, v in ipairs(l1) do\n        if not set[v] then\n\
    \            set[v] = true\n            r[n] = v\n            n = n + 1\n    \
    \    end\n    end\n    local n = 1\n    for _, v in ipairs(l2) do\n        if\
    \ set[v] then\n            r[n] = v\n            n = n + 1\n        end\n    end\n\
    \    return r\nend", "    local result = {}\n    local result_map = {}\n    local\
    \ n1 = #l1\n    local n2 = #l2\n    local i1 = 1\n    local i2 = 1\n    while\
    \ i1 <= n1 and i2 <= n2 do\n        local v1 = l1[i1]\n        local v2 = l2[i2]\n\
    \        if v1 == v2 then\n            result_map[v1] = true\n            i1 =\
    \ i1 + 1\n            i2 = i2 + 1\n        elseif v1 < v2 then\n            i1\
    \ = i1 + 1\n        else\n            i2 = i2 + 1\n        end\n    end\n    for\
    \ v in pairs(result_map) do\n        result[#result + 1] = v\n    end\n    return\
    \ result\nend", "  local l = {}\n  for v in items(l1) do\n    l[v] = true\n  end\n\
    \  for k,v in pairs(l2) do\n    if l[v] then\n      l[v] = nil\n      l[#l+1]\
    \ = v\n    end\n  end\n  return l\nend", "\tlocal c = {}\n\tfor k, v in pairs(l1)\
    \ do\n\t\tif contains(l2, v) then\n\t\t\tc[k] = v\n\t\tend\n\tend\n\treturn uniq(c)\n\
    end", "    local a, b = {}, {}\n    for _, k in ipairs(l1) do\n        a[k] =\
    \ true\n    end\n    for _, k in ipairs(l2) do\n        if a[k] then\n       \
    \     b[#b + 1] = k\n        end\n    end\n    sort(b)\n    return b\nend", "\t\
    local common = {}\n\tlocal index = {}\n\tfor _, v in ipairs(l1) do\n\t\tif not\
    \ index[v] then\n\t\t\tcommon[#common + 1] = v\n\t\t\tindex[v] = true\n\t\tend\n\
    \tend\n\tfor _, v in ipairs(l2) do\n\t\tif index[v] then\n\t\t\tcommon[#common\
    \ + 1] = v\n\t\t\tindex[v] = nil\n\t\tend\n\tend\n\treturn sort(common)\nend",
  "    local ret = {}\n    for k, v in pairs(l1) do\n        if l2[v] then\n     \
    \       table.insert(ret, v)\n        end\n    end\n    return ret\nend", "  return\
    \ table.keys(set(l1, l2))\nend", "    local t1 = unique(l1)\n    local t2 = unique(l2)\n\
    \    local res = {}\n    local i1, i2 = 1, 1\n    while t1[i1] and t2[i2] do\n\
    \        if t1[i1] == t2[i2] then\n            table.insert(res, t1[i1])\n   \
    \         i1 = i1 + 1\n            i2 = i2 + 1\n        elseif t1[i1] < t2[i2]\
    \ then\n            i1 = i1 + 1\n        else\n            i2 = i2 + 1\n     \
    \   end\n    end\n    return res\nend", "    if #l1 == 0 or #l2 == 0 then\n  \
    \      return {}\n    end\n    local t1 = {}\n    local t2 = {}\n    local result\
    \ = {}\n    for _, v in ipairs(l1) do\n        t1[v] = v\n    end\n    for _,\
    \ v in ipairs(l2) do\n        t2[v] = v\n    end\n    for k, _ in pairs(t1) do\n\
    \        if t2[k] then\n            table.insert(result, k)\n        end\n   \
    \ end\n    table.sort(result)\n    return result\nend", "    if (not l1) or (not\
    \ l2) then\n        return {}\n    end\n    local res = {}\n    for _, e in ipairs(l1)\
    \ do\n        for _, f in ipairs(l2) do\n            if (e == f) and (not table.contains(res,\
    \ e)) then\n                table.insert(res, e)\n            end\n        end\n\
    \    end\n    table.sort(res)\n    return res\nend", "\tlocal set = {}\n\tfor\
    \ i = 1, #l1 do\n\t\tset[l1[i]] = true\n\tend\n\tlocal res = {}\n\tfor i = 1,\
    \ #l2 do\n\t\tif set[l2[i]] then\n\t\t\tres[#res + 1] = l2[i]\n\t\tend\n\tend\n\
    \treturn sort(res)\nend", "  if type(l1) ~= 'table' or type(l2) ~= 'table' then\
    \ return {} end\n  local common = {}\n  for _, v in ipairs(l1) do\n    if contains(l2,\
    \ v) then\n      common[#common + 1] = v\n    end\n  end\n  return common\nend",
  "  return sorted(unique(l1)) * sorted(unique(l2))\nend", "    local h = {}\n   \
    \ for _, v in ipairs(l1) do\n        h[v] = true\n    end\n    local result =\
    \ {}\n    for _, v in ipairs(l2) do\n        if h[v] then\n            table.insert(result,\
    \ v)\n        end\n    end\n    table.sort(result)\n    return result\nend", " \
    \   local res = {}\n    for _, v in ipairs(l1) do\n        if in_table(v, l2)\
    \ then\n            res[#res + 1] = v\n        end\n    end\n    table.sort(res)\n\
    \    return uniq(res)\nend", "\tlocal t = {}\n\tfor v in values(l1) do\n\t\tif\
    \ find(l2, v) then t[#t+1] = v end\n\tend\n\tsort(t)\n\treturn t\nend", "    local\
    \ ret = {}\n    for _, x in ipairs(l1) do\n        for _, y in ipairs(l2) do\n\
    \            if x == y then\n                table.insert(ret, x)\n          \
    \  end\n        end\n    end\n    table.sort(ret)\n    return ret\nend", "  local\
    \ h = {}\n  for _, v in ipairs(l1) do\n    h[v] = true\n  end\n  local r = {}\n\
    \  for _, v in ipairs(l2) do\n    if h[v] then\n      r[#r + 1] = v\n    end\n\
    \  end\n  return sort(r)\nend", "    local r = {}\n    for i = 1, #l1 do\n   \
    \     for j = 1, #l2 do\n            if l1[i] == l2[j] then\n                r[#r\
    \ + 1] = l1[i]\n            end\n        end\n    end\n    table.sort(r)\n   \
    \ return r\nend", "  local c = {}\n  local seen = {}\n  for i, v in ipairs(l1)\
    \ do\n    seen[v] = true\n  end\n  for i, v in ipairs(l2) do\n    if seen[v] then\n\
    \      table.insert(c, v)\n    end\n  end\n  table.sort(c)\n  return c\nend",
  "  local t = {}\n  for _, x in ipairs(l1) do\n    if find(l2, x) then t[#t+1] =\
    \ x end\n  end\n  return sort(t)\nend", "  local s = {}\n  local res = {}\n  for\
    \ _, v in ipairs(l1) do\n    s[v] = true\n  end\n  for _, v in ipairs(l2) do\n\
    \    if s[v] then\n      res[#res+1] = v\n    end\n  end\n  return sort_unique(res)\n\
    end", "  local res = {}\n  for _, v in ipairs(l1) do\n    if indexOf(l2, v) then\n\
    \      res[#res + 1] = v\n    end\n  end\n  return res\nend", "  local ret = {}\n\
    \  local hash = {}\n  for i = 1, #l1 do\n    hash[l1[i]] = true\n  end\n  for\
    \ i = 1, #l2 do\n    if hash[l2[i]] then\n      ret[#ret + 1] = l2[i]\n    end\n\
    \  end\n  table.sort(ret)\n  return ret\nend", "    local t = {}\n    for i =\
    \ 1, #l1 do\n        local v = l1[i]\n        for j = 1, #l2 do\n            if\
    \ v == l2[j] then\n                t[#t + 1] = v\n                break\n    \
    \        end\n        end\n    end\n    table.sort(t)\n    return t\nend", " \
    \ local t = {}\n  local ts = {}\n  local a = 0\n  local u1 = unique(l1)\n  local\
    \ u2 = unique(l2)\n  for _, v in ipairs(u1) do\n    for _, v2 in ipairs(u2) do\n\
    \      if v == v2 then\n        t[a] = v\n        a = a + 1\n      end\n    end\n\
    \  end\n  for _, v in ipairs(t) do\n    if #ts == 0 then\n      ts[0] = v\n  \
    \  else\n      local i = 0\n      while i < #ts do\n        if v < ts[i] then\n\
    \          insert(ts, i, v)\n          break\n        elseif i == #ts - 1 then\n\
    \          ts[#ts] = v\n          break\n        end\n        i = i + 1\n    \
    \  end\n    end\n  end\n  return ts\nend", "    local set = {}\n    for _, v in\
    \ ipairs(l1) do\n        set[v] = true\n    end\n    local intersection = {}\n\
    \    for _, v in ipairs(l2) do\n        if set[v] then\n            intersection[#intersection\
    \ + 1] = v\n        end\n    end\n    table.sort(intersection)\n    return intersection\n\
    end", "\tlocal result = {}\n\tlocal i = 0\n\tfor x in pairs(l1) do\n\t\tif l2[x]\
    \ then\n\t\t\ti = i + 1\n\t\t\tresult[i] = x\n\t\tend\n\tend\n\tsort(result)\n\
    \treturn result\nend", "  local l3 = {}\n  for _, v in ipairs(l1) do\n    for\
    \ _, v2 in ipairs(l2) do\n      if v == v2 then\n        table.insert(l3, v)\n\
    \      end\n    end\n  end\n  return unique(l3)\nend", "  local t1 = {}\n  local\
    \ t2 = {}\n  for _, v in ipairs(l1) do\n    t1[v] = true\n  end\n  for _, v in\
    \ ipairs(l2) do\n    t2[v] = true\n  end\n  local t = {}\n  for k, _ in pairs(t1)\
    \ do\n    if t2[k] then\n      t[#t + 1] = k\n    end\n  end\n  return t\nend",
  "  local result = {}\n  local t1 = type(l1)\n  local t2 = type(l2)\n  if t1 ~= 'table'\
    \ or t2 ~= 'table' then\n    error('Common: Expected two tables, but got ' ..\
    \ t1 .. ' and ' .. t2)\n  end\n  if t1 == 'table' and t2 == 'table' then\n   \
    \ for _, v in ipairs(l1) do\n      if find(l2, v) then\n        insert(result,\
    \ v)\n      end\n    end\n  end\n  sort(result)\n  return result\nend", "  local\
    \ t = {}\n  local i, v\n  for i, v in ipairs(l1) do\n    if contains(l2, v) then\
    \ t[#t+1] = v end\n  end\n  return sorted(t)\nend", "    local ret = {}\n    for\
    \ _, v in ipairs(l1) do\n        if index_of(l2, v) then\n            tinsert(ret,\
    \ v)\n        end\n    end\n    return reverse(sort(ret))\nend", "    if type(l1)\
    \ ~= 'table' or type(l2) ~= 'table' then\n        return {}\n    end\n    local\
    \ t = {}\n    for _, v in ipairs(l1) do\n        if ipairs(l2)[v] ~= nil then\n\
    \            t[#t + 1] = v\n        end\n    end\n    return unique(t)\nend",
  "    local s = {}\n    for _, v in ipairs(l1) do\n        if in_table(v, l2) then\n\
    \            s[#s + 1] = v\n        end\n    end\n    return s\nend", "    local\
    \ t = {}\n    local r = {}\n    for _, v in ipairs(l1) do\n        t[v] = v\n\
    \    end\n    for _, v in ipairs(l2) do\n        if t[v] then\n            r[#r+1]\
    \ = v\n        end\n    end\n    table.sort(r)\n    return r\nend", "  local t\
    \ = {}\n  for i = 1, #l1 do\n    t[l1[i]] = 1\n  end\n  for i = 1, #l2 do\n  \
    \  if t[l2[i]] then\n      t[l2[i]] = t[l2[i]] + 1\n    else\n      t[l2[i]] =\
    \ 1\n    end\n  end\n  local res = {}\n  for k, v in pairs(t) do\n    if v > 1\
    \ then\n      res[#res + 1] = k\n    end\n  end\n  table.sort(res)\n  return res\n\
    end", "  local ret = {}\n  local c = 0\n  local i = 1\n  while i <= #l1 do\n \
    \   local j = 1\n    while j <= #l2 do\n      if l1[i] == l2[j] then\n       \
    \ if c == 0 then\n          ret[1] = l1[i]\n          c = 1\n        else\n  \
    \        local m = 1\n          while m <= c do\n            if ret[m] > l1[i]\
    \ then\n              break\n            end\n            m = m + 1\n        \
    \  end\n          if ret[m] ~= l1[i] then\n            c = c + 1\n           \
    \ for n = c, m + 1, -1 do\n              ret[n] = ret[n - 1]\n            end\n\
    \            ret[m] = l1[i]\n          end\n        end\n      end\n      j =\
    \ j + 1\n    end\n    i = i + 1\n  end\n  return ret\nend", "  local t = {}\n\
    \  local ret = {}\n  if (#l1 == 0 or #l2 == 0) then return {} end\n  for _, v\
    \ in ipairs(l1) do\n    t[v] = 1\n  end\n  for _, v in ipairs(l2) do\n    if t[v]\
    \ then\n      ret[#ret + 1] = v\n    end\n  end\n  table.sort(ret)\n  return ret\n\
    end", "  local ids = {}\n  for _, v in ipairs(l1) do\n    ids[v] = true\n  end\n\
    \  local result = {}\n  for _, v in ipairs(l2) do\n    if ids[v] then\n      table.insert(result,\
    \ v)\n    end\n  end\n  table.sort(result)\n  return result\nend", "    local\
    \ result = {}\n    for _,v in ipairs(l1) do\n        for _,v2 in ipairs(l2) do\n\
    \            if v == v2 then\n                table.insert(result, v)\n      \
    \      end\n        end\n    end\n    table.sort(result)\n    return result\n\
    end", "\tlocal out = {}\n\tfor k, _ in pairs(l1) do\n\t\tif l2[k] then out[k]\
    \ = true end\n\tend\n\tlocal out_list = {}\n\tfor k, _ in pairs(out) do out_list[#out_list\
    \ + 1] = k end\n\ttable.sort(out_list)\n\treturn out_list\nend", "  local r =\
    \ {}\n  for _, v in ipairs(l1) do\n    if not not_common[v] and not unique_check[v]\
    \ then\n      unique_check[v] = true\n      for _, v2 in ipairs(l2) do\n     \
    \   if v == v2 then\n          r[#r + 1] = v\n          break\n        end\n \
    \     end\n    end\n  end\n  for _, v in ipairs(r) do\n    unique_check[v] = nil\n\
    \  end\n  return r\nend", "    local common = {}\n    for k, v in pairs(l1) do\n\
    \        if l2[v] then\n            common[#common + 1] = v\n        end\n   \
    \ end\n    return sort(common)\nend", "    local t = {}\n    for _, v in ipairs(l1)\
    \ do\n        if contains(l2, v) then\n            if not contains(t, v) then\n\
    \                t[#t + 1] = v\n            end\n        end\n    end\n    sort(t)\n\
    \    return t\nend", "\tif not l1 or not l2 then return {} end\n\tlocal res =\
    \ {}\n\tfor _, v in ipairs(l1) do\n\t\tif util.contains(l2, v) then\n\t\t\ttable.insert(res,\
    \ v)\n\t\tend\n\tend\n\treturn util.numsort(res)\nend", "    local res = {}\n\
    \    for _, v in ipairs(l1) do\n        if find(l2, v) then\n            res[#res\
    \ + 1] = v\n        end\n    end\n    return sort(res)\nend", "  local ret = {}\n\
    \  for k,v in pairs(l1) do\n    if type(v) == 'table' then\n      if l2[k] and\
    \ #v > 0 and #l2[k] > 0 then\n        local common_table = common(v, l2[k])\n\
    \        if #common_table > 0 then\n          ret[k] = common_table\n        end\n\
    \      end\n    else\n      if l2[k] and l2[k] == v then\n        ret[k] = v\n\
    \      end\n    end\n  end\n  return ret\nend", "  local c = {}\n  local map =\
    \ {}\n  for _, v in ipairs(l1) do\n    map[v] = true\n  end\n  for _, v in ipairs(l2)\
    \ do\n    if map[v] then\n      c[#c + 1] = v\n    end\n  end\n  table.sort(c)\n\
    \  return c\nend", "  local c = {}\n  local seen = {}\n  for _, v in ipairs(l1)\
    \ do\n    if list.contains(l2, v) and not seen[v] then\n      c[#c+1] = v\n  \
    \    seen[v] = true\n    end\n  end\n  return c\nend", "    local t = {}\n   \
    \ for k, v in pairs(l1) do\n        if l2[v] then\n            t[v] = v\n    \
    \    end\n    end\n    local r = {}\n    for k, v in pairs(t) do\n        r[#r\
    \ + 1] = v\n    end\n    table.sort(r)\n    return r\nend", "    local result\
    \ = {}\n    for _, v in ipairs(l1) do\n        for _, vv in ipairs(l2) do\n  \
    \          if v == vv then table.insert(result, v) end\n        end\n    end\n\
    \    return sort_unique(result)\nend", "    local a = {}\n    local b = {}\n \
    \   for k,v in pairs(l1) do\n        a[v] = true\n    end\n    for k,v in pairs(l2)\
    \ do\n        if a[v] then\n            b[v] = true\n        end\n    end\n  \
    \  return sorted_keys(b)\nend", "    local lut = {}\n    for _, v in ipairs(l1)\
    \ do\n        lut[v] = true\n    end\n    local ret = {}\n    for _, v in ipairs(l2)\
    \ do\n        if lut[v] then\n            table.insert(ret, v)\n        end\n\
    \    end\n    table.sort(ret)\n    return ret\nend", "  local t = {}\n  for _,\
    \ v in ipairs(l1) do\n    t[v] = true\n  end\n  local r = {}\n  for _, v in ipairs(l2)\
    \ do\n    if t[v] then\n      r[#r + 1] = v\n    end\n  end\n  sort(r)\n  return\
    \ r\nend", "    local out = {}\n    for i, e in ipairs(l1) do\n        for j,\
    \ f in ipairs(l2) do\n            if e == f then\n                tinsert(out,\
    \ e)\n                break\n            end\n        end\n    end\n    return\
    \ table.sort(out)\nend", "\tlocal r = {}\n\tfor i, v in ipairs(l1) do\n\t\tfor\
    \ j, w in ipairs(l2) do\n\t\t\tif v == w then\n\t\t\t\tinsert(r, v)\n\t\t\t\t\
    break\n\t\t\tend\n\t\tend\n\tend\n\treturn unique(r)\nend", "    local found =\
    \ {}\n    for i, a in ipairs(l1) do\n        for j, b in ipairs(l2) do\n     \
    \       if a == b and not found[a] then\n                found[a] = true\n   \
    \         end\n        end\n    end\n    local res = {}\n    for k, v in pairs(found)\
    \ do\n        table.insert(res, k)\n    end\n    return res\nend", "\tlocal r\
    \ = {}\n\tl1 = l1 or {}\n\tl2 = l2 or {}\n\tfor _, v in ipairs(l1) do\n\t\tif\
    \ match(l2, v) then\n\t\t\ttable.insert(r, v)\n\t\tend\n\tend\n\tsort(r)\n\treturn\
    \ r\nend", "    local copy = {}\n    for _, v in ipairs(l1) do copy[v] = true\
    \ end\n    for _, v in ipairs(l2) do\n        if copy[v] then\n            copy[v]\
    \ = nil\n            copy[#copy+1] = v\n        end\n    end\n    return copy\n\
    end", "    local c = {}\n    local map = {}\n    for _,v in ipairs(l1) do\n  \
    \      map[v] = true\n    end\n    for _,v in ipairs(l2) do\n        if map[v]\
    \ then\n            c[#c+1] = v\n        end\n    end\n    sort(c)\n    return\
    \ c\nend", "    local common = {}\n    local seen = {}\n    for _, v in ipairs(l1)\
    \ do\n        seen[v] = true\n    end\n    for _, v in ipairs(l2) do\n       \
    \ if seen[v] then\n            table.insert(common, v)\n        end\n    end\n\
    \    return common\nend", "    if type(l1) ~= 'table' or type(l2) ~= 'table' then\n\
    \        error(\"Table expected\")\n    end\n    local l3 = {}\n    for _, e in\
    \ ipairs(l1) do\n        if contains(l2, e) then\n            append(l3, e)\n\
    \        end\n    end\n    return sort(l3)\nend", "    local s = {}\n    for _,\
    \ v in ipairs(l1) do\n        if contains(l2, v) then s[#s+1] = v end\n    end\n\
    \    return sort_uniq(s)\nend", "  local c = {}\n  for k, v in pairs(l1) do c[v]\
    \ = true end\n  for k, v in pairs(l2) do c[v] = (c[v] and true or nil) end\n \
    \ local a = {}\n  for k, v in pairs(c) do a[#a+1] = k end\n  table.sort(a)\n \
    \ return a\nend", "    local r = {}\n    local ri = 1\n    local l1i, l2i = 1,\
    \ 1\n    while l1i <= #l1 and l2i <= #l2 do\n        if l1[l1i] == l2[l2i] then\n\
    \            r[ri] = l1[l1i]\n            ri = ri + 1\n            l1i = l1i +\
    \ 1\n            l2i = l2i + 1\n        elseif l1[l1i] < l2[l2i] then\n      \
    \      l1i = l1i + 1\n        else\n            l2i = l2i + 1\n        end\n \
    \   end\n    return r\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
