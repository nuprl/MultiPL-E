name: HumanEval_115_max_fill
language: lua
results:
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ add_top(grid, i, j)\n    if i >= 1 and grid[i][j] ~= 1 then\n      grid[i][j]\
    \ = 1\n      return true\n    end\n    return false\n  end\n  local function fill_top(grid,\
    \ capacity)\n    local filled = {}\n    for j = 1, #grid[1] do\n      for i =\
    \ #grid, 1, -1 do\n        local is_filled = add_top(grid, i, j)\n        if is_filled\
    \ then\n          filled[#filled + 1] = true\n          if #filled == capacity\
    \ then return end\n        end\n      end\n    end\n  end\n  local function is_filled(grid)\n\
    \    for i = 1, #grid do\n      for j = 1, #grid[1] do\n        if grid[i][j]\
    \ == 0 then return false end\n      end\n    end\n    return true\n  end\n  local\
    \ function is_not_filled(grid)\n    return not is_filled(grid)\n  end\n  local\
    \ fills = 0\n  repeat\n    fill_top(grid, capacity)\n    fills = fills + 1\n \
    \ until is_filled(grid)\n  return fills - 1\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc4kbwjlc.lua:64:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmpc4kbwjlc.lua:64: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local rows =\
    \ #grid\n  local cols = #grid[1]\n  local tot = 0\n  for _ = 1, capacity do\n\
    \    local min = 10\n    for _, r in ipairs(grid) do\n      if min == 0 then break\
    \ end\n      for _, c in ipairs(r) do\n        if c == 1 then\n          min =\
    \ 0\n          break\n        end\n      end\n    end\n    if min == 0 then\n\
    \      for c = 1, cols do\n        for r = 1, rows do\n          if grid[r][c]\
    \ == 1 then\n            grid[r][c] = 0\n            tot = tot + 1\n         \
    \   if r < rows then\n              grid[r + 1][c] = 1\n            end\n    \
    \      end\n        end\n      end\n    end\n  end\n  return tot\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa1b2tr_9.lua:57:\
    \ expected: 6, actual: 7\nstack traceback:\n\t/tmp/tmpa1b2tr_9.lua:57: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local drop_count\
    \ = 0\n  local well_count = #grid[1]\n  local water_count = 0\n  for row_index,\
    \ row in ipairs(grid) do\n    local biggest_consecutive_count = 0\n    local consecutive_count\
    \ = 0\n    for cell_index, cell in ipairs(row) do\n      if cell == 1 then\n \
    \       consecutive_count = consecutive_count + 1\n      else\n        if consecutive_count\
    \ > biggest_consecutive_count then\n          biggest_consecutive_count = consecutive_count\n\
    \        end\n        consecutive_count = 0\n      end\n    end\n    if consecutive_count\
    \ > biggest_consecutive_count then\n      biggest_consecutive_count = consecutive_count\n\
    \    end\n    local allowed_max_consecutive_count = capacity\n    local needed_consecutive_count\
    \ = biggest_consecutive_count - allowed_max_consecutive_count\n    if needed_consecutive_count\
    \ > 0 then\n      local needed_drop_count = math.ceil(needed_consecutive_count\
    \ / capacity)\n      local allowed_consecutive_count = needed_consecutive_count\
    \ - (needed_drop_count * capacity)\n      local allowed_row_count = math.ceil(allowed_consecutive_count\
    \ / well_count)\n      drop_count = drop_count + needed_drop_count\n      water_count\
    \ = water_count + (allowed_consecutive_count - (allowed_row_count * well_count))\n\
    \    end\n  end\n  return drop_count\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr7cl1u14.lua:58:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpr7cl1u14.lua:58: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local num_rows\
    \ = #grid\n    local num_cols = #grid[1]\n    local buckets = {}\n    local new_buckets\
    \ = {}\n    for i = 1, num_rows do\n        local bucket = 0\n        for j =\
    \ 1, num_cols do\n            bucket = bucket + grid[i][j]\n        end\n    \
    \    buckets[i] = bucket\n    end\n    local total_buckets = math.ceil(num_rows\
    \ * num_cols / capacity)\n    local bucket_num = 0\n    local bucket_dist = {}\n\
    \    for i = 1, num_rows do\n        for j = 1, num_cols do\n            local\
    \ dist = 0\n            for k = i - 1, 1, -1 do\n                if grid[k][j]\
    \ == 1 then\n                    dist = dist + 1\n                end\n      \
    \      end\n            table.insert(bucket_dist, dist)\n        end\n    end\n\
    \    local function is_lower(i, j)\n        return (i > 1 and grid[i - 1][j] ==\
    \ 1) or (j > 1 and grid[i][j - 1] == 1)\n    end\n    local function add_bucket()\n\
    \        bucket_num = bucket_num + 1\n        local bucket_index = bucket_num\
    \ % num_rows\n        local bucket_height = buckets[bucket_index]\n        new_buckets[bucket_index]\
    \ = bucket_height\n        local bucket_height_remaining = capacity\n        while\
    \ bucket_height_remaining > 0 do\n            local min_dist = math.huge\n   \
    \         local min_dist_pos = -1\n            for j = 1, #bucket_dist do\n  \
    \              if bucket_dist[j] > 0 and bucket_dist[j] < min_dist then\n    \
    \                min_dist = bucket_dist[j]\n                    min_dist_pos =\
    \ j\n                end\n            end\n            if min_dist_pos == -1 then\n\
    \                break\n            end\n            local pos = {math.floor((min_dist_pos\
    \ - 1) / num_cols) + 1, (min_dist_pos - 1) % num_cols + 1}\n            local\
    \ min_dist_val =\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp5q_alfml.lua:71: unexpected symbol near '='\n"
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ min(a, b) return a < b and a or b end\n  local function get_column(grid, column)\n\
    \    local result = {}\n    for i = 1, #grid do\n      table.insert(result, grid[i][column])\n\
    \    end\n    return result\n  end\n  local function count_empty_and_fill(rows,\
    \ capacity)\n    local total_empty = 0\n    local total_filled = 0\n    for i\
    \ = 1, #rows do\n      local row = rows[i]\n      local current_empty = 0\n  \
    \    local current_filled = 0\n      for j = 1, #row do\n        if row[j] ==\
    \ 0 then\n          current_empty = current_empty + 1\n        else\n        \
    \  current_filled = current_filled + 1\n        end\n      end\n      if current_empty\
    \ == 0 then\n        total_filled = total_filled + current_filled\n      else\n\
    \        total_empty = total_empty + current_empty\n        local filled = min(current_empty,\
    \ capacity)\n        total_filled = total_filled + filled\n        current_empty\
    \ = current_empty - filled\n        total_empty = total_empty + current_empty\n\
    \      end\n    end\n    return total_empty, total_filled\n  end\n  local result\
    \ = 0\n  for i = 1, #grid[1] do\n    local total_empty, total_filled = count_empty_and_fill(get_column(grid,\
    \ i), capacity)\n    result = result + total_empty + total_filled\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdukrhnvw.lua:38:\
    \ attempt to get length of a number value (local 'row')\nstack traceback:\n\t\
    /tmp/tmpdukrhnvw.lua:38: in local 'count_empty_and_fill'\n\t/tmp/tmpdukrhnvw.lua:59:\
    \ in local 'candidate'\n\t/tmp/tmpdukrhnvw.lua:68: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local n =\
    \ grid.length\n    local width = grid[1].length\n    local sum = 0\n    for x\
    \ = 1, n do\n        for y = 1, width do\n            sum = sum + grid[x][y]\n\
    \        end\n    end\n    return sum * capacity\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpylhm3qng.lua:26:\
    \ 'for' limit must be a number\nstack traceback:\n\t/tmp/tmpylhm3qng.lua:26: in\
    \ local 'candidate'\n\t/tmp/tmpylhm3qng.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local result\
    \ = 0\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpx_zlo9m4.lua:35: 'end' expected (to close 'function' at line\
    \ 22) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local level\
    \ = 0\n    local best = 0\n    local rows = #grid\n    local columns = #grid[1]\n\
    \    local row, column = 0, 0\n    while true do\n        level = level + 1\n\
    \        for row = 0, rows-1 do\n            for column = 0, columns-1 do\n  \
    \              if grid[row+1][column+1] >= level then\n                    grid[row+1][column+1]\
    \ = grid[row+1][column+1] - capacity\n                    if grid[row+1][column+1]\
    \ < level then\n                        grid[row+1][column+1] = 0\n          \
    \          end\n                    best = best + 1\n                end\n   \
    \         end\n        end\n        if level == capacity then\n            break\n\
    \        end\n    end\n    return best\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa2rvlftk.lua:52:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmpa2rvlftk.lua:52: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  return nil\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7bn0gweb.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmp7bn0gweb.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local m =\
    \ #grid\n    local n = #grid[1]\n    local s = 0\n    for i=1,m do\n        for\
    \ j=1,n do\n            if grid[i][j] == 1 then\n                local row_sum\
    \ = 0\n                for k=1,n do\n                    row_sum = row_sum + grid[i][k]\n\
    \                end\n                if row_sum > capacity then\n           \
    \         for k=1,n do\n                        grid[i][k] = 0\n             \
    \       end\n                    s = s + capacity\n                else\n    \
    \                for k=1,n do\n                        grid[i][k] = 0\n      \
    \              end\n                    s = s + row_sum\n                end\n\
    \            end\n        end\n    end\n    return s\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmhwx4p4x.lua:53:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpmhwx4p4x.lua:53: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local num_rows\
    \ = #grid\n  local num_cols = #grid[1]\n  local low = 0\n  local high = 1 + grid[1][1]\n\
    \  local min_num_fills = num_rows * num_cols\n  while high <= capacity do\n  \
    \  local num_fills = 0\n    local val = (low + high) / 2\n    for i = 1, num_rows\
    \ do\n      for j = 1, num_cols do\n        if grid[i][j] <= val then\n      \
    \    num_fills = num_fills + (val - grid[i][j])\n        end\n      end\n    end\n\
    \    if num_fills < min_num_fills then\n      high = val + 1\n      min_num_fills\
    \ = num_fills\n    else\n      low = val + 1\n    end\n  end\n  return min_num_fills\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaxb12h6i.lua:51:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpaxb12h6i.lua:51: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ fill(current_fill, remaining_walls)\n    if #remaining_walls == 0 then\n   \
    \   return 0\n    end\n    local wall = remaining_walls[1]\n    local max_so_far\
    \ = current_fill\n    local max_fill = 0\n    for i = 1, #wall do\n      local\
    \ num_filled = 0\n      local wells_filled = 0\n      for j = i, #wall do\n  \
    \      local well = wall[j]\n        wells_filled = wells_filled + well\n    \
    \    num_filled = num_filled + 1\n        if wells_filled > capacity then\n  \
    \        break\n        end\n        max_fill = math.max(max_fill, num_filled\
    \ + fill(max_so_far + wells_filled, {table.unpack(remaining_walls, 2, #remaining_walls)}))\n\
    \      end\n    end\n    return max_fill\n  end\n  return fill(0, grid)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8wrueaew.lua:51:\
    \ expected: 6, actual: 9\nstack traceback:\n\t/tmp/tmp8wrueaew.lua:51: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp14qsa4r4.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmp14qsa4r4.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local n_steps\
    \ = 0\n    local n_wells = #grid\n    local n_levels = #grid[1]\n    local max_depth\
    \ = {}\n    for i = 1, n_wells do\n        max_depth[i] = 0\n        for j = 1,\
    \ n_levels do\n            if grid[i][j] == 1 then\n                max_depth[i]\
    \ = j\n            end\n        end\n    end\n    repeat\n        local max_reach\
    \ = 0\n        for i = 1, n_wells do\n            if max_depth[i] > max_reach\
    \ then\n                max_reach = max_depth[i]\n            end\n        end\n\
    \        for i = 1, n_wells do\n            max_depth[i] = max_depth[i] - capacity\n\
    \            if max_depth[i] < 0 then\n                max_depth[i] = 0\n    \
    \        end\n        end\n        n_steps = n_steps + 1\n    until max_reach\
    \ == 0\n    return n_steps\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb7ha7rhh.lua:56:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmpb7ha7rhh.lua:56: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local max_total = 0\n    local idx =\
    \ 1\n    local changes = {}\n    while true do\n        local max_row = 0\n  \
    \      local max_row_idx = 0\n        for i=1, rows do\n            local sum\
    \ = 0\n            for j=1, cols do\n                sum = sum + grid[i][j]\n\
    \            end\n            if sum > max_row then\n                max_row =\
    \ sum\n                max_row_idx = i\n            end\n        end\n       \
    \ if max_row == 0 then\n            break\n        end\n        for j=1, cols\
    \ do\n            grid[max_row_idx][j] = 0\n        end\n        local change\
    \ = max_row - capacity\n        if change >= 0 then\n            for j=1, cols\
    \ do\n                grid[max_row_idx][j] = grid[max_row_idx][j] + change\n \
    \           end\n            max_total = max_total + change\n            changes[idx]\
    \ = idx .. \") \" .. change\n            idx = idx + 1\n        end\n    end\n\
    \    print(\"Bucket lowering count: \" .. max_total)\n    print(\"Lowering list:\"\
    )\n    for _, v in ipairs(changes) do\n        print(v)\n    end\n    return max_total\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "Bucket lowering count: 4099276460824344813\nLowering list:\n1) 3\n2) 11\n\
    3) 43\n4) 171\n5) 683\n6) 2731\n7) 10923\n8) 43691\n9) 174763\n10) 699051\n11)\
    \ 2796203\n12) 11184811\n13) 44739243\n14) 178956971\n15) 715827883\n16) 2863311531\n\
    17) 11453246123\n18) 45812984491\n19) 183251937963\n20) 733007751851\n21) 2932031007403\n\
    22) 11728124029611\n23) 46912496118443\n24) 187649984473771\n25) 750599937895083\n\
    26) 3002399751580331\n27) 12009599006321323\n28) 48038396025285291\n29) 192153584101141163\n\
    30) 768614336404564651\n31) 3074457345618258603\n32) 0\n33) 0\nF\nFailed tests:\n\
    -------------\n1) test_humaneval\n/tmp/tmpqv34a3ja.lua:68: expected: 6, actual:\
    \ 4099276460824344813\nstack traceback:\n\t/tmp/tmpqv34a3ja.lua:68: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    return (0)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsghd13r2.lua:29:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmpsghd13r2.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  if not grid\
    \ or #grid == 0 then return 0 end\n  local row_count = #grid\n  local row_length\
    \ = #grid[1]\n  local times = 0\n  -- total water in each bucket\n  local bucket\
    \ = {}\n  -- water left in the wells\n  local wells = {}\n  -- bucket fill index\n\
    \  local b = 1\n  -- wells fill index\n  local w = 1\n  -- append the water to\
    \ bucket\n  local function add_water(amount)\n    if amount > 0 then\n      bucket[b]\
    \ = bucket[b] or 0\n      bucket[b] = bucket[b] + amount\n      b = b % row_length\
    \ + 1\n      times = times + 1\n    end\n  end\n  -- retrieve water from wells\n\
    \  local function get_water(amount)\n    wells[w] = wells[w] or 0\n    if wells[w]\
    \ < amount then\n      amount = wells[w]\n    end\n    wells[w] = wells[w] - amount\n\
    \    w = w % row_length + 1\n    return amount\n  end\n  -- fill the wells\n \
    \ for _, row in ipairs(grid) do\n    for _, water in ipairs(row) do\n      wells[w]\
    \ = (wells[w] or 0) + water\n      w = w % row_length + 1\n    end\n  end\n  --\
    \ start draining the wells\n  while true do\n    local total_water = 0\n    --\
    \ calculate the total water in each bucket\n    for _, water in ipairs(bucket)\
    \ do\n      total_water = total_water + water\n    end\n    -- check if there\
    \ is still water left in the wells\n    if total_water == 0 then\n      local\
    \ total_wells = 0\n      for _, water in ipairs(wells) do\n        total_wells\
    \ = total_wells + water\n      end\n      if total_wells == 0 then\n        break\n\
    \      end\n    end\n    -- fill the buckets\n    for i = 1, row_length do\n \
    \     local water = get_water(capacity)\n      add_water(water)\n    end\n  end\n\
    \  return times\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- your code\
    \ goes here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqv9qgzub.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpqv9qgzub.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local water_units\
    \ = 0\n    local level = 0\n    local w_len = #grid[1]\n    while true do\n  \
    \      local is_level = false\n        local j = 1\n        while j <= w_len do\n\
    \            if grid[1][j] ~= 0 then\n                local k = 1\n          \
    \      while k <= capacity and j <= w_len do\n                    if grid[1][j]\
    \ ~= 0 then\n                        grid[1][j] = 0\n                        water_units\
    \ = water_units + 1\n                        is_level = true\n               \
    \     end\n                    k = k + 1\n                    j = j + 1\n    \
    \            end\n            else\n                j = j + 1\n            end\n\
    \        end\n        if not is_level then\n            break\n        end\n \
    \       level = level + 1\n        local x_len = #grid\n        local i = x_len\n\
    \        while i > 1 do\n            local j = 1\n            while j <= w_len\
    \ do\n                if grid[i][j] ~= 0 then\n                    local k = 1\n\
    \                    while k <= capacity and j <= w_len do\n                 \
    \       if grid[i][j] ~= 0 then\n                            grid[i][j] = 0\n\
    \                            water_units = water_units + 1\n                 \
    \       end\n                        k = k + 1\n                        j = j\
    \ + 1\n                    end\n                else\n                    j =\
    \ j + 1\n                end\n            end\n            i = i - 1\n       \
    \ end\n    end\n    return water_units\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_pms3jrc.lua:78:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmp_pms3jrc.lua:78: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  if #grid ==\
    \ 0 then return 0 end\n  local empties = 0\n  local capacity = capacity or 1\n\
    \  for i = 1, #grid do\n    local wells = {}\n    for j = 1, #grid[i] do\n   \
    \   if grid[i][j] == 1 then\n        wells[#wells + 1] = { row = i, column = j\
    \ }\n      end\n    end\n    while #wells > 0 do\n      local filled = 0\n   \
    \   local water = capacity\n      while water > 0 and #wells > 0 do\n        if\
    \ grid[wells[1].row][wells[1].column] == 1 then\n          water = water - 1\n\
    \          filled = filled + 1\n          grid[wells[1].row][wells[1].column]\
    \ = 0\n        end\n        table.remove(wells, 1)\n      end\n      if filled\
    \ > 0 then\n        empties = empties + 1\n      end\n    end\n  end\n  return\
    \ empties\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
