language: lua
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ add_top(grid, i, j)\n    if i >= 1 and grid[i][j] ~= 1 then\n      grid[i][j]\
    \ = 1\n      return true\n    end\n    return false\n  end\n  local function fill_top(grid,\
    \ capacity)\n    local filled = {}\n    for j = 1, #grid[1] do\n      for i =\
    \ #grid, 1, -1 do\n        local is_filled = add_top(grid, i, j)\n        if is_filled\
    \ then\n          filled[#filled + 1] = true\n          if #filled == capacity\
    \ then return end\n        end\n      end\n    end\n  end\n  local function is_filled(grid)\n\
    \    for i = 1, #grid do\n      for j = 1, #grid[1] do\n        if grid[i][j]\
    \ == 0 then return false end\n      end\n    end\n    return true\n  end\n  local\
    \ function is_not_filled(grid)\n    return not is_filled(grid)\n  end\n  local\
    \ fills = 0\n  repeat\n    fill_top(grid, capacity)\n    fills = fills + 1\n \
    \ until is_filled(grid)\n  return fills - 1\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc4kbwjlc.lua:64:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmpc4kbwjlc.lua:64: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local rows =\
    \ #grid\n  local cols = #grid[1]\n  local tot = 0\n  for _ = 1, capacity do\n\
    \    local min = 10\n    for _, r in ipairs(grid) do\n      if min == 0 then break\
    \ end\n      for _, c in ipairs(r) do\n        if c == 1 then\n          min =\
    \ 0\n          break\n        end\n      end\n    end\n    if min == 0 then\n\
    \      for c = 1, cols do\n        for r = 1, rows do\n          if grid[r][c]\
    \ == 1 then\n            grid[r][c] = 0\n            tot = tot + 1\n         \
    \   if r < rows then\n              grid[r + 1][c] = 1\n            end\n    \
    \      end\n        end\n      end\n    end\n  end\n  return tot\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa1b2tr_9.lua:57:\
    \ expected: 6, actual: 7\nstack traceback:\n\t/tmp/tmpa1b2tr_9.lua:57: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local drop_count\
    \ = 0\n  local well_count = #grid[1]\n  local water_count = 0\n  for row_index,\
    \ row in ipairs(grid) do\n    local biggest_consecutive_count = 0\n    local consecutive_count\
    \ = 0\n    for cell_index, cell in ipairs(row) do\n      if cell == 1 then\n \
    \       consecutive_count = consecutive_count + 1\n      else\n        if consecutive_count\
    \ > biggest_consecutive_count then\n          biggest_consecutive_count = consecutive_count\n\
    \        end\n        consecutive_count = 0\n      end\n    end\n    if consecutive_count\
    \ > biggest_consecutive_count then\n      biggest_consecutive_count = consecutive_count\n\
    \    end\n    local allowed_max_consecutive_count = capacity\n    local needed_consecutive_count\
    \ = biggest_consecutive_count - allowed_max_consecutive_count\n    if needed_consecutive_count\
    \ > 0 then\n      local needed_drop_count = math.ceil(needed_consecutive_count\
    \ / capacity)\n      local allowed_consecutive_count = needed_consecutive_count\
    \ - (needed_drop_count * capacity)\n      local allowed_row_count = math.ceil(allowed_consecutive_count\
    \ / well_count)\n      drop_count = drop_count + needed_drop_count\n      water_count\
    \ = water_count + (allowed_consecutive_count - (allowed_row_count * well_count))\n\
    \    end\n  end\n  return drop_count\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr7cl1u14.lua:58:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpr7cl1u14.lua:58: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local num_rows\
    \ = #grid\n    local num_cols = #grid[1]\n    local buckets = {}\n    local new_buckets\
    \ = {}\n    for i = 1, num_rows do\n        local bucket = 0\n        for j =\
    \ 1, num_cols do\n            bucket = bucket + grid[i][j]\n        end\n    \
    \    buckets[i] = bucket\n    end\n    local total_buckets = math.ceil(num_rows\
    \ * num_cols / capacity)\n    local bucket_num = 0\n    local bucket_dist = {}\n\
    \    for i = 1, num_rows do\n        for j = 1, num_cols do\n            local\
    \ dist = 0\n            for k = i - 1, 1, -1 do\n                if grid[k][j]\
    \ == 1 then\n                    dist = dist + 1\n                end\n      \
    \      end\n            table.insert(bucket_dist, dist)\n        end\n    end\n\
    \    local function is_lower(i, j)\n        return (i > 1 and grid[i - 1][j] ==\
    \ 1) or (j > 1 and grid[i][j - 1] == 1)\n    end\n    local function add_bucket()\n\
    \        bucket_num = bucket_num + 1\n        local bucket_index = bucket_num\
    \ % num_rows\n        local bucket_height = buckets[bucket_index]\n        new_buckets[bucket_index]\
    \ = bucket_height\n        local bucket_height_remaining = capacity\n        while\
    \ bucket_height_remaining > 0 do\n            local min_dist = math.huge\n   \
    \         local min_dist_pos = -1\n            for j = 1, #bucket_dist do\n  \
    \              if bucket_dist[j] > 0 and bucket_dist[j] < min_dist then\n    \
    \                min_dist = bucket_dist[j]\n                    min_dist_pos =\
    \ j\n                end\n            end\n            if min_dist_pos == -1 then\n\
    \                break\n            end\n            local pos = {math.floor((min_dist_pos\
    \ - 1) / num_cols) + 1, (min_dist_pos - 1) % num_cols + 1}\n            local\
    \ min_dist_val =\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp5q_alfml.lua:71: unexpected symbol near ''=''

    '
  stdout: ''
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ min(a, b) return a < b and a or b end\n  local function get_column(grid, column)\n\
    \    local result = {}\n    for i = 1, #grid do\n      table.insert(result, grid[i][column])\n\
    \    end\n    return result\n  end\n  local function count_empty_and_fill(rows,\
    \ capacity)\n    local total_empty = 0\n    local total_filled = 0\n    for i\
    \ = 1, #rows do\n      local row = rows[i]\n      local current_empty = 0\n  \
    \    local current_filled = 0\n      for j = 1, #row do\n        if row[j] ==\
    \ 0 then\n          current_empty = current_empty + 1\n        else\n        \
    \  current_filled = current_filled + 1\n        end\n      end\n      if current_empty\
    \ == 0 then\n        total_filled = total_filled + current_filled\n      else\n\
    \        total_empty = total_empty + current_empty\n        local filled = min(current_empty,\
    \ capacity)\n        total_filled = total_filled + filled\n        current_empty\
    \ = current_empty - filled\n        total_empty = total_empty + current_empty\n\
    \      end\n    end\n    return total_empty, total_filled\n  end\n  local result\
    \ = 0\n  for i = 1, #grid[1] do\n    local total_empty, total_filled = count_empty_and_fill(get_column(grid,\
    \ i), capacity)\n    result = result + total_empty + total_filled\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdukrhnvw.lua:38:\
    \ attempt to get length of a number value (local 'row')\nstack traceback:\n\t\
    /tmp/tmpdukrhnvw.lua:38: in local 'count_empty_and_fill'\n\t/tmp/tmpdukrhnvw.lua:59:\
    \ in local 'candidate'\n\t/tmp/tmpdukrhnvw.lua:68: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local n =\
    \ grid.length\n    local width = grid[1].length\n    local sum = 0\n    for x\
    \ = 1, n do\n        for y = 1, width do\n            sum = sum + grid[x][y]\n\
    \        end\n    end\n    return sum * capacity\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpylhm3qng.lua:26:\
    \ 'for' limit must be a number\nstack traceback:\n\t/tmp/tmpylhm3qng.lua:26: in\
    \ local 'candidate'\n\t/tmp/tmpylhm3qng.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local result\
    \ = 0\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpx_zlo9m4.lua:35: ''end'' expected (to close ''function'' at
    line 22) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local level\
    \ = 0\n    local best = 0\n    local rows = #grid\n    local columns = #grid[1]\n\
    \    local row, column = 0, 0\n    while true do\n        level = level + 1\n\
    \        for row = 0, rows-1 do\n            for column = 0, columns-1 do\n  \
    \              if grid[row+1][column+1] >= level then\n                    grid[row+1][column+1]\
    \ = grid[row+1][column+1] - capacity\n                    if grid[row+1][column+1]\
    \ < level then\n                        grid[row+1][column+1] = 0\n          \
    \          end\n                    best = best + 1\n                end\n   \
    \         end\n        end\n        if level == capacity then\n            break\n\
    \        end\n    end\n    return best\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa2rvlftk.lua:52:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmpa2rvlftk.lua:52: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  return nil\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7bn0gweb.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmp7bn0gweb.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local m =\
    \ #grid\n    local n = #grid[1]\n    local s = 0\n    for i=1,m do\n        for\
    \ j=1,n do\n            if grid[i][j] == 1 then\n                local row_sum\
    \ = 0\n                for k=1,n do\n                    row_sum = row_sum + grid[i][k]\n\
    \                end\n                if row_sum > capacity then\n           \
    \         for k=1,n do\n                        grid[i][k] = 0\n             \
    \       end\n                    s = s + capacity\n                else\n    \
    \                for k=1,n do\n                        grid[i][k] = 0\n      \
    \              end\n                    s = s + row_sum\n                end\n\
    \            end\n        end\n    end\n    return s\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmhwx4p4x.lua:53:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpmhwx4p4x.lua:53: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local num_rows\
    \ = #grid\n  local num_cols = #grid[1]\n  local low = 0\n  local high = 1 + grid[1][1]\n\
    \  local min_num_fills = num_rows * num_cols\n  while high <= capacity do\n  \
    \  local num_fills = 0\n    local val = (low + high) / 2\n    for i = 1, num_rows\
    \ do\n      for j = 1, num_cols do\n        if grid[i][j] <= val then\n      \
    \    num_fills = num_fills + (val - grid[i][j])\n        end\n      end\n    end\n\
    \    if num_fills < min_num_fills then\n      high = val + 1\n      min_num_fills\
    \ = num_fills\n    else\n      low = val + 1\n    end\n  end\n  return min_num_fills\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaxb12h6i.lua:51:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpaxb12h6i.lua:51: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ fill(current_fill, remaining_walls)\n    if #remaining_walls == 0 then\n   \
    \   return 0\n    end\n    local wall = remaining_walls[1]\n    local max_so_far\
    \ = current_fill\n    local max_fill = 0\n    for i = 1, #wall do\n      local\
    \ num_filled = 0\n      local wells_filled = 0\n      for j = i, #wall do\n  \
    \      local well = wall[j]\n        wells_filled = wells_filled + well\n    \
    \    num_filled = num_filled + 1\n        if wells_filled > capacity then\n  \
    \        break\n        end\n        max_fill = math.max(max_fill, num_filled\
    \ + fill(max_so_far + wells_filled, {table.unpack(remaining_walls, 2, #remaining_walls)}))\n\
    \      end\n    end\n    return max_fill\n  end\n  return fill(0, grid)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8wrueaew.lua:51:\
    \ expected: 6, actual: 9\nstack traceback:\n\t/tmp/tmp8wrueaew.lua:51: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp14qsa4r4.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmp14qsa4r4.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local n_steps\
    \ = 0\n    local n_wells = #grid\n    local n_levels = #grid[1]\n    local max_depth\
    \ = {}\n    for i = 1, n_wells do\n        max_depth[i] = 0\n        for j = 1,\
    \ n_levels do\n            if grid[i][j] == 1 then\n                max_depth[i]\
    \ = j\n            end\n        end\n    end\n    repeat\n        local max_reach\
    \ = 0\n        for i = 1, n_wells do\n            if max_depth[i] > max_reach\
    \ then\n                max_reach = max_depth[i]\n            end\n        end\n\
    \        for i = 1, n_wells do\n            max_depth[i] = max_depth[i] - capacity\n\
    \            if max_depth[i] < 0 then\n                max_depth[i] = 0\n    \
    \        end\n        end\n        n_steps = n_steps + 1\n    until max_reach\
    \ == 0\n    return n_steps\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb7ha7rhh.lua:56:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmpb7ha7rhh.lua:56: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local max_total = 0\n    local idx =\
    \ 1\n    local changes = {}\n    while true do\n        local max_row = 0\n  \
    \      local max_row_idx = 0\n        for i=1, rows do\n            local sum\
    \ = 0\n            for j=1, cols do\n                sum = sum + grid[i][j]\n\
    \            end\n            if sum > max_row then\n                max_row =\
    \ sum\n                max_row_idx = i\n            end\n        end\n       \
    \ if max_row == 0 then\n            break\n        end\n        for j=1, cols\
    \ do\n            grid[max_row_idx][j] = 0\n        end\n        local change\
    \ = max_row - capacity\n        if change >= 0 then\n            for j=1, cols\
    \ do\n                grid[max_row_idx][j] = grid[max_row_idx][j] + change\n \
    \           end\n            max_total = max_total + change\n            changes[idx]\
    \ = idx .. \") \" .. change\n            idx = idx + 1\n        end\n    end\n\
    \    print(\"Bucket lowering count: \" .. max_total)\n    print(\"Lowering list:\"\
    )\n    for _, v in ipairs(changes) do\n        print(v)\n    end\n    return max_total\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "Bucket lowering count: 4099276460824344813\nLowering list:\n1) 3\n2) 11\n\
    3) 43\n4) 171\n5) 683\n6) 2731\n7) 10923\n8) 43691\n9) 174763\n10) 699051\n11)\
    \ 2796203\n12) 11184811\n13) 44739243\n14) 178956971\n15) 715827883\n16) 2863311531\n\
    17) 11453246123\n18) 45812984491\n19) 183251937963\n20) 733007751851\n21) 2932031007403\n\
    22) 11728124029611\n23) 46912496118443\n24) 187649984473771\n25) 750599937895083\n\
    26) 3002399751580331\n27) 12009599006321323\n28) 48038396025285291\n29) 192153584101141163\n\
    30) 768614336404564651\n31) 3074457345618258603\n32) 0\n33) 0\nF\nFailed tests:\n\
    -------------\n1) test_humaneval\n/tmp/tmpqv34a3ja.lua:68: expected: 6, actual:\
    \ 4099276460824344813\nstack traceback:\n\t/tmp/tmpqv34a3ja.lua:68: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    return (0)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsghd13r2.lua:29:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmpsghd13r2.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: -1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  if not grid\
    \ or #grid == 0 then return 0 end\n  local row_count = #grid\n  local row_length\
    \ = #grid[1]\n  local times = 0\n  -- total water in each bucket\n  local bucket\
    \ = {}\n  -- water left in the wells\n  local wells = {}\n  -- bucket fill index\n\
    \  local b = 1\n  -- wells fill index\n  local w = 1\n  -- append the water to\
    \ bucket\n  local function add_water(amount)\n    if amount > 0 then\n      bucket[b]\
    \ = bucket[b] or 0\n      bucket[b] = bucket[b] + amount\n      b = b % row_length\
    \ + 1\n      times = times + 1\n    end\n  end\n  -- retrieve water from wells\n\
    \  local function get_water(amount)\n    wells[w] = wells[w] or 0\n    if wells[w]\
    \ < amount then\n      amount = wells[w]\n    end\n    wells[w] = wells[w] - amount\n\
    \    w = w % row_length + 1\n    return amount\n  end\n  -- fill the wells\n \
    \ for _, row in ipairs(grid) do\n    for _, water in ipairs(row) do\n      wells[w]\
    \ = (wells[w] or 0) + water\n      w = w % row_length + 1\n    end\n  end\n  --\
    \ start draining the wells\n  while true do\n    local total_water = 0\n    --\
    \ calculate the total water in each bucket\n    for _, water in ipairs(bucket)\
    \ do\n      total_water = total_water + water\n    end\n    -- check if there\
    \ is still water left in the wells\n    if total_water == 0 then\n      local\
    \ total_wells = 0\n      for _, water in ipairs(wells) do\n        total_wells\
    \ = total_wells + water\n      end\n      if total_wells == 0 then\n        break\n\
    \      end\n    end\n    -- fill the buckets\n    for i = 1, row_length do\n \
    \     local water = get_water(capacity)\n      add_water(water)\n    end\n  end\n\
    \  return times\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- your code\
    \ goes here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqv9qgzub.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpqv9qgzub.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local water_units\
    \ = 0\n    local level = 0\n    local w_len = #grid[1]\n    while true do\n  \
    \      local is_level = false\n        local j = 1\n        while j <= w_len do\n\
    \            if grid[1][j] ~= 0 then\n                local k = 1\n          \
    \      while k <= capacity and j <= w_len do\n                    if grid[1][j]\
    \ ~= 0 then\n                        grid[1][j] = 0\n                        water_units\
    \ = water_units + 1\n                        is_level = true\n               \
    \     end\n                    k = k + 1\n                    j = j + 1\n    \
    \            end\n            else\n                j = j + 1\n            end\n\
    \        end\n        if not is_level then\n            break\n        end\n \
    \       level = level + 1\n        local x_len = #grid\n        local i = x_len\n\
    \        while i > 1 do\n            local j = 1\n            while j <= w_len\
    \ do\n                if grid[i][j] ~= 0 then\n                    local k = 1\n\
    \                    while k <= capacity and j <= w_len do\n                 \
    \       if grid[i][j] ~= 0 then\n                            grid[i][j] = 0\n\
    \                            water_units = water_units + 1\n                 \
    \       end\n                        k = k + 1\n                        j = j\
    \ + 1\n                    end\n                else\n                    j =\
    \ j + 1\n                end\n            end\n            i = i - 1\n       \
    \ end\n    end\n    return water_units\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_pms3jrc.lua:78:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmp_pms3jrc.lua:78: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 0
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  if #grid ==\
    \ 0 then return 0 end\n  local empties = 0\n  local capacity = capacity or 1\n\
    \  for i = 1, #grid do\n    local wells = {}\n    for j = 1, #grid[i] do\n   \
    \   if grid[i][j] == 1 then\n        wells[#wells + 1] = { row = i, column = j\
    \ }\n      end\n    end\n    while #wells > 0 do\n      local filled = 0\n   \
    \   local water = capacity\n      while water > 0 and #wells > 0 do\n        if\
    \ grid[wells[1].row][wells[1].column] == 1 then\n          water = water - 1\n\
    \          filled = filled + 1\n          grid[wells[1].row][wells[1].column]\
    \ = 0\n        end\n        table.remove(wells, 1)\n      end\n      if filled\
    \ > 0 then\n        empties = empties + 1\n      end\n    end\n  end\n  return\
    \ empties\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local max_row\
    \ = 1\n  local filled = 0\n  while max_row > 0 do\n    max_row = 0\n    for r=1,#grid\
    \ do\n      local row = grid[r]\n      local sum = 0\n      for i=1,#row do\n\
    \        sum = sum + row[i]\n      end\n      if sum > 0 then\n        max_row\
    \ = r\n        grid[r] = {}\n        filled = filled + 1\n      end\n    end\n\
    \  end\n  return filled\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk_b2z_64.lua:46:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpk_b2z_64.lua:46: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 0
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local result = 0\n    for row = 1, rows\
    \ do\n        local fill = 0\n        for col = 1, cols do\n            fill =\
    \ fill + grid[row][col]\n        end\n        result = result + math.ceil(fill\
    \ / capacity)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ create_states(states, state, cap)\n        local new_states = {}\n        for\
    \ _, s in ipairs(states) do\n            for i = 1, #s - cap + 1 do\n        \
    \        local new_state = {}\n                for j = 1, #s do\n            \
    \        new_state[j] = math.max(s[j], state[j])\n                end\n      \
    \          table.insert(new_states, new_state)\n            end\n        end\n\
    \        return new_states\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpytby1rm_.lua:47: ''end'' expected (to close ''function'' at
    line 22) near <eof>

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    return grid.map(function(row)\
    \ return row.filter(function(cell) return cell == 1 end).length end).sum() * capacity\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzmc4n990.lua:23:\
    \ attempt to call a nil value (field 'map')\nstack traceback:\n\t/tmp/tmpzmc4n990.lua:23:\
    \ in local 'candidate'\n\t/tmp/tmpzmc4n990.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe9g184hc.lua:28:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpe9g184hc.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal total_water\
    \ = 0\n\t\n\t-- max_water == sum(grid)\n\tfor i = 1, #grid do\n\t\tfor j = 1,\
    \ #grid[i] do\n\t\t\ttotal_water = total_water + grid[i][j]\n\t\tend\n\tend\n\t\
    \n\treturn math.ceil(total_water / capacity)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpolp6dirz.lua:42:\
    \ expected: 2, actual: 1\nstack traceback:\n\t/tmp/tmpolp6dirz.lua:42: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local result\
    \ = 0\n    local m = #grid\n    local n = #grid[1]\n    local level = 0\n    local\
    \ water = 0\n    local stack = {}\n    local stack_top = 0\n    local used = {}\n\
    \    local used_top = 0\n    local function visit(r, c)\n        water = water\
    \ + 1\n        stack_top = stack_top + 1\n        stack[stack_top] = r * n + c\n\
    \        used_top = used_top + 1\n        used[used_top] = r * n + c\n    end\n\
    \    local function fill()\n        local i\n        for i = 1, used_top do\n\
    \            local r = math.floor(used[i] / n)\n            local c = used[i]\
    \ % n\n            grid[r][c] = 1\n        end\n        used_top = 0\n    end\n\
    \    local function empty()\n        local i\n        for i = 1, stack_top do\n\
    \            local r = math.floor(stack[i] / n)\n            local c = stack[i]\
    \ % n\n            grid[r][c] = 0\n        end\n        stack_top = 0\n    end\n\
    \    while true do\n        local i\n        local j\n        water = 0\n    \
    \    level = level + 1\n        -- fill wells\n        for i = 1, m do\n     \
    \       for j = 1, n do\n                if grid[i][j] == 0 then\n           \
    \         visit(i, j)\n                end\n            end\n        end\n   \
    \     if water == 0 then\n            break\n        end\n        if water <=\
    \ capacity then\n            fill()\n            result = result + 1\n       \
    \ else\n            -- empty wells\n            empty()\n            local last_level\
    \ = level\n            -- find next wells\n            for i = 1, m do\n     \
    \           for j = 1, n do\n                    if grid[i][j] == 1 then\n   \
    \                     visit(i, j)\n                    end\n                end\n\
    \            end\n            if last_level == level then\n                break\n\
    \            end\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkp_ng3nb.lua:99:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmpkp_ng3nb.lua:99: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local visited = {}\n    local times\
    \ = 0\n    for i = 1, rows do\n        for j = 1, cols do\n            if grid[i][j]\
    \ == 1 and not visited[i] then\n                times = times + 1\n          \
    \      local bucket = capacity\n                local row = i\n              \
    \  while bucket > 0 and row <= rows do\n                    if grid[row][j] ==\
    \ 1 then\n                        bucket = bucket - 1\n                    end\n\
    \                    visited[row] = true\n                    row = row + 1\n\
    \                end\n            end\n        end\n    end\n    return times\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2k88b47m.lua:49:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmp2k88b47m.lua:49: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local wells\
    \ = {}\n    for _, row in ipairs(grid) do\n        wells[#wells + 1] = row\n \
    \   end\n    table.sort(wells, function(w1, w2)\n        local w1_s = w1:sum()\n\
    \        local w2_s = w2:sum()\n        if w1_s == w2_s then\n            return\
    \ w1[1] < w2[1]\n        end\n        return w1_s > w2_s\n    end)\n    local\
    \ num_lowers = 0\n    for i = #wells, 1, -1 do\n        local fill_col = 1\n \
    \       local well = wells[i]\n        while capacity > 0 and fill_col <= #well\
    \ do\n            local fill_amount = math.min(capacity, well[fill_col])\n   \
    \         capacity = capacity - fill_amount\n            well[fill_col] = well[fill_col]\
    \ - fill_amount\n            fill_col = fill_col + 1\n            num_lowers =\
    \ num_lowers + 1\n        end\n    end\n    return num_lowers\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpoq0b6st7.lua:28:\
    \ attempt to call a nil value (method 'sum')\nstack traceback:\n\t/tmp/tmpoq0b6st7.lua:28:\
    \ in function </tmp/tmpoq0b6st7.lua:27>\n\t[C]: in function 'table.sort'\n\t/tmp/tmpoq0b6st7.lua:27:\
    \ in local 'candidate'\n\t/tmp/tmpoq0b6st7.lua:53: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local row =\
    \ #grid\n  local column = #grid[1]\n  local count = 0\n  local max_value = 0\n\
    \  local i, j\n  for i = 1, row do\n    local max_row = 0\n    for j = 1, column\
    \ do\n      max_row = max_row + grid[i][j]\n    end\n    count = count + max_row\n\
    \    max_value = max(max_value, max_row)\n  end\n  return count + (max_value -\
    \ 1) * (row - 1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbdoztic1.lua:34:\
    \ attempt to call a nil value (global 'max')\nstack traceback:\n\t/tmp/tmpbdoztic1.lua:34:\
    \ in local 'candidate'\n\t/tmp/tmpbdoztic1.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  return 0\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp375bc7wk.lua:29:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmp375bc7wk.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local visited = {}\n    local function\
    \ dfs(row, col)\n        local key = tostring(row) .. tostring(col)\n        if\
    \ visited[key] then\n            return\n        end\n        visited[key] = true\n\
    \        local row_above = row - 1\n        local row_below = row + 1\n      \
    \  local col_left = col - 1\n        local col_right = col + 1\n        if row_above\
    \ >= 1 and grid[row_above][col] == 1 then\n            dfs(row_above, col)\n \
    \       end\n        if row_below <= rows and grid[row_below][col] == 1 then\n\
    \            dfs(row_below, col)\n        end\n        if col_left >= 1 and grid[row][col_left]\
    \ == 1 then\n            dfs(row, col_left)\n        end\n        if col_right\
    \ <= cols and grid[row][col_right] == 1 then\n            dfs(row, col_right)\n\
    \        end\n    end\n    local components = 0\n    for row = 1, rows do\n  \
    \      for col = 1, cols do\n            if grid[row][col] == 1 then\n       \
    \         dfs(row, col)\n                components = components + 1\n       \
    \     end\n        end\n    end\n    return (components * capacity)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp26a1q3pw.lua:65:\
    \ expected: 5, actual: 18\nstack traceback:\n\t/tmp/tmp26a1q3pw.lua:65: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local rows =\
    \ #grid\n  local cols = #grid[1]\n  local wells = {}\n  for _, row in ipairs(grid)\
    \ do\n    table.insert(wells, row)\n  end\n  local i = 1\n  local j = 1\n  local\
    \ count = 0\n  local current_row = 0\n  local next_row = 0\n  while i <= rows\
    \ and j <= cols do\n    current_row = wells[i][j]\n    next_row = 0\n    if current_row\
    \ > 0 then\n      wells[i][j] = current_row - capacity\n      if i < rows then\n\
    \        next_row = wells[i + 1][j]\n        wells[i + 1][j] = next_row + capacity\n\
    \      end\n      count = count + 1\n    end\n    if j == cols then\n      j =\
    \ 1\n      i = i + 1\n    else\n      j = j + 1\n    end\n  end\n  return count\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzux3x4ta.lua:58:\
    \ expected: 6, actual: 7\nstack traceback:\n\t/tmp/tmpzux3x4ta.lua:58: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local height = #grid[1]\n    local function is_full(row, col)\n\
    \        return grid[row][col] == 1\n    end\n    local function lower_bucket(row,\
    \ col)\n        if not is_full(row, col) then\n            return\n        end\n\
    \        grid[row][col] = 0\n        local max_row = height - 1\n        if row\
    \ < max_row then\n            grid[row + 1][col] = 1\n        end\n        if\
    \ col < rows then\n            grid[row][col + 1] = 1\n        end\n    end\n\
    \    local total = rows * height\n    local result = 0\n    for i = 1, total do\n\
    \        if is_full(1, i) then\n            lower_bucket(1, i)\n            result\
    \ = result + 1\n        end\n    end\n    for i = 1, total do\n        for j =\
    \ 1, capacity do\n            if is_full(j, i) then\n                lower_bucket(j,\
    \ i)\n                result = result + 1\n            end\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv3rl8elo.lua:63:\
    \ expected: 6, actual: 1\nstack traceback:\n\t/tmp/tmpv3rl8elo.lua:63: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- Fill in\
    \ the code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk2zsnmpc.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpk2zsnmpc.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: -1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- fill in lines\
    \ we already did\n  local lines_done = {}\n  local rows = #grid\n  local cols\
    \ = #grid[1]\n  local max_count = 0\n  for col = 1, cols do\n    for row = 1,\
    \ rows do\n      if grid[row][col] == 1 and not lines_done[row] then\n       \
    \ lines_done[row] = true\n        max_count = max_count + 1\n      end\n    end\n\
    \  end\n  local last_col = cols\n  while last_col > 0 do\n    local best_row =\
    \ -1\n    local best_count = -1\n    for row = 1, rows do\n      if lines_done[row]\
    \ then\n        local count = 0\n        for col = last_col, 1, -1 do\n      \
    \    if grid[row][col] == 1 then\n            count = count + 1\n          end\n\
    \          if count == capacity then\n            break\n          end\n     \
    \   end\n        if count > best_count then\n          best_count = count\n  \
    \        best_row = row\n        end\n      end\n    end\n    if best_row == -1\
    \ then\n      break\n    end\n    for col = last_col, 1, -1 do\n      if grid[best_row][col]\
    \ == 1 then\n        grid[best_row][col] = 0\n        last_col = col\n       \
    \ break\n      end\n    end\n    max_count = max_count + 1\n  end\n  return max_count\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978084
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ fill_row(row)\n    local wells = {}\n    for i = 1,#row do\n      if row[i]\
    \ == 1 then wells[#wells+1] = i end\n    end\n    return function()\n      if\
    \ #wells > 0 then\n        local ret = wells[1]\n        table.remove(wells, 1)\n\
    \        return ret\n      end\n    end\n  end\n  local function move_bucket(i,\
    \ j)\n    local function helper(i, j)\n      if i == #grid and j == #grid[1] then\
    \ return 0 end\n      if i < #grid and grid[i+1][j] == 1 then\n        return\
    \ helper(i+1, j) + 1\n      elseif j < #grid[1] and grid[i][j+1] == 1 then\n \
    \       return helper(i, j+1) + 1\n      elseif i > 1 and grid[i-1][j] == 1 then\n\
    \        return helper(i-1, j) + 1\n      elseif j > 1 and grid[i][j-1] == 1 then\n\
    \        return helper(i, j-1) + 1\n      else\n        return 1e99\n      end\n\
    \    end\n    return helper(i, j)\n  end\n  local moves = 0\n  local i = 1\n \
    \ local j = 1\n  local bucket = capacity\n  local fill = fill_row(grid[1])\n \
    \ while i <= #grid do\n    local next_move = fill()\n    if next_move then\n \
    \     moves = moves + move_bucket(i, j)\n      j = next_move\n      bucket = capacity\n\
    \    else\n      i = i + 1\n      fill = fill_row(grid[i])\n    end\n    if bucket\
    \ > 0 then\n      moves = moves + 1\n      bucket = bucket - 1\n    end\n  end\n\
    \  return moves\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6fix1dq0.lua:25:\
    \ attempt to get length of a nil value (local 'row')\nstack traceback:\n\t/tmp/tmp6fix1dq0.lua:25:\
    \ in local 'fill_row'\n\t/tmp/tmp6fix1dq0.lua:66: in local 'candidate'\n\t/tmp/tmp6fix1dq0.lua:79:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- your code\
    \ goes here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpetlu2bid.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpetlu2bid.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local result\
    \ = 0\n  local max_row = #grid\n  local max_column = #grid[1]\n  local cur_row\
    \ = 1\n  local cur_column = 1\n  local num_of_buckets = 0\n  local is_visited\
    \ = {}\n  for i = 1, max_row do\n    is_visited[i] = {}\n    for j = 1, max_column\
    \ do\n      is_visited[i][j] = false\n    end\n  end\n  while true do\n    if\
    \ is_visited[cur_row][cur_column] == false then\n      is_visited[cur_row][cur_column]\
    \ = true\n      if grid[cur_row][cur_column] == 1 then\n        num_of_buckets\
    \ = num_of_buckets + 1\n        result = result + 1\n      end\n    end\n    if\
    \ num_of_buckets == capacity then\n      num_of_buckets = 0\n      if (cur_row\
    \ + 1 <= max_row) and (is_visited[cur_row + 1][cur_column] == false) then\n  \
    \      cur_row = cur_row + 1\n      elseif (cur_column + 1 <= max_column) and\
    \ (is_visited[cur_row][cur_column + 1] == false) then\n        cur_column = cur_column\
    \ + 1\n      elseif cur_row ~= 1 then\n        cur_row = cur_row - 1\n      else\n\
    \        break\n      end\n    else\n      if (cur_row + 1 <= max_row) and (is_visited[cur_row\
    \ + 1][cur_column] == false) then\n        cur_row = cur_row + 1\n      elseif\
    \ (cur_column + 1 <= max_column) and (is_visited[cur_row][cur_column + 1] == false)\
    \ then\n        cur_column = cur_column + 1\n      elseif cur_row ~= 1 then\n\
    \        cur_row = cur_row - 1\n      else\n        break\n      end\n    end\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbs1l489_.lua:73:\
    \ expected: 6, actual: 4\nstack traceback:\n\t/tmp/tmpbs1l489_.lua:73: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- your code\
    \ goes here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqv9qgzub.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpqv9qgzub.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local r = 0\n\
    \  for i = 1, #grid do\n    for j = 1, #grid[i] do\n      if grid[i][j] == 1 then\n\
    \        r = r + 1\n        local k = i + 1\n        while k <= #grid and capacity\
    \ > 0 do\n          if grid[k][j] == 1 then\n            grid[k][j] = 0\n    \
    \        capacity = capacity - 1\n          end\n          k = k + 1\n       \
    \ end\n      end\n    end\n    capacity = capacity - 1\n  end\n  return r\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfz7a7_x_.lua:46:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmpfz7a7_x_.lua:46: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ _max_fill(grid, capacity, count)\n    local function _visit(grid, capacity,\
    \ row, count)\n      if row == #grid + 1 then\n        return count\n      end\n\
    \      for i = 1, #grid[row] do\n        if grid[row][i] == 1 then\n         \
    \ grid[row][i] = 0\n          capacity = capacity - 1\n          if capacity ==\
    \ 0 then\n            count = count + 1\n            capacity = capacity + 1\n\
    \          end\n        end\n      end\n      return _visit(grid, capacity, row\
    \ + 1, count)\n    end\n    return _visit(grid, capacity, 1, count)\n  end\n \
    \ return _max_fill(grid, capacity, 0)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7qyb3h91.lua:49:\
    \ expected: 5, actual: 8\nstack traceback:\n\t/tmp/tmp7qyb3h91.lua:49: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- TODO\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvkxwto1_.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpvkxwto1_.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO: add\
    \ implementation\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwdfts7lt.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpwdfts7lt.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local num_lowerings\
    \ = 0\n    local height = #grid\n    local width = #grid[1]\n    local max_level\
    \ = 0\n    for row = 1, height do\n        for col = 1, width do\n           \
    \ max_level = math.max(max_level, grid[row][col])\n        end\n    end\n    local\
    \ cur_level = 0\n    while cur_level < max_level do\n        local water_level\
    \ = {}\n        for col = 1, width do\n            water_level[col] = 0\n    \
    \    end\n        cur_level = cur_level + 1\n        for row = 1, height do\n\
    \            for col = 1, width do\n                if grid[row][col] == cur_level\
    \ then\n                    water_level[col] = water_level[col] + 1\n        \
    \        end\n            end\n        end\n        for col = 1, width do\n  \
    \          local buckets_to_fill = math.ceil(water_level[col] / capacity)\n  \
    \          num_lowerings = num_lowerings + buckets_to_fill\n        end\n    end\n\
    \    return num_lowerings\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5nebru1p.lua:58:\
    \ expected: 5, actual: 6\nstack traceback:\n\t/tmp/tmp5nebru1p.lua:58: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local total_taps\
    \ = 0\n  local rows = #grid\n  local cols = #grid[1]\n  local max = 0\n  for r\
    \ = 1, rows do\n    for c = 1, cols do\n      if grid[r][c] == 1 then\n      \
    \  total_taps = total_taps + 1\n      end\n    end\n  end\n  for c = 1, cols do\n\
    \    local bsize = 0\n    for r = 1, rows do\n      if grid[r][c] == 1 then\n\
    \        bsize = bsize + 1\n      end\n    end\n    max = math.max(max, bsize)\n\
    \  end\n  max = math.min(max, capacity)\n  return total_taps - max\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr41nl25k.lua:50:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmpr41nl25k.lua:50: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal water\
    \ = 0\n\tlocal steps = 0\n\tfor i = 1, #grid do\n\t\tfor j = 1, #grid[i] do\n\t\
    \t\tlocal current = grid[i][j]\n\t\t\tif current == 1 then\n\t\t\t\tlocal less\
    \ = capacity - water\n\t\t\t\tif less > 0 then\n\t\t\t\t\twater = water + less\n\
    \t\t\t\t\tsteps = steps + less\n\t\t\t\tend\n\t\t\t\twater = water - 1\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn steps\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0ik088gm.lua:45:\
    \ expected: 5, actual: 10\nstack traceback:\n\t/tmp/tmp0ik088gm.lua:45: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local max_col_val,\
    \ max_col_pos = 0, 0\n  local max_row_val, max_row_pos = 0, 0\n  local times =\
    \ 0\n  local last_max_pos = 0\n  local i = 0\n  while i < #grid do\n    max_col_val,\
    \ max_col_pos = 0, 0\n    max_row_val, max_row_pos = 0, 0\n    local j = 1\n \
    \   while j <= #grid[i] do\n      if grid[i][j] > max_col_val then\n        max_col_val\
    \ = grid[i][j]\n        max_col_pos = j\n      end\n      j = j + 1\n    end\n\
    \    if max_col_val > 0 then\n      j = 1\n      while j <= #grid[i] do\n    \
    \    grid[i][j] = grid[i][j] - 1\n        j = j + 1\n      end\n      times =\
    \ times + 1\n      if i > last_max_pos then\n        last_max_pos = i\n      end\n\
    \    end\n    i = i + 1\n  end\n  i = 0\n  while i < #grid do\n    local j = 1\n\
    \    while j <= #grid[i] do\n      if grid[i][j] > max_row_val then\n        max_row_val\
    \ = grid[i][j]\n        max_row_pos = i\n      end\n      j = j + 1\n    end\n\
    \    if max_row_val > 0 then\n      j = 1\n      while j <= #grid[i] do\n    \
    \    grid[i][j] = grid[i][j] - 1\n        j = j + 1\n      end\n      times =\
    \ times + 1\n      if i > last_max_pos then\n        last_max_pos = i\n      end\n\
    \    end\n    i = i + 1\n  end\n  return times\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbi1jur6i.lua:32:\
    \ attempt to get length of a nil value (field '?')\nstack traceback:\n\t/tmp/tmpbi1jur6i.lua:32:\
    \ in local 'candidate'\n\t/tmp/tmpbi1jur6i.lua:81: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- TODO: Write\
    \ this\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplz0vo7c7.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmplz0vo7c7.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local rows =\
    \ #grid\n  local cols = #grid[1]\n  local max_height = 0\n  local wells = {}\n\
    \  local buckets = {}\n  for row = 1, rows do\n    local level = 0\n    for col\
    \ = 1, cols do\n      if grid[row][col] == 1 then\n        level = level + 1\n\
    \      end\n      wells[row] = wells[row] or {}\n      wells[row][col] = level\n\
    \      max_height = math.max(max_height, level)\n    end\n  end\n  for row = 1,\
    \ rows do\n    for col = 1, cols do\n      buckets[row] = buckets[row] or {}\n\
    \      buckets[row][col] = capacity\n    end\n  end\n  for height = max_height,\
    \ 1, -1 do\n    for row = 1, rows do\n      for col = 1, cols do\n        local\
    \ bucket = buckets[row][col]\n        local well = wells[row][col]\n        if\
    \ bucket > 0 and well == height then\n          local max_bucket = math.min(bucket,\
    \ well)\n          buckets[row][col] = bucket - max_bucket\n          wells[row][col]\
    \ = well - max_bucket\n          local max_fill = math.min(bucket, well)\n   \
    \       buckets[row - 1] = buckets[row - 1] or {}\n          buckets[row - 1][col]\
    \ = (buckets[row - 1][col] or 0) + max_fill\n          local max_fill = math.min(bucket,\
    \ well)\n          buckets[row + 1] = buckets[row + 1] or {}\n          buckets[row\
    \ + 1][col] = (buckets[row + 1][col] or 0) + max_fill\n          local max_fill\
    \ = math.min(bucket, well)\n          buckets[row][col - 1] = (buckets[row][col\
    \ - 1] or 0) + max_fill\n          local max_fill = math.min(bucket, well)\n \
    \         buckets[row][col + 1] = (buckets[row][col + 1] or 0) + max_fill\n  \
    \      end\n      end\n    end\n \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpxxti_e0b.lua:79: ''end'' expected (to close ''for'' at line
    45) near <eof>

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local total\
    \ = 0\n    local filled = 0\n    for _, row in ipairs(grid) do\n        for _,\
    \ well in ipairs(row) do\n            if well == 1 then\n                total\
    \ = total + 1\n            end\n        end\n    end\n    for _, row in ipairs(grid)\
    \ do\n        for _, well in ipairs(row) do\n            if well == 1 then\n \
    \               filled = filled + 1\n                local drops = math.ceil(filled\
    \ / capacity)\n                if filled == total then\n                    drops\
    \ = drops - 1\n                end\n                total = total + drops\n  \
    \          end\n        end\n    end\n    return total\nend\nreturn max_fill\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpzn_obyht.lua:47: <eof> expected near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local max_rows = math.max(rows, cols)\n\
    \    local min_rows = math.min(rows, cols)\n    local rotations = 0\n    local\
    \ times = 0\n    while rotations < 2 do\n        local current_rows = max_rows\n\
    \        local current_cols = min_rows\n        local current_grid = grid\n  \
    \      if rotations == 1 then\n            current_grid = rotate_grid(grid)\n\
    \            current_rows = min_rows\n            current_cols = max_rows\n  \
    \      end\n        for row = 1, current_rows do\n            for col = 1, current_cols\
    \ do\n                if current_grid[row][col] == 1 then\n                  \
    \  fill_row(current_grid, capacity, row, current_cols)\n                    times\
    \ = times + 1\n                end\n            end\n        end\n        rotations\
    \ = rotations + 1\n    end\n    return times\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpobwd8fxm.lua:41:\
    \ attempt to call a nil value (global 'fill_row')\nstack traceback:\n\t/tmp/tmpobwd8fxm.lua:41:\
    \ in local 'candidate'\n\t/tmp/tmpobwd8fxm.lua:54: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 0
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local max_heights\
    \ = {}\n    for i = 1, #grid do\n        local max_height = 0\n        for j =\
    \ 1, #grid[i] do\n            if grid[i][j] == 1 then\n                max_height\
    \ = max_height + 1\n            end\n        end\n        max_heights[i] = max_height\n\
    \    end\n    local result = 0\n    for i = 1, #max_heights do\n        result\
    \ = result + math.ceil(max_heights[i] / capacity)\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ max_row(row)\n        local sum = 0\n        for _, val in ipairs(row) do\n\
    \            sum = sum + val\n        end\n        return math.ceil(sum / capacity)\n\
    \    end\n    local row_max = 0\n    for _, row in ipairs(grid) do\n        local\
    \ r = max_row(row)\n        if r > row_max then\n            row_max = r\n   \
    \     end\n    end\n    return row_max\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpveb8p4s7.lua:43:\
    \ expected: 6, actual: 4\nstack traceback:\n\t/tmp/tmpveb8p4s7.lua:43: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local grid_height\
    \ = #grid\n    local grid_width = #grid[1]\n    local max_fill_count = 0\n   \
    \ for row_number = 1, grid_height do\n        for column_number = 1, grid_width\
    \ do\n            if grid[row_number][column_number] == 1 then\n             \
    \   max_fill_count = max_fill_count + 1\n            end\n        end\n    end\n\
    \    return max_fill_count * capacity\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpildkpvlh.lua:40:\
    \ expected: 5, actual: 18\nstack traceback:\n\t/tmp/tmpildkpvlh.lua:40: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local count\
    \ = 0\n    local wells = {}\n    local n = #grid[1]\n    for i = 1, #grid do\n\
    \        wells[i] = {}\n        for j = 1, n do\n            wells[i][j] = {grid[i][j],\
    \ 0}\n        end\n    end\n    for i = 1, #wells do\n        for j = 1, n do\n\
    \            if wells[i][j][1] == 1 then\n                for k = 1, capacity\
    \ do\n                    if wells[i][j][2] == 0 then\n                      \
    \  wells[i][j][2] = 1\n                        count = count + 1\n           \
    \         end\n                    if i ~= #wells and wells[i + 1][j][2] == 0\
    \ then\n                        wells[i + 1][j][2] = 1\n                     \
    \   count = count + 1\n                    end\n                    if j ~= n\
    \ and wells[i][j + 1][2] == 0 then\n                        wells[i][j + 1][2]\
    \ = 1\n                        count = count + 1\n                    end\n  \
    \              end\n            end\n        end\n    end\n    return count\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpai8wxq_b.lua:58:\
    \ expected: 6, actual: 8\nstack traceback:\n\t/tmp/tmpai8wxq_b.lua:58: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO: implement\
    \ it\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpevtsky0l.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpevtsky0l.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal side =\
    \ #grid[1]\n\tlocal height = #grid\n\tlocal row = height\n\tlocal col = 1\n\t\
    local number_of_drops = 0\n\tlocal total_drops = height * capacity\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp9ec_50fb.lua:40: ''end'' expected (to close ''function'' at
    line 22) near <eof>

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local wells\
    \ = {}\n    for y, row in ipairs(grid) do\n        for x, water in ipairs(row)\
    \ do\n            if water == 1 then\n                wells[#wells + 1] = { x\
    \ = x, y = y }\n            end\n        end\n    end\n    if #wells == 0 then\n\
    \        return 0\n    end\n    local function sort(a, b)\n        return a.y\
    \ < b.y or (a.y == b.y and a.x < b.x)\n    end\n    table.sort(wells, sort)\n\
    \    local step = 0\n    for i = 1, #wells do\n        local w = wells[i]\n  \
    \      local row = grid[w.y]\n        local water = math.min(capacity, row[w.x])\n\
    \        capacity = capacity - water\n        row[w.x] = row[w.x] - water\n  \
    \      step = step + water\n        if capacity == 0 then\n            capacity\
    \ = capacity + 1\n            step = step + 1\n        end\n    end\n    return\
    \ step\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9tchynek.lua:57:\
    \ expected: 6, actual: 12\nstack traceback:\n\t/tmp/tmp9tchynek.lua:57: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: -1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local fill =\
    \ 0\n  local wells = #grid\n  local length = #grid[1]\n  local wells_filled =\
    \ {}\n  local i, j\n  for i = 1, wells do\n    wells_filled[i] = 0\n  end\n  while\
    \ true do\n    -- Drop every bucket\n    for i = 1, wells do\n      wells_filled[i]\
    \ = wells_filled[i] + 1\n    end\n    fill = fill + 1\n    -- Check for filled\
    \ wells\n    for i = 1, wells do\n      if wells_filled[i] > capacity then\n \
    \       -- Return if a well is empty\n        return fill - 1\n      end\n   \
    \ end\n    -- Check for filled columns\n    for j = 1, length do\n      for i\
    \ = 1, wells do\n        if grid[i][j] == 1 and wells_filled[i] < capacity then\n\
    \          break\n        end\n        if i == wells then\n          for i = 1,\
    \ wells do\n            wells_filled[i] = wells_filled[i] - 1\n          end\n\
    \          fill = fill - 1\n        end\n      end\n    end\n  end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978084
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\t-- TODO: Implement\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiomrn9dh.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpiomrn9dh.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ gcd(a, b)\n    if b == 0 then return a end\n    return gcd(b, a % b)\n  end\n\
    \  local rows = #grid\n  local cols = #grid[1]\n  local moves = 0\n  local i =\
    \ 0\n  local j = 0\n  while true do\n    local g = gcd(i, j)\n    local mi = i\
    \ / g\n    local mj = j / g\n    while grid[mi] and grid[mi][mj] == 1 do\n   \
    \   grid[mi][mj] = 0\n      mi = mi + i\n      mj = mj + j\n    end\n    if mi\
    \ > rows or mj > cols then break end\n    if grid[mi] and grid[mi][mj] == 0 then\n\
    \      grid[mi][mj] = 1\n      moves = moves + 1\n    end\n    if i == capacity\
    \ then\n      j = j + 1\n      i = 0\n    else\n      i = i + 1\n    end\n  end\n\
    \  return moves\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp973x8jjl.lua:59:\
    \ expected: 6, actual: 2\nstack traceback:\n\t/tmp/tmp973x8jjl.lua:59: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal sum =\
    \ 0\n\tfor i,row in ipairs(grid) do\n\t\tlocal prev_filled = 0\n\t\tfor j, filled\
    \ in ipairs(row) do\n\t\t\tlocal d = filled - prev_filled\n\t\t\tif d > 0 then\n\
    \t\t\t\tsum = sum + d\n\t\t\t\tprev_filled = prev_filled + capacity\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn sum\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz29d22e8.lua:40:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpz29d22e8.lua:40: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    return 0\n\
    end\nreturn max_fill\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpewoe35zw.lua:26: <eof> expected near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ max_fill_rec(i, j, bucket)\n        if i > #grid or j > #grid[1] then\n    \
    \        return 0\n        end\n        local current = grid[i][j]\n        local\
    \ diff = capacity - bucket\n        if current < diff then\n            return\
    \ current + max_fill_rec(i, j + 1, bucket + current)\n        else\n         \
    \   return diff + max_fill_rec(i, j + 1, capacity)\n        end\n    end\n   \
    \ local bucket = capacity\n    local water = 0\n    for i = 1, #grid do\n    \
    \    local row = grid[i]\n        local column = #row\n        for j = 1, column\
    \ do\n            if row[j] == 1 then\n                local filled = max_fill_rec(i,\
    \ j, bucket)\n                water = water + filled\n                bucket =\
    \ capacity - filled\n            end\n        end\n    end\n    return water\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3vxifds3.lua:54:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmp3vxifds3.lua:54: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- It seems\
    \ that this problem can be solved using the greedy algorithm.\n    -- First, pick\
    \ up the well with the most number of water units from\n    -- the first column.\n\
    \    -- Repeat it for all wells.\n    -- The algorithm should work for all cases,\
    \ since:\n    -- * if the picked up well is rightmost,\n    --   there are no\
    \ available wells to its right\n    -- * if the picked up well is leftmost,\n\
    \    --   the other available wells are not rightmost\n    -- * if the picked\
    \ up well is not rightmost, not leftmost,\n    --   it may be possible to pick\
    \ up water from the well\n    --     to its right, in which case the well that\
    \ we picked up\n    --     was rightmost on its column, so it must have the most\
    \ number\n    --     of water units on its column\n    --     (if it doesn't,\
    \ the algorithm produces an incorrect solution)\n    -- * otherwise, the picked\
    \ up well is not rightmost, not leftmost,\n    --   and it is not possible to\
    \ pick up water from the well to its right\n    --   (which means that we have\
    \ picked up the well with the most\n    --    number of water units on its column)\n\
    \    local n = 0\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n  \
    \          n = n + math.min(grid[i][j], capacity)\n        end\n    end\n    return\
    \ n\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1sf0afwo.lua:55:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmp1sf0afwo.lua:55: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    return 0\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptnoznpl8.lua:29:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmptnoznpl8.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp14qsa4r4.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmp14qsa4r4.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local total_fill\
    \ = 0\n    for _, row in ipairs(grid) do\n        local fill_left = capacity\n\
    \        for _, value in ipairs(row) do\n            if value == 1 then\n    \
    \            fill_left = fill_left - 1\n            else\n                fill_left\
    \ = capacity\n            end\n            if fill_left == 0 then\n          \
    \      total_fill = total_fill + 1\n                fill_left = capacity\n   \
    \         end\n        end\n    end\n    return total_fill\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzkz3lkva.lua:45:\
    \ expected: 5, actual: 4\nstack traceback:\n\t/tmp/tmpzkz3lkva.lua:45: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tif #grid ==\
    \ 0 then return 0 end\n\tlocal function drop(row, col)\n\t\tlocal c = 0\n\t\t\
    if row < #grid then c = c + grid[row + 1][col] end\n\t\tif col < #grid[1] then\
    \ c = c + grid[row][col + 1] end\n\t\treturn c\n\tend\n\tlocal function fill(row,\
    \ col)\n\t\tlocal c = 0\n\t\tif row > 1 then c = c + grid[row - 1][col] end\n\t\
    \tif col > 1 then c = c + grid[row][col - 1] end\n\t\treturn c\n\tend\n\t-- local\
    \ drops = {}\n\t-- for i = 1, #grid do\n\t-- \tdrops[i] = {}\n\t-- \tfor j = 1,\
    \ #grid[1] do\n\t-- \t\tdrops[i][j] = drop(i, j)\n\t-- \tend\n\t-- end\n\t-- local\
    \ fills = {}\n\t-- for i = 1, #grid do\n\t-- \tfills[i] = {}\n\t-- \tfor j = 1,\
    \ #grid[1] do\n\t-- \t\tfills[i][j] = fill(i, j)\n\t-- \tend\n\t-- end\n\tlocal\
    \ function dp(i, j, c)\n\t\tif i > #grid or j > #grid[1] then return 0 end\n\t\
    \tif i == #grid and j == #grid[1] then return 0 end\n\t\tlocal left = dp(i, j\
    \ + 1, c)\n\t\tlocal down = dp(i + 1, j, c)\n\t\tlocal cur = grid[i][j]\n\t\t\
    local max_drop = drop(i, j)\n\t\tlocal fill_up = fill(i, j)\n\t\tlocal min_fill\
    \ = math.min(c, max_drop)\n\t\tlocal remained = c - min_fill\n\t\tlocal left_move\
    \ = math.max(0, fill_up - remained)\n\t\tif min_fill > 0 then\n\t\t\tleft = left\
    \ + min_fill\n\t\t\tdown = down + left_move\n\t\tend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp3xus7ujs.lua:76: ''end'' expected (to close ''function'' at
    line 50) near <eof>

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local n_rows\
    \ = #grid\n  local n_columns = #grid[1]\n  local rows = {}\n  for i = 1, n_rows\
    \ do\n    rows[i] = {}\n    for j = 1, n_columns do\n      rows[i][j] = grid[i][j]\n\
    \    end\n  end\n  local function reduce_column(j)\n    local first_non_zero =\
    \ 0\n    for i = 1, n_rows do\n      if rows[i][j] == 1 then\n        first_non_zero\
    \ = i\n        break\n      end\n    end\n    if first_non_zero == 0 then\n  \
    \    return 0\n    end\n    local max_fill = n_rows - first_non_zero + 1\n   \
    \ if max_fill > capacity then\n      max_fill = capacity\n    end\n    for i =\
    \ first_non_zero, n_rows do\n      rows[i][j] = rows[i][j] - max_fill\n    end\n\
    \    return max_fill\n  end\n  local n_fills = 0\n  for j = 1, n_columns do\n\
    \    n_fills = n_fills + reduce_column(j)\n  end\n  return n_fills\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd9mwj1ra.lua:62:\
    \ expected: 6, actual: 4\nstack traceback:\n\t/tmp/tmpd9mwj1ra.lua:62: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe9g184hc.lua:28:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpe9g184hc.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: -1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- for each\
    \ bucket, calculate the maximum value of a bucket if we empty it\n    --   if\
    \ the bucket is above the maximum, add the value to the result\n    --   else\
    \ add the maximum to the result\n    --   then set the bucket equal to the maximum\n\
    \    --   then subtract all the buckets in the same column by 1\n    -- return\
    \ the result\n    local result = 0\n    local max = 1\n    while (max > 0) do\n\
    \        max = 0\n        for i = 1, #grid do\n            local bucket = grid[i][#grid[i]]\n\
    \            if (bucket > max) then\n                max = bucket\n          \
    \  end\n            result = result + math.min(bucket, max)\n            grid[i][#grid[i]]\
    \ = math.min(bucket, max)\n            for j = 1, #grid[i] - 1 do\n          \
    \      if (grid[i][j] > 0) then\n                    grid[i][j] = grid[i][j] -\
    \ 1\n                end\n            end\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978084
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal n, m =\
    \ #grid, #grid[1]\n\tlocal total_fill, wells_to_fill = 0, 0\n\tlocal function\
    \ fill_well(i, j)\n\t\tif grid[i][j] == 1 then\n\t\t\tgrid[i][j] = 0\n\t\t\twells_to_fill\
    \ = wells_to_fill - 1\n\t\tend\n\tend\n\tlocal function fill_wells(i, j)\n\t\t\
    fill_well(i, j)\n\t\tif i > 1 then fill_well(i - 1, j) end\n\t\tif i < n then\
    \ fill_well(i + 1, j) end\n\t\tif j > 1 then fill_well(i, j - 1) end\n\t\tif j\
    \ < m then fill_well(i, j + 1) end\n\tend\n\tfor i = 1, n do\n\t\tfor j = 1, m\
    \ do\n\t\t\tif grid[i][j] == 1 then\n\t\t\t\twells_to_fill = wells_to_fill + 1\n\
    \t\t\tend\n\t\tend\n\tend\n\twhile wells_to_fill > 0 do\n\t\tlocal bucket_fill\
    \ = 0\n\t\tfor i = 1, n do\n\t\t\tfor j = 1, m do\n\t\t\t\tif grid[i][j] == 1\
    \ then\n\t\t\t\t\tbucket_fill = bucket_fill + 1\n\t\t\t\t\tif bucket_fill == capacity\
    \ then\n\t\t\t\t\t\tfill_wells(i, j)\n\t\t\t\t\t\ttotal_fill = total_fill + 1\n\
    \t\t\t\t\t\tbucket_fill = 0\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\
    \tif bucket_fill > 0 then\n\t\t\ttotal_fill = total_fill + 1\n\t\tend\n\tend\n\
    \treturn total_fill\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt73o92te.lua:69:\
    \ expected: 6, actual: 4\nstack traceback:\n\t/tmp/tmpt73o92te.lua:69: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ drop(row, col)\n        grid[row][col] = grid[row][col] - 1\n        return\
    \ col ~= 1 and drop(row, col - 1) or drop(row - 1, #grid[1])\n    end\n    local\
    \ function lower(row, col)\n        return (grid[row][col] == 1 and drop(row,\
    \ col))\n        or col == #grid[1] and lower(row + 1, 1)\n        or lower(row,\
    \ col + 1)\n    end\n    return lower(1, 1) or 0\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpsz9yuioe.lua:24:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmpsz9yuioe.lua:24:\
    \ in upvalue 'drop'\n\t/tmp/tmpsz9yuioe.lua:25: in upvalue 'drop'\n\t/tmp/tmpsz9yuioe.lua:25:\
    \ in upvalue 'drop'\n\t/tmp/tmpsz9yuioe.lua:25: in upvalue 'drop'\n\t/tmp/tmpsz9yuioe.lua:28:\
    \ in upvalue 'lower'\n\t/tmp/tmpsz9yuioe.lua:30: in upvalue 'lower'\n\t/tmp/tmpsz9yuioe.lua:30:\
    \ in local 'lower'\n\t/tmp/tmpsz9yuioe.lua:32: in local 'candidate'\n\t/tmp/tmpsz9yuioe.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\t-- your code\
    \ goes here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwhxmll2x.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpwhxmll2x.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- TODO: Implement\
    \ this method\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt2uubrbc.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpt2uubrbc.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO: implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkkbaztvt.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpkkbaztvt.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal height\
    \ = #grid\n\tlocal length = #grid[1]\n\tlocal buckets = {}\n\tfor y = 1, height\
    \ do\n\t\tfor x = 1, length do\n\t\t\tlocal bucket = {\n\t\t\t\tx = x,\n\t\t\t\
    \ty = y,\n\t\t\t\twater = capacity,\n\t\t\t\tsource = nil,\n\t\t\t\ttarget = nil,\n\
    \t\t\t\tdropped = 0,\n\t\t\t}\n\t\t\tbuckets[#buckets + 1] = bucket\n\t\tend\n\
    \tend\n\tfor y = 1, height do\n\t\tfor x = 1, length do\n\t\t\tif grid[y][x] ==\
    \ 1 then\n\t\t\t\tlocal source = buckets[(y - 1) * length + x]\n\t\t\t\tlocal\
    \ target = buckets[y * length + x]\n\t\t\t\tsource.target = target\n\t\t\t\ttarget.source\
    \ = source\n\t\t\tend\n\t\tend\n\tend\n\tlocal function drop(bucket)\n\t\tbucket.water\
    \ = bucket.water - 1\n\t\tbucket.dropped = bucket.dropped + 1\n\t\tif bucket.water\
    \ == 0 then\n\t\t\tif bucket.target ~= nil then\n\t\t\t\tdrop(bucket.target)\n\
    \t\t\tend\n\t\tend\n\tend\n\tlocal result = 0\n\tfor _, bucket in ipairs(buckets)\
    \ do\n\t\tif bucket.source == nil then\n\t\t\tdrop(bucket)\n\t\t\tresult = result\
    \ + 1\n\t\tend\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv3yaz8eu.lua:45:\
    \ attempt to index a nil value (local 'target')\nstack traceback:\n\t/tmp/tmpv3yaz8eu.lua:45:\
    \ in local 'candidate'\n\t/tmp/tmpv3yaz8eu.lua:71: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local sum =\
    \ 0\n  local min = capacity + 1\n  for _, x in ipairs(grid) do\n    for _, y in\
    \ ipairs(x) do\n      sum = sum + y\n      if y < min then\n        min = y\n\
    \      end\n    end\n  end\n  return sum + (capacity - min) * #grid\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp96nptdgt.lua:39:\
    \ expected: 6, actual: 9\nstack traceback:\n\t/tmp/tmp96nptdgt.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local total\
    \ = 0\n  local rows = {}\n  local len = #grid[1]\n  for i = 1, #grid do\n    local\
    \ s = 0\n    for j = 1, len do\n      if grid[i][j] == 1 then\n        s = s +\
    \ 1\n      end\n    end\n    if s > 0 then\n      total = total + 1\n      rows[total]\
    \ = s\n    end\n  end\n  local n = #rows\n  local sum = 0\n  for i = 1, n do\n\
    \    sum = sum + rows[i]\n  end\n  if sum < capacity then\n    return 0\n  end\n\
    \  local sum_arr = {}\n  sum_arr[1] = rows[1]\n  for i = 2, n do\n    sum_arr[i]\
    \ = sum_arr[i - 1] + rows[i]\n  end\n  local fill = {}\n  fill[1] = rows[1]\n\
    \  for i = 2, n do\n    fill[i] = fill[i - 1] + rows[i]\n    if fill[i] > capacity\
    \ then\n      fill[i] = capacity\n    end\n  end\n  local dp = {}\n  dp[1] = 0\n\
    \  dp[2] = rows[1]\n  for i = 3, n do\n    dp[i] = math.min(\n      dp[i - 1]\
    \ + rows[i - 1],\n      dp[i - 2] + fill[i - 1] + rows[i - 1] + rows[i])\n  end\n\
    \  return dp[n]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphwd9z262.lua:73:\
    \ expected: 6, actual: 2\nstack traceback:\n\t/tmp/tmphwd9z262.lua:73: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- check args\n\
    \  if type(grid) ~= 'table' or type(capacity) ~= 'number' then return nil end\n\
    \  -- validate capacity\n  if capacity < 1 or capacity > 10 then return nil end\n\
    \  -- validate grid\n  if #grid < 1 or #grid > 100 then return nil end\n  local\
    \ ref_len = #grid[1]\n  for i = 1, #grid do\n    if type(grid[i]) ~= 'table' or\
    \ #grid[i] ~= ref_len then return nil end\n    for j = 1, #grid[i] do\n      if\
    \ grid[i][j] ~= 0 and grid[i][j] ~= 1 then return nil end\n    end\n  end\n  --\
    \ init variables\n  local wells = 0\n  local fill_count = 0\n  local buckets =\
    \ {}\n  -- run\n  for i = 1, #grid do\n    for j = 1, #grid[i] do\n      if grid[i][j]\
    \ == 1 then\n        wells = wells + 1\n        table.insert(buckets, capacity)\n\
    \      end\n    end\n  end\n  while #buckets > 0 do\n    buckets[1] = buckets[1]\
    \ - 1\n    fill_count = fill_count + 1\n    if buckets[1] == 0 then table.remove(buckets,\
    \ 1) end\n  end\n  return fill_count + (wells - 1)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbihap4sp.lua:60:\
    \ expected: 6, actual: 11\nstack traceback:\n\t/tmp/tmpbihap4sp.lua:60: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local total_fill\
    \ = 0\n    local visited = {}\n    local x_max = #grid[1]\n    local y_max = #grid\n\
    \    local function search(x, y)\n        if x >= x_max or y >= y_max or x < 0\
    \ or y < 0 then\n            return\n        end\n        if grid[y][x] == 1 then\n\
    \            return\n        end\n        if visited[x] and visited[x][y] then\n\
    \            return\n        end\n        total_fill = total_fill + 1\n      \
    \  if not visited[x] then\n            visited[x] = {}\n        end\n        visited[x][y]\
    \ = true\n        if y > 0 then\n            search(x, y - 1)\n        end\n \
    \       if y < y_max - 1 then\n            search(x, y + 1)\n        end\n   \
    \     if x > 0 then\n            search(x - 1, y)\n        end\n        if x <\
    \ x_max - 1 then\n            search(x + 1, y)\n        end\n    end\n    local\
    \ is_empty = true\n    for y = 0, y_max - 1 do\n        if grid[y][0] == 0 then\n\
    \            is_empty = false\n            search(0, y)\n        end\n    end\n\
    \    if is_empty then\n        return 0\n    end\n    return total_fill * capacity\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptwnlze5l.lua:57:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmptwnlze5l.lua:57:\
    \ in local 'candidate'\n\t/tmp/tmptwnlze5l.lua:71: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local num_rows\
    \ = #grid\n    local num_cols = #grid[1]\n    local total_capacity = num_rows\
    \ * capacity\n    local total_water = 0\n    local result = 0\n    local function\
    \ bucket_fill(row, col)\n        local function bucket_fill_in_row(row, total_filled,\
    \ num_filled)\n            if col == num_cols or grid[row][col] == 0 then\n  \
    \              if total_filled == capacity then\n                    grid[row][col]\
    \ = 0\n                    total_water = total_water + total_filled\n        \
    \            if total_water == total_capacity then\n                        return\
    \ 0\n                    end\n                    return 1\n                end\n\
    \                return 0\n            end\n            if total_filled == capacity\
    \ then\n                return 0\n            end\n            grid[row][col]\
    \ = 0\n            return bucket_fill_in_row(row, total_filled + 1, num_filled\
    \ + 1)\n        end\n        local function bucket_fill_rec(row, total_filled,\
    \ num_filled)\n            if total_filled == capacity then\n                return\
    \ 0\n            end\n            if row == num_rows then\n                return\
    \ num_filled\n            end\n            local filled_in_row = bucket_fill_in_row(row,\
    \ total_filled, num_filled)\n            local filled_rec = bucket_fill_rec(row\
    \ + 1, total_filled, num_filled + filled_in_row)\n            return filled_rec\n\
    \        end\n        local function bucket_fill_rec_col(col, total_filled, num_filled)\n\
    \            if total_filled == capacity then\n                return 0\n    \
    \        end\n            if col == num_cols then\n                return num_filled\n\
    \            end\n            local filled_rec = bucket_fill_rec(0, total_filled,\
    \ num_filled)\n            local filled_rec_col = bucket_fill_rec_col(col + 1,\
    \ total_filled, num_filled + filled_rec)\n            return filled_rec_col\n\
    \        end\n        return bucket_fill_rec_col(col, 0, 0)\n    end\n    while\
    \ total_water < total_capacity do\n        result = result + bucket_fill(0, 0)\n\
    \    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpl85gzsbi.lua:85: ''end'' expected (to close ''function'' at
    line 22) near <eof>

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmmlnosih.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpmmlnosih.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- TODO: Implement\
    \ me!\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpepn595_j.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpepn595_j.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- TODO: implement\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc8_rsppc.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpc8_rsppc.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- Your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpowu9lu9q.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpowu9lu9q.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ get_left(grid, row, col)\n        local left = 0\n        for i = col - 1, 1,\
    \ -1 do\n            if grid[row][i] == 1 then\n                left = left +\
    \ 1\n            else\n                break\n            end\n        end\n \
    \       return left\n    end\n    local function get_right(grid, row, col)\n \
    \       local right = 0\n        for i = col + 1, #grid[row] do\n            if\
    \ grid[row][i] == 1 then\n                right = right + 1\n            else\n\
    \                break\n            end\n        end\n        return right\n \
    \   end\n    local function get_left_up(grid, row, col)\n        local left_up\
    \ = 0\n        for i = row - 1, 1, -1 do\n            if grid[i][col] == 1 then\n\
    \                left_up = left_up + 1\n            else\n                break\n\
    \            end\n        end\n        return left_up\n    end\n    local function\
    \ get_right_down(grid, row, col)\n        local right_down = 0\n        for i\
    \ = row + 1, #grid do\n            if grid[i][col] == 1 then\n               \
    \ right_down = right_down + 1\n            else\n                break\n     \
    \       end\n        end\n        return right_down\n    end\n    local fill =\
    \ 0\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n            if grid[i][j]\
    \ == 1 then\n                local left = get_left(grid, i, j)\n             \
    \   local right = get_right(grid, i, j)\n                local left_up = get_left_up(grid,\
    \ i, j)\n                local right_down = get_right_down(grid, i, j)\n     \
    \           local size = math.min(left, right, left_up, right_down)\n        \
    \        local offset = j - size - 1\n                for k = 0, 2 * size do\n\
    \                    grid[i - size + k][offset + k] = 0\n                end\n\
    \                fill = fill + size + 1\n            end\n        end\n    end\n\
    \    return fill\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb0l7c5p6.lua:91:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmpb0l7c5p6.lua:91: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- Put your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwaxvjt45.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpwaxvjt45.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  return 0\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp375bc7wk.lua:29:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmp375bc7wk.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    return -1\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp04r5zm0w.lua:29:\
    \ expected: 6, actual: -1\nstack traceback:\n\t/tmp/tmp04r5zm0w.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local count\
    \ = 0\n  for i = 1, #grid do\n    for j = 1, #grid[i] do\n      if grid[i][j]\
    \ == 1 then\n        for k = i, 0, -1 do\n          if grid[k][j] == 1 then\n\
    \            grid[k][j] = 0\n            count = count + 1\n          end\n  \
    \      end\n      end\n    end\n  end\n  return count\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8giv9asa.lua:28:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmp8giv9asa.lua:28:\
    \ in local 'candidate'\n\t/tmp/tmp8giv9asa.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local depth\
    \ = 0\n    local count = 0\n    for row = 1, #grid do\n        for col = 1, #grid[row]\
    \ do\n            if grid[row][col] == 1 then\n                local water = capacity\
    \ - depth\n                count = count + water\n                depth = capacity\n\
    \            else\n                depth = depth - 1\n            end\n      \
    \  end\n        depth = 0\n    end\n    return count\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpngirc6w6.lua:44:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmpngirc6w6.lua:44: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 0
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal buckets\
    \ = 0\n\tfor i, row in ipairs(grid) do\n\t\tlocal water = 0\n\t\tfor j, well in\
    \ ipairs(row) do\n\t\t\twater = water + well\n\t\t\tif water == capacity then\n\
    \t\t\t\tbuckets = buckets + 1\n\t\t\t\twater = 0\n\t\t\telseif water > capacity\
    \ then\n\t\t\t\tbuckets = buckets + 1\n\t\t\t\twater = well\n\t\t\tend\n\t\tend\n\
    \t\tif water > 0 then\n\t\t\tbuckets = buckets + 1\n\t\tend\n\tend\n\treturn buckets\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local total\
    \ = 0\n    for i = 1, #grid do\n        local current = 0\n        for j = 1,\
    \ #grid[i] do\n            if grid[i][j] == 1 then\n                current =\
    \ current + 1\n            end\n        end\n        total = total + math.min(current,\
    \ capacity)\n    end\n    return total\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzw848hwu.lua:39:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpzw848hwu.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- your code\
    \ here\n    return false\nend\nreturn max_fill\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpslussete.lua:27: <eof> expected near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\t-- grid 2d table\
    \ of 1's and 0's representing filled wells\n\t-- capacity of the water bucket\n\
    \t\n\tlocal empties = {}\n\t\n\tlocal rows = #grid\n\tlocal cols = #grid[1]\n\t\
    \n\t--[[\n\t-- Find the first filled well on the leftmost\n\tfor i = 1, rows do\n\
    \t\tfor j = 1, cols do\n\t\t\tif grid[i][j] == 1 then\n\t\t\t\ttable.insert(empties,\
    \ {i, j})\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t--]]\n\t\n\t\n\t-- Find\
    \ the empties\n\tfor i = 1, rows do\n\t\tfor j = 1, cols do\n\t\t\tif grid[i][j]\
    \ == 1 then\n\t\t\t\ttable.insert(empties, {i, j})\n\t\t\tend\n\t\tend\n\tend\n\
    \t\n\tif #empties == 0 then\n\t\treturn 0\n\tend\n\t\n\t--table.sort(empties,\
    \ function(a, b) return a[2] < b[2] end)\n\t\n\t-- Loop until the bucket capacity\
    \ is reached\n\tlocal total = 0\n\tlocal curr_cap = 0\n\tlocal em_ptr = 1\n\t\
    local em_len = #empties\n\t\n\twhile curr_cap < capacity do\n\t\tlocal curr_i\
    \ = empties[em_ptr][1]\n\t\tlocal curr_j = empties[em_ptr][2]\n\t\t\n\t\tif grid[curr_i][curr_j]\
    \ == 1 then\n\t\t\t-- Fill the bucket with one from the well\n\t\t\tgrid[curr_i][curr_j]\
    \ = 0\n\t\t\tcurr_cap = curr_cap + 1\n\t\tend\n\t\t\n\t\t-- Go to the next well\n\
    \t\tif em_ptr < em_len then\n\t\t\tem_ptr = em_ptr + 1\n\t\telse\n\t\t\tem_ptr\
    \ = 1\n\t\tend\n\t\t\n\t\ttotal = total + 1\n\tend\n\t\n\treturn total\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp09u575wm.lua:91:\
    \ expected: 6, actual: 1\nstack traceback:\n\t/tmp/tmp09u575wm.lua:91: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    --TODO: Implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmzldanmg.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpmzldanmg.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local water\
    \ = {}\n    local bucket = 0\n    local total = 0\n    local counter = 0\n   \
    \ local i, j\n    local max = -1\n    local temp = 0\n    for i = 1, #grid do\n\
    \        total = 0\n        for j = 1, #grid[i] do\n            if grid[i][j]\
    \ == 1 then\n                total = total + 1\n            end\n        end\n\
    \        water[i] = total\n    end\n    while true do\n        counter = 0\n \
    \       max = -1\n        temp = 0\n        for i = 1, #water do\n           \
    \ if water[i] > max then\n                max = water[i]\n                temp\
    \ = i\n            end\n        end\n        if max == 0 then\n            break\n\
    \        end\n        water[temp] = water[temp] - 1\n        for i = 1, #water\
    \ do\n            if water[i] == 0 then\n                counter = counter + 1\n\
    \            end\n        end\n        if counter ~= #water then\n           \
    \ bucket = bucket + 1\n        end\n    end\n    return math.ceil(bucket / capacity)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptgznfllx.lua:68:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmptgznfllx.lua:68: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ fill(row)\n        local cnt = 0\n        for col = 1, #row do\n           \
    \ if row[col] == 1 then\n                cnt = cnt + 1\n            end\n    \
    \    end\n        return cnt\n    end\n    local cnt = 0\n    for _, row in ipairs(grid)\
    \ do\n        cnt = cnt + fill(row)\n    end\n    return cnt * capacity\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphs26hefj.lua:43:\
    \ expected: 5, actual: 18\nstack traceback:\n\t/tmp/tmphs26hefj.lua:43: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal cnt =\
    \ 0\n\tlocal n = #grid\n\tlocal m = #grid[1]\n\tfor j = 1, m do\n\t\tlocal fill\
    \ = 0\n\t\tfor i = 1, n do\n\t\t\tfill = fill + grid[i][j]\n\t\t\tif fill == capacity\
    \ then\n\t\t\t\tgrid[i][j] = 0\n\t\t\t\tfill = 0\n\t\t\t\tcnt = cnt + 1\n\t\t\t\
    elseif fill > capacity then\n\t\t\t\tgrid[i][j] = fill - capacity\n\t\t\t\tfill\
    \ = capacity\n\t\t\t\tcnt = cnt + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn cnt\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpool38_4e.lua:48:\
    \ expected: 5, actual: 3\nstack traceback:\n\t/tmp/tmpool38_4e.lua:48: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- 1) Find\
    \ the max height of the columns\n    local num_columns = #grid[1]\n    local max_heights\
    \ = {}\n    for i = 1, num_columns do\n        local max_height = 0\n        for\
    \ j = 1, #grid do\n            if grid[j][i] == 1 then\n                max_height\
    \ = max_height + 1\n            end\n        end\n        max_heights[i] = max_height\n\
    \    end\n    -- 2) We now know that the maximum number of buckets needed is the\
    \ sum of the \n    --    max heights we just found\n    local num_buckets = 0\n\
    \    for i = 1, #max_heights do\n        num_buckets = num_buckets + max_heights[i]\n\
    \    end\n    -- 3) For each column, we need to find the number of wells that\
    \ are above the \n    --    max height we found in the previous step and subtract\
    \ that from the \n    --    number of buckets.\n    for i = 1, num_columns do\n\
    \        for j = 1, #grid do\n            if grid[j][i] == 1 and j > max_heights[i]\
    \ then\n                num_buckets = num_buckets - 1\n            end\n     \
    \   end\n    end\n    -- 4) Now that we have the number of buckets we need to\
    \ fill, we can divide \n    --    by the number of wells in a column and divide\
    \ that by the capacity to \n    --    find the number of times we need to lower\
    \ the buckets.\n    local num_lowers = num_buckets / capacity / num_columns\n\
    \    return num_lowers\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8j5wff90.lua:61:\
    \ expected: 6, actual: 0.5\nstack traceback:\n\t/tmp/tmp8j5wff90.lua:61: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local length\
    \ = #grid[1]\n  local last_row = grid[#grid]\n  local last_row_zeros = {}\n  local\
    \ zeros = 0\n  local count = 0\n  local fill = 0\n  local current = 0\n  local\
    \ current_row = 1\n  local i = 1\n  local row = grid[current_row]\n  while(i <=\
    \ length) do\n    if (row[i] == 0) then\n      zeros = zeros + 1\n    else\n \
    \     if (zeros > 0) then\n        last_row_zeros[zeros] = (last_row_zeros[zeros]\
    \ or 0) + 1\n      end\n      zeros = 0\n    end\n    i = i + 1\n  end\n  if (zeros\
    \ > 0) then\n    last_row_zeros[zeros] = (last_row_zeros[zeros] or 0) + 1\n  end\n\
    \  i = 0\n  while (i < length) do\n    local left_zeros = 0\n    local left_zeros_count\
    \ = 0\n    local right_zeros = 0\n    local right_zeros_count = 0\n    local zero_count\
    \ = 0\n    local j = 1\n    local left_filled = 0\n    local right_filled = 0\n\
    \    while (j <= length) do\n      if (j <= i) then\n        left_filled = left_filled\
    \ + (row[j] or 0)\n      else\n        right_filled = right_filled + (row[j] or\
    \ 0)\n      end\n      j = j + 1\n    end\n    zero_count = (i - left_filled)\
    \ + (length - right_filled - i)\n    left_zeros_count = (i - left_filled)\n  \
    \  left_zeros = left_zeros_count\n    right_zeros_count = (length - right_filled\
    \ - i)\n    right_zeros = right_zeros_count\n    if (left_zeros > 0) then\n  \
    \    zero_count = zero_count - (last_row_zeros[left_zeros] or 0)\n    end\n  \
    \  if (right_zeros > 0) then\n      zero\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmptmom6a4q.lua:75: syntax error near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local water\
    \ = 0\n    local n = grid.n\n    local m = grid[1].n\n    local function fill(i,\
    \ j)\n        if i <= n and j <= m and grid[i][j] == 1 then\n            local\
    \ q = capacity\n            while q > 0 and j <= m do\n                grid[i][j]\
    \ = 0\n                q = q - 1\n                j = j + 1\n            end\n\
    \            if j <= m then\n                grid[i][j] = grid[i][j] + q\n   \
    \         end\n        end\n    end\n    local function check_row(i)\n       \
    \ local j = 1\n        while j <= m do\n            if grid[i][j] == 1 then\n\
    \                water = water + 1\n                fill(i, j)\n            end\n\
    \            j = j + 1\n        end\n    end\n    local i = 1\n    while i <=\
    \ n do\n        check_row(i)\n        i = i + 1\n    end\n    return water\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmps_zekjcs.lua:50:\
    \ attempt to compare number with nil\nstack traceback:\n\t/tmp/tmps_zekjcs.lua:50:\
    \ in local 'candidate'\n\t/tmp/tmps_zekjcs.lua:60: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  return 0\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp375bc7wk.lua:29:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmp375bc7wk.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local max_y = 0\n    local ans = 0\n\
    \    for i=1,rows do\n        for j=1,cols do\n            max_y = math.max(max_y,\
    \ grid[i][j])\n        end\n    end\n    for y=0,max_y do\n        local sum =\
    \ 0\n        for i=1,rows do\n            for j=1,cols do\n                if\
    \ grid[i][j] > y then\n                    sum = sum + 1\n                end\n\
    \            end\n        end\n        ans = ans + math.ceil(sum / capacity)\n\
    \    end\n    return ans\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd2m_wwph.lua:53:\
    \ expected: 2, actual: 1\nstack traceback:\n\t/tmp/tmpd2m_wwph.lua:53: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local times\
    \ = 0\n  for i = 1, #grid do\n    for j = 1, #grid[i] do\n      times = times\
    \ + math.floor(grid[i][j] / capacity)\n      if (grid[i][j] % capacity) ~= 0 then\n\
    \        times = times + 1\n      end\n    end\n  end\n  return times\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_cfzfu7k.lua:39:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmp_cfzfu7k.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  if #grid ==\
    \ 0 then return 0 end\n  local curr_max = 0\n  local count = 0\n  for i = 1, #grid\
    \ do\n    for j = 1, #grid[i] do\n      curr_max = math.max(curr_max, grid[i][j])\n\
    \    end\n  end\n  for i = 1, curr_max do\n    for j = 1, #grid do\n      for\
    \ k = 1, #grid[j] do\n        if grid[j][k] > 0 then\n          if grid[j][k]\
    \ > capacity then\n            grid[j][k] = grid[j][k] - capacity\n          \
    \  count = count + 1\n          else\n            count = count + 1\n        \
    \    grid[j][k] = 0\n          end\n        end\n      end\n    end\n  end\n \
    \ return count\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptezz4vwz.lua:53:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmptezz4vwz.lua:53: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    if type(grid)\
    \ ~= 'table' or type(capacity) ~= 'number' then\n        error('bad input')\n\
    \    end\n    for k, row in ipairs(grid) do\n        for m, cell in ipairs(row)\
    \ do\n            if cell ~= 0 and cell ~= 1 then\n                error('bad\
    \ input')\n            end\n        end\n    end\n    if #grid > 10^2 or capacity\
    \ < 1 or capacity > 10 then\n        error('bad input')\n    end\n    local count\
    \ = 0\n    for k, row in ipairs(grid) do\n        for m, cell in ipairs(row) do\n\
    \            if cell == 1 then\n                local prev = m - 1\n         \
    \       while prev >= 1 and grid[k][prev] == 1 do\n                    prev =\
    \ prev - 1\n                end\n                if prev == 0 then\n         \
    \           count = count + 1\n                end\n            end\n        end\n\
    \    end\n    return count\nend\nreturn max_fill\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpauelhc9z.lua:53: <eof> expected near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  if capacity\
    \ == 0 then return 0 end\n  -- return total number of water units that can be\
    \ extracted\n  -- from the grid given the capacity\n  local function fill(grid,\
    \ capacity)\n    local function fill_row(row, capacity)\n      local water = 0\n\
    \      local left = capacity\n      for i = 1, #row do\n        if row[i] == 1\
    \ then\n          water = water + 1\n          row[i] = 0\n          left = left\
    \ - 1\n        end\n        if left == 0 then return water end\n      end\n  \
    \    return water\n    end\n    local total = 0\n    for i = 1, #grid do\n   \
    \   total = total + fill_row(grid[i], capacity)\n    end\n    return total\n \
    \ end\n  -- return true if at least one well has water\n  local function has_water(grid)\n\
    \    for i = 1, #grid do\n      for j = 1, #grid[i] do\n        if grid[i][j]\
    \ == 1 then return true end\n      end\n    end\n    return false\n  end\n  local\
    \ step = 0\n  while has_water(grid) do\n    local water = fill(grid, capacity)\n\
    \    if water == 0 then break end\n    step = step + 1\n  end\n  return step\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt6dq0f3g.lua:67:\
    \ expected: 6, actual: 4\nstack traceback:\n\t/tmp/tmpt6dq0f3g.lua:67: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- 3rd arg\
    \ is a state vector\n    local function try(i, j, d)\n        if i <= #grid and\
    \ j < #grid[1] then\n            -- return capacity of next well\n           \
    \ if grid[i][j] == 1 then\n                return try(i, j + 1, capacity)\n  \
    \          else\n                -- try with some water in it\n              \
    \  return math.min(try(i, j + 1, capacity), try(i, j + 1, capacity - 1))\n   \
    \         end\n        else\n            -- empty well, return full capacity\n\
    \            return capacity\n        end\n    end\n    local result = 0\n   \
    \ for i = 1, #grid do\n        result = result + try(i, 1, capacity)\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmjsw2lcj.lua:48:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpmjsw2lcj.lua:48: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ water_cell(cell)\n        return cell == 1\n    end\n    local height = #grid\n\
    \    local width = #grid[1]\n    local count = 0\n    for row = 1, height do\n\
    \        local current_capacity = capacity\n        for col = 1, width do\n  \
    \          if water_cell(grid[row][col]) then\n                grid[row][col]\
    \ = 0\n                current_capacity = current_capacity - 1\n            end\n\
    \            if current_capacity == 0 then\n                break\n          \
    \  end\n        end\n        count = count + capacity - current_capacity\n   \
    \ end\n    return count\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt6zw_32s.lua:48:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpt6zw_32s.lua:48: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local m, n =\
    \ #grid, #grid[1]\n  local grid_copy = {}\n  for i = 1, m do\n    grid_copy[i]\
    \ = {}\n    for j = 1, n do\n      grid_copy[i][j] = grid[i][j]\n    end\n  end\n\
    \  local drops = 0\n  while true do\n    local drop_this_round = false\n    for\
    \ j = 1, n do\n      for i = 1, m do\n        if grid_copy[i][j] > 0 then\n  \
    \        grid_copy[i][j] = grid_copy[i][j] - capacity\n          drops = drops\
    \ + 1\n          drop_this_round = true\n        end\n      end\n    end\n   \
    \ if not drop_this_round then\n      break\n    end\n  end\n  return drops\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7wrggv5v.lua:54:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmp7wrggv5v.lua:54: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local cycles\
    \ = 0\n  local height = #grid\n  local width = #grid[1]\n  local rows = {}\n \
    \ local buckets = {}\n  local function row_to_buckets(row)\n    local bkts = {}\n\
    \    for i = 1, width do\n      bkts[i] = row[i]\n    end\n    return bkts\n \
    \ end\n  local function buckets_to_row(bkts)\n    local row = {}\n    for i =\
    \ 1, width do\n      row[i] = bkts[i]\n    end\n    return row\n  end\n  local\
    \ function empty_buckets()\n    for i = 1, height do\n      buckets[i] = 0\n \
    \   end\n  end\n  local function fill_buckets()\n    for i = 1, height do\n  \
    \    if buckets[i] == 0 then\n        buckets[i] = capacity\n      end\n    end\n\
    \  end\n  local function dump_row()\n    cycles = cycles + 1\n    for i = 1, width\
    \ do\n      if buckets[i] > 0 then\n        buckets[i] = buckets[i] - 1\n    \
    \  end\n    end\n  end\n  local function dump_buckets()\n    for i = 1, height\
    \ do\n      dump_row()\n    end\n  end\n  local function empty_rows()\n    for\
    \ i = 1, height do\n      rows[i] = row_to_buckets(grid[i])\n    end\n  end\n\
    \  local function fill_rows()\n    for i = 1, height do\n      grid[i] = buckets_to_row(rows[i])\n\
    \    end\n  end\n  empty_rows()\n  while true do\n    local changed = false\n\
    \    empty_buckets()\n    fill_buckets()\n    dump_buckets()\n    for i = 1, height\
    \ do\n      for j = 1, width do\n        if rows[i][j] > 0 then\n          changed\
    \ = true\n          rows[i][j] = rows[i][j] - 1\n        end\n      end\n    end\n\
    \    if not changed then\n      break\n    end\n  end\n  fill_rows()\n  return\
    \ cycles\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpg_wmelp7.lua:57:\
    \ attempt to compare number with nil\nstack traceback:\n\t/tmp/tmpg_wmelp7.lua:57:\
    \ in upvalue 'dump_row'\n\t/tmp/tmpg_wmelp7.lua:64: in local 'dump_buckets'\n\t\
    /tmp/tmpg_wmelp7.lua:82: in local 'candidate'\n\t/tmp/tmpg_wmelp7.lua:102: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ fill_grid(grid, capacity)\n        local function index_of_max(grid)\n     \
    \       local max_index, max_value = -1, -1\n            for i, row in ipairs(grid)\
    \ do\n                local max_row_value = math.max(unpack(row))\n          \
    \      if max_row_value > max_value then\n                    max_index, max_value\
    \ = i, max_row_value\n                end\n            end\n            return\
    \ max_index, max_value\n        end\n        local index, value = index_of_max(grid)\n\
    \        if value <= 0 then\n            return 0\n        end\n        for i,\
    \ row in ipairs(grid) do\n            for j, cell in ipairs(row) do\n        \
    \        if i == index then\n                    grid[i][j] = math.max(0, grid[i][j]\
    \ - capacity)\n                else\n                    grid[i][j] = math.max(0,\
    \ grid[i][j] - capacity / 2)\n                end\n            end\n        end\n\
    \        return 1 + fill_grid(grid, capacity)\n    end\n    return fill_grid(grid,\
    \ capacity)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0p2e05hz.lua:27:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmp0p2e05hz.lua:27:\
    \ in local 'index_of_max'\n\t/tmp/tmp0p2e05hz.lua:34: in function </tmp/tmp0p2e05hz.lua:23>\n\
    \t(...tail calls...)\n\t/tmp/tmp0p2e05hz.lua:55: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO: Implement\
    \ this function!\nend\n \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpufxd4vg_.lua:30:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpufxd4vg_.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local count\
    \ = 0\n  local max = 0\n  local index_of_max = 0\n  local max_level = 0\n  local\
    \ visited = {}\n  local function dfs(index, level)\n    if visited[index] then\
    \ return end\n    visited[index] = true\n    count = count + 1\n    if level >\
    \ max_level then\n      max_level = level\n      max = index\n      index_of_max\
    \ = 1\n    elseif level == max_level then\n      index_of_max = index_of_max +\
    \ 1\n    end\n    if grid[index - 1] and grid[index - 1][level] == 1 then\n  \
    \    dfs(index - 1, level)\n    end\n    if grid[index + 1] and grid[index + 1][level]\
    \ == 1 then\n      dfs(index + 1, level)\n    end\n    if grid[index][level +\
    \ 1] == 1 then\n      dfs(index, level + 1)\n    end\n  end\n  while count < #grid\
    \ do\n    dfs(max, max_level)\n    --print(max_level, count, index_of_max)\n \
    \   count = count + capacity * index_of_max\n    max_level = max_level - 1\n \
    \ end\n  return count\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph7673m_x.lua:45:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmph7673m_x.lua:45:\
    \ in local 'dfs'\n\t/tmp/tmph7673m_x.lua:50: in local 'candidate'\n\t/tmp/tmph7673m_x.lua:61:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\t-- Get the number\
    \ of rows from grid.\n\tlocal n = #grid\n\t-- If n == 0, then there are no rows.\
    \ Return 0.\n\tif n == 0 then return 0 end\n\t-- Get the number of wells from\
    \ grid[1].\n\tlocal m = #grid[1]\n\t-- If m == 0, then there are no wells. Return\
    \ 0.\n\tif m == 0 then return 0 end\n\t-- Create a table called 'fills' and initialize\
    \ it with the number of rows, n.\n\tlocal fills = {}\n\tfor i = 1, n do\n\t\t\
    -- Add a column to fills.\n\t\tfills[i] = {}\n\t\t-- Iterate over each element\
    \ in grid[i] and add it to fills[i].\n\t\tfor j = 1, m do\n\t\t\tfills[i][j] =\
    \ grid[i][j]\n\t\tend\n\tend\n\t-- Initialize a table called 'max_fill'.\n\tlocal\
    \ max_fill = {}\n\t-- Call the function get_max_fills to fill the table.\n\tget_max_fills(fills,\
    \ n, m, capacity, max_fill)\n\t-- Return the value at index 1 in max_fill.\n\t\
    return max_fill[1]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpiadn36p4.lua:44:\
    \ attempt to call a nil value (global 'get_max_fills')\nstack traceback:\n\t/tmp/tmpiadn36p4.lua:44:\
    \ in local 'candidate'\n\t/tmp/tmpiadn36p4.lua:52: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ raise_bucket(row, col)\n        local i = row + 1\n        while grid[i] and\
    \ grid[i][col] == 0 do\n            grid[i][col] = 1\n            i = i + 1\n\
    \        end\n    end\n    local function lower_bucket(row, col)\n        local\
    \ i = row\n        while grid[i] and grid[i][col] == 1 do\n            grid[i][col]\
    \ = 0\n            i = i - 1\n        end\n    end\n    local n_rows = #grid\n\
    \    local n_cols = #grid[1]\n    local n_buckets = n_cols\n    local n_times\
    \ = 0\n    for row = 1, n_rows do\n        for col = 1, n_cols do\n          \
    \  if grid[row][col] == 1 then\n                raise_bucket(row, col)\n     \
    \           n_times = n_times + 1\n            end\n        end\n        if row\
    \ % capacity == 0 then\n            for col = 1, n_cols do\n                lower_bucket(row,\
    \ col)\n                n_times = n_times + 1\n            end\n        end\n\
    \    end\n    for row = n_rows, 1, -1 do\n        for col = 1, n_cols do\n   \
    \         if grid[row][col] == 1 then\n                raise_bucket(row, col)\n\
    \                n_times = n_times + 1\n            end\n        end\n       \
    \ if row % capacity == 0 then\n            for col = 1, n_cols do\n          \
    \      lower_bucket(row, col)\n                n_times = n_times + 1\n       \
    \     end\n        end\n    end\n    return n_times\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnsr3g8m5.lua:75:\
    \ expected: 6, actual: 31\nstack traceback:\n\t/tmp/tmpnsr3g8m5.lua:75: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  return 0\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp375bc7wk.lua:29:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmp375bc7wk.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local sum\
    \ = 0\n    for i, well in ipairs(grid) do\n        sum = sum + max_sum(well, capacity)\n\
    \    end\n    return sum\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpo9dufigx.lua:25:\
    \ attempt to call a nil value (global 'max_sum')\nstack traceback:\n\t/tmp/tmpo9dufigx.lua:25:\
    \ in local 'candidate'\n\t/tmp/tmpo9dufigx.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local count\
    \ = 0\n  local well_count = #grid\n  local well_len = #grid[1]\n  local buckets\
    \ = {}\n  for row_num = 1, well_count do\n    buckets[row_num] = 0\n  end\n  while\
    \ true do\n    local filled = false\n    for row_num = 1, well_count do\n    \
    \  for well_num = 1, well_len do\n        if grid[row_num][well_num] == 1 then\n\
    \          if capacity > buckets[row_num] then\n            buckets[row_num] =\
    \ buckets[row_num] + 1\n            grid[row_num][well_num] = 0\n            filled\
    \ = true\n          end\n        end\n      end\n    end\n    if filled then\n\
    \      count = count + 1\n    else\n      break\n    end\n  end\n  return count\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpknpv0umd.lua:55:\
    \ expected: 6, actual: 1\nstack traceback:\n\t/tmp/tmpknpv0umd.lua:55: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ test_bucket(bucket, grid)\n        local function get_next_bucket(bucket, grid)\n\
    \            local i, j = bucket[1], bucket[2]\n            local x, y\n     \
    \       for x = 1, #grid do\n                for y = 1, #grid[x] do\n        \
    \            if not (x == i and y == j) and grid[x][y] > 0 then\n            \
    \            return {x, y}\n                    end\n                end\n   \
    \         end\n            return false\n        end\n        local i, j = bucket[1],\
    \ bucket[2]\n        local n = capacity\n        local nb\n        grid[i][j]\
    \ = 0\n        while n > 0 do\n            nb = get_next_bucket(bucket, grid)\n\
    \            if nb then\n                grid[nb[1]][nb[2]] = grid[nb[1]][nb[2]]\
    \ - 1\n                n = n - 1\n            else\n                break\n  \
    \          end\n        end\n        return n == 0\n    end\n    local function\
    \ count_filled(grid)\n        local c = 0\n        for i = 1, #grid do\n     \
    \       for j = 1, #grid[i] do\n                if grid[i][j] > 0 then\n     \
    \               c = c + 1\n                end\n            end\n        end\n\
    \        return c\n    end\n    local filled = count_filled(grid)\n    local times\
    \ = 0\n    while filled > 0 do\n        for i = 1, #grid do\n            for j\
    \ = 1, #grid[i] do\n                if grid[i][j] > 0 then\n                 \
    \   if test_bucket({i, j}, grid) then\n                        times = times +\
    \ 1\n                        filled = count_filled(grid)\n                   \
    \     if filled == 0 then\n                            return times\n        \
    \                end\n                    end\n                end\n         \
    \   end\n        end\n    end\n    return times\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzt58o7h7.lua:85:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpzt58o7h7.lua:85: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local max =\
    \ 0\n  for i = 1, #grid do\n    for j = 1, #grid[i] do\n      if grid[i][j] ==\
    \ 1 then\n        max = max + capacity\n      end\n    end\n  end\n  return max\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0bbf5h9c.lua:38:\
    \ expected: 5, actual: 18\nstack traceback:\n\t/tmp/tmp0bbf5h9c.lua:38: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local w = #grid[1]\n\
    \  local h = #grid\n  local result = 0\n  for i = 1, w do\n    local total = 0\n\
    \    for j = 1, h do\n      total = total + grid[j][i]\n    end\n    result =\
    \ result + math.ceil(total / capacity)\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5zfa4nyl.lua:40:\
    \ expected: 5, actual: 6\nstack traceback:\n\t/tmp/tmp5zfa4nyl.lua:40: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- a single\
    \ well cannot hold more than capacity water\n  local times = 0\n  local result\
    \ = {}\n  for _, row in ipairs(grid) do\n    local fill = capacity\n    for _,\
    \ well in ipairs(row) do\n      if well == 1 then\n        if fill < capacity\
    \ then\n          times = times + 1\n          fill = capacity\n        end\n\
    \        fill = fill - 1\n      end\n    end\n  end\n  return times\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl7jdjer5.lua:44:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpl7jdjer5.lua:44: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local result\
    \ = 0\n    for i = 1, #grid do\n        local row = grid[i]\n        if row[1]\
    \ == 1 then\n            result = result + capacity\n        end\n        for\
    \ j = 2, #row do\n            if row[j] == 1 and row[j - 1] == 0 then\n      \
    \          result = result + capacity\n            end\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmu5l4pa9.lua:41:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpmu5l4pa9.lua:41: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local total\
    \ = 0\n    for _, row in ipairs(grid) do\n        local row_max = capacity\n \
    \       for _, level in ipairs(row) do\n            if level == 1 then\n     \
    \           row_max = row_max - 1\n            end\n        end\n        total\
    \ = total + row_max\n    end\n    return total\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv3vxouea.lua:39:\
    \ expected: 6, actual: -3\nstack traceback:\n\t/tmp/tmpv3vxouea.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal function\
    \ tostring(grid)\n\t\tlocal s = \"\"\n\t\tfor i = 1, #grid do\n\t\t\tfor j = 1,\
    \ #grid[i] do\n\t\t\t\ts = s .. grid[i][j]\n\t\t\tend\n\t\t\ts = s .. \"\\n\"\n\
    \t\tend\n\t\treturn s\n\tend\n\tlocal function print(grid)\n\t\tprint(tostring(grid))\n\
    \tend\n\tlocal function prints(s)\n\t\tprint(s)\n\tend\n\tlocal function string.split(s,\
    \ sep)\n\t\tlocal fields = {}\n\t\tlocal pattern = string.format(\"([^%s]+)\"\
    , sep)\n\t\ts:gsub(pattern, function(c) fields[#fields+1] = c end)\n\t\treturn\
    \ fields\n\tend\n\tlocal function string.rstrip(s)\n\t\treturn s:gsub(\"%s+$\"\
    , \"\")\n\tend\n\tlocal function string.lstrip(s)\n\t\treturn s:gsub(\"^%s+\"\
    , \"\")\n\tend\n\tlocal function string.startswith(s, sub)\n\t\treturn s:sub(1,\
    \ #sub) == sub\n\tend\n\tlocal function string.endswith(s, sub)\n\t\treturn s:sub(-#sub)\
    \ == sub\n\tend\n\tlocal function string.replace(s, pat, rep)\n\t\treturn s:gsub(pat,\
    \ rep)\n\tend\n\tlocal function string.insert(s, i, rep)\n\t\treturn s:sub(1,\
    \ i) .. rep .. s:sub(i+1)\n\tend\n\tlocal function string.count(s, sub)\n\t\t\
    return select(2, s:gsub(sub, \"\"))\n\tend\n\tlocal function string.ljust(s, len,\
    \ pad)\n\t\tif len <= #s then return s end\n\t\treturn s .. string.rep(pad or\
    \ \" \", len - #s)\n\tend\n\tlocal function string.rjust(s, len, pad)\n\t\tif\
    \ len <= #s then return s end\n\t\treturn string.rep(pad or \" \", len - #s\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpw8d30aiq.lua:39: ''('' expected near ''.''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local result\
    \ = 0\n    for i, v in ipairs(grid) do\n        local max = 0\n        for _,\
    \ j in ipairs(v) do\n            if j > max then\n                max = j\n  \
    \          end\n        end\n        if max > 0 then\n            result = result\
    \ + max\n        end\n    end\n    return capacity * result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn77v1hik.lua:41:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpn77v1hik.lua:41: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local j = 0\n\
    \  local i = 0\n  local count = 0\n  local row = #grid\n  local col = #grid[1]\n\
    \  while i < row do\n    while j < col do\n      if grid[i][j] == 1 then\n   \
    \     while i < row and grid[i][j] == 1 do\n          grid[i][j] = 0\n       \
    \   i = i + 1\n        end\n        i = i - 1\n        count = count + 1\n   \
    \   end\n      j = j + 1\n    end\n    j = 0\n    i = i + 1\n  end\n  return count\
    \ * capacity\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp80grgbte.lua:30:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmp80grgbte.lua:30:\
    \ in local 'candidate'\n\t/tmp/tmp80grgbte.lua:49: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local fill_count\
    \ = 0\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n            local\
    \ bucket_fill = math.floor(grid[i][j] / capacity)\n            grid[i][j] = grid[i][j]\
    \ - bucket_fill * capacity\n            fill_count = fill_count + bucket_fill\n\
    \        end\n    end\n    return fill_count\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9wvhw415.lua:38:\
    \ expected: 5, actual: 0\nstack traceback:\n\t/tmp/tmp9wvhw415.lua:38: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local n =\
    \ 0\n    for _,line in ipairs(grid) do\n        for _,col in ipairs(line) do\n\
    \            if col > 0 then\n                n = n + capacity - col\n       \
    \     end\n        end\n    end\n    return n\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphzsjakyi.lua:37:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmphzsjakyi.lua:37: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ table_max(t)\n        local maximum = 0\n        for i,v in ipairs(t) do\n \
    \           if (v > maximum) then\n                maximum = v\n            end\n\
    \        end\n        return maximum\n    end\n    local function table_sum(t)\n\
    \        local sum = 0\n        for i,v in ipairs(t) do\n            sum = sum\
    \ + v\n        end\n        return sum\n    end\n    local columns = {}\n    for\
    \ i,v in ipairs(grid) do\n        local units = 0\n        for j,u in ipairs(v)\
    \ do\n            if (u == 1) then\n                units = units + 1\n      \
    \      end\n        end\n        columns[i] = units\n    end\n    local column_sum\
    \ = table_sum(columns)\n    local column_max = table_max(columns)\n    local column_operations\
    \ = math.ceil(column_sum / capacity)\n    local row_operations = math.ceil(column_max\
    \ / capacity)\n    return row_operations + column_operations\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvvx2h2iz.lua:59:\
    \ expected: 6, actual: 10\nstack traceback:\n\t/tmp/tmpvvx2h2iz.lua:59: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local ok,\
    \ err = nil\n    ok, err = pcall(function ()\n        local rows = #grid\n   \
    \     local columns = #grid[1]\n        local cap = capacity\n        local sum\
    \ = 0\n        local last_line = nil\n        local last_line_sum = 0\n      \
    \  local filling = false\n        local filling_from = nil\n        local filling_from_sum\
    \ = 0\n        for i = 1, rows do\n            local row = grid[i]\n         \
    \   local row_sum = 0\n            for j = 1, columns do\n                local\
    \ elem = row[j]\n                row_sum = row_sum + elem\n            end\n \
    \           if row_sum == 0 then\n                if filling then\n          \
    \          filling = false\n                    filling_from = nil\n         \
    \           filling_from_sum = 0\n                end\n            else\n    \
    \            if filling then\n                    filling_from_sum = filling_from_sum\
    \ + row_sum\n                    if filling_from_sum >= cap then\n           \
    \             sum = sum + 1\n                        filling_from_sum = 0\n  \
    \                  end\n                else\n                    if last_line_sum\
    \ < cap then\n                        filling = true\n                       \
    \ filling_from = i\n                        filling_from_sum = row_sum\n     \
    \               else\n                        sum = sum + 1\n                \
    \    end\n                end\n            end\n            last_line = row\n\
    \            last_line_sum = row_sum\n        end\n        return sum\n    end)\n\
    \    if not ok then\n        print(err)\n    end\n    return err\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm772v2zl.lua:78:\
    \ expected: 6, actual: 2\nstack traceback:\n\t/tmp/tmpm772v2zl.lua:78: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- Your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpowu9lu9q.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpowu9lu9q.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local count\
    \ = 0\n    for i, row in ipairs(grid) do\n        -- the number of blocks to move\
    \ in a row\n        local to_move = 0\n        for j, col in ipairs(row) do\n\
    \            -- the number of blocks if current cell is 1\n            -- if we\
    \ have moved previous blocks, then we need to move\n            -- one less in\
    \ this row\n            to_move = to_move + col - 1\n            -- if to_move\
    \ is less than zero, we only need to do\n            -- the previous operation,\n\
    \            -- which is lowering the bucket count times.\n            if to_move\
    \ < 0 then\n                count = count + count_in_bucket(to_move, capacity)\n\
    \            end\n        end\n        -- if to_move is not less than zero, then\
    \ we need to move\n        -- it in this row\n        if to_move > 0 then\n  \
    \          count = count + count_in_bucket(to_move, capacity)\n        end\n \
    \   end\n    return count\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphd5zh_ke.lua:36:\
    \ attempt to call a nil value (global 'count_in_bucket')\nstack traceback:\n\t\
    /tmp/tmphd5zh_ke.lua:36: in local 'candidate'\n\t/tmp/tmphd5zh_ke.lua:51: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local length\
    \ = #grid[1]\n  local width = #grid\n  local times = 0\n  for i = 1, width do\n\
    \    for j = 1, length do\n      if grid[i][j] == 1 then\n        for k = j, length\
    \ do\n          if grid[i][k] == 1 then\n            times = times + 1\n     \
    \     else\n            break\n          end\n        end\n        j = j + capacity\
    \ - 1\n      end\n    end\n  end\n  return times\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxlzlgch9.lua:46:\
    \ expected: 6, actual: 12\nstack traceback:\n\t/tmp/tmpxlzlgch9.lua:46: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmmlnosih.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpmmlnosih.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- write your\
    \ code in Lua 5.3\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptl3b9h_z.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmptl3b9h_z.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  return 1\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzu2jce8t.lua:29:\
    \ expected: 6, actual: 1\nstack traceback:\n\t/tmp/tmpzu2jce8t.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local count\
    \ = 0\n    local wells = {}\n    local buckets = {}\n    local emptyWells = {}\n\
    \    local i, j, k\n    local rowCount = #grid\n    local colCount = #grid[1]\n\
    \    local currentCol = 0\n    local currentRow = 0\n    local bucketIndex = 1\n\
    \    local emptyWellIndex = 1\n    local currentWells = 1\n    local currentBuckets\
    \ = 1\n    local currentEmptyWells = 1\n    local isAllEmpty = false\n    local\
    \ isRowEmpty = false\n    local isColEmpty = false\n    local isColFull = false\n\
    \    local isRowFull = false\n    local isAllFull = false\n    local bucketCount\
    \ = capacity * rowCount\n    for i = 1, rowCount do\n        buckets[i] = capacity\n\
    \        wells[i] = {}\n        for j = 1, colCount do\n            wells[i][j]\
    \ = grid[i][j]\n        end\n    end\n    while true do\n        currentCol =\
    \ 0\n        currentRow = 0\n        bucketIndex = 1\n        emptyWellIndex =\
    \ 1\n        currentWells = #wells\n        currentBuckets = #buckets\n      \
    \  currentEmptyWells = #emptyWells\n        isAllEmpty = true\n        isAllFull\
    \ = true\n        for i = 1, currentWells do\n            isRowEmpty = true\n\
    \            isRowFull = true\n            for j = 1, currentBuckets do\n    \
    \            if wells[i][j] == 1 then\n                    isRowEmpty = false\n\
    \                    isAllEmpty = false\n                else\n              \
    \      isRowFull = false\n                    isAllFull = false\n            \
    \    end\n            end\n            if isRowEmpty then\n                emptyWells[emptyWellIndex]\
    \ = {i, currentBuckets + 1}\n                emptyWellIndex = emptyWellIndex +\
    \ 1\n            elseif isRowFull then\n                emptyWells[emptyWellIndex]\
    \ = {i, currentBuckets + 1}\n                emptyWellIndex = emptyWellIndex +\
    \ 1\n            end\n        end\n        if isAllEmpty then\n            break\n\
    \        end\n        if isAllFull then\n            for i = 1, currentEmptyWells\
    \ do\n                currentRow = emptyWells[i][1\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpc7w60ot1.lua:87: '']'' expected near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local buckets\
    \ = {}\n  local max_bucket = 0\n  local min_bucket = capacity + 1\n  for i = 1,\
    \ #grid do\n    local bucket = 0\n    for j = 1, #grid[i] do\n      bucket = bucket\
    \ + grid[i][j]\n    end\n    buckets[i] = bucket\n    max_bucket = math.max(max_bucket,\
    \ bucket)\n    min_bucket = math.min(min_bucket, bucket)\n  end\n  local count\
    \ = 0\n  for i = 1, #buckets do\n    count = count + buckets[i]\n  end\n  count\
    \ = count - max_bucket\n  local unused = capacity - min_bucket\n  if unused >\
    \ 0 then\n    count = count - unused\n  end\n  return count\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8qh2vv4u.lua:50:\
    \ expected: 6, actual: 2\nstack traceback:\n\t/tmp/tmp8qh2vv4u.lua:50: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local columns\
    \ = {}\n  local row = 1\n  local total = 0\n  while true do\n    local column\
    \ = 1\n    columns[row] = columns[row] or {}\n    while true do\n      local value\
    \ = grid[row][column]\n      if value == 1 then\n        if columns[row][column]\
    \ == nil then\n          columns[row][column] = capacity\n        end\n      \
    \  local delta = capacity - columns[row][column]\n        if columns[row + 1]\
    \ and columns[row + 1][column] then\n          delta = math.min(delta, columns[row\
    \ + 1][column])\n        end\n        if delta > 0 then\n          columns[row][column]\
    \ = columns[row][column] + delta\n          if columns[row + 1] then\n       \
    \     columns[row + 1][column] = columns[row + 1][column] - delta\n          end\n\
    \          total = total + delta\n        end\n      end\n      column = column\
    \ + 1\n      if not grid[row][column] then\n        break\n      end\n    end\n\
    \    row = row + 1\n    if not grid[row] then\n      break\n    end\n  end\n \
    \ return total\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg5a2tyj7.lua:63:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmpg5a2tyj7.lua:63: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- TODO: Write\
    \ your code here\n  return 0\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcoicz5uq.lua:30:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmpcoicz5uq.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- find the\
    \ lowest non-empty row\n    local lowest_row = nil\n    for i = 1, #grid do\n\
    \        if grid[i][1] == 1 then\n            lowest_row = i\n            break\n\
    \        end\n    end\n    -- if there is no non-empty row, return 0\n    if lowest_row\
    \ == nil then\n        return 0\n    end\n    -- find the highest non-empty row\n\
    \    local highest_row = nil\n    for i = #grid, 1, -1 do\n        if grid[i][1]\
    \ == 1 then\n            highest_row = i\n            break\n        end\n   \
    \ end\n    -- move water from the lowest non-empty row to the highest non-empty\
    \ row\n    local moves = 0\n    while lowest_row <= highest_row do\n        --\
    \ move water in the lowest non-empty row to the highest non-empty row\n      \
    \  if grid[lowest_row][1] == 1 then\n            moves = moves + 1\n         \
    \   -- fill wells in the lowest non-empty row\n            for i = 1, #grid[lowest_row]\
    \ do\n                if grid[lowest_row][i] == 1 then\n                    grid[lowest_row][i]\
    \ = 0\n                end\n            end\n            -- fill wells in the\
    \ highest non-empty row\n            for i = 1, #grid[highest_row] do\n      \
    \          if i > capacity then\n                    break\n                end\n\
    \                if grid[highest_row][i] == 0 then\n                    grid[highest_row][i]\
    \ = 1\n                end\n            end\n        end\n        lowest_row =\
    \ lowest_row + 1\n    end\n    return moves\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb2qnj8dg.lua:73:\
    \ expected: 6, actual: 1\nstack traceback:\n\t/tmp/tmpb2qnj8dg.lua:73: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local len\
    \ = 0\n    for _, r in ipairs(grid) do\n        for _, c in ipairs(r) do\n   \
    \         if c == 1 then\n                len = len + 1\n            end\n   \
    \     end\n    end\n    return capacity * len\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb3b5h0v9.lua:38:\
    \ expected: 5, actual: 18\nstack traceback:\n\t/tmp/tmpb3b5h0v9.lua:38: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local w, h =\
    \ #grid[1], #grid\n  local count = 0\n  local row_counts = {}\n  for row = 1,\
    \ h do\n    local sum = 0\n    for col = 1, w do\n      sum = sum + grid[row][col]\n\
    \    end\n    count = count + sum\n    table.insert(row_counts, sum)\n  end\n\
    \  if capacity >= count then\n    return 0\n  end\n  local max = math.max(unpack(row_counts))\n\
    \  if capacity < max then\n    return count - capacity * h\n  end\n  return count\
    \ - capacity * h + max - capacity\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpk7q1dl8s.lua:37:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpk7q1dl8s.lua:37:\
    \ in local 'candidate'\n\t/tmp/tmpk7q1dl8s.lua:47: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  --\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpypitqhl0.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpypitqhl0.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local bucket\
    \ = capacity\n    local count = 0\n    for i = 1, #grid do\n        for j = 1,\
    \ #grid[i] do\n            if grid[i][j] == 1 then\n                if bucket\
    \ == 0 then\n                    bucket = capacity\n                    count\
    \ = count + 1\n                end\n                bucket = bucket - 1\n    \
    \        end\n        end\n    end\n    return count\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp37p7gvxz.lua:42:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmp37p7gvxz.lua:42: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\t-- body\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx21rsmqr.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpx21rsmqr.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local n = #grid\n\
    \  local m = #grid[1]\n  local max_depth = 0\n  local water_count = 0\n  for i=1,n\
    \ do\n    local depth = 0\n    for j=1,m do\n      depth = depth + grid[i][j]\n\
    \    end\n    max_depth = math.max(max_depth, depth)\n    water_count = water_count\
    \ + depth\n  end\n  local bucket_count = math.ceil(water_count / capacity)\n \
    \ local well_count = math.ceil(max_depth / capacity)\n  return bucket_count *\
    \ well_count\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7o3v_p2p.lua:43:\
    \ expected: 6, actual: 24\nstack traceback:\n\t/tmp/tmp7o3v_p2p.lua:43: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows,\
    \ cols = #grid, #grid[1]\n    local answer = 0\n    local visited = {}\n    local\
    \ queue = {}\n    local top = 1\n    local function enqueue(x, y)\n        queue[top]\
    \ = {x, y}\n        top = top + 1\n    end\n    local function dequeue()\n   \
    \     local head = queue[1]\n        top = top - 1\n        queue[1] = queue[top]\n\
    \        return head\n    end\n    local function isValid(x, y)\n        return\
    \ x > 0 and x <= rows and y > 0 and y <= cols\n    end\n    for i=1,rows do\n\
    \        for j=1,cols do\n            if grid[i][j] == 1 and not visited[i..'-'..j]\
    \ then\n                enqueue(i, j)\n                visited[i..'-'..j] = true\n\
    \                local count = 1\n                while count > 0 do\n       \
    \             local u = dequeue()\n                    count = count - 1\n   \
    \                 if grid[u[1]][u[2]] == 1 then\n                        grid[u[1]][u[2]]\
    \ = 0\n                        answer = answer + 1\n                        if\
    \ isValid(u[1]+1, u[2]) and not visited[(u[1]+1)..'-'..u[2]] then\n          \
    \                  enqueue(u[1]+1, u[2])\n                            visited[(u[1]+1)..'-'..u[2]]\
    \ = true\n                            count = count + 1\n                    \
    \    end\n                        if isValid(u[1]-1, u[2]) and not visited[(u[1]-1)..'-'..u[2]]\
    \ then\n                            enqueue(u[1]-1, u[2])\n                  \
    \          visited[(u[1]-1)..'-'..u[2]] = true\n                            count\
    \ = count + 1\n                        end\n                        if isValid(u[1],\
    \ u[2]+1) and not visited[u[1]..'-'..(u[2]+1)] then\n                        \
    \    enqueue(u[1], u[2]+1)\n                            visited[u[1]..'-'\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp50ugvp88.lua:66: '']'' expected near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- your code\
    \ here\n    -- returns the number of times you need to lower the buckets\nend\n\
    return max_fill\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpptuanqpd.lua:27: <eof> expected near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local wells\
    \ = {}\n  local rows = #grid\n  local cols = #grid[1]\n  for i=1, rows do\n  \
    \  wells[i] = {value = 0, filled = false}\n    for j=1, cols do\n      if grid[i][j]\
    \ == 1 then\n        wells[i].value = wells[i].value + 1\n      end\n    end\n\
    \  end\n  local i = 1\n  local res = 0\n  local function update()\n    local max_v\
    \ = 0\n    local max_i = 0\n    for j=1, rows do\n      if wells[j].value > max_v\
    \ then\n        max_v = wells[j].value\n        max_i = j\n      end\n    end\n\
    \    if max_v > 0 then\n      wells[max_i].value = wells[max_i].value - capacity\n\
    \      wells[max_i].filled = true\n      res = res + 1\n    end\n  end\n  while\
    \ true do\n    update()\n    i = i + 1\n    if i > rows then i = 1 end\n    if\
    \ wells[i].filled then\n      wells[i].filled = false\n    else\n      break\n\
    \    end\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsllb2e9h.lua:67:\
    \ expected: 6, actual: 1\nstack traceback:\n\t/tmp/tmpsllb2e9h.lua:67: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local max_fill_so_far\
    \ = 0\n    local count = 0\n    for i = 1, #grid do\n        for j = 1, #grid[i]\
    \ do\n            if grid[i][j] == 1 then\n                if max_fill_so_far\
    \ < capacity then\n                    grid[i][j] = 0\n                    max_fill_so_far\
    \ = max_fill_so_far + 1\n                else\n                    count = count\
    \ + 1\n                    max_fill_so_far = 0\n                end\n        \
    \    end\n        end\n    end\n    return count\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp068wgnya.lua:44:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmp068wgnya.lua:44: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    if capacity\
    \ == 0 then\n        return 0\n    end\n    local num_rows = #grid\n    local\
    \ num_cols = #grid[1]\n    local well_stack = {}\n    local row_indices = {}\n\
    \    local col_indices = {}\n    local num_wells = 0\n    local total_water =\
    \ 0\n    for row = 1, num_rows do\n        for col = 1, num_cols do\n        \
    \    if grid[row][col] == 1 then\n                num_wells = num_wells + 1\n\
    \                row_indices[num_wells] = row\n                col_indices[num_wells]\
    \ = col\n                well_stack[num_wells] = 0\n            end\n        end\n\
    \    end\n    local num_cycles = 0\n    while num_wells > 0 do\n        num_cycles\
    \ = num_cycles + 1\n        local num_wells_to_fill = 0\n        for i = 1, num_wells\
    \ do\n            local well_index = i\n            local num_units_of_water =\
    \ well_stack[well_index]\n            local row = row_indices[well_index]\n  \
    \          local col = col_indices[well_index]\n            if num_units_of_water\
    \ < capacity then\n                local num_cols_above = col - 1\n          \
    \      local num_cols_below = num_cols - col\n                local num_cols_to_fill\
    \ = num_cols_above + num_cols_below\n                local num_units_to_fill =\
    \ math.min(capacity - num_units_of_water, num_cols_to_fill)\n                local\
    \ num_cols_above_to_fill = math.floor(num_units_to_fill / 2)\n               \
    \ local num_cols_below_to_fill = num_units_to_fill - num_cols_above_to_fill\n\
    \                total_water = total_water + num_units_to_fill\n             \
    \   num_units_of_water = num_units_of_water + num_units_to_fill\n            \
    \    well_stack[well_index] = num_units_of_water\n                if num_\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp5jqaqez4.lua:63: ''then'' expected near ''lu''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local sum\
    \ = 0\n    for _, row in ipairs(grid) do\n        local max_well = math.max(unpack(row))\n\
    \        sum = sum + max_well\n    end\n    return math.ceil(sum / capacity)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6hcg8myc.lua:25:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmp6hcg8myc.lua:25:\
    \ in local 'candidate'\n\t/tmp/tmp6hcg8myc.lua:34: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local max_rows,\
    \ max_cols = #grid, #grid[1]\n  local row_counts = {}\n  for i = 1, max_rows do\n\
    \    row_counts[i] = 0\n    for j = 1, max_cols do\n      row_counts[i] = row_counts[i]\
    \ + grid[i][j]\n    end\n  end\n  local move_count = 0\n  local current_row =\
    \ 1\n  while current_row <= max_rows do\n    if row_counts[current_row] == 0 then\n\
    \      current_row = current_row + 1\n    else\n      local row_to_remove_from\
    \ = current_row\n      while current_row <= max_rows and\n            row_counts[current_row]\
    \ == row_counts[row_to_remove_from] do\n        row_counts[current_row] = row_counts[current_row]\
    \ - capacity\n        current_row = current_row + 1\n      end\n      move_count\
    \ = move_count + 1\n    end\n  end\n  return move_count\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5mpllyvz.lua:52:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmp5mpllyvz.lua:52: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- your solution\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpusjd632c.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpusjd632c.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local desc\
    \ = {}\n    local level = {}\n    local r = #grid\n    local c = #grid[1]\n  \
    \  local g = {}\n    for i = 1, r do\n        g[i] = {}\n        level[i] = 0\n\
    \        desc[i] = 0\n        for j = 1, c do\n            g[i][j] = grid[i][j]\n\
    \        end\n    end\n    for i = 1, r do\n        for j = 1, c do\n        \
    \    if g[i][j] == 1 then\n                if level[i] < capacity then\n     \
    \               level[i] = level[i] + 1\n                else\n              \
    \      desc[i] = desc[i] + 1\n                end\n            end\n        end\n\
    \    end\n    local function next_step()\n        local max_desc = 0\n       \
    \ local min_desc = 0\n        local max_desc_i = -1\n        local min_desc_i\
    \ = -1\n        for i = 1, r do\n            if desc[i] > max_desc then\n    \
    \            max_desc = desc[i]\n                max_desc_i = i\n            end\n\
    \            if desc[i] < min_desc then\n                min_desc = desc[i]\n\
    \                min_desc_i = i\n            end\n        end\n        if max_desc_i\
    \ ~= -1 and min_desc_i ~= -1 then\n            level[max_desc_i] = level[max_desc_i]\
    \ - 1\n            level[min_desc_i] = level[min_desc_i] + 1\n            desc[max_desc_i]\
    \ = desc[max_desc_i] - 1\n            desc[min_desc_i] = desc[min_desc_i] + 1\n\
    \            return true\n        end\n        return false\n    end\n    local\
    \ count = 0\n    while next_step() do\n        count = count + 1\n    end\n  \
    \  return count\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpst1m9oto.lua:81:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmpst1m9oto.lua:81: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local sum =\
    \ 0\n  local g_max = 0\n  local drops = 0\n  local work = true\n  while work do\n\
    \    work = false\n    for i = 1, #grid do\n      if grid[i][#grid[i]] == 1 then\n\
    \        sum = sum + 1\n        grid[i][#grid[i]] = 0\n        work = true\n \
    \     end\n    end\n    if sum > 0 then\n      drops = drops + 1\n      sum =\
    \ sum - capacity\n      if sum > 0 then\n        sum = sum - 1\n        g_max\
    \ = g_max + 1\n      end\n    end\n  end\n  return g_max + drops\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4kbwjsm4.lua:51:\
    \ expected: 6, actual: 1\nstack traceback:\n\t/tmp/tmp4kbwjsm4.lua:51: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ min_fill(wells)\n        local min_fill_value = 0\n        for _, well in ipairs(wells)\
    \ do\n            min_fill_value = math.max(min_fill_value, well)\n        end\n\
    \        return min_fill_value\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpp6smg6n_.lua:41: ''end'' expected (to close ''function'' at
    line 22) near <eof>

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local num_buckets_lowered\
    \ = 0\n    local nrows = #grid\n    local ncols = #grid[1]\n    for i = 1, nrows\
    \ do\n        for j = 1, ncols do\n            local well_water = grid[i][j]\n\
    \            if well_water > 0 then\n                local num_buckets_to_extract\
    \ = math.ceil(well_water / capacity)\n                grid[i][j] = grid[i][j]\
    \ - capacity * num_buckets_to_extract\n                num_buckets_lowered = num_buckets_lowered\
    \ + num_buckets_to_extract\n            end\n        end\n    end\n    return\
    \ num_buckets_lowered\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoko4lnfw.lua:43:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmpoko4lnfw.lua:43: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local grid_length\
    \ = #grid\n  local row_length = #grid[1]\n  local sum = 0\n  -- \u0441\u0443\u043C\
    \u043C\u0430 \u0435\u0434\u0438\u043D\u0438\u0446 \u0432 \u0432\u044B\u0448\u043A\
    \u0430\u0445\n  for i = 1, grid_length do\n    for j = 1, row_length do\n    \
    \  sum = sum + grid[i][j]\n    end\n  end\n  return (grid_length - 1) * capacity\
    \ + sum\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnhhdtn0w.lua:38:\
    \ expected: 6, actual: 8\nstack traceback:\n\t/tmp/tmpnhhdtn0w.lua:38: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- grid : 2d\
    \ table of ints -> well matrix\n  -- capacity : int -> bucket capacity\n  local\
    \ n_wells = #grid\n  local n_units = #grid[1]\n  local n_cycles = 0\n  local curr_unit\
    \ = 1\n  -- for each well, pour the water into the bucket\n  for i = 1, n_wells\
    \ do\n    -- for each unit in the well,\n    for j = 1, n_units do\n      -- if\
    \ the unit contains water\n      if grid[i][j] == 1 then\n        -- pour the\
    \ water from the unit into the bucket,\n        -- incrementing the number of\
    \ cycles\n        grid[i][j] = 0\n        n_cycles = n_cycles + 1\n      end\n\
    \    end\n  end\n  return n_cycles\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxgltluvd.lua:49:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmpxgltluvd.lua:49: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local n =\
    \ #grid\n    local m = #grid[1]\n    local result = 0\n    for i = 1, n do\n \
    \       for j = 1, m do\n            local water = 0\n            for x = i -\
    \ 1, 0, -1 do\n                water = water + grid[x][j]\n            end\n \
    \           if water > capacity then\n                result = result + water\
    \ - capacity\n            end\n        end\n    end\n    return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphhrawpy5.lua:30:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmphhrawpy5.lua:30:\
    \ in local 'candidate'\n\t/tmp/tmphhrawpy5.lua:43: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local m = #grid\n\
    \  local n = #grid[1]\n  local visited = {}\n  local function dfs(i, j)\n    if\
    \ i < 1 or i > m or j < 1 or j > n or visited[i] and visited[i][j] or grid[i][j]\
    \ == 0 then\n      return\n    end\n    visited[i] = visited[i] or {}\n    visited[i][j]\
    \ = true\n    return true\n  end\n  local function get_wet_cell_count()\n    local\
    \ wet_cell_count = 0\n    for i = 1, m do\n      for j = 1, n do\n        if grid[i][j]\
    \ == 1 then\n          wet_cell_count = wet_cell_count + 1\n        end\n    \
    \  end\n    end\n    return wet_cell_count\n  end\n  local function remove_water()\n\
    \    for i = 1, m do\n      for j = 1, n do\n        if grid[i][j] == 1 then\n\
    \          grid[i][j] = 0\n        end\n      end\n    end\n  end\n  local function\
    \ pour_water(i, j)\n    grid[i][j] = 1\n    dfs(i + 1, j)\n    dfs(i - 1, j)\n\
    \    dfs(i, j + 1)\n    dfs(i, j - 1)\n  end\n  local function sink_bucket(i,\
    \ j)\n    pour_water(i, j)\n    if get_wet_cell_count() == m * n then\n      return\
    \ true\n    end\n    if capacity > 1 then\n      return sink_bucket(i + 1, j)\
    \ or sink_bucket(i - 1, j) or sink_bucket(i, j + 1) or sink_bucket(i, j - 1)\n\
    \    end\n    return false\n  end\n  local function bucket_count()\n    local\
    \ count = 0\n    for i = 1, m do\n      for j = 1, n do\n        if dfs(i, j)\
    \ then\n          count = count + 1\n        end\n      end\n    end\n    return\
    \ count\n  end\n  local count =\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpa8e7gkz3.lua:83: unexpected symbol near ''=''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local counter\
    \ = 0\n    local function fill_rows(row_index)\n        while true do\n      \
    \      local full = true\n            for i = 1, #grid[row_index] do\n       \
    \         if grid[row_index][i] == 1 then\n                    full = false\n\
    \                    break\n                end\n            end\n           \
    \ if full then\n                return\n            end\n            for i = 1,\
    \ #grid[row_index] do\n                if grid[row_index][i] == 1 then\n     \
    \               local bucket = capacity\n                    for j = row_index,\
    \ 1, -1 do\n                        if grid[j][i] == 1 then\n                \
    \            bucket = bucket - 1\n                            grid[j][i] = 0\n\
    \                        end\n                        if bucket == 0 then\n  \
    \                          break\n                        end\n              \
    \      end\n                    counter = counter + 1\n                end\n \
    \           end\n        end\n    end\n    for i = 1, #grid do\n        fill_rows(i)\n\
    \    end\n    return counter\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa02n1l32.lua:63:\
    \ expected: 5, actual: 9\nstack traceback:\n\t/tmp/tmpa02n1l32.lua:63: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\t\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxil_hnix.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpxil_hnix.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local n_rows\
    \ = #grid\n  local n_cols = #grid[1]\n  local row_accumulators = {}\n  local col_accumulators\
    \ = {}\n  for row_i = 1, n_rows do\n    for col_i = 1, n_cols do\n      if grid[row_i][col_i]\
    \ == 1 then\n        row_accumulators[row_i] = (row_accumulators[row_i] or 0)\
    \ + 1\n        col_accumulators[col_i] = (col_accumulators[col_i] or 0) + 1\n\
    \      end\n    end\n  end\n  local row_fills = 0\n  for i = 1, n_rows do\n  \
    \  if row_accumulators[i] ~= nil then\n      row_fills = row_fills + math.ceil(row_accumulators[i]\
    \ / capacity)\n    end\n  end\n  local col_fills = 0\n  for i = 1, n_cols do\n\
    \    if col_accumulators[i] ~= nil then\n      col_fills = col_fills + math.ceil(col_accumulators[i]\
    \ / capacity)\n    end\n  end\n  return row_fills + col_fills\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdm616qwt.lua:53:\
    \ expected: 6, actual: 12\nstack traceback:\n\t/tmp/tmpdm616qwt.lua:53: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ get_number_of_fill_holes(well)\n    local count = 0\n    for i, v in ipairs(well)\
    \ do\n      if v == 1 then\n        count = count + 1\n      end\n    end\n  \
    \  return count\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp4b8gly9u.lua:43: ''end'' expected (to close ''function'' at
    line 22) near <eof>

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO: add\
    \ implementation here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5sv7qvu8.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmp5sv7qvu8.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- do stuff\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsr287pq6.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpsr287pq6.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp14qsa4r4.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmp14qsa4r4.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local count\
    \ = 0\n    for i = 1, #grid do\n        local row = grid[i]\n        for j = 1,\
    \ #row do\n            local cell = row[j]\n            if cell == 1 then\n  \
    \              local bucket = capacity\n                while bucket > 0 do\n\
    \                    if i - 1 < 1 or grid[i - 1][j] == 0 then\n              \
    \          bucket = bucket - 1\n                        grid[i][j] = 0\n     \
    \               end\n                    if bucket == 0 then\n               \
    \         count = count + 1\n                    end\n                    i =\
    \ i - 1\n                end\n            end\n        end\n    end\n    return\
    \ count\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8js_e5_g.lua:33:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmp8js_e5_g.lua:33:\
    \ in local 'candidate'\n\t/tmp/tmp8js_e5_g.lua:49: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    return capacity\
    \ * (grid.length - 2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpps6x9cwe.lua:23:\
    \ attempt to perform arithmetic on a nil value (field 'length')\nstack traceback:\n\
    \t/tmp/tmpps6x9cwe.lua:23: in local 'candidate'\n\t/tmp/tmpps6x9cwe.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local answers\
    \ = {}\n    local iterations = 0\n    while true do\n        iterations = iterations\
    \ + 1\n        local columns = #grid[1]\n        local rows = #grid\n        local\
    \ row_index = 1\n        local column_index = 1\n        local previous_index\
    \ = 0\n        local previous_column_index = 0\n        local answer = 0\n   \
    \     while column_index <= columns do\n            while row_index <= rows do\n\
    \                if grid[row_index][column_index] == 1 then\n                \
    \    if capacity == 0 then\n                        table.insert(answers, answer)\n\
    \                        return answers\n                    end\n           \
    \         grid[row_index][column_index] = 0\n                    row_index = row_index\
    \ + 1\n                    capacity = capacity - 1\n                    answer\
    \ = answer + 1\n                else\n                    row_index = row_index\
    \ + 1\n                end\n            end\n            column_index = column_index\
    \ + 1\n            row_index = 1\n        end\n        table.insert(answers, answer)\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyeg05e6k.lua:59:\
    \ expected: 6, actual: {1}\nstack traceback:\n\t/tmp/tmpyeg05e6k.lua:59: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local i, j\
    \ = 1, 1\n    local times = 0\n    for i = 1, #grid do\n        local j = 1\n\
    \        local k = 1\n        local count = 0\n        local current_capacity\
    \ = capacity\n        while j <= #grid[i] do\n            if grid[i][j] == 1 then\n\
    \                count = count + 1\n                current_capacity = current_capacity\
    \ - 1\n                j = j + 1\n            else\n                if count >\
    \ 0 then\n                    k = k + 1\n                    current_capacity\
    \ = capacity\n                    count = 0\n                else\n          \
    \          j = j + 1\n                end\n            end\n            if current_capacity\
    \ == 0 then\n                times = times + 1\n                current_capacity\
    \ = capacity\n            end\n        end\n        if count > 0 then\n      \
    \      times = times + 1\n        end\n    end\n    return times\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc8qgt4a6.lua:59:\
    \ expected: 6, actual: 7\nstack traceback:\n\t/tmp/tmpc8qgt4a6.lua:59: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ min(a, b) return a < b and a or b end\n    local function sum(x)\n        local\
    \ s = 0\n        for _, y in ipairs(x) do s = s + y end\n        return s\n  \
    \  end\n    local fills = {}\n    for i, row in ipairs(grid) do\n        local\
    \ fills_in_row = {}\n        local sum_row = sum(row)\n        local num_fills\
    \ = sum_row // capacity\n        local remainder = sum_row % capacity\n      \
    \  for j = 1, #row do\n            if row[j] == 1 then\n                fills_in_row[j]\
    \ = capacity\n            else\n                fills_in_row[j] = 0\n        \
    \    end\n        end\n        for j = 1, remainder do\n            fills_in_row[j]\
    \ = fills_in_row[j] + 1\n        end\n        fills[i] = fills_in_row\n    end\n\
    \    local function max_fill_in_column(j)\n        local m = 0\n        for i\
    \ = 1, #fills do\n            m = max(m, fills[i][j])\n        end\n        return\
    \ m\n    end\n    local s = 0\n    for j = 1, #fills[1] do\n        s = s + max_fill_in_column(j)\n\
    \    end\n    return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9njqde6h.lua:50:\
    \ attempt to call a nil value (global 'max')\nstack traceback:\n\t/tmp/tmp9njqde6h.lua:50:\
    \ in local 'max_fill_in_column'\n\t/tmp/tmp9njqde6h.lua:56: in local 'candidate'\n\
    \t/tmp/tmp9njqde6h.lua:64: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local result\
    \ = 0\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpx_zlo9m4.lua:35: ''end'' expected (to close ''function'' at
    line 22) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ min(a, b)\n    if a < b then\n      return a\n    else\n      return b\n   \
    \ end\n  end\n  local filled = 0\n  for i = 1, #grid do\n    local well = grid[i]\n\
    \    local water = 0\n    for j = 1, #well do\n      if well[j] == 1 then\n  \
    \      water = water + 1\n      end\n    end\n    filled = filled + capacity -\
    \ min(capacity, water)\n  end\n  return filled\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgwg1w8l9.lua:47:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmpgwg1w8l9.lua:47: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local cache\
    \ = {}\n    local function path(row, col)\n        if row == #grid and col ==\
    \ #grid[1] then\n            return 0\n        end\n        if row > #grid or\
    \ col > #grid[1] then\n            return math.huge\n        end\n        if cache[row]\
    \ and cache[row][col] then\n            return cache[row][col]\n        end\n\
    \        local result = math.min(\n            path(row + 1, col) + 1,\n     \
    \       path(row, col + 1) + 1,\n            path(row + 1, col + 1) + 1,\n   \
    \         grid[row][col] == 1 and path(row + 1, col + 1) or math.huge\n      \
    \  )\n        if not cache[row] then\n            cache[row] = {}\n        end\n\
    \        cache[row][col] = result\n        return result\n    end\n    return\
    \ math.floor(path(1, 1) / capacity)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1o4aw07x.lua:52:\
    \ expected: 6, actual: 2\nstack traceback:\n\t/tmp/tmp1o4aw07x.lua:52: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- TODO\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvkxwto1_.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpvkxwto1_.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1,\
    \ 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1,\
    \ 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0,\
    \ 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmmlnosih.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpmmlnosih.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local columns = #grid[1]\n    local result = 0\n    local remaining\
    \ = 0\n    for column = 1, columns do\n        local min_height = 0\n        for\
    \ row = 1, rows do\n            local well = grid[row][column]\n            if\
    \ well == 1 then\n                if row > min_height then\n                 \
    \   if remaining >= row - min_height then\n                        remaining =\
    \ remaining - (row - min_height)\n                    else\n                 \
    \       result = result + 1\n                        remaining = capacity - (row\
    \ - min_height)\n                    end\n                end\n              \
    \  min_height = row\n            end\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprz2pj8ox.lua:51:\
    \ expected: 5, actual: 7\nstack traceback:\n\t/tmp/tmprz2pj8ox.lua:51: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- need to implement\
    \ this\n  return 0\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq7bnaynk.lua:30:\
    \ expected: 6, actual: 0\nstack traceback:\n\t/tmp/tmpq7bnaynk.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    -- TODO: Implement\
    \ the solution\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcsz3f2i_.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpcsz3f2i_.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local wells_num\
    \ = #grid[1]\n    local rows_num = #grid\n    local max_level = 0\n    local wells_status\
    \ = {}\n    local water_level = 0\n    local time = 0\n    local rows_filled =\
    \ 0\n    -- find the maximum level\n    for i=1,rows_num do\n        for j=1,wells_num\
    \ do\n            if grid[i][j] > 0 then\n                max_level = max_level\
    \ + 1\n            end\n        end\n    end\n    while water_level < max_level\
    \ do\n        water_level = water_level + 1\n        time = time + 1\n       \
    \ rows_filled = 0\n        for i=1,rows_num do\n            local row_filled =\
    \ true\n            for j=1,wells_num do\n                if grid[i][j] > 0 then\n\
    \                    if wells_status[j] < capacity then\n                    \
    \    row_filled = false\n                        wells_status[j] = wells_status[j]\
    \ + 1\n                    end\n                end\n            end\n       \
    \     if row_filled then\n                rows_filled = rows_filled + 1\n    \
    \        end\n        end\n        if rows_filled == rows_num then\n         \
    \   for i=1,wells_num do\n                wells_status[i] = 0\n            end\n\
    \        end\n    end\n    return time\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpe_04un3z.lua:46:\
    \ attempt to compare nil with number\nstack traceback:\n\t/tmp/tmpe_04un3z.lua:46:\
    \ in local 'candidate'\n\t/tmp/tmpe_04un3z.lua:68: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ fill_once(grid, capacity)\n    local num_rows = #grid\n    local num_cols =\
    \ #grid[1]\n    local fill_count = 0\n    for i = 1, num_rows do\n      local\
    \ num_units = 0\n      for j = 1, num_cols do\n        num_units = num_units +\
    \ grid[i][j]\n      end\n      if num_units > 0 then\n        if num_units > capacity\
    \ then\n          for j = 1, num_cols do\n            grid[i][j] = grid[i][j]\
    \ - 1\n          end\n          fill_count = fill_count + 1\n        else\n  \
    \        for j = 1, num_cols do\n            grid[i][j] = 0\n          end\n \
    \         fill_count = fill_count + num_units\n        end\n      end\n    end\n\
    \    return fill_count\n  end\n  local total_fill_count = 0\n  repeat\n    local\
    \ fill_count = fill_once(grid, capacity)\n    total_fill_count = total_fill_count\
    \ + fill_count\n  until fill_count == 0\n  return total_fill_count\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy3zxaxx5.lua:59:\
    \ expected: 6, actual: 3\nstack traceback:\n\t/tmp/tmpy3zxaxx5.lua:59: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local count\
    \ = 0\n  local function recurse(row, col)\n    count = count + 1\n    grid[row][col]\
    \ = 0\n    if row == #grid and col == #grid[row] then\n      return count\n  \
    \  end\n    if row < #grid and grid[row + 1][col] == 1 then\n      recurse(row\
    \ + 1, col)\n    end\n    if col < #grid[row] and grid[row][col + 1] == 1 then\n\
    \      recurse(row, col + 1)\n    end\n  end\n  recurse(1, 1)\n  return count\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmped103zpr.lua:44:\
    \ expected: 6, actual: 1\nstack traceback:\n\t/tmp/tmped103zpr.lua:44: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local function\
    \ recurse(grid, row, columns)\n        if row == #grid then\n            return\
    \ 0\n        end\n        local count = 0\n        for column = 1, #grid[row]\
    \ do\n            if grid[row][column] == 1 then\n                local search\
    \ = row + 1\n                while search <= #grid and grid[search][column] ==\
    \ 0 do\n                    search = search + 1\n                end\n       \
    \         if search <= #grid then\n                    grid[search][column] =\
    \ 0\n                    count = count + 1\n                end\n            end\n\
    \        end\n        local search = row + 1\n        while search <= #grid and\
    \ count < capacity do\n            for column = 1, #grid[search] do\n        \
    \        if grid[search][column] == 1 then\n                    grid[search][column]\
    \ = 0\n                    count = count + 1\n                end\n          \
    \  end\n            search = search + 1\n        end\n        count = count +\
    \ recurse(grid, row + 1, columns)\n        return count\n    end\n    return recurse(grid,\
    \ 1, #grid[1])\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpthxdifk3.lua:59:\
    \ expected: 6, actual: 2\nstack traceback:\n\t/tmp/tmpthxdifk3.lua:59: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- Empty wells.\n\
    \  local empty_wells = {}\n  for row_i, row in ipairs(grid) do\n    local row_empty_wells\
    \ = {}\n    for well_i, well in ipairs(row) do\n      if well == 0 then\n    \
    \    table.insert(row_empty_wells, well_i)\n      end\n    end\n    table.insert(empty_wells,\
    \ row_empty_wells)\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpoqa3i4qa.lua:45: ''end'' expected (to close ''function'' at
    line 22) near <eof>

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  -- your code\
    \ goes here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0,\
    \ 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpetlu2bid.lua:29:\
    \ expected: 6, actual: nil\nstack traceback:\n\t/tmp/tmpetlu2bid.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n\tlocal rows =\
    \ #grid\n\tlocal cols = #grid[1]\n\tlocal count = 0\n\tlocal i = 1\n\twhile i\
    \ <= rows do\n\t\tlocal j = 1\n\t\twhile j <= cols do\n\t\t\tif grid[i][j] ==\
    \ 1 then\n\t\t\t\tlocal c = capacity\n\t\t\t\twhile c > 0 do\n\t\t\t\t\tif i +\
    \ c <= rows then\n\t\t\t\t\t\tgrid[i + c][j] = 0\n\t\t\t\t\t\tc = c - 1\n\t\t\t\
    \t\telse\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tcount = count\
    \ + 1\n\t\t\tend\n\t\t\tj = j + 1\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn count\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptc8bzr6k.lua:52:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmptc8bzr6k.lua:52: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 0
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local n =\
    \ #grid\n    local m = #grid[1]\n    local cnt = 0\n    local max_height = 0\n\
    \    for i = 1, n do\n        local row = grid[i]\n        local sum = 0\n   \
    \     for j = 1, m do\n            if row[j] == 1 then\n                sum =\
    \ sum + 1\n            end\n        end\n        local height = math.floor(sum\
    \ / capacity)\n        local rest = sum % capacity\n        local water = rest\
    \ > 0 and height + 1 or height\n        max_height = math.max(max_height, water)\n\
    \        cnt = cnt + water\n    end\n    return cnt\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local function\
    \ max_depth(grid)\n    local r = {}\n    for i = 1, #grid do\n      local d =\
    \ 0\n      for j = 1, #grid[i] do\n        if grid[i][j] == 1 then\n         \
    \ d = d + 1\n        end\n      end\n      table.insert(r, d)\n    end\n    return\
    \ r\n  end\n  local function min_in_row(row)\n    local r = math.huge\n    for\
    \ i = 1, #row do\n      if row[i] < r then\n        r = row[i]\n      end\n  \
    \  end\n    return r\n  end\n  local function max_in_row(row)\n    local r = 0\n\
    \    for i = 1, #row do\n      if row[i] > r then\n        r = row[i]\n      end\n\
    \    end\n    return r\n  end\n  local function find_max_in_row(row)\n    local\
    \ r = 0\n    for i = 1, #row do\n      if row[i] > r then\n        r = row[i]\n\
    \      end\n    end\n    return r\n  end\n  local function all_depths_in_row(row)\n\
    \    local r = {}\n    for i = 1, #row do\n      if row[i] > 0 then\n        table.insert(r,\
    \ row[i])\n      end\n    end\n    return r\n  end\n  local function find_min_height(row)\n\
    \    return math.min(unpack(all_depths_in_row(row)))\n  end\n  local function\
    \ find_max_height(row)\n    return math.max(unpack(all_depths_in_row(row)))\n\
    \  end\n  local function make_average_row(row, depth)\n    local r = {}\n    for\
    \ i = 1, #row do\n      if row[i] > 0 then\n        table.insert(r, depth)\n \
    \     else\n        table.insert(r, 0)\n      end\n    end\n    return r\n  end\n\
    \  local function times_repeated(v, row)\n    local r = 0\n    for i = 1, #\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
    \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1),\
    \ 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}},\
    \ 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n\
    \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpu1e_6bd9.lua:92: ''do'' expected near ''=''

    '
  stdout: ''
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local n =\
    \ #grid\n    local m = #grid[1]\n    local buckets = m\n    local res = 0\n  \
    \  local max_fill = math.floor(capacity / buckets)\n    for i = 1, n do\n    \
    \    local sum = 0\n        for j = 1, m do\n            sum = sum + grid[i][j]\n\
    \        end\n        local fill = math.floor(sum / buckets)\n        if fill\
    \ > max_fill then\n            res = res + (fill - max_fill) * buckets\n     \
    \   end\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1,\
    \ 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0,\
    \ 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphf3mv3me.lua:44:\
    \ expected: 6, actual: 4\nstack traceback:\n\t/tmp/tmphf3mv3me.lua:44: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
- exit_code: 1
  program: "-- You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n-- and\
    \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
    \ the wells.\n-- Output the number of times you need to lower the buckets.\n--\
    \ Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n\
    -- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1},\
    \ {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}},\
    \ 5)\n-- 0\n-- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length\
    \ <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- *\
    \ 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local rows\
    \ = #grid\n    local columns = #grid[1]\n    local buckets = 0\n    local fill_row\n\
    \    for j = 1, columns do\n        buckets = buckets + grid[1][j]\n    end\n\
    \    while true do\n        fill_row = false\n        for i = 2, rows do\n   \
    \         local empty_count = 0\n            for j = 1, columns do\n         \
    \       if grid[i][j] == 0 then\n                    empty_count = empty_count\
    \ + 1\n                end\n            end\n            if empty_count <= capacity\
    \ then\n                for j = 1, columns do\n                    if grid[i][j]\
    \ == 1 then\n                        grid[i][j] = 0\n                        buckets\
    \ = buckets + 1\n                    end\n                end\n              \
    \  fill_row = true\n            end\n        end\n        if not fill_row then\n\
    \            break\n        end\n    end\n    return buckets\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0,\
    \ 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0,\
    \ 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1,\
    \ 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}},\
    \ 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq3aenj9x.lua:59:\
    \ expected: 6, actual: 5\nstack traceback:\n\t/tmp/tmpq3aenj9x.lua:59: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659978079
