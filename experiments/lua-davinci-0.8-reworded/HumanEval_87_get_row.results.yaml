name: HumanEval_87_get_row
language: lua
results:
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local row = 0\n    local\
    \ res = {}\n    for i = 1, #lst do\n        for j = 1, #lst[i] do\n          \
    \  if lst[i][j] == x then\n                row = row + 1\n                res[row]\
    \ = {i - 1, j - 1}\n            end\n        end\n    end\n    table.sort(res,\
    \ function(a, b)\n        if a[1] < b[1] then\n            return true\n     \
    \   elseif a[1] > b[1] then\n            return false\n        else\n        \
    \    return a[2] > b[2]\n        end\n    end)\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4},\
    \ {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1,\
    \ 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1,\
    \ 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3},\
    \ {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local coords = {}\n   \
    \ for y, v in ipairs(lst) do\n        for i, n in ipairs(v) do\n            if\
    \ n == x then\n                table.insert(coords, {y - 1, #v - i})\n       \
    \     end\n        end\n    end\n    local function compare(a, b)\n        if\
    \ a[1] < b[1] then\n            return true\n        elseif a[1] == b[1] then\n\
    \            return a[2] > b[2]\n        end\n        return false\n    end\n\
    \    table.sort(coords, compare)\n    return coords\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4},\
    \ {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1,\
    \ 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1,\
    \ 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3},\
    \ {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzr5ax0w6.lua:40:\
    \ expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{0, 5}, {1, 5},\
    \ {1, 1}, {2, 5}, {2, 0}}\nstack traceback:\n\t/tmp/tmpzr5ax0w6.lua:40: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local result = {}\n   \
    \ for i, row in ipairs(lst) do\n        for j, v in ipairs(row) do\n         \
    \   if v == x then\n                table.insert(result, {i - 1, j - 1})\n   \
    \         end\n        end\n    end\n    table.sort(result, function(a, b)\n \
    \       return a[1] < b[1] or (a[1] == b[1] and a[2] > b[2])\n    end)\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1,\
    \ 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n   \
    \ lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3,\
    \ 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0,\
    \ 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6},\
    \ {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1,\
    \ 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5},\
    \ {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}},\
    \ 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n  local res = {}\n  local len\
    \ = #lst\n  for i = 0, len - 1 do\n    local len1 = #lst[i + 1]\n    for j = 0,\
    \ len1 - 1 do\n      if lst[i + 1][j + 1] == x then\n        table.insert(res,\
    \ {i, j})\n      end\n    end\n  end\n  table.sort(res, function(a, b)\n    if\
    \ a[1] == b[1] then\n      return a[2] > b[2]\n    else\n      return a[1] < b[1]\n\
    \    end\n  end)\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4,\
    \ 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6},\
    \ {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1,\
    \ 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5},\
    \ {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}},\
    \ 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n  local res = {}\n  for i =\
    \ 1, #lst do\n    for j = 1, #lst[i] do\n      if lst[i][j] == x then\n      \
    \  res[#res + 1] = {i - 1, j - 1}\n      end\n    end\n  end\n  local sort = function(a,\
    \ b)\n    if a[1] == b[1] then\n      return a[2] > b[2]\n    else\n      return\
    \ a[1] < b[1]\n    end\n  end\n  table.sort(res, sort)\n  return res\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2,\
    \ 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1},\
    \ {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2,\
    \ 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3,\
    \ 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n  local res = {}\n  for row\
    \ = 0, #lst - 1 do\n    for col = 0, #lst[row + 1] - 1 do\n      if lst[row +\
    \ 1][col + 1] == x then\n        table.insert(res, {row, col})\n      end\n  \
    \  end\n  end\n  table.sort(res, function(a, b)\n    if a[1] == b[1] then\n  \
    \    return a[2] > b[2]\n    else\n      return a[1] < b[1]\n    end\n  end)\n\
    \  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2,\
    \ 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6},\
    \ {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1,\
    \ 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5},\
    \ {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}},\
    \ 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n\tlocal r = {}\n\tfor i, v\
    \ in ipairs(lst) do\n\t\tfor j, n in ipairs(v) do\n\t\t\tif n == x then\n\t\t\t\
    \ttable.insert(r, {i - 1, j - 1})\n\t\t\tend\n\t\tend\n\tend\n\treturn r\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2,\
    \ 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1},\
    \ {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2,\
    \ 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3,\
    \ 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0et3xudc.lua:31:\
    \ expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{0, 0}, {1, 0},\
    \ {1, 4}, {2, 0}, {2, 5}}\nstack traceback:\n\t/tmp/tmp0et3xudc.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n\tres={}\n\tfor y,v in ipairs(lst)\
    \ do\n\t\tfor y1,v1 in ipairs(v) do\n\t\t\tif v1==x then\n\t\t\t\tres[#res+1]={y-1,y1-1}\n\
    \t\t\tend\n\t\tend\n\tend\n\ttable.sort(res,function(a,b) return a[1]<b[1] or\
    \ (a[1]==b[1] and a[2]>b[2]) end)\n\treturn res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4},\
    \ {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1,\
    \ 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1,\
    \ 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3},\
    \ {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local res = {}\n    for\
    \ i = 1, #lst do\n        local row = lst[i]\n        for j = 1, #row do\n   \
    \         if row[j] == x then\n                res[#res + 1] = {i - 1, j - 1}\n\
    \            end\n        end\n    end\n    -- Sort coordinates initially by rows\
    \ in ascending order.\n    -- Also, sort coordinates of the row by columns in\
    \ descending order.\n    table.sort(res, function(a, b)\n        if a[1] == b[1]\
    \ then\n            return a[2] > b[2]\n        else\n            return a[1]\
    \ < b[1]\n        end\n    end)\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4},\
    \ {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1,\
    \ 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1,\
    \ 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3},\
    \ {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local res = {}\n    for\
    \ i = 1, #lst do\n        for j = 1, #lst[i] do\n            if lst[i][j] == x\
    \ then\n                res[#res + 1] = {i - 1, j - 1}\n            end\n    \
    \    end\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4,\
    \ 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6},\
    \ {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1,\
    \ 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5},\
    \ {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}},\
    \ 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphg_y2882.lua:31:\
    \ expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{0, 0}, {1, 0},\
    \ {1, 4}, {2, 0}, {2, 5}}\nstack traceback:\n\t/tmp/tmphg_y2882.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local row={}\n    for i=1,#lst\
    \ do\n        for j=1,#lst[i] do\n            if lst[i][j]==x then\n         \
    \       table.insert(row,{i-1,j-1})\n            end\n        end\n    end\n \
    \   return row\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2,\
    \ 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6},\
    \ {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1,\
    \ 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5},\
    \ {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}},\
    \ 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgdps32l0.lua:31:\
    \ expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{0, 0}, {1, 0},\
    \ {1, 4}, {2, 0}, {2, 5}}\nstack traceback:\n\t/tmp/tmpgdps32l0.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n  local ret = {}\n  for row,\
    \ _row in ipairs(lst) do\n    for col, _col in ipairs(_row) do\n      if _col\
    \ == x then\n        ret[#ret + 1] = {row - 1, col - 1}\n      end\n    end\n\
    \  end\n  table.sort(ret, function(a, b)\n    if a[1] == b[1] then\n      return\
    \ a[2] > b[2]\n    else\n      return a[1] < b[1]\n    end\n  end)\n  return ret\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2,\
    \ 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1},\
    \ {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2,\
    \ 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3,\
    \ 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local result = {}\n   \
    \ for row, value in ipairs(lst) do\n        for col, value in ipairs(value) do\n\
    \            if value == x then\n                table.insert(result, {row - 1,\
    \ col - 1})\n            end\n        end\n    end\n    table.sort(result, function(left,\
    \ right)\n        if left[1] == right[1] then\n            return left[2] > right[2]\n\
    \        else\n            return left[1] < right[1]\n        end\n    end)\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4,\
    \ 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6},\
    \ {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1,\
    \ 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5},\
    \ {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}},\
    \ 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n  local res = {}\n  for row,\
    \ lst in ipairs(lst) do\n    for column, x_ in ipairs(lst) do\n      if x_ ==\
    \ x then\n        table.insert(res, {row - 1, column - 1})\n      end\n    end\n\
    \  end\n  table.sort(res, function(a, b)\n    if a[1] == b[1] then\n      return\
    \ a[2] > b[2]\n    else\n      return a[1] < b[1]\n    end\n  end)\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2,\
    \ 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1},\
    \ {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2,\
    \ 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3,\
    \ 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n\tlocal r = {}\n\tfor y,v in\
    \ ipairs(lst) do\n\t\tfor k, vv in ipairs(v) do\n\t\t\tif vv == x then\n\t\t\t\
    \ttable.insert(r, {y - 1, k - 1})\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(r,\
    \ function(a, b) return a[1] < b[1] end)\n\tfor i,v in ipairs(r) do\n\t\ttable.sort(v,\
    \ function(a, b) return a[2] > b[2] end)\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4},\
    \ {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1,\
    \ 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1,\
    \ 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3},\
    \ {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3sanewqe.lua:27:\
    \ attempt to index a number value (local 'a')\nstack traceback:\n\t/tmp/tmp3sanewqe.lua:27:\
    \ in function </tmp/tmp3sanewqe.lua:27>\n\t[C]: in function 'table.sort'\n\t/tmp/tmp3sanewqe.lua:27:\
    \ in local 'candidate'\n\t/tmp/tmp3sanewqe.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n\tlocal t = {}\n\tlocal i =\
    \ 0\n\tfor _, row in ipairs(lst) do\n\t\tlocal l = {}\n\t\tlocal j = 0\n\t\tfor\
    \ _, y in ipairs(row) do\n\t\t\tif y == x then\n\t\t\t\ttable.insert(l, {j, i})\n\
    \t\t\tend\n\t\t\tj = j + 1\n\t\tend\n\t\tfor _, k in ipairs(l) do\n\t\t\ttable.insert(t,\
    \ k)\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4},\
    \ {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1,\
    \ 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1,\
    \ 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3},\
    \ {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr6g4dscw.lua:39:\
    \ expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{0, 0}, {0, 1},\
    \ {4, 1}, {0, 2}, {5, 2}}\nstack traceback:\n\t/tmp/tmpr6g4dscw.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    if lst == nil then\n  \
    \      return nil\n    end\n    local new_lst = {}\n    for i,v in ipairs(lst)\
    \ do\n        for j, v2 in ipairs(v) do\n            if v2 == x then\n       \
    \         table.insert(new_lst, {i - 1, j - 1})\n            end\n        end\n\
    \    end\n    table.sort(new_lst, function(x, y) return x[1] < y[1] end)\n   \
    \ for _,v in ipairs(new_lst) do\n        table.sort(v, function(x, y) return x\
    \ > y end)\n    end\n    return new_lst\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4},\
    \ {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1,\
    \ 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1,\
    \ 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3},\
    \ {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpej08pyhh.lua:38:\
    \ expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{0, 0}, {1, 0},\
    \ {4, 1}, {2, 0}, {5, 2}}\nstack traceback:\n\t/tmp/tmpej08pyhh.lua:38: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n\tlocal result = {}\n\tfor\
    \ i, v in ipairs(lst) do\n\t\tfor j, u in ipairs(v) do\n\t\t\tif u == x then\n\
    \t\t\t\tresult[#result + 1] = {i - 1, j - 1}\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(result,\
    \ function(a, b)\n\t\treturn a[1] < b[1] or (a[1] == b[1] and a[2] > b[2])\n\t\
    end)\n\treturn result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5,\
    \ 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4,\
    \ 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6},\
    \ {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1,\
    \ 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5},\
    \ {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}},\
    \ 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\n\
    end\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n  -- your code here\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2,\
    \ 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1},\
    \ {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2,\
    \ 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3,\
    \ 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3ftd57b6.lua:23:\
    \ expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: nil\nstack traceback:\n\
    \t/tmp/tmp3ftd57b6.lua:23: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a 2 dimensional data, as a nested tables,\n-- which is\
    \ similar to matrix, however, unlike matrices,\n-- each row may contain a different\
    \ number of columns.\n-- Given lst, and integer x, find integers x in the table,\n\
    -- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table\
    \ is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially\
    \ by rows in ascending order.\n-- Also, sort coordinates of the row by columns\
    \ in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5},\
    \ {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}},\
    \ 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local res = {}\n    for\
    \ i = 1, #lst do\n        for j = 1, #lst[i] do\n            if lst[i][j] == x\
    \ then\n                res[#res + 1] = {i - 1, j - 1}\n            end\n    \
    \    end\n    end\n    local comp = function(t1, t2)\n        if t1[1] ~= t2[1]\
    \ then\n            return t1[1] < t2[1]\n        else\n            return t1[2]\
    \ > t2[2]\n        end\n    end\n    table.sort(res, comp)\n    return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n\
    \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2,\
    \ 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1,\
    \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6},\
    \ {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1},\
    \ {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2,\
    \ 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1,\
    \ 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3,\
    \ 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
    \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
    \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
