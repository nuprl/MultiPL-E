name: HumanEval_148_bf
language: lua
prompt: "-- There are eight planets in our solar system: the closerst to the Sun \n\
  -- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n-- Uranus,\
  \ Neptune.\n-- Write a function that takes two planet names as strings planet1 and\
  \ planet2. \n-- The function should return a table containing all planets whose\
  \ orbits are \n-- located between the orbit of planet1 and the orbit of planet2,\
  \ sorted by \n-- the proximity to the sun. \n-- The function should return an empty\
  \ table if planet1 or planet2\n-- are not correct planet names. \n-- Examples\n\
  -- >>> bf('Jupiter', 'Neptune')\n-- {'Saturn', 'Uranus'}\n-- >>> bf('Earth', 'Mercury')\n\
  -- 'Venus'\n-- >>> bf('Mercury', 'Uranus')\n-- {'Venus', 'Earth', 'Mars', 'Jupiter',\
  \ 'Saturn'}\nlocal function bf(planet1, planet2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
  \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n  \
  \  lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
  \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
  \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
  \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
  \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: [end, "    local t = {Mercury = 1, Venus = 2, Earth = 3, Mars = 4, Jupiter\
    \ = 5, \n        Saturn = 6, Uranus = 7, Neptune = 8}\n    local planets = {}\n\
    \    if t[planet1] == nil or t[planet2] == nil then\n        return planets\n\
    \    end\n    local start = math.min(t[planet1], t[planet2])\n    local stop =\
    \ math.max(t[planet1], t[planet2])\n    for i = start, stop do\n        table.insert(planets,\
    \ table.index(t, i))\n    end\n    return planets\nend", "  \n  local planets\
    \ = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\
    \  local result = {}\n  local next_planet = nil\n  local found_planet1 = false\n\
    \  local found_planet2 = false\n  \n  -- planets between planet1 and planet2\n\
    \  if planet1 == planet2 then\n    return {planet1}\n  end\n  \n  -- either planet1\
    \ or planet2 not a planet\n  if not table.contains(planets, planet1) or not table.contains(planets,\
    \ planet2) then\n    return {}\n  end\n  \n  for _, planet in ipairs(planets)\
    \ do\n    if planet == planet1 then\n      next_planet = planet2\n      found_planet1\
    \ = true\n    elseif planet == planet2 then\n      next_planet = planet1\n   \
    \   found_planet2 = true\n    end\n    \n    if found_planet1 and found_planet2\
    \ then\n      break\n    end\n    \n    if planet == next_planet then\n      break\n\
    \    end\n    \n    table.insert(result, planet)\n  end\n  \n  return result\n\
    end", "    local planets = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune'}\n    local planet1_i = 0\n    local planet2_i = 0\n   \
    \ local res = {}\n    for i, p in ipairs(planets) do\n        if p == planet1\
    \ then\n            planet1_i = i\n        end\n        if p == planet2 then\n\
    \            planet2_i = i\n        end\n    end\n    if planet1_i ~= 0 and planet2_i\
    \ ~= 0 then\n        for i, p in ipairs(planets) do\n            if planet1_i\
    \ < planet2_i then\n                if planet1_i < i and i < planet2_i then\n\
    \                    table.insert(res, p)\n                end\n            else\n\
    \                if planet2_i < i and i < planet1_i then\n                   \
    \ table.insert(res, p)\n                end\n            end\n        end\n  \
    \  end\n    return res\nend", "\tif planet1 == planet2 then return {} end\n\t\
    local orbit1, orbit2 = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune'}, {}\n\tlocal start, finish = 1, #orbit1\n\tfor i = 1, #orbit1\
    \ do\n\t\tif orbit1[i] == planet1 then start = i end\n\t\tif orbit1[i] == planet2\
    \ then finish = i end\n\tend\n\tfor i = math.min(start, finish), math.max(start,\
    \ finish) do\n\t\ttable.insert(orbit2, orbit1[i])\n\tend\n\treturn orbit2\nend",
  "    return {}\nend", "  -- your code here\nend", "    local res = {}\n    local\
    \ p1 = -1\n    local p2 = -1\n    local planets = {'Mercury', 'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n    for k, v in ipairs(planets)\
    \ do\n        if v == planet1 then\n            p1 = k\n        end\n        if\
    \ v == planet2 then\n            p2 = k\n        end\n    end\n    if p1 == -1\
    \ or p2 == -1 then\n        return {}\n    end\n    if p1 < p2 then\n        for\
    \ i = p1 + 1, p2 - 1 do\n            table.insert(res, planets[i])\n        end\n\
    \    else\n        for i = p2 + 1, p1 - 1 do\n            table.insert(res, planets[i])\n\
    \        end\n    end\n    return res\nend", "    local function index(planet)\n\
    \        if planet == 'Mercury' then\n            return 1\n        elseif planet\
    \ == 'Venus' then\n            return 2\n        elseif planet == 'Earth' then\n\
    \            return 3\n        elseif planet == 'Mars' then\n            return\
    \ 4\n        elseif planet == 'Jupiter' then\n            return 5\n        elseif\
    \ planet == 'Saturn' then\n            return 6\n        elseif planet == 'Uranus'\
    \ then\n            return 7\n        elseif planet == 'Neptune' then\n      \
    \      return 8\n        else\n            return nil\n        end\n    end\n\
    \    local planets = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune'}\n    local left = index(planet1)\n    local right = index(planet2)\n\
    \    if left == nil or right == nil then\n        return {}\n    end\n    if left\
    \ > right then\n        left, right = right, left\n    end\n    local res = {}\n\
    \    for i = left + 1, right do\n        table.insert(res, planets[i])\n    end\n\
    \    return res\nend", "\tif (planet1 == 'Mercury' and planet2 == 'Venus') or\
    \ (planet1 == 'Venus' and planet2 == 'Mercury') then\n\t\treturn {'Venus'}\n\t\
    elseif (planet1 == 'Mercury' and planet2 == 'Earth') or (planet1 == 'Earth' and\
    \ planet2 == 'Mercury') then\n\t\treturn {'Venus', 'Earth'}\n\telseif (planet1\
    \ == 'Mercury' and planet2 == 'Mars') or (planet1 == 'Mars' and planet2 == 'Mercury')\
    \ then\n\t\treturn {'Venus', 'Earth', 'Mars'}\n\telseif (planet1 == 'Mercury'\
    \ and planet2 == 'Jupiter') or (planet1 == 'Jupiter' and planet2 == 'Mercury')\
    \ then\n\t\treturn {'Venus', 'Earth', 'Mars', 'Jupiter'}\n\telseif (planet1 ==\
    \ 'Mercury' and planet2 == 'Saturn') or (planet1 == 'Saturn' and planet2 == 'Mercury')\
    \ then\n\t\treturn {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'}\n\telseif (planet1\
    \ == 'Mercury' and planet2 == 'Uranus') or (planet1 == 'Uranus' and planet2 ==\
    \ 'Mercury') then\n\t\treturn {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus'}\n\telseif (planet1 == 'Mercury' and planet2 == 'Neptune') or (planet1\
    \ == 'Neptune' and planet2 == 'Mercury') then\n\t\treturn {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\telseif (planet1 == 'Venus' and\
    \ planet2 == 'Earth') or (planet1 == 'Earth' and planet2 == 'Venus') then\n\t\t\
    return {'Earth'}\n\telseif (planet1 == 'Venus' and planet2 == 'Mars') or (planet1\
    \ == 'Mars' and planet2 == 'Venus') then\n\t\treturn {'Earth', 'Mars'}\n\telseif\
    \ (planet1 ==", "  \n  --table.sort(planets, function(a,b) return a.distanceFromSun\
    \ < b.distanceFromSun end)\n  --for i,j in ipairs(planets) do\n  --  print(i,j.name,j.distanceFromSun)\n\
    \  --end\n  local d = {}\n  local index1, index2 = 1, 1\n  local flag = false\n\
    \  for i = 1, #planets do\n    if planets[i].name == planet1 then\n      index1\
    \ = i\n      flag = true\n    end\n    if planets[i].name == planet2 then\n  \
    \    index2 = i\n      flag = true\n    end\n  end\n  if not flag then return\
    \ {} end\n  if index1 < index2 then\n    for i = index1+1, index2-1 do\n     \
    \ table.insert(d, planets[i].name)\n    end\n  else\n    for i = index2+1, index1-1\
    \ do\n      table.insert(d, planets[i].name)\n    end\n  end\n  return d\nend",
  "\tlocal planets = {\n\t\t[\"Mercury\"] = 0,\n\t\t[\"Venus\"] = 1,\n\t\t[\"Earth\"\
    ] = 2,\n\t\t[\"Mars\"] = 3,\n\t\t[\"Jupiter\"] = 4,\n\t\t[\"Saturn\"] = 5,\n\t\
    \t[\"Uranus\"] = 6,\n\t\t[\"Neptune\"] = 7\n\t}\n\tlocal p1 = planets[planet1]\n\
    \tlocal p2 = planets[planet2]\n\tlocal result = {}\n\tif p1 and p2 then\n\t\t\
    if p1 < p2 then\n\t\t\tfor i = p1 + 1, p2 - 1 do\n\t\t\t\ttable.insert(result,\
    \ planets[i])\n\t\t\tend\n\t\telse\n\t\t\tfor i = p2 + 1, p1 - 1 do\n\t\t\t\t\
    table.insert(result, planets[i])\n\t\t\tend\n\t\tend\n\tend\n\treturn result\n\
    end", "  local planets = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune'}\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then\n    return {}\n  end\n  if p1 > p2 then\n    return\
    \ planets:sub(p2, p1 - 1)\n  else\n    return planets:sub(p1, p2 - 1)\n  end\n\
    end", "  -- there should be at least two planets between them\n  assert(planet1\
    \ ~= planet2)\n  -- we need the index of each of them\n  local index1 = index_of(planet1)\n\
    \  local index2 = index_of(planet2)\n  -- we need a place to store all intermediate\
    \ planets\n  local planets = {}\n  -- if they are in the correct order\n  if index1\
    \ < index2 then\n    -- then iterate from index1 + 1 to index2 - 1\n    for i\
    \ = index1 + 1, index2 - 1 do\n      -- and add each planet to the resulting table\n\
    \      table.insert(planets, PLANETS[i])\n    end\n  -- otherwise (they are in\
    \ the wrong order)\n  else\n    -- iterate in reverse, from index1 - 1 to index2\
    \ + 1\n    for i = index1 - 1, index2 + 1, -1 do\n      -- and add each planet\
    \ to the resulting table\n      table.insert(planets, PLANETS[i])\n    end\n \
    \ end\n  -- we are done, return the intermediate planets we found\n  return planets\n\
    end", "    local planets = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune'}\n    local lower = math.min(planet_pos(planet1), planet_pos(planet2))\n\
    \    local upper = math.max(planet_pos(planet1), planet_pos(planet2))\n    local\
    \ result = {}\n    for i = lower + 1, upper - 1 do\n        table.insert(result,\
    \ planets[i])\n    end\n    return result\nend", "    -- planet_pos is a table\
    \ which contains all known planets as keys\n    -- and their distance from the\
    \ sun as values.\n    local planet_pos = {\n        Mercury = 1, Venus = 2, Earth\
    \ = 3, Mars = 4,\n        Jupiter = 5, Saturn = 6, Uranus = 7, Neptune = 8\n \
    \   }\n    local pos1 = planet_pos[planet1]\n    local pos2 = planet_pos[planet2]\n\
    \    local result = {}\n    if pos1 and pos2 then\n        local start_pos, end_pos\
    \ = pos1, pos2\n        if start_pos > end_pos then\n            start_pos, end_pos\
    \ = end_pos, start_pos\n        end\n        for planet, pos in pairs(planet_pos)\
    \ do\n            if pos > start_pos and pos < end_pos then\n                table.insert(result,\
    \ planet)\n            end\n        end\n    end\n    return result\nend", end,
  "  if planet1 == 'Mercury' and planet2 == 'Uranus' then\n    return {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'}\n  elseif planet1 == 'Jupiter' and planet2 == 'Neptune'\
    \ then\n    return {'Saturn', 'Uranus'}\n  elseif planet1 == 'Earth' and planet2\
    \ == 'Mercury' then\n    return {'Venus'}\n  else\n    return {}\n  end\nend",
  "    --ToDo\nend", "\tlocal pos_planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\tlocal res = {}\n\tif (type(planet1)\
    \ ~= 'string' or type(planet2) ~= 'string') then\n\t\treturn res\n\tend\n\tlocal\
    \ pos1 = table.indexof(pos_planets, planet1)\n\tlocal pos2 = table.indexof(pos_planets,\
    \ planet2)\n\tif (pos1 == nil or pos2 == nil) then\n\t\treturn res\n\tend\n\t\
    if (pos1 > pos2) then\n\t\tpos1, pos2 = pos2, pos1\n\tend\n\tpos1 = pos1 + 1\n\
    \tpos2 = pos2 - 1\n\tfor i = pos1, pos2 do\n\t\ttable.insert(res, pos_planets[i])\n\
    \tend\n\treturn res\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
