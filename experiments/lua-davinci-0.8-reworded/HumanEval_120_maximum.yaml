name: HumanEval_120_maximum
language: lua
prompt: "-- Given a table arr of integers and a positive integer k, return a sorted\
  \ table \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- >>>\
  \ maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4,\
  \ 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n\
  -- {2}\n-- Note:\n-- 1. The length of the table will be in the range of [1, 1000].\n\
  -- 2. The elements in the table will be in the range of [-1000, 1000].\n-- 3. 0\
  \ <= k <= len(arr)\nlocal function maximum(arr, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n\
  \    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4,\
  \ -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1),\
  \ {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20,\
  \ 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n\
  \    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3,\
  \ 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n  \
  \  lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4,\
  \ -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n \
  \   lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local n = #arr\n    if n == 0 then return {} end\n    table.sort(arr)\n\
    \    local res = {}\n    for i = n, n - k + 1, -1 do\n        table.insert(res,\
    \ arr[i])\n    end\n    return res\nend", "    local max_value = -math.huge\n\
    \    local max_list = {}\n    local curr_pos = 1\n    while k > 0 do\n       \
    \ local max_pos = -1\n        for i = curr_pos, #arr do\n            if arr[i]\
    \ > max_value then\n                max_value = arr[i]\n                max_pos\
    \ = i\n            end\n        end\n        if max_pos == -1 then\n         \
    \   break\n        end\n        max_list[#max_list + 1] = max_value\n        max_value\
    \ = -math.huge\n        curr_pos = max_pos + 1\n        k = k - 1\n    end\n \
    \   return max_list\nend", "    local function minHeap(arr, size)\n        for\
    \ i = math.floor(size / 2), 1, -1 do\n            local left = 2 * i\n       \
    \     local right = 2 * i + 1\n            local temp = arr[i]\n            if\
    \ left <= size and arr[left] < temp then\n                temp = arr[left]\n \
    \               arr[left] = arr[i]\n                arr[i] = temp\n          \
    \  end\n            if right <= size and arr[right] < temp then\n            \
    \    temp = arr[right]\n                arr[right] = arr[i]\n                arr[i]\
    \ = temp\n            end\n        end\n    end\n    local function heapSort(arr,\
    \ size)\n        for i = size, 2, -1 do\n            local temp = arr[1]\n   \
    \         arr[1] = arr[i]\n            arr[i] = temp\n            minHeap(arr,\
    \ i - 1)\n        end\n    end\n    local heap = {}\n    for i = 1, #arr do\n\
    \        if i > k then\n            if arr[i] > heap[1] then\n               \
    \ heap[1] = arr[i]\n                minHeap(heap, k)\n            end\n      \
    \  else\n            heap[i] = arr[i]\n            minHeap(heap, i)\n        end\n\
    \    end\n    heapSort(heap, k)\n    return heap\nend", "    local n = #arr\n\
    \    for i = 1, n - 1 do\n        for j = i + 1, n do\n            if arr[i] <\
    \ arr[j] then\n                arr[i], arr[j] = arr[j], arr[i]\n            end\n\
    \        end\n    end\n    local t = {}\n    for i = 1, k do\n        t[i] = arr[i]\n\
    \    end\n    return t\nend", "    table.sort(arr, function(a, b) return a > b\
    \ end)\n    local ret = {}\n    for i = 1, k do\n        ret[i] = arr[i]\n   \
    \ end\n    return ret\nend", "    local t = {}\n    for i, v in ipairs(arr) do\n\
    \        if i > k then\n            if i == k + 1 then\n                table.sort(t)\n\
    \            end\n            if v > t[1] then\n                t[1] = v\n   \
    \         end\n        else\n            t[i] = v\n        end\n    end\n    table.sort(t)\n\
    \    return t\nend", "\tsort(arr)\n\tfor i = #arr, #arr - k + 1, -1 do\n\t\ttable.remove(arr,\
    \ i)\n\tend\n\treturn arr\nend", "    local i = 1\n    local len = #arr\n    while\
    \ i <= k do\n        local j = len\n        while j > i do\n            if arr[j]\
    \ > arr[j - 1] then\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n\
    \            end\n            j = j - 1\n        end\n        i = i + 1\n    end\n\
    \    return table.slice(arr, #arr - k + 1, #arr)\nend", "    local n = #arr\n\
    \    if k == 0 then\n        return {}\n    elseif k >= n then\n        return\
    \ arr\n    end\n    local function partition(i, j)\n        local r = i + math.random(j\
    \ - i)\n        arr[i], arr[r] = arr[r], arr[i]\n        local p = arr[i]\n  \
    \      local l, r = i, j\n        while l < r do\n            while l < r and\
    \ arr[r] <= p do\n                r = r - 1\n            end\n            if l\
    \ < r then\n                arr[l] = arr[r]\n                l = l + 1\n     \
    \       end\n            while l < r and arr[l] >= p do\n                l = l\
    \ + 1\n            end\n            if l < r then\n                arr[r] = arr[l]\n\
    \                r = r - 1\n            end\n        end\n        arr[l] = p\n\
    \        return l\n    end\n    local function quickSelect(i, j, k)\n        local\
    \ q = partition(i, j)\n        if q - i + 1 == k then\n            return\n  \
    \      elseif q - i + 1 > k then\n            quickSelect(i, q - 1, k)\n     \
    \   else\n            quickSelect(q + 1, j, k - (q - i + 1))\n        end\n  \
    \  end\n    quickSelect(1, n, k)\n    return arr\nend", "  if k == 1 then\n  \
    \  local max = -math.huge\n    for _, value in ipairs(arr) do\n      if value\
    \ > max then\n        max = value\n      end\n    end\n    return {max}\n  end\n\
    \  local function minheapify(arr, i, k)\n    local l, r = 2 * i, 2 * i + 1\n \
    \   local smallest = i\n    if l <= k and arr[l] < arr[smallest] then\n      smallest\
    \ = l\n    end\n    if r <= k and arr[r] < arr[smallest] then\n      smallest\
    \ = r\n    end\n    if smallest ~= i then\n      arr[i], arr[smallest] = arr[smallest],\
    \ arr[i]\n      minheapify(arr, smallest, k)\n    end\n  end\n  local function\
    \ buildminheap(arr, k)\n    for i = math.floor(k / 2), 1, -1 do\n      minheapify(arr,\
    \ i, k)\n    end\n  end\n  local function extractmin(arr, k)\n    local min =\
    \ arr[1]\n    arr[1] = arr[k]\n    k = k - 1\n    minheapify(arr, 1, k)\n    return\
    \ min\n  end\n  local heap = {}\n  for i = 1, k do\n    heap[i] = arr[i]\n  end\n\
    \  buildminheap(heap, k)\n  for i = k + 1, #arr do\n    if arr[i] > heap[1] then\n\
    \      heap[1] = arr[i]\n      minheapify(heap, 1, k)\n    end\n  end\n  return\
    \ heap\nend", "    local function partition(arr, left, right)\n        local pivot\
    \ = arr[left]\n        local l = left + 1\n        local r = right\n        while\
    \ l <= r do\n            while l <= r and arr[l] <= pivot do\n               \
    \ l = l + 1\n            end\n            while l <= r and arr[r] > pivot do\n\
    \                r = r - 1\n            end\n            if l < r then\n     \
    \           arr[l], arr[r] = arr[r], arr[l]\n            end\n        end\n  \
    \      arr[left], arr[r] = arr[r], arr[left]\n        return r\n    end\n    if\
    \ k > #arr then\n        k = #arr\n    end\n    local left = 1\n    local right\
    \ = #arr\n    while true do\n        local mid = partition(arr, left, right)\n\
    \        if mid == k then\n            break\n        elseif mid < k then\n  \
    \          left = mid + 1\n        else\n            right = mid - 1\n       \
    \ end\n    end\n    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n\
    \    end\n    return res\nend", "  local heap = min_heap:new(k)\n  for _, v in\
    \ ipairs(arr) do\n    heap:insert(v)\n  end\n  local result = {}\n  for i = 1,\
    \ k do\n    result[i] = heap:pop()\n  end\n  return result\nend", end, "    local\
    \ used = {}\n    local res = {}\n    for i = 1, k do\n        local max = -2000\n\
    \        local index = 0\n        for j = 1, #arr do\n            if (arr[j] >\
    \ max) and (not used[j]) then\n                max = arr[j]\n                index\
    \ = j\n            end\n        end\n        used[index] = true\n        res[i]\
    \ = max\n    end\n    return res\nend", "    local function partition(arr, lo,\
    \ hi)\n        local p = lo\n        local pivot = arr[hi]\n        for i = lo,\
    \ hi - 1 do\n            if arr[i] > pivot then\n                local temp =\
    \ arr[i]\n                arr[i] = arr[p]\n                arr[p] = temp\n   \
    \             p = p + 1\n            end\n        end\n        arr[hi] = arr[p]\n\
    \        arr[p] = pivot\n        return p\n    end\n    local function quick_select(arr,\
    \ lo, hi, k)\n        if lo >= hi then\n            return\n        end\n    \
    \    local p = partition(arr, lo, hi)\n        if p + 1 == k then\n          \
    \  return\n        elseif p + 1 < k then\n            quick_select(arr, p + 1,\
    \ hi, k)\n        else\n            quick_select(arr, lo, p - 1, k)\n        end\n\
    \    end\n    quick_select(arr, 1, #arr, k)\n    return arr\nend", "    local\
    \ function comparator(a, b)\n        return a > b\n    end\n    if k == 0 then\n\
    \        return {}\n    end\n    table.sort(arr, comparator)\n    local ret =\
    \ {}\n    for i = 1, k do\n        ret[i] = arr[i]\n    end\n    return ret\n\
    end", "    local k = math.min(k, #arr)\n    local t = {}\n    local function func(i,\
    \ j)\n        if i > j then return false end\n        local m = math.floor((i\
    \ + j) / 2)\n        local p = i\n        local q = j\n        while p < q do\n\
    \            while p < q and arr[p] >= arr[m] do p = p + 1 end\n            while\
    \ p < q and arr[q] <= arr[m] do q = q - 1 end\n            arr[p], arr[q] = arr[q],\
    \ arr[p]\n        end\n        if arr[p] > arr[m] then p = p - 1 end\n       \
    \ arr[p], arr[m] = arr[m], arr[p]\n        if p + 1 == k then\n            for\
    \ i = 1, k do\n                t[i] = arr[i]\n            end\n            return\
    \ true\n        elseif p + 1 > k then\n            return func(i, p - 1)\n   \
    \     else\n            return func(p + 1, j)\n        end\n    end\n    func(1,\
    \ #arr)\n    return t\nend", "    local len = #arr\n    local left = 1\n    local\
    \ right = len\n    while left <= right do\n        local pivot = left\n      \
    \  for i = left, right do\n            if arr[i] >= arr[pivot] then\n        \
    \        pivot = i\n            end\n        end\n        arr[left], arr[pivot]\
    \ = arr[pivot], arr[left]\n        if left == k then\n            break\n    \
    \    elseif left < k then\n            left = left + 1\n        else\n       \
    \     right = right - 1\n        end\n    end\n    return table.move(arr, 1, k,\
    \ 1, {})\nend", "    table.sort(arr, function(a, b) return a > b end)\n    local\
    \ ret = {}\n    for i = 1, k do\n        ret[i] = arr[i]\n    end\n    return\
    \ ret\nend", "    table.sort(arr, function(a, b) return a > b end)\n    local\
    \ r = {}\n    for i = 1, k do\n        r[i] = arr[i]\n    end\n    return r\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
