name: HumanEval_120_maximum
language: lua
prompt: "-- Given a table arr of integers and a positive integer k, return a sorted\
  \ table \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- >>>\
  \ maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4,\
  \ 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n\
  -- {2}\n-- Note:\n-- 1. The length of the table will be in the range of [1, 1000].\n\
  -- 2. The elements in the table will be in the range of [-1000, 1000].\n-- 3. 0\
  \ <= k <= len(arr)\nlocal function maximum(arr, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n\
  \    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4,\
  \ -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1),\
  \ {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20,\
  \ 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n\
  \    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3,\
  \ 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n  \
  \  lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4,\
  \ -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n \
  \   lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local n = #arr\n    if n == 0 then return {} end\n    table.sort(arr)\n\
    \    local res = {}\n    for i = n, n - k + 1, -1 do\n        table.insert(res,\
    \ arr[i])\n    end\n    return res\nend", "    local max_value = -math.huge\n\
    \    local max_list = {}\n    local curr_pos = 1\n    while k > 0 do\n       \
    \ local max_pos = -1\n        for i = curr_pos, #arr do\n            if arr[i]\
    \ > max_value then\n                max_value = arr[i]\n                max_pos\
    \ = i\n            end\n        end\n        if max_pos == -1 then\n         \
    \   break\n        end\n        max_list[#max_list + 1] = max_value\n        max_value\
    \ = -math.huge\n        curr_pos = max_pos + 1\n        k = k - 1\n    end\n \
    \   return max_list\nend", "    local function minHeap(arr, size)\n        for\
    \ i = math.floor(size / 2), 1, -1 do\n            local left = 2 * i\n       \
    \     local right = 2 * i + 1\n            local temp = arr[i]\n            if\
    \ left <= size and arr[left] < temp then\n                temp = arr[left]\n \
    \               arr[left] = arr[i]\n                arr[i] = temp\n          \
    \  end\n            if right <= size and arr[right] < temp then\n            \
    \    temp = arr[right]\n                arr[right] = arr[i]\n                arr[i]\
    \ = temp\n            end\n        end\n    end\n    local function heapSort(arr,\
    \ size)\n        for i = size, 2, -1 do\n            local temp = arr[1]\n   \
    \         arr[1] = arr[i]\n            arr[i] = temp\n            minHeap(arr,\
    \ i - 1)\n        end\n    end\n    local heap = {}\n    for i = 1, #arr do\n\
    \        if i > k then\n            if arr[i] > heap[1] then\n               \
    \ heap[1] = arr[i]\n                minHeap(heap, k)\n            end\n      \
    \  else\n            heap[i] = arr[i]\n            minHeap(heap, i)\n        end\n\
    \    end\n    heapSort(heap, k)\n    return heap\nend", "    local n = #arr\n\
    \    for i = 1, n - 1 do\n        for j = i + 1, n do\n            if arr[i] <\
    \ arr[j] then\n                arr[i], arr[j] = arr[j], arr[i]\n            end\n\
    \        end\n    end\n    local t = {}\n    for i = 1, k do\n        t[i] = arr[i]\n\
    \    end\n    return t\nend", "    table.sort(arr, function(a, b) return a > b\
    \ end)\n    local ret = {}\n    for i = 1, k do\n        ret[i] = arr[i]\n   \
    \ end\n    return ret\nend", "    local t = {}\n    for i, v in ipairs(arr) do\n\
    \        if i > k then\n            if i == k + 1 then\n                table.sort(t)\n\
    \            end\n            if v > t[1] then\n                t[1] = v\n   \
    \         end\n        else\n            t[i] = v\n        end\n    end\n    table.sort(t)\n\
    \    return t\nend", "\tsort(arr)\n\tfor i = #arr, #arr - k + 1, -1 do\n\t\ttable.remove(arr,\
    \ i)\n\tend\n\treturn arr\nend", "    local i = 1\n    local len = #arr\n    while\
    \ i <= k do\n        local j = len\n        while j > i do\n            if arr[j]\
    \ > arr[j - 1] then\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n\
    \            end\n            j = j - 1\n        end\n        i = i + 1\n    end\n\
    \    return table.slice(arr, #arr - k + 1, #arr)\nend", "    local n = #arr\n\
    \    if k == 0 then\n        return {}\n    elseif k >= n then\n        return\
    \ arr\n    end\n    local function partition(i, j)\n        local r = i + math.random(j\
    \ - i)\n        arr[i], arr[r] = arr[r], arr[i]\n        local p = arr[i]\n  \
    \      local l, r = i, j\n        while l < r do\n            while l < r and\
    \ arr[r] <= p do\n                r = r - 1\n            end\n            if l\
    \ < r then\n                arr[l] = arr[r]\n                l = l + 1\n     \
    \       end\n            while l < r and arr[l] >= p do\n                l = l\
    \ + 1\n            end\n            if l < r then\n                arr[r] = arr[l]\n\
    \                r = r - 1\n            end\n        end\n        arr[l] = p\n\
    \        return l\n    end\n    local function quickSelect(i, j, k)\n        local\
    \ q = partition(i, j)\n        if q - i + 1 == k then\n            return\n  \
    \      elseif q - i + 1 > k then\n            quickSelect(i, q - 1, k)\n     \
    \   else\n            quickSelect(q + 1, j, k - (q - i + 1))\n        end\n  \
    \  end\n    quickSelect(1, n, k)\n    return arr\nend", "  if k == 1 then\n  \
    \  local max = -math.huge\n    for _, value in ipairs(arr) do\n      if value\
    \ > max then\n        max = value\n      end\n    end\n    return {max}\n  end\n\
    \  local function minheapify(arr, i, k)\n    local l, r = 2 * i, 2 * i + 1\n \
    \   local smallest = i\n    if l <= k and arr[l] < arr[smallest] then\n      smallest\
    \ = l\n    end\n    if r <= k and arr[r] < arr[smallest] then\n      smallest\
    \ = r\n    end\n    if smallest ~= i then\n      arr[i], arr[smallest] = arr[smallest],\
    \ arr[i]\n      minheapify(arr, smallest, k)\n    end\n  end\n  local function\
    \ buildminheap(arr, k)\n    for i = math.floor(k / 2), 1, -1 do\n      minheapify(arr,\
    \ i, k)\n    end\n  end\n  local function extractmin(arr, k)\n    local min =\
    \ arr[1]\n    arr[1] = arr[k]\n    k = k - 1\n    minheapify(arr, 1, k)\n    return\
    \ min\n  end\n  local heap = {}\n  for i = 1, k do\n    heap[i] = arr[i]\n  end\n\
    \  buildminheap(heap, k)\n  for i = k + 1, #arr do\n    if arr[i] > heap[1] then\n\
    \      heap[1] = arr[i]\n      minheapify(heap, 1, k)\n    end\n  end\n  return\
    \ heap\nend", "    local function partition(arr, left, right)\n        local pivot\
    \ = arr[left]\n        local l = left + 1\n        local r = right\n        while\
    \ l <= r do\n            while l <= r and arr[l] <= pivot do\n               \
    \ l = l + 1\n            end\n            while l <= r and arr[r] > pivot do\n\
    \                r = r - 1\n            end\n            if l < r then\n     \
    \           arr[l], arr[r] = arr[r], arr[l]\n            end\n        end\n  \
    \      arr[left], arr[r] = arr[r], arr[left]\n        return r\n    end\n    if\
    \ k > #arr then\n        k = #arr\n    end\n    local left = 1\n    local right\
    \ = #arr\n    while true do\n        local mid = partition(arr, left, right)\n\
    \        if mid == k then\n            break\n        elseif mid < k then\n  \
    \          left = mid + 1\n        else\n            right = mid - 1\n       \
    \ end\n    end\n    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n\
    \    end\n    return res\nend", "  local heap = min_heap:new(k)\n  for _, v in\
    \ ipairs(arr) do\n    heap:insert(v)\n  end\n  local result = {}\n  for i = 1,\
    \ k do\n    result[i] = heap:pop()\n  end\n  return result\nend", end, "    local\
    \ used = {}\n    local res = {}\n    for i = 1, k do\n        local max = -2000\n\
    \        local index = 0\n        for j = 1, #arr do\n            if (arr[j] >\
    \ max) and (not used[j]) then\n                max = arr[j]\n                index\
    \ = j\n            end\n        end\n        used[index] = true\n        res[i]\
    \ = max\n    end\n    return res\nend", "    local function partition(arr, lo,\
    \ hi)\n        local p = lo\n        local pivot = arr[hi]\n        for i = lo,\
    \ hi - 1 do\n            if arr[i] > pivot then\n                local temp =\
    \ arr[i]\n                arr[i] = arr[p]\n                arr[p] = temp\n   \
    \             p = p + 1\n            end\n        end\n        arr[hi] = arr[p]\n\
    \        arr[p] = pivot\n        return p\n    end\n    local function quick_select(arr,\
    \ lo, hi, k)\n        if lo >= hi then\n            return\n        end\n    \
    \    local p = partition(arr, lo, hi)\n        if p + 1 == k then\n          \
    \  return\n        elseif p + 1 < k then\n            quick_select(arr, p + 1,\
    \ hi, k)\n        else\n            quick_select(arr, lo, p - 1, k)\n        end\n\
    \    end\n    quick_select(arr, 1, #arr, k)\n    return arr\nend", "    local\
    \ function comparator(a, b)\n        return a > b\n    end\n    if k == 0 then\n\
    \        return {}\n    end\n    table.sort(arr, comparator)\n    local ret =\
    \ {}\n    for i = 1, k do\n        ret[i] = arr[i]\n    end\n    return ret\n\
    end", "    local k = math.min(k, #arr)\n    local t = {}\n    local function func(i,\
    \ j)\n        if i > j then return false end\n        local m = math.floor((i\
    \ + j) / 2)\n        local p = i\n        local q = j\n        while p < q do\n\
    \            while p < q and arr[p] >= arr[m] do p = p + 1 end\n            while\
    \ p < q and arr[q] <= arr[m] do q = q - 1 end\n            arr[p], arr[q] = arr[q],\
    \ arr[p]\n        end\n        if arr[p] > arr[m] then p = p - 1 end\n       \
    \ arr[p], arr[m] = arr[m], arr[p]\n        if p + 1 == k then\n            for\
    \ i = 1, k do\n                t[i] = arr[i]\n            end\n            return\
    \ true\n        elseif p + 1 > k then\n            return func(i, p - 1)\n   \
    \     else\n            return func(p + 1, j)\n        end\n    end\n    func(1,\
    \ #arr)\n    return t\nend", "    local len = #arr\n    local left = 1\n    local\
    \ right = len\n    while left <= right do\n        local pivot = left\n      \
    \  for i = left, right do\n            if arr[i] >= arr[pivot] then\n        \
    \        pivot = i\n            end\n        end\n        arr[left], arr[pivot]\
    \ = arr[pivot], arr[left]\n        if left == k then\n            break\n    \
    \    elseif left < k then\n            left = left + 1\n        else\n       \
    \     right = right - 1\n        end\n    end\n    return table.move(arr, 1, k,\
    \ 1, {})\nend", "    table.sort(arr, function(a, b) return a > b end)\n    local\
    \ ret = {}\n    for i = 1, k do\n        ret[i] = arr[i]\n    end\n    return\
    \ ret\nend", "    table.sort(arr, function(a, b) return a > b end)\n    local\
    \ r = {}\n    for i = 1, k do\n        r[i] = arr[i]\n    end\n    return r\n\
    end", "\tlocal len = #arr\n\tif k <= 0 or k > len then\n\t\treturn {}\n\tend\n\
    \tlocal s = 0\n\tlocal e = len\n\tlocal index = 0\n\twhile true do\n\t\tindex\
    \ = partition(arr, s, e)\n\t\tif index == k - 1 then\n\t\t\tbreak\n\t\telseif\
    \ index < k - 1 then\n\t\t\ts = index + 1\n\t\telse\n\t\t\te = index\n\t\tend\n\
    \tend\n\tlocal res = {}\n\tfor i = 1, k do\n\t\tres[i] = arr[i]\n\tend\n\tsort(res)\n\
    \treturn res\nend", "    local heap = {}\n    for i = 1, k do\n        heap[i]\
    \ = arr[i]\n    end\n    for i = k / 2, 1, -1 do\n        local j = i * 2\n  \
    \      while j <= k do\n            if j + 1 <= k and heap[j + 1] < heap[j] then\n\
    \                j = j + 1\n            end\n            if heap[i] <= heap[j]\
    \ then\n                break\n            end\n            heap[i], heap[j] =\
    \ heap[j], heap[i]\n            j = j * 2\n        end\n    end\n    for i = k\
    \ + 1, #arr do\n        if arr[i] > heap[1] then\n            heap[1] = arr[i]\n\
    \            local j = 1\n            while j * 2 <= k do\n                local\
    \ s = j * 2\n                if s + 1 <= k and heap[s + 1] < heap[s] then\n  \
    \                  s = s + 1\n                end\n                if heap[j]\
    \ <= heap[s] then\n                    break\n                end\n          \
    \      heap[j], heap[s] = heap[s], heap[j]\n                j = s\n          \
    \  end\n        end\n    end\n    local function cmp(a, b)\n        return a >\
    \ b\n    end\n    table.sort(heap, cmp)\n    return heap\nend", "    return {}\n\
    end", "    local minHeap = {}\n    local i = 1\n    local function swap(t, i,\
    \ j)\n        t[i], t[j] = t[j], t[i]\n    end\n    local function heapify(t,\
    \ idx)\n        local parent = math.floor(idx / 2)\n        while t[parent] >\
    \ t[idx] do\n            swap(t, parent, idx)\n            idx = parent\n    \
    \        parent = math.floor(idx / 2)\n        end\n    end\n    local function\
    \ heapInsert(t, elem)\n        t[#t + 1] = elem\n        heapify(t, #t)\n    end\n\
    \    local function heapPop(t)\n        local ret = t[1]\n        t[1] = t[#t]\n\
    \        t[#t] = nil\n        local n = #t\n        local i = 1\n        while\
    \ 2 * i <= n do\n            local l = 2 * i\n            local r = 2 * i + 1\n\
    \            local min = l\n            if r <= n and t[r] < t[l] then\n     \
    \           min = r\n            end\n            if t[i] <= t[min] then\n   \
    \             break\n            end\n            swap(t, i, min)\n          \
    \  i = min\n        end\n        return ret\n    end\n    local function heapSize(t)\n\
    \        return #t\n    end\n    while i <= k do\n        heapInsert(minHeap,\
    \ arr[i])\n        i = i + 1\n    end\n    while i <= #arr do\n        if arr[i]\
    \ > minHeap[1] then\n            heapPop(minHeap)\n            heapInsert(minHeap,\
    \ arr[i])\n        end\n        i = i + 1\n    end\n    local j = #minHeap\n \
    \   while j > 1 do\n        swap(minHeap, 1, j)\n        j = j - 1\n        local\
    \ i = 1\n        while 2 * i <= j do\n            local l = 2 * i\n          \
    \  local r = 2 * i + 1\n            local min = l\n            if r <= j and minHeap[r]\
    \ < minHeap[", "    local sorted = {}\n    for i = 1, #arr do\n        table.insert(sorted,\
    \ arr[i])\n    end\n    table.sort(sorted)\n    local res = {}\n    for i = #sorted,\
    \ #sorted - k + 1, -1 do\n        table.insert(res, sorted[i])\n    end\n    return\
    \ res\nend", "\tlocal t = {}\n\tfor i = 1, #arr do\n\t\tt[i] = arr[i]\n\tend\n\
    \ttable.sort(t)\n\tlocal m = {}\n\tfor i = 1, k do\n\t\tm[i] = t[#t - i + 1]\n\
    \tend\n\treturn m\nend", "  local temp = {}\n  for _, v in ipairs(arr) do\n  \
    \  temp[#temp + 1] = v\n  end\n  table.sort(temp, function(a, b) return a > b\
    \ end)\n  for i = k + 1, #temp do\n    temp[i] = nil\n  end\n  return temp\nend",
  "    local n = #arr\n    if k == n then\n        return arr\n    end\n    local\
    \ heap = {}\n    for i = 1, n do\n        heap[i] = arr[i]\n    end\n    for i\
    \ = (n - 1) / 2, 1, -1 do\n        local j = i * 2\n        while j <= n do\n\
    \            if j + 1 <= n and heap[j + 1] > heap[j] then\n                j =\
    \ j + 1\n            end\n            if heap[i] < heap[j] then\n            \
    \    heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            \
    \    j = i * 2\n            else\n                break\n            end\n   \
    \     end\n    end\n    for i = 1, k - 1 do\n        heap[1], heap[n - i + 1]\
    \ = heap[n - i + 1], heap[1]\n        local j = 1\n        local t = n - i\n \
    \       while j * 2 <= t do\n            local m = j * 2\n            if m + 1\
    \ <= t and heap[m + 1] > heap[m] then\n                m = m + 1\n           \
    \ end\n            if heap[j] < heap[m] then\n                heap[j], heap[m]\
    \ = heap[m], heap[j]\n                j = m\n            else\n              \
    \  break\n            end\n        end\n    end\n    return heap\nend", end, end,
  "    local arr_len = #arr\n    if k == 0 then\n        return {}\n    elseif k >=\
    \ arr_len then\n        return arr\n    end\n    local k_max = {}\n    local tmp\
    \ = {}\n    for i = 1, k do\n        k_max[i] = arr[i]\n    end\n    table.sort(k_max)\n\
    \    for i = k + 1, arr_len do\n        if arr[i] > k_max[1] then\n          \
    \  for j = 1, k do\n                tmp[j] = k_max[j]\n            end\n     \
    \       for j = 1, k do\n                k_max[j] = tmp[k - j + 1]\n         \
    \   end\n            k_max[1] = arr[i]\n        end\n    end\n    return k_max\n\
    end", "    -- local function filter(v, i)\n    --     if v > arr[k] then\n   \
    \ --         return true\n    --     end\n    -- end\n    -- for i = 1, k do\n\
    \    --     arr = table.filter(arr, filter)\n    -- end\n    local max = nil\n\
    \    local max_index = nil\n    for i = 1, k do\n        max = arr[i]\n      \
    \  max_index = i\n        for j = i + 1, #arr do\n            if arr[j] > max\
    \ then\n                max = arr[j]\n                max_index = j\n        \
    \    end\n        end\n        arr[i], arr[max_index] = arr[max_index], arr[i]\n\
    \    end\n    return table.sub(arr, 1, k)\nend", "\ttable.sort(arr, function(a,\
    \ b) return a > b end)\n\tlocal ret = {}\n\tfor i = 1, k do\n\t\tret[i] = arr[i]\n\
    \tend\n\treturn ret\nend", "    local ret = {}\n    for i = 1, k do\n        local\
    \ j, v = 1, arr[1]\n        for m = 2, #arr do\n            if v < arr[m] then\n\
    \                j, v = m, arr[m]\n            end\n        end\n        table.insert(ret,\
    \ v)\n        table.remove(arr, j)\n    end\n    return ret\nend", "    local\
    \ temp = table.copy(arr)\n    table.sort(temp)\n    local function f(list, count)\n\
    \        if count == 0 then\n            return {}\n        else\n           \
    \ return {list[#list - count + 1]} + f(list, count - 1)\n        end\n    end\n\
    \    return f(temp, k)\nend", "    if k == 0 then return {} end\n    local res\
    \ = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n    heapify(res,\
    \ k)\n    for i = k + 1, #arr do\n        if arr[i] > res[1] then\n          \
    \  res[1] = arr[i]\n            heapify(res, k)\n        end\n    end\n    return\
    \ res\nend", "  table.sort(arr, function(a, b) return a < b end)\n  local result\
    \ = {}\n  for i = 1, k do\n    result[i] = arr[i]\n  end\n  return result\nend",
  "    local heap = {}\n    local len = 0\n    local i = 1\n    while i <= k do\n\
    \        heap[i] = arr[i]\n        len = len + 1\n        i = i + 1\n    end\n\
    \    heapify(heap, len)\n    while i <= #arr do\n        if arr[i] > heap[1] then\n\
    \            heap[1] = arr[i]\n            heapify(heap, len)\n        end\n \
    \       i = i + 1\n    end\n    for i = 1, k do\n        len = len - 1\n     \
    \   heap[1], heap[len + 1] = heap[len + 1], heap[1]\n        heapify(heap, len)\n\
    \    end\n    return heap\nend", "    if k == 0 then return {} end\n    local\
    \ heap = {};\n    local function push(val)\n        local pos = #heap + 1;\n \
    \       heap[pos] = val;\n        while pos > 1 do\n            local p = pos\
    \ >> 1;\n            if heap[p] >= heap[pos] then break end\n            heap[p],\
    \ heap[pos] = heap[pos], heap[p];\n            pos = p;\n        end\n    end\n\
    \    local function pop()\n        local function heapify(start, stop)\n     \
    \       local pos = start;\n            while pos <= stop do\n               \
    \ local l = pos << 1;\n                local r = l + 1;\n                if l\
    \ <= stop and heap[l] > heap[pos] then\n                    pos = l;\n       \
    \         end\n                if r <= stop and heap[r] > heap[pos] then\n   \
    \                 pos = r;\n                end\n                if pos == start\
    \ then break end\n                heap[start], heap[pos] = heap[pos], heap[start];\n\
    \                start = pos;\n            end\n        end\n        local res\
    \ = heap[1];\n        heap[1] = heap[#heap];\n        heap[#heap] = nil;\n   \
    \     heapify(1, #heap);\n        return res;\n    end\n    for i = 1, #arr do\n\
    \        if #heap < k then\n            push(arr[i]);\n        elseif arr[i] >\
    \ heap[1] then\n            pop();\n            push(arr[i]);\n        end\n \
    \   end\n    local res = {};\n    for i = 1, k do\n        res[i] = pop();\n \
    \   end\n    return res;\nend", "    local res = {}\n    for _, v in ipairs(arr)\
    \ do\n        table.insert(res, v)\n    end\n    table.sort(res, function(a, b)\
    \ return a > b end)\n    local ks = {}\n    for i = 1, k do\n        table.insert(ks,\
    \ res[i])\n    end\n    return ks\nend", "  local len = #arr\n  if k == len then\n\
    \    table.sort(arr)\n    return arr\n  end\n  local ans = {}\n  for i = 1, k\
    \ do\n    ans[i] = arr[i]\n  end\n  table.sort(ans)\n  for i = k + 1, len do\n\
    \    local tmp = arr[i]\n    if tmp > ans[1] then\n      ans[1] = tmp\n      table.sort(ans)\n\
    \    end\n  end\n  return ans\nend", "\tlocal heap = Heap(function(a, b) return\
    \ a > b end)\n\tfor _, v in ipairs(arr) do\n\t\theap:push(v)\n\t\tif heap:size()\
    \ > k then\n\t\t\theap:pop()\n\t\tend\n\tend\n\tlocal result = {}\n\tfor i = 1,\
    \ k do\n\t\tresult[#result + 1] = heap:pop()\n\tend\n\ttable.sort(result)\n\t\
    return result\nend", "    local maxHeap = {}\n    for i, v in ipairs(arr) do\n\
    \        if #maxHeap < k then\n            table.insert(maxHeap, v)\n        else\n\
    \            if v > maxHeap[1] then\n                maxHeap[1] = v\n        \
    \    end\n        end\n        maxHeap = upAdjust(maxHeap)\n    end\n    return\
    \ maxHeap\nend", "    table.sort(arr, function(a, b) return a > b end)\n    return\
    \ table.move(arr, 1, k, 1, {})\nend", "    local n = #arr\n    if k == 0 then\n\
    \        return {}\n    elseif k == n then\n        return arr\n    end\n    local\
    \ less = function(a, b) return a < b end\n    local more = function(a, b) return\
    \ a > b end\n    local partition = function(arr, compare, l, r)\n        if l\
    \ >= r then\n            return\n        end\n        local p = (l + r) // 2\n\
    \        local pivot = arr[p]\n        arr[l], arr[p] = arr[p], arr[l]\n     \
    \   local i = l\n        for j = l + 1, r do\n            if compare(arr[j], pivot)\
    \ then\n                i = i + 1\n                arr[i], arr[j] = arr[j], arr[i]\n\
    \            end\n        end\n        arr[l], arr[i] = arr[i], arr[l]\n     \
    \   return i\n    end\n    local quicksort = function(arr, compare, l, r)\n  \
    \      if l >= r then\n            return\n        end\n        local p = partition(arr,\
    \ compare, l, r)\n        quicksort(arr, compare, l, p - 1)\n        quicksort(arr,\
    \ compare, p + 1, r)\n    end\n    local part = partition(arr, less, 1, n)\n \
    \   quicksort(arr, more, 1, part)\n    return {unpack(arr, 1, k)}\nend", "   \
    \ local n = #arr\n    assert(k > 0 and k <= n)\n    local res = {}\n    local\
    \ m = 0\n    for i = 1, n do\n        while m > 0 and arr[i] > res[m] and #res\
    \ + n - i >= k do\n            m = m - 1\n        end\n        if m < k then\n\
    \            m = m + 1\n            res[m] = arr[i]\n        end\n    end\n  \
    \  return res\nend", "    table.sort(arr, function(a, b) return a > b end)\n \
    \   local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n  \
    \  return res\nend", "    if k > #arr then k = #arr end\n    local t = {}\n  \
    \  for i = 1, k do\n        local v, i2 = math.huge, i\n        for j = i, #arr\
    \ do\n            if arr[j] > v then\n                v, i2 = arr[j], j\n    \
    \        end\n        end\n        t[i] = v\n        arr[i2] = math.huge\n   \
    \ end\n    return t\nend", "    local key = function(x) return x end\n    return\
    \ map(table.sort(clone(arr), key, 1, k))\nend", "    local function partition(arr,\
    \ left, right)\n        local pivot = arr[left]\n        local i = left + 1\n\
    \        local j = right\n        while i <= j do\n            while i <= j and\
    \ arr[i] > pivot do\n                i = i + 1\n            end\n            while\
    \ i <= j and arr[j] < pivot do\n                j = j - 1\n            end\n \
    \           if i <= j then\n                arr[i], arr[j] = arr[j], arr[i]\n\
    \                i = i + 1\n                j = j - 1\n            end\n     \
    \   end\n        arr[left], arr[j] = arr[j], arr[left]\n        return j\n   \
    \ end\n    local function quickselect(arr, left, right, k)\n        if k > 0 and\
    \ k <= right - left + 1 then\n            local i = partition(arr, left, right)\n\
    \            if i - left == k - 1 then\n                return\n            elseif\
    \ i - left > k - 1 then\n                quickselect(arr, left, i - 1, k)\n  \
    \          else\n                quickselect(arr, i + 1, right, k - i + left -\
    \ 1)\n            end\n        end\n    end\n    quickselect(arr, 1, #arr, k)\n\
    \    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n \
    \   return res\nend", "    local n = #arr\n    if k == 0 then\n        return\
    \ {}\n    elseif k >= n then\n        table.sort(arr)\n        return arr\n  \
    \  else\n        local ret = { }\n        for i = 1, k do\n            local maxidx\
    \ = i\n            for j = i + 1, n do\n                if arr[j] > arr[maxidx]\
    \ then\n                    maxidx = j\n                end\n            end\n\
    \            ret[i] = arr[maxidx]\n            arr[maxidx] = arr[i]\n        end\n\
    \        return ret\n    end\nend", "\ttable.sort(arr, function(a, b) return a\
    \ > b end)\n\treturn table.slice(arr, 1, k)\nend", "    local heap = Heap.new()\n\
    \    for _, v in ipairs(arr) do\n        heap:insert(v)\n    end\n    local res\
    \ = {}\n    for i = 1, k do\n        res[i] = heap:extract_max()\n    end\n  \
    \  return res\nend", "    local n = #arr\n    local func\n    func = function(l,\
    \ r)\n        if l < r then\n            local pos = partition(arr, l, r)\n  \
    \          if pos == k then\n                return\n            elseif pos <\
    \ k then\n                func(pos + 1, r)\n            else\n               \
    \ func(l, pos - 1)\n            end\n        end\n    end\n    func(1, n)\n  \
    \  local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n   \
    \ return res\nend", "    local sz = #arr\n    if k > sz then\n        k = sz\n\
    \    end\n    table.sort(arr, function(a, b) return a > b end)\n    local res\
    \ = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n    return res\n\
    end", "    local heap = {}\n    local size = 0\n    for i = 1, #arr do\n     \
    \   if size < k then\n            heap[i] = arr[i]\n            size = size +\
    \ 1\n            local index = i\n            while index > 1 do\n           \
    \     local parent = math.floor(index / 2)\n                if heap[parent] <\
    \ heap[index] then\n                    heap[parent], heap[index] = heap[index],\
    \ heap[parent]\n                    index = parent\n                else\n   \
    \                 break\n                end\n            end\n        else\n\
    \            if arr[i] > heap[1] then\n                heap[1] = arr[i]\n    \
    \            local index = 1\n                while index < k do\n           \
    \         local left = index * 2\n                    local right = left + 1\n\
    \                    if left > k then\n                        break\n       \
    \             elseif right > k then\n                        if heap[left] > heap[index]\
    \ then\n                            heap[left], heap[index] = heap[index], heap[left]\n\
    \                        end\n                        break\n                \
    \    else\n                        if heap[left] > heap[right] then\n        \
    \                    if heap[left] > heap[index] then\n                      \
    \          heap[left], heap[index] = heap[index], heap[left]\n               \
    \                 index = left\n                            else\n           \
    \                     break\n                            end\n               \
    \         else\n                            if heap[right] > heap[index] then\n\
    \                                heap[right], heap[index] = heap[index], heap[right]\n\
    \                                index = right\n                            else\n\
    \                                break\n                            end\n    \
    \                    end\n                    end\n                end\n     \
    \       end\n        end\n    end\n    return heap\nend", "    local n = #arr\n\
    \    table.sort(arr)\n    local res = {}\n    for i = 1, k do\n        res[i]\
    \ = arr[n - i + 1]\n    end\n    return res\nend", "    local arr2 = tablex.sort(arr,\
    \ function(a, b) return a > b end)\n    return tablex.sub(arr2, 1, k)\nend", " \
    \   local n = #arr\n    if k > n then k = n end\n    for i = 1, k do\n       \
    \ for j = n, i + 1, -1 do\n            if arr[j] > arr[j - 1] then\n         \
    \       arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            end\n        end\n\
    \    end\n    return {table.unpack(arr, 1, k)}\nend", "    local r = {}\n    for\
    \ i = 1, k do\n        r[i] = -math.huge\n    end\n    for i = 1, #arr do\n  \
    \      local v = arr[i]\n        local j = #r\n        while j > 0 and v > r[j]\
    \ do\n            r[j + 1] = r[j]\n            j = j - 1\n        end\n      \
    \  r[j + 1] = v\n    end\n    return r\nend", "    local b = {}\n    for i = 1,\
    \ k do\n        b[i] = arr[i]\n    end\n    local b_len = k\n    local b_i = 1\n\
    \    while b_i < b_len do\n        local j = b_i\n        while j < b_len and\
    \ b[j] < b[j + 1] do\n            local t = b[j]\n            b[j] = b[j + 1]\n\
    \            b[j + 1] = t\n            j = j + 1\n        end\n        b_i = b_i\
    \ + 1\n    end\n    for i = k + 1, #arr do\n        if arr[i] > b[b_len] then\n\
    \            b[b_len] = arr[i]\n            local j = b_len\n            while\
    \ j > 1 and b[j] > b[j - 1] do\n                local t = b[j]\n             \
    \   b[j] = b[j - 1]\n                b[j - 1] = t\n                j = j - 1\n\
    \            end\n        end\n    end\n    return b\nend", "    local res = {}\n\
    \    for _, v in ipairs(arr) do\n        if #res < k then\n            table.insert(res,\
    \ v)\n        else\n            for i, v1 in ipairs(res) do\n                if\
    \ v > v1 then\n                    table.insert(res, i, v)\n                 \
    \   break\n                end\n            end\n        end\n    end\n    return\
    \ res\nend", "\tlocal len = #arr\n\tif k > len then\n\t\tk = len\n\tend\n\ttable.sort(arr,\
    \ function(x, y) return x > y end)\n\tlocal res = {}\n\tfor i = 1, k do\n\t\t\
    res[i] = arr[i]\n\tend\n\treturn res\nend", "    local cmp = function(a, b)\n\
    \        return a > b\n    end\n    table.sort(arr, cmp)\n    local m = {}\n \
    \   for i = 1, k do\n        m[i] = arr[i]\n    end\n    return m\nend", "   \
    \ assert(#arr > 0)\n    assert(k > 0)\n    assert(k <= #arr)\n    local function\
    \ partition(left, right)\n        local pivot = arr[left]\n        local index\
    \ = left\n        for i = left + 1, right do\n            if arr[i] > pivot then\n\
    \                index = index + 1\n                arr[i], arr[index] = arr[index],\
    \ arr[i]\n            end\n        end\n        arr[left], arr[index] = arr[index],\
    \ arr[left]\n        return index\n    end\n    local function quickSelect(left,\
    \ right, k)\n        if left == right then\n            return\n        end\n\
    \        local pivot = partition(left, right)\n        if pivot == k then\n  \
    \          return\n        elseif pivot > k then\n            quickSelect(left,\
    \ pivot - 1, k)\n        else\n            quickSelect(pivot + 1, right, k)\n\
    \        end\n    end\n    quickSelect(1, #arr, k)\n    local ans = {}\n    for\
    \ i = 1, k do\n        ans[i] = arr[i]\n    end\n    return ans\nend", "    local\
    \ bucket = {}\n    for i = 1, #arr do\n        if bucket[arr[i]] == nil then\n\
    \            bucket[arr[i]] = 1\n        else\n            bucket[arr[i]] = bucket[arr[i]]\
    \ + 1\n        end\n    end\n    local r = {}\n    for i = 1, k do\n        local\
    \ max = -1001\n        for key, val in pairs(bucket) do\n            if key >\
    \ max then\n                max = key\n            end\n        end\n        table.insert(r,\
    \ max)\n        bucket[max] = nil\n    end\n    return r\nend", "    local t =\
    \ {}\n    for i = 1, k do\n        t[i] = arr[i]\n    end\n    table.sort(t)\n\
    \    for i = k + 1, #arr do\n        local n = arr[i]\n        if n > t[1] then\n\
    \            t[1] = n\n            table.sort(t)\n        end\n    end\n    return\
    \ t\nend", "  local len = #arr\n  if k <= 0 or k > len then return {} end\n  if\
    \ k == len then\n    table.sort(arr)\n    return arr\n  end\n  table.sort(arr,\
    \ function(a, b) return a < b end)\n  local r = {}\n  for i = 1, k do\n    r[i]\
    \ = arr[i]\n  end\n  return r\nend", "    local function swap(arr, i, j)\n   \
    \     arr[i], arr[j] = arr[j], arr[i]\n    end\n    local function partition(arr,\
    \ lo, hi)\n        local i, j = lo, hi\n        local v = arr[lo]\n        while\
    \ i < j do\n            while i < j and arr[j] < v do\n                j = j -\
    \ 1\n            end\n            if i < j then\n                swap(arr, i,\
    \ j)\n                i = i + 1\n            end\n            while i < j and\
    \ arr[i] > v do\n                i = i + 1\n            end\n            if i\
    \ < j then\n                swap(arr, i, j)\n                j = j - 1\n     \
    \       end\n        end\n        return i\n    end\n    local function dfs(arr,\
    \ lo, hi, k)\n        if lo == hi then\n            return\n        end\n    \
    \    local i = partition(arr, lo, hi)\n        if i == k then\n            return\n\
    \        elseif i < k then\n            dfs(arr, i + 1, hi, k)\n        else\n\
    \            dfs(arr, lo, i - 1, k)\n        end\n    end\n    dfs(arr, 1, #arr,\
    \ k)\n    local result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n\
    \    end\n    return result\nend", "    table.sort(arr, function(a, b) return\
    \ a > b end)\n    local len = #arr\n    if k >= len then\n        return arr\n\
    \    end\n    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n \
    \   end\n    return res\nend", "  if #arr < k then\n    return arr\n  end\n  table.sort(arr,\
    \ function(a, b) return a > b end)\n  local result = {}\n  for i = 1, k do\n \
    \   result[i] = arr[i]\n  end\n  return result\nend", "  -- set the Kth key to\
    \ the largest element, and push up from there.\n  -- arr[0] will be a garbage\
    \ value that's never used.\n  for i = k, #arr do\n    arr[0] = arr[i]\n    for\
    \ j = i, k, -1 do\n      if arr[j-1] > arr[0] then\n        arr[j] = arr[j-1]\n\
    \      else\n        arr[j] = arr[0]\n        break\n      end\n    end\n  end\n\
    \  return arr\nend", "  local k, kth = 0, nil\n  for i = 1, #arr do\n    if k\
    \ == 0 then\n      kth = arr[i]\n      k = 1\n    elseif arr[i] > kth then\n \
    \     arr[i], kth = kth, arr[i]\n      k = 1\n    elseif arr[i] == kth then\n\
    \      k = k + 1\n    end\n  end\n  local res = {}\n  for i = 1, #arr do\n   \
    \ if arr[i] == kth then\n      table.insert(res, arr[i])\n      if #res == k then\n\
    \        break\n      end\n    end\n  end\n  return res\nend", "    table.sort(arr,\
    \ function(a, b) return a > b end)\n    local res = {}\n    for i = 1, k do\n\
    \        res[i] = arr[i]\n    end\n    return res\nend", "    local len = #arr\n\
    \    if len == k then\n        table.sort(arr)\n        return arr\n    end\n\
    \    local function sort_fn(a, b)\n        return a > b\n    end\n    local ret\
    \ = {}\n    for i = 1, k do\n        ret[i] = arr[i]\n    end\n    table.sort(ret,\
    \ sort_fn)\n    for i = k + 1, len do\n        local j = 1\n        while ret[j]\
    \ > arr[i] do\n            j = j + 1\n        end\n        if j <= k then\n  \
    \          local temp = ret[k]\n            ret[k] = arr[i]\n            while\
    \ j < k do\n                local temp2 = ret[j]\n                ret[j] = temp\n\
    \                temp = temp2\n                j = j + 1\n            end\n  \
    \      end\n    end\n    return ret\nend\n_M.maximum = maximum", "    assert(#arr\
    \ >= 1 and #arr <= 1000)\n    for _, v in ipairs(arr) do\n        assert(v >=\
    \ -1000 and v <= 1000)\n    end\n    assert(k >= 1 and k <= #arr)\n    local ret\
    \ = {}\n    local t = {}\n    for i = 1, k do\n        t[i] = arr[i]\n    end\n\
    \    t = heap_sort(t)\n    for i = k + 1, #arr do\n        if arr[i] > t[1] then\n\
    \            t[1] = arr[i]\n            heap_sort(t)\n        end\n    end\n \
    \   for i = 1, k do\n        ret[i] = t[i]\n    end\n    return ret\nend", "\t\
    sort(arr)\n\tlocal res = {}\n\tfor i = 1, k do\n\t\tres[i] = arr[i]\n\tend\n\t\
    return res\nend", "    local sorted = {}\n    for _, v in ipairs(arr) do\n   \
    \     local i = 1\n        while i <= #sorted and sorted[i] < v do\n         \
    \   i = i + 1\n        end\n        table.insert(sorted, i, v)\n    end\n    local\
    \ result = {}\n    for i = 1, k do\n        result[i] = sorted[i]\n    end\n \
    \   return result\nend", "    -- TODO\nend", "    if not arr or k < 1 or k > #arr\
    \ then\n        return\n    end\n    local heap = {}\n    local top = 0\n    local\
    \ function siftUp(i)\n        local p = math.floor(i / 2)\n        if p > 0 and\
    \ heap[p] < heap[i] then\n            heap[p], heap[i] = heap[i], heap[p]\n  \
    \          siftUp(p)\n        end\n    end\n    local function siftDown(i)\n \
    \       local n = math.floor(i / 2)\n        local m = math.min(top - n, 2)\n\
    \        local imax = i\n        for j = 1, m do\n            if heap[i + j] >\
    \ heap[imax] then\n                imax = i + j\n            end\n        end\n\
    \        if imax ~= i then\n            heap[i], heap[imax] = heap[imax], heap[i]\n\
    \            siftDown(imax)\n        end\n    end\n    for i = 1, #arr do\n  \
    \      top = top + 1\n        heap[top] = arr[i]\n        siftUp(top)\n      \
    \  if top > k then\n            heap[1] = heap[top]\n            top = top - 1\n\
    \            siftDown(1)\n        end\n    end\n    for i = 1, top - 1 do\n  \
    \      for j = i + 1, top do\n            if heap[i] < heap[j] then\n        \
    \        heap[i], heap[j] = heap[j], heap[i]\n            end\n        end\n \
    \   end\n    return heap\nend", "    local res = {}\n    local start = 1\n   \
    \ while start <= k do\n        local maxNum = nil\n        local maxIndex = nil\n\
    \        for i = start, #arr do\n            if not maxNum or arr[i] > maxNum\
    \ then\n                maxNum = arr[i]\n                maxIndex = i\n      \
    \      end\n        end\n        table.insert(res, maxNum)\n        table.remove(arr,\
    \ maxIndex)\n        start = start + 1\n    end\n    return res\nend", "    if\
    \ k > #arr then\n        return arr\n    end\n    local result = {}\n    for i\
    \ = 1, k do\n        local max = -math.huge\n        local maxIndex = 1\n    \
    \    for j = 1, #arr do\n            if arr[j] > max then\n                max\
    \ = arr[j]\n                maxIndex = j\n            end\n        end\n     \
    \   table.insert(result, max)\n        table.remove(arr, maxIndex)\n    end\n\
    \    return result\nend", "    local t = {}\n    for i, v in ipairs(arr) do\n\
    \        if i <= k then\n            table.insert(t, v)\n        else\n      \
    \      local n = v\n            local nidx = 1\n            for j, w in ipairs(t)\
    \ do\n                if w < n then\n                    n = w\n             \
    \       nidx = j\n                end\n            end\n            if nidx <=\
    \ k then\n                t[nidx] = v\n            end\n        end\n    end\n\
    \    table.sort(t)\n    return t\nend", "    local set = {}\n    for i = 1, #arr\
    \ do\n        set[#set + 1] = arr[i]\n    end\n    table.sort(set)\n    local\
    \ start = #set - k + 1\n    local result = {}\n    for i = start, #set do\n  \
    \      result[#result + 1] = set[i]\n    end\n    return result\nend", "  table.sort(arr,\
    \ function(a, b) return a > b end)\n  local ret = {}\n  for i = 1, k do\n    ret[i]\
    \ = arr[i]\n  end\n  return ret\nend", "    table.sort(arr, function(a, b) return\
    \ a > b end)\n    local t = {}\n    for i = 1, k do\n        t[i] = arr[i]\n \
    \   end\n    return t\nend", "    local n = #arr\n    if n <= k then\n       \
    \ return arr\n    end\n    local qs = quick_sort(arr)\n    local res = {}\n  \
    \  for i = 1, k do\n        res[i] = qs[i]\n    end\n    return res\nend", " \
    \   local copy = {}\n    for _, value in ipairs(arr) do\n        table.insert(copy,\
    \ value)\n    end\n    table.sort(copy, function(a, b) return a > b end)\n   \
    \ local max = {}\n    for i = 1, k do\n        table.insert(max, copy[i])\n  \
    \  end\n    return max\nend", "  local n = #arr\n  local list = arr\n  if n >\
    \ k then\n    list = {}\n    for i = 1, k do\n      list[i] = arr[i]\n    end\n\
    \    for i = k + 1, n do\n      local j = 1\n      for j = 1, k do\n        if\
    \ arr[i] > list[j] then\n          for h = k, j + 1, -1 do\n            list[h]\
    \ = list[h - 1]\n          end\n          list[j] = arr[i]\n          break\n\
    \        end\n      end\n    end\n  end\n  return list\nend", "    local heap\
    \ = Heap()\n    for _, v in ipairs(arr) do\n        heap:insert(v)\n    end\n\
    \    local result = {}\n    while k > 0 do\n        k = k - 1\n        result[#result\
    \ + 1] = heap:pop()\n    end\n    return result\nend", "\tlocal l = {}\n\tlocal\
    \ len = #arr\n\tlocal a, b = 0, len - 1\n\tfor i = 1, k do\n\t\tif arr[i] < arr[len\
    \ - i + 1] then\n\t\t\tl[i] = arr[len - i + 1]\n\t\t\tb = b - 1\n\t\telse\n\t\t\
    \tl[i] = arr[i]\n\t\t\ta = a + 1\n\t\tend\n\tend\n\tfor i = k + 1, len do\n\t\t\
    if b >= i then\n\t\t\tif arr[i] > l[k] then\n\t\t\t\tl[k] = arr[i]\n\t\t\t\tb\
    \ = b - 1\n\t\t\tend\n\t\telseif a < i then\n\t\t\tif arr[i] < l[k] then\n\t\t\
    \t\tl[k] = arr[i]\n\t\t\t\ta = a + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn l\n\
    end", "    local results = {}\n    for i, v in ipairs(arr) do\n        if #results\
    \ < k then\n            table.insert(results, v)\n        else\n            table.sort(results)\n\
    \            local min = results[1]\n            if v > min then\n           \
    \     table.remove(results, 1)\n                table.insert(results, v)\n   \
    \         end\n        end\n    end\n    table.sort(results)\n    return results\n\
    end", "  local len = #arr\n  local result = {}\n  local function keyCompare(i,\
    \ j)\n    return arr[i] > arr[j]\n  end\n  table.sort(arr, keyCompare)\n  for\
    \ i = 1, k do\n    result[i] = arr[i]\n  end\n  return result\nend", "    assert(type(arr)\
    \ == \"table\", \"arr must be a table\")\n    assert(type(k) == \"number\", \"\
    k must be a number\")\n    local len = #arr\n    assert(len > 0, \"arr can't be\
    \ empty\")\n    assert(len >= k, \"k can't be greater than arr's length\")\n \
    \   assert(k > 0, \"k must be a positive integer\")\n    local heap = {}\n   \
    \ local heapLen = 0\n    local heapPop = function()\n        if heapLen == 0 then\n\
    \            return nil\n        end\n        local result = heap[1]\n       \
    \ heap[1] = heap[heapLen]\n        heapLen = heapLen - 1\n        local i = 1\n\
    \        while i <= heapLen do\n            local j = i * 2\n            if j\
    \ < heapLen and heap[j] < heap[j + 1] then\n                j = j + 1\n      \
    \      end\n            if j > heapLen or heap[i] >= heap[j] then\n          \
    \      break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n\
    \            i = j\n        end\n        return result\n    end\n    local heapPush\
    \ = function(num)\n        heapLen = heapLen + 1\n        heap[heapLen] = num\n\
    \        local i = heapLen\n        while i > 1 do\n            local j = math.floor(i\
    \ / 2)\n            if heap[j] >= heap[i] then\n                break\n      \
    \      end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n\
    \        end\n    end\n    for i = 1, len do\n        heapPush(arr[i])\n    end\n\
    \    local result = {}\n    for i = 1, k do\n        result[i] = heapPop()\n \
    \   end\n    return result\nend", "    table.sort(arr, function(a, b) return a\
    \ > b end)\n    local t = {}\n    for i = 1, k do\n        t[i] = arr[i]\n   \
    \ end\n    return t\nend", "    local ret = {}\n    local heap = {}\n    local\
    \ size = 0\n    local function insert(arr, val)\n        local left, right = 1,\
    \ #arr\n        while left <= right do\n            local mid = math.floor((left\
    \ + right) / 2)\n            if arr[mid] > val then\n                right = mid\
    \ - 1\n            else\n                left = mid + 1\n            end\n   \
    \     end\n        table.insert(arr, left, val)\n    end\n    for i = 1, #arr\
    \ do\n        if size < k then\n            insert(heap, arr[i])\n           \
    \ size = size + 1\n        else\n            if arr[i] > heap[1] then\n      \
    \          heap[1] = arr[i]\n                local size = #heap\n            \
    \    local i = 1\n                while true do\n                    local min,\
    \ minPos = heap[i], i\n                    if i * 2 <= size and heap[i * 2] <\
    \ min then\n                        min, minPos = heap[i * 2], i * 2\n       \
    \             end\n                    if i * 2 + 1 <= size and heap[i * 2 + 1]\
    \ < min then\n                        min, minPos = heap[i * 2 + 1], i * 2 + 1\n\
    \                    end\n                    if minPos == i then\n          \
    \              break\n                    end\n                    heap[i], heap[minPos]\
    \ = heap[minPos], heap[i]\n                    i = minPos\n                end\n\
    \            end\n        end\n    end\n    return heap\nend", "    local n =\
    \ #arr\n    if n == 0 then return {} end\n    local t = {}\n    for i = 1, n do\n\
    \        local a = arr[i]\n        local j = i\n        while j > 1 and t[j -\
    \ 1] < a do\n            t[j] = t[j - 1]\n            j = j - 1\n        end\n\
    \        t[j] = a\n    end\n    local result = {}\n    for i = 1, k do\n     \
    \   result[i] = t[i]\n    end\n    return result\nend", "    if not arr or not\
    \ k then\n        return nil\n    end\n    if k == 0 then\n        return {}\n\
    \    end\n    if k == 1 then\n        return {math.max(unpack(arr))}\n    end\n\
    \    if k == #arr then\n        return arr\n    end\n    local len = #arr\n  \
    \  if k > len then\n        return arr\n    end\n    local newArr = {}\n    local\
    \ res = {}\n    for i = 1, k do\n        newArr[i] = arr[i]\n    end\n    table.sort(newArr)\n\
    \    for i = k + 1, len do\n        if arr[i] > newArr[1] then\n            newArr[1]\
    \ = arr[i]\n            table.sort(newArr)\n        end\n    end\n    for i =\
    \ k, 1, -1 do\n        res[k - i + 1] = newArr[i]\n    end\n    return res\nend",
  "  local len = #arr\n  local res = {}\n  for i = 1, k do\n    local max = arr[1]\n\
    \    local index = 1\n    for j = 2, len do\n      if arr[j] > max then\n    \
    \    max = arr[j]\n        index = j\n      end\n    end\n    res[i] = max\n \
    \   table.remove(arr, index)\n    len = len - 1\n  end\n  return res\nend", " \
    \   return false\nend", "    local tb = {}\n    for i = 1, #arr do\n        local\
    \ idx = i\n        for j = i + 1, #arr do\n            if arr[j] > arr[idx] then\n\
    \                idx = j\n            end\n        end\n        if idx ~= i then\n\
    \            arr[i], arr[idx] = arr[idx], arr[i]\n        end\n        if i >=\
    \ k then\n            break\n        end\n        tb[i] = arr[i]\n    end\n  \
    \  return tb\nend", "    table.sort(arr, function(a, b) return a > b end)\n  \
    \  local result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n    end\n\
    \    return result\nend", "    -- Write your code here\n    local ret = {}\n \
    \   for i = 1, #arr do\n        if i <= k then\n            table.insert(ret,\
    \ arr[i])\n        else\n            local max = -1001\n            local maxIndex\
    \ = -1\n            for j = 1, #ret do\n                if ret[j] > max then\n\
    \                    max = ret[j]\n                    maxIndex = j\n        \
    \        end\n            end\n            if arr[i] < max then\n            \
    \    ret[maxIndex] = arr[i]\n            end\n        end\n    end\n    table.sort(ret)\n\
    \    return ret\nend", "  local max_vals = {}\n  for i = 1, k do\n    max_vals[i]\
    \ = arr[i]\n  end\n  for i = 1, k do\n    for j = i, k do\n      if max_vals[i]\
    \ < max_vals[j] then\n        max_vals[i], max_vals[j] = max_vals[j], max_vals[i]\n\
    \      end\n    end\n  end\n  for i = k + 1, #arr do\n    local insert_flag =\
    \ false\n    for j = 1, k do\n      if arr[i] > max_vals[j] then\n        insert_flag\
    \ = true\n        local j_backup = j\n        while insert_flag and j < k do\n\
    \          max_vals[j], max_vals[j + 1] = max_vals[j + 1], max_vals[j]\n     \
    \     j = j + 1\n        end\n        max_vals[j_backup] = arr[i]\n        break\n\
    \      end\n    end\n  end\n  return max_vals\nend", "  local function compare(a,\
    \ b)\n    return a > b\n  end\n  local heap = heapq.nlargest(k, arr, compare)\n\
    \  return heap\nend", "    local res = {}\n    for i = 1, k do\n        res[i]\
    \ = -1e9\n    end\n    for i = 1, #arr do\n        if arr[i] > res[k] then\n \
    \           res[k] = arr[i]\n            local j = k\n            while j > 1\
    \ and res[j] > res[j - 1] do\n                res[j], res[j - 1] = res[j - 1],\
    \ res[j]\n                j = j - 1\n            end\n        end\n    end\n \
    \   return res\nend", "\tlocal heap = libheap.new()\n\tlocal n = 0\n\tfor i =\
    \ 1, #arr do\n\t\tif n < k then\n\t\t\theap:insert(arr[i])\n\t\t\tn = n + 1\n\t\
    \telse\n\t\t\tlocal cur = heap:top()\n\t\t\tif arr[i] > cur then\n\t\t\t\theap:replace(arr[i])\n\
    \t\t\tend\n\t\tend\n\tend\n\tlocal res = {}\n\tfor i = 1, n do\n\t\tres[n-i+1]\
    \ = heap:extract()\n\tend\n\treturn res\nend", "  local arr2 = {}\n  for _,v in\
    \ ipairs(arr) do\n    arr2[#arr2+1] = v\n  end\n  table.sort(arr2)\n  local result\
    \ = {}\n  for i = #arr2, #arr2-k+1, -1 do\n    result[#result+1] = arr2[i]\n \
    \ end\n  return result\nend", "  -- Sort the array in descending order.\n  table.sort(arr,\
    \ function(a, b) return a > b end)\n  -- Return the first k elements.\n  local\
    \ res = {}\n  for i = 1, k do\n    res[i] = arr[i]\n  end\n  return res\nend",
  "    local t = {}\n    local k = k\n    if #arr <= k then\n        return arr\n\
    \    end\n    for i = 1, #arr do\n        if #t < k then\n            table.insert(t,\
    \ arr[i])\n        else\n            table.sort(t)\n            if arr[i] > t[1]\
    \ then\n                table.remove(t, 1)\n                table.insert(t, arr[i])\n\
    \            end\n        end\n    end\n    table.sort(t)\n    return t\nend",
  "    local tmp = {}\n    for i = 1, k do\n        tmp[i] = arr[i]\n    end\n   \
    \ table.sort(tmp)\n    for i = k + 1, #arr do\n        if arr[i] > tmp[1] then\n\
    \            table.remove(tmp, 1)\n            table.insert(tmp, arr[i])\n   \
    \         table.sort(tmp)\n        end\n    end\n    return tmp\nend", "  assert(type(arr)\
    \ == 'table' and type(k) == 'number')\n  assert(#arr > 0 and k > 0 and k <= #arr)\n\
    \  local temp = {}\n  local res = {}\n  for i = 1, #arr do\n    insert(temp, arr[i])\n\
    \  end\n  sort(temp)\n  local index = #temp\n  while #res < k do\n    res[#res\
    \ + 1] = temp[index]\n    index = index - 1\n  end\n  return res\nend", "    local\
    \ ans = {}\n    for i = 1, #arr do\n        local v = arr[i]\n        if #ans\
    \ < k then\n            table.insert(ans, v)\n        else\n            local\
    \ x = ans[k]\n            if v > x then\n                ans[k] = v\n        \
    \    end\n        end\n        table.sort(ans)\n    end\n    return ans\nend",
  "    local heap = {}\n    local size = 0\n    local length = #arr\n    local result\
    \ = {}\n    local i, j\n    local function maxheapify(arr, index)\n        local\
    \ largest = index\n        local left = 2 * index\n        local right = 2 * index\
    \ + 1\n        if left <= size and arr[left] > arr[largest] then\n           \
    \ largest = left\n        end\n        if right <= size and arr[right] > arr[largest]\
    \ then\n            largest = right\n        end\n        if largest ~= index\
    \ then\n            arr[index], arr[largest] = arr[largest], arr[index]\n    \
    \        maxheapify(arr, largest)\n        end\n    end\n    for i = 1, length\
    \ do\n        if size < k then\n            size = size + 1\n            heap[size]\
    \ = arr[i]\n            j = size\n            while j > 1 and heap[j] > heap[j\
    \ // 2] do\n                heap[j], heap[j // 2] = heap[j // 2], heap[j]\n  \
    \              j = j // 2\n            end\n        elseif arr[i] < heap[1] then\n\
    \            heap[1] = arr[i]\n            maxheapify(heap, 1)\n        end\n\
    \    end\n    for i = 1, k do\n        result[i] = heap[1]\n        heap[1] =\
    \ heap[size]\n        size = size - 1\n        maxheapify(heap, 1)\n    end\n\
    \    return result\nend", "  -- Your code here\nend", "    if #arr == 0 then return\
    \ arr end\n    local t = {}\n    for i = 1, #arr do\n        t[i] = arr[i]\n \
    \   end\n    table.sort(t, function(a, b) return a > b end)\n    local res = {}\n\
    \    for i = 1, k do\n        res[i] = t[i]\n    end\n    return res\nend", " \
    \   if k >= #arr then return arr end\n    local heap = {}\n    for i, v in ipairs(arr)\
    \ do\n        if #heap < k then\n            table.insert(heap, v)\n         \
    \   sift_up(heap, #heap)\n        elseif v > heap[1] then\n            heap[1]\
    \ = v\n            sift_down(heap, 1)\n        end\n    end\n    table.sort(heap)\n\
    \    return heap\nend\nreturn maximum", "    local tbl = {}\n    local idx = 0\n\
    \    for _, v in ipairs(arr) do\n        idx = idx + 1\n        tbl[idx] = v\n\
    \        local i = idx\n        while i > 1 and tbl[i] > tbl[i-1] do\n       \
    \     tbl[i], tbl[i-1] = tbl[i-1], tbl[i]\n            i = i - 1\n        end\n\
    \    end\n    for i = k, #tbl do\n        tbl[i] = nil\n    end\n    return tbl\n\
    end", "  local maxs = {}\n  local i, n = 1, #arr\n  while i <= n do\n    local\
    \ t = maxs[1]\n    if not t or arr[i] > t then\n      table.insert(maxs, 1, arr[i])\n\
    \      if #maxs > k then\n        table.remove(maxs)\n      end\n    else\n  \
    \    for j = #maxs, 1, -1 do\n        if not maxs[j] or arr[i] > maxs[j] then\n\
    \          table.insert(maxs, j + 1, arr[i])\n          if #maxs > k then\n  \
    \          table.remove(maxs)\n          end\n          break\n        end\n \
    \     end\n    end\n    i = i + 1\n  end\n  return maxs\nend", "    sort(arr)\n\
    \    local ret = {}\n    for i = #arr, #arr - k + 1, -1 do\n        ret[#ret +\
    \ 1] = arr[i]\n    end\n    return ret\nend", "  local a = {}\n  for i = 1, k\
    \ do\n    a[i] = arr[i]\n  end\n  table.sort(a)\n  for i = k + 1, #arr do\n  \
    \  if arr[i] > a[1] then\n      table.remove(a, 1)\n      table.insert(a, arr[i])\n\
    \      table.sort(a)\n    end\n  end\n  return a\nend", end, "  local function\
    \ makeHeap(arr, k)\n    local heap = {}\n    for i = 1, k do\n      heap[i] =\
    \ arr[i]\n    end\n    for i = k, 2, -1 do\n      heapDown(heap, i, k)\n    end\n\
    \    return heap\n  end\n  local function heapDown(heap, i, n)\n    while 2 *\
    \ i <= n do\n      local j = 2 * i\n      if j + 1 <= n and heap[j + 1] < heap[j]\
    \ then\n        j = j + 1\n      end\n      if heap[i] <= heap[j] then\n     \
    \   break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n\
    \    end\n  end\n  local function heapUp(heap, i)\n    while i > 1 and heap[i]\
    \ < heap[i // 2] do\n      heap[i], heap[i // 2] = heap[i // 2], heap[i]\n   \
    \   i = i // 2\n    end\n  end\n  local function heapInsert(heap, i, n, x)\n \
    \   heap[i] = x\n    heapUp(heap, i)\n  end\n  local function heapExtract(heap,\
    \ i, n)\n    local x = heap[i]\n    heap[i] = heap[n]\n    heapDown(heap, i, n\
    \ - 1)\n    return x\n  end\n  local function heapSort(heap, k)\n    local arr\
    \ = {}\n    for i = 1, k do\n      arr[i] = heapExtract(heap, 1, k + 1 - i)\n\
    \    end\n    return arr\n  end\n  local n = #arr\n  if k > n then\n    k = n\n\
    \  end\n  local heap = makeHeap(arr, k)\n  for i = k + 1, n do\n    if arr[i]\
    \ > heap[1] then\n      heapInsert(heap, 1, k, arr[i])\n    end\n  end\n  return\
    \ heapSort(heap, k)\nend", "  local function partition(arr, pivot, left, right)\n\
    \    while left <= right do\n      while left <= right and arr[left] > pivot do\n\
    \        left = left + 1\n      end\n      while left <= right and arr[right]\
    \ < pivot do\n        right = right - 1\n      end\n      if left <= right then\n\
    \        arr[left], arr[right] = arr[right], arr[left]\n        left = left +\
    \ 1\n        right = right - 1\n      end\n    end\n    return left\n  end\n \
    \ local function quickselect(arr, k, left, right)\n    local pivot = arr[right]\n\
    \    local i = partition(arr, pivot, left, right - 1)\n    arr[i], arr[right]\
    \ = arr[right], arr[i]\n    if i == k then\n      return\n    elseif i < k then\n\
    \      quickselect(arr, k, i + 1, right)\n    else\n      quickselect(arr, k,\
    \ left, i - 1)\n    end\n  end\n  quickselect(arr, k, 1, #arr)\n  return table.slice(arr,\
    \ 1, k)\nend", "  table.sort(arr, function(a, b) return a > b end)\n  local result\
    \ = {}\n  for i = 1, k do\n    result[i] = arr[i]\n  end\n  return result\nend",
  "\tlocal len = #arr\n\tlocal result = {}\n\tfor i = 1, k do\n\t\tlocal max = -math.huge\n\
    \t\tlocal idx = 0\n\t\tfor j = 1, len do\n\t\t\tif arr[j] > max then\n\t\t\t\t\
    max = arr[j]\n\t\t\t\tidx = j\n\t\t\tend\n\t\tend\n\t\tresult[i] = max\n\t\tarr[idx]\
    \ = -math.huge\n\tend\n\treturn result\nend", "\tlocal len = #arr\n\tif k <= 0\
    \ or k > len then\n\t\treturn {}\n\tend\n\tlocal maxT = {}\n\tfor i = 1, k do\n\
    \t\tmaxT[i] = arr[i]\n\tend\n\tfor i = k, len do\n\t\ttable.sort(maxT)\n\t\tif\
    \ arr[i] > maxT[1] then\n\t\t\tmaxT[1] = arr[i]\n\t\tend\n\tend\n\ttable.sort(maxT)\n\
    \treturn maxT\nend", "    if not arr or #arr < 1 or not k or k < 1 then\n    \
    \    return arr\n    end\n    local ret = {}\n    local map = {}\n    for i =\
    \ 1, #arr do\n        local idx = 1\n        local val = arr[i]\n        while\
    \ map[idx] and map[idx][1] >= val do\n            idx = idx + 1\n        end\n\
    \        table.insert(map, idx, {val, i})\n        if #map > k then\n        \
    \    table.remove(map, #map)\n        end\n    end\n    for i = 1, #map do\n \
    \       table.insert(ret, map[i][1])\n    end\n    return ret\nend", "    local\
    \ len = #arr\n    if len <= k then\n        table.sort(arr)\n        return arr\n\
    \    end\n    for i = 1, len - 1 do\n        local e = arr[i]\n        for j =\
    \ i + 1, len do\n            if e < arr[j] then\n                arr[i], arr[j]\
    \ = arr[j], arr[i]\n                e = arr[i]\n            end\n        end\n\
    \    end\n    local result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n\
    \    end\n    return result\nend", "  local n = #arr\n  if n == 0 then return\
    \ {} end\n  if k == 0 then return {} end\n  local window = {}\n  for i = 1, k\
    \ do window[i] = arr[i] end\n  table.sort(window)\n  for i = k + 1, n do\n   \
    \ if arr[i] > window[1] then\n      window[1] = arr[i]\n      table.sort(window)\n\
    \    end\n  end\n  return window\nend", "  local result = {}\n  local heap = newHeap()\n\
    \  for i = 1, #arr do\n    heap:insert(arr[i])\n  end\n  for i = 1, k do\n   \
    \ result[i] = heap:pop()\n  end\n  return result\nend", "\ttable.sort(arr, function(a,\
    \ b) return a > b end)\n\tlocal res = {}\n\tfor i = 1, k do res[i] = arr[i] end\n\
    \treturn res\nend", "    if not arr or k <= 0 then return {} end\n    local t\
    \ = {}\n    for i = 1, #arr do\n        local pos = #t\n        for j = 1, #t\
    \ do\n            if arr[i] > t[j] then\n                pos = j\n           \
    \     break\n            end\n        end\n        if pos < k then\n         \
    \   if pos < #t then\n                for j = #t, pos+1, -1 do\n             \
    \       t[j] = t[j-1]\n                end\n            end\n            t[pos]\
    \ = arr[i]\n        end\n    end\n    return t\nend", "    local arr, k = arr,\
    \ k\n    local set, ret = {}, {}\n    for i, v in ipairs(arr) do\n        if i\
    \ <= k then\n            table.insert(set, v)\n        else\n            local\
    \ min = table.remove(set, 1)\n            for j, m in ipairs(set) do\n       \
    \         if m < min then\n                    min = m\n                end\n\
    \            end\n            if v > min then\n                table.insert(set,\
    \ v)\n            else\n                table.insert(set, min)\n            end\n\
    \        end\n    end\n    while #set > 0 do\n        table.insert(ret, table.remove(set))\n\
    \    end\n    return ret\nend", "    table.sort(arr, function(a, b) return a >\
    \ b end)\n    local ret = {}\n    for i = 1, k do\n        ret[i] = arr[i]\n \
    \   end\n    return ret\nend", "    local res = {}\n    local tmp = {}\n    for\
    \ _, v in ipairs(arr) do\n        tmp[#tmp + 1] = v\n    end\n    table.sort(tmp)\n\
    \    for i = #tmp, 1, -1 do\n        res[#res + 1] = tmp[i]\n        if #res ==\
    \ k then\n            break\n        end\n    end\n    return res\nend", "   \
    \ table.sort(arr, function(a, b) return a > b end)\n    local result = {}\n  \
    \  for i = 1, k do\n        result[i] = arr[i]\n    end\n    return result\nend",
  "    local data = {}\n    for i = 1, k do\n        table.insert(data, i, arr[i])\n\
    \    end\n    if k == #arr then\n        table.sort(data)\n        return data\n\
    \    end\n    for i = k + 1, #arr do\n        local j = 1\n        while j <=\
    \ k do\n            if arr[i] > data[j] then\n                table.insert(data,\
    \ j, arr[i])\n                table.remove(data, k + 1)\n                break\n\
    \            end\n            j = j + 1\n        end\n    end\n    return data\n\
    end", "\tlocal function partition(arr, l, r)\n\t\tlocal pivot = math.random(l,\
    \ r)\n\t\tarr[pivot], arr[r] = arr[r], arr[pivot]\n\t\tlocal i = l - 1\n\t\tfor\
    \ j = l, r do\n\t\t\tif arr[j] < arr[r] then\n\t\t\t\ti = i + 1\n\t\t\t\tarr[i],\
    \ arr[j] = arr[j], arr[i]\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\t\tarr[i], arr[r]\
    \ = arr[r], arr[i]\n\t\treturn i\n\tend\n\tlocal function helper(arr, l, r, k)\n\
    \t\tlocal m = partition(arr, l, r)\n\t\tif m - l < k then\n\t\t\treturn helper(arr,\
    \ m + 1, r, k - (m - l) - 1)\n\t\telseif m - l == k then\n\t\t\treturn\n\t\telse\n\
    \t\t\treturn helper(arr, l, m - 1, k)\n\t\tend\n\tend\n\tlocal result = {}\n\t\
    for i = 1, k do\n\t\tresult[i] = arr[i]\n\tend\n\thelper(result, 1, k, k)\n\t\
    for i = k + 1, #arr do\n\t\tif arr[i] > result[k] then\n\t\t\tresult[k] = arr[i]\n\
    \t\t\thelper(result, 1, k, k)\n\t\tend\n\tend\n\treturn result\nend", "\tlocal\
    \ sorted = {}\n\tfor i = 1, #arr do\n\t\tlocal x = arr[i]\n\t\tlocal j = 1\n\t\
    \twhile j <= #sorted and x < sorted[j] do\n\t\t\tj = j + 1\n\t\tend\n\t\ttable.insert(sorted,\
    \ j, x)\n\tend\n\tfor i = #sorted, k + 1, -1 do\n\t\ttable.remove(sorted, i)\n\
    \tend\n\treturn sorted\nend", "    local tbl = {}\n    local i = 1\n    while\
    \ i <= k do\n        local max = arr[i]\n        local idx = i\n        for j\
    \ = i + 1, #arr do\n            if arr[j] > max then\n                max = arr[j]\n\
    \                idx = j\n            end\n        end\n        arr[idx] = arr[i]\n\
    \        arr[i] = max\n        tbl[i] = max\n        i = i + 1\n    end\n    return\
    \ tbl\nend", "    table.sort(arr, function(a, b) return a > b end)\n    return\
    \ {table.unpack(arr, 1, k)}\nend", "    local function split(t, i)\n        local\
    \ l = {}\n        local r = {}\n        for j = 1, #t do\n            if j <=\
    \ i then\n                l[#l + 1] = t[j]\n            else\n               \
    \ r[#r + 1] = t[j]\n            end\n        end\n        return l, r\n    end\n\
    \    local function quickSort(arr)\n        if #arr <= 1 then\n            return\
    \ arr\n        end\n        local i = 1\n        local j = #arr\n        local\
    \ pivot = arr[1]\n        while i < j do\n            while i < j and arr[j] <=\
    \ pivot do\n                j = j - 1\n            end\n            arr[i] = arr[j]\n\
    \            while i < j and arr[i] >= pivot do\n                i = i + 1\n \
    \           end\n            arr[j] = arr[i]\n        end\n        arr[i] = pivot\n\
    \        return split(arr, i)\n    end\n    local function merge(l, r)\n     \
    \   local m = {}\n        while #l > 0 and #r > 0 do\n            if l[1] < r[1]\
    \ then\n                m[#m + 1] = table.remove(l, 1)\n            else\n   \
    \             m[#m + 1] = table.remove(r, 1)\n            end\n        end\n \
    \       while #l > 0 do\n            m[#m + 1] = table.remove(l, 1)\n        end\n\
    \        while #r > 0 do\n            m[#m + 1] = table.remove(r, 1)\n       \
    \ end\n        return m\n    end\n    local function mergeSort(arr)\n        if\
    \ #arr <= 1 then\n            return arr\n        end\n        local i = math.floor(#arr\
    \ / 2)\n        local l, r = split(arr, i)\n        l = mergeSort(l)\n       \
    \ r = mergeSort(r)\n        return merge(l, r)\n    end\n    if #arr == 0 then\n\
    \        return {}\n    end\n    arr = mergeSort(arr)\n    local r = {}\n    for\
    \ i = 1, #arr do\n        if #r < k then", "    local n = #arr\n    if k == 0\
    \ then\n        return {}\n    elseif k >= n then\n        return arr\n    end\n\
    \    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n \
    \   table.sort(res)\n    for i = k + 1, n do\n        local j = k\n        while\
    \ j > 1 and res[j] < arr[i] do\n            j = j - 1\n        end\n        if\
    \ j < k then\n            for l = k, j + 1, -1 do\n                res[l] = res[l\
    \ - 1]\n            end\n            res[j + 1] = arr[i]\n        end\n    end\n\
    \    return res\nend", "  if k == 0 then return {} end\n  if k == 1 then return\
    \ {table.max(arr)} end\n  table.sort(arr)\n  return arr.slice(#arr - k + 1, #arr)\n\
    end", "\tlocal function max(x, y)\n\t\treturn x >= y and x or y\n\tend\n\ttable.sort(arr,\
    \ function(x, y) return max(x, y) end)\n\tlocal res = {}\n\tfor i = 1, k do\n\t\
    \tres[i] = arr[i]\n\tend\n\treturn res\nend", "    local function trim(arr, s,\
    \ e)\n        if e > #arr then\n            e = #arr\n        end\n        local\
    \ ret = {}\n        for i = s, e do\n            table.insert(ret, arr[i])\n \
    \       end\n        return ret\n    end\n    table.sort(arr, function(a, b) return\
    \ a > b end)\n    return trim(arr, 1, k)\nend", "    table.sort(arr, function(a,\
    \ b) return a > b end)\n    return table.sub(arr, 1, k)\nend", "\tlocal r = {}\n\
    \tfor i = 1, k do\n\t\tlocal m = i\n\t\tfor j = i, #arr do\n\t\t\tif arr[j] >\
    \ arr[m] then\n\t\t\t\tm = j\n\t\t\tend\n\t\tend\n\t\tr[i] = arr[m]\n\t\tarr[m]\
    \ = arr[i]\n\tend\n\treturn r\nend", "    local index = {}\n    for i = 1, #arr\
    \ do\n        local j = i\n        while j > 1 and arr[j] > arr[index[j - 1]]\
    \ do\n            index[j], index[j - 1] = index[j - 1], index[j]\n          \
    \  j = j - 1\n        end\n        index[j] = i\n    end\n    local ret = {}\n\
    \    for i = 1, k do\n        ret[i] = arr[index[i]]\n    end\n    return ret\n\
    end", end, end, "    -- write your code here\n    local result = {}\n    for i\
    \ = 1, k do\n        local max = nil\n        local index = nil\n        for j\
    \ = 1, #arr do\n            if arr[j] > max then\n                max = arr[j]\n\
    \                index = j\n            end\n        end\n        table.insert(result,\
    \ max)\n        table.remove(arr, index)\n    end\n    return result\nend", " \
    \ -- Write your code here\n  local max = function(a, b)\n    if a > b then\n \
    \     return a\n    else\n      return b\n    end\n  end\n  local function qsort(data,\
    \ i, j)\n    if i >= j then\n      return\n    end\n    local pivot = data[i]\n\
    \    local low = i\n    local high = j\n    while i < j do\n      while data[j]\
    \ < pivot and i < j do\n        j = j - 1\n      end\n      data[i] = data[j]\n\
    \      while data[i] >= pivot and i < j do\n        i = i + 1\n      end\n   \
    \   data[j] = data[i]\n    end\n    data[i] = pivot\n    qsort(data, low, i -\
    \ 1)\n    qsort(data, i + 1, high)\n  end\n  qsort(arr, 1, #arr)\n  local result\
    \ = {}\n  for i = 1, k do\n    result[i] = arr[i]\n  end\n  return result\nend",
  "    local heap = Heap.new(k, true)\n    for _, v in ipairs(arr) do\n        heap:insert(v)\n\
    \    end\n    local result = {}\n    for i = 1, k do\n        result[i] = heap:pop()\n\
    \    end\n    return result\nend", "    -- O(N log K) time\n    -- O(K) space\n\
    \    if k == 0 then return {} end\n    local heap = {}\n    local n = #arr\n \
    \   for i = 1, k do\n        heap[i] = arr[i]\n    end\n    table.sort(heap)\n\
    \    for i = k + 1, n do\n        if arr[i] > heap[1] then\n            heap[1]\
    \ = arr[i]\n            table.sort(heap)\n        end\n    end\n    return heap\n\
    end", "    table.sort(arr, function(a, b) return a > b end)\n    local result\
    \ = {}\n    for i = 1, k do\n        result[i] = arr[i]\n    end\n    return result\n\
    end", "    if k == 0 then return {} end\n    if k == 1 then\n        local ans\
    \ = arr[1]\n        for i = 2, #arr do\n            if arr[i] > ans then ans =\
    \ arr[i] end\n        end\n        return {ans}\n    end\n    local len = #arr\n\
    \    local pivot = arr[math.random(len)]\n    local left, right = {}, {}\n   \
    \ for i = 1, len do\n        if arr[i] > pivot then\n            table.insert(right,\
    \ arr[i])\n        elseif arr[i] < pivot then\n            table.insert(left,\
    \ arr[i])\n        end\n    end\n    local leftLen = #left\n    if leftLen >=\
    \ k then\n        return maximum(left, k)\n    elseif leftLen + 1 == k then\n\
    \        return left\n    else\n        local rightLen = #right\n        if leftLen\
    \ + rightLen < k then\n            table.insert(left, pivot)\n            table.insert(left,\
    \ unpack(right))\n            return left\n        else\n            return maximum(right,\
    \ k - leftLen - 1)\n        end\n    end\nend\n_exports.maximum = maximum", " \
    \   local n = #arr\n    local idx = n - k + 1\n    if idx < 1 then\n        idx\
    \ = 1\n    end\n    table.sort(arr, function(a, b) return a > b end)\n    return\
    \ table.move(arr, idx, n, 1, {})\nend", "    local arr1 = {}\n    local n = #arr\n\
    \    if k > n then\n        return {}\n    end\n    for i = 1, k do\n        arr1[i]\
    \ = arr[i]\n    end\n    table.sort(arr1)\n    for i = k + 1, n do\n        if\
    \ arr[i] > arr1[1] then\n            arr1[1] = arr[i]\n            table.sort(arr1)\n\
    \        end\n    end\n    return arr1\nend", "    local arr2 = {}\n    for i\
    \ = 1, k do\n        local max_value = -1000\n        local max_index = 0\n  \
    \      for j = 1, #arr do\n            if arr[j] > max_value then\n          \
    \      max_value = arr[j]\n                max_index = j\n            end\n  \
    \      end\n        table.insert(arr2, max_value)\n        table.remove(arr, max_index)\n\
    \    end\n    return arr2\nend", "\tlocal heap = heap_new();\n\tfor _, v in ipairs(arr)\
    \ do\n\t\theap_insert(heap, v);\n\tend\n\tlocal r = {};\n\tfor i = 1, k do\n\t\
    \tr[i] = heap_extract_max(heap);\n\tend\n\treturn r;\nend", "    local function\
    \ partition(t, lo, hi)\n        local i, j = lo, hi\n        local v = t[lo]\n\
    \        while true do\n            while t[i] > v do i = i + 1 end\n        \
    \    while t[j] < v do j = j - 1 end\n            if i >= j then break end\n \
    \           t[i], t[j] = t[j], t[i]\n            i, j = i + 1, j - 1\n       \
    \ end\n        return j\n    end\n    local function quick_select(t, k)\n    \
    \    local lo, hi = 1, #t\n        while lo < hi do\n            local m = partition(t,\
    \ lo, hi)\n            if m == k then break end\n            if m < k then lo\
    \ = m + 1\n            else hi = m end\n        end\n    end\n    quick_select(arr,\
    \ k)\n    return arr\nend", "    -- Insertion Sort:\n    local function insert(t,\
    \ x)\n        local i = #t\n        while i > 0 and t[i] < x do\n            t[i\
    \ + 1] = t[i]\n            i = i - 1\n        end\n        t[i + 1] = x\n    end\n\
    \    local result = {}\n    for i = 1, #arr do\n        if i <= k then\n     \
    \       insert(result, arr[i])\n        else\n            insert(result, arr[i])\n\
    \            local j = #result\n            while j > 0 and result[j] > result[j\
    \ - 1] do\n                result[j], result[j - 1] = result[j - 1], result[j]\n\
    \                j = j - 1\n            end\n            result[j] = nil\n   \
    \     end\n    end\n    return result\nend", "  local len = #arr\n  if len <=\
    \ 1 then return arr end\n  local n = math.min(len, k)\n  local i = 0\n  while\
    \ i < n - 1 do\n    local j = i + 1\n    while j < n do\n      if arr[i] < arr[j]\
    \ then\n        local tmp = arr[i]\n        arr[i] = arr[j]\n        arr[j] =\
    \ tmp\n      end\n      j = j + 1\n    end\n    i = i + 1\n  end\n  local result\
    \ = {}\n  for i = 1, n do\n    result[i] = arr[i]\n  end\n  return result\nend",
  "  table.sort(arr, function(a, b) return a > b end)\n  return copyArray(arr, 1,\
    \ k)\nend", "    local function binary_search(t, l, h, val)\n        local mid\
    \ = math.floor((l + h) / 2)\n        if t[mid] == val then\n            return\
    \ mid\n        elseif l >= h then\n            return mid\n        elseif t[mid]\
    \ < val then\n            return binary_search(t, mid + 1, h, val)\n        else\n\
    \            return binary_search(t, l, mid - 1, val)\n        end\n    end\n\
    \    local arr_sorted = {}\n    local len = #arr\n    for i = 1, k do\n      \
    \  local insert_idx = binary_search(arr_sorted, 1, i - 1, arr[i])\n        table.insert(arr_sorted,\
    \ insert_idx, arr[i])\n    end\n    for i = k + 1, len do\n        if arr[i] >\
    \ arr_sorted[1] then\n            local insert_idx = binary_search(arr_sorted,\
    \ 1, k, arr[i])\n            table.insert(arr_sorted, insert_idx, arr[i])\n  \
    \          table.remove(arr_sorted, 1)\n        end\n    end\n    return arr_sorted\n\
    end", "    local l = {}\n    for i = 1, k do\n        table.insert(l, -math.huge)\n\
    \    end\n    for i = 1, #arr do\n        local v = arr[i]\n        local p =\
    \ 0\n        for j = 1, k do\n            if v > l[j] then\n                p\
    \ = j\n                break\n            end\n        end\n        if p > 0 then\n\
    \            table.insert(l, p, v)\n            table.remove(l)\n        end\n\
    \    end\n    return l\nend", "    local function helper(nums, left, right)\n\
    \        local k = left\n        local pivot = nums[left]\n        for i = left\
    \ + 1, right do\n            if nums[i] < pivot then\n                k = k +\
    \ 1\n                nums[i], nums[k] = nums[k], nums[i]\n            end\n  \
    \      end\n        nums[left], nums[k] = nums[k], nums[left]\n        return\
    \ k\n    end\n    local function sort(nums, left, right, k)\n        local target\
    \ = helper(nums, left, right)\n        if target == k then\n            return\
    \ nums[1:k]\n        elseif target < k then\n            return sort(nums, target\
    \ + 1, right, k)\n        else\n            return sort(nums, left, target - 1,\
    \ k)\n        end\n    end\n    return sort(arr, 1, #arr, k)\nend", "  local i,\
    \ n = 1, #arr\n  while i < n do\n    local j = i\n    while j > 0 and arr[j] >\
    \ arr[j + 1] do\n      arr[j], arr[j + 1] = arr[j + 1], arr[j]\n      j = j -\
    \ 1\n    end\n    i = i + 1\n  end\n  local ans = {}\n  for i = 1, k do\n    ans[i]\
    \ = arr[i]\n  end\n  return ans\nend", "    local heap = {}\n    for i = 1, k\
    \ do\n        heap[i] = arr[i]\n    end\n    for i = (k + 1) / 2, 1, -1 do\n \
    \       heapify(heap, i, k)\n    end\n    for i = k + 1, #arr do\n        if arr[i]\
    \ > heap[1] then\n            heap[1] = arr[i]\n            heapify(heap, 1, k)\n\
    \        end\n    end\n    return heap\nend", "    local len = #arr\n    local\
    \ idx, cnt = 1, k\n    while idx <= len do\n        cnt = cnt - 1\n        if\
    \ cnt == 0 then\n            break\n        end\n        if arr[idx] < 0 then\n\
    \            for i = idx, 2, -1 do\n                if arr[i - 1] < arr[i] then\n\
    \                    arr[i - 1], arr[i] = arr[i], arr[i - 1]\n               \
    \ else\n                    break\n                end\n            end\n    \
    \    else\n            for i = idx, 2, -1 do\n                if arr[i - 1] >\
    \ arr[i] then\n                    arr[i - 1], arr[i] = arr[i], arr[i - 1]\n \
    \               else\n                    break\n                end\n       \
    \     end\n        end\n        idx = idx + 1\n    end\n    return {unpack(arr,\
    \ 1, k)}\nend\n_M.maximum = maximum", "    if #arr < k then return arr end\n \
    \   local heap = { 0 }\n    for i = 1, k do\n        table.insert(heap, arr[i])\n\
    \    end\n    local function siftup(pos)\n        local v = heap[pos]\n      \
    \  local parent = pos // 2\n        while parent > 0 and v > heap[parent] do\n\
    \            heap[pos] = heap[parent]\n            pos = parent\n            parent\
    \ = pos // 2\n        end\n        heap[pos] = v\n    end\n    local function\
    \ siftdown(pos)\n        local v = heap[pos]\n        local child = pos * 2\n\
    \        while child <= k do\n            if child + 1 <= k and heap[child] <\
    \ heap[child + 1] then\n                child = child + 1\n            end\n \
    \           if v > heap[child] then break end\n            heap[pos] = heap[child]\n\
    \            pos = child\n            child = pos * 2\n        end\n        heap[pos]\
    \ = v\n    end\n    for i = k // 2, 1, -1 do\n        siftdown(i)\n    end\n \
    \   for i = k + 1, #arr do\n        if arr[i] > heap[1] then\n            heap[1]\
    \ = arr[i]\n            siftdown(1)\n        end\n    end\n    return heap\nend",
  end, "  local max = {}\n  for i = 1, #arr do\n    max[i] = arr[i]\n  end\n  if k\
    \ == #arr then\n    table.sort(max)\n    return max\n  end\n  for i = #arr, k\
    \ + 1, -1 do\n    table.remove(max, 1)\n  end\n  table.sort(max)\n  return max\n\
    end", "    local result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n\
    \    end\n    table.sort(result)\n    for i = k + 1, #arr do\n        if arr[i]\
    \ > result[1] then\n            table.remove(result, 1)\n            table.insert(result,\
    \ arr[i])\n            table.sort(result)\n        end\n    end\n    return result\n\
    end", "  -- Write your code here.\n  table.sort(arr, function(a, b) return a >\
    \ b end)\n  local t = {}\n  for i = 1, k do\n    t[i] = arr[i]\n  end\n  return\
    \ t\nend", "    if #arr < k then\n        return arr\n    end\n    local PQ =\
    \ require('algo.PriorityQueue')\n    local pq = PQ.new(function(e1, e2) return\
    \ e1 > e2 end)\n    for _, v in ipairs(arr) do\n        pq:push(v)\n        if\
    \ pq:size() > k then\n            pq:pop()\n        end\n    end\n    local r\
    \ = {}\n    while not pq:empty() do\n        table.insert(r, 1, pq:pop())\n  \
    \  end\n    return r\nend", "  table.sort(arr, function(a, b) return a > b end)\n\
    \  return table.slice(arr, 1, k)\nend", "    local n = #arr\n    table.sort(arr)\n\
    \    local ans = {}\n    for i = n - k + 1, n do\n        table.insert(ans, arr[i])\n\
    \    end\n    return ans\nend", "    return {}\nend", "    local heap = {}\n \
    \   for i = 1, k do\n        heap[i] = arr[i]\n    end\n    table.sort(heap)\n\
    \    for i = k + 1, #arr do\n        if arr[i] > heap[1] then\n            heap[1]\
    \ = arr[i]\n            table.sort(heap)\n        end\n    end\n    return heap\n\
    end", "  local r = table.qsort(arr)\n  for i = #r, k + 1, -1 do\n    table.remove(r,\
    \ i)\n  end\n  return r\nend", "    local k = math.min(k, #arr)\n    local d =\
    \ {}\n    local s = {}\n    local m = {}\n    local p = math.floor(k / 2)\n  \
    \  local t = {}\n    table.sort(arr)\n    for i = #arr, 1, -1 do\n        table.insert(d,\
    \ arr[i])\n    end\n    for i = 1, k do\n        m[i] = d[i]\n    end\n    for\
    \ i = k + 1, #d do\n        for j = 1, p do\n            local tj = j\n      \
    \      local tk = 2 * p - j + 1\n            local ti = j * 2\n            while\
    \ ti <= i - 1 do\n                if d[ti] > d[tj] then\n                    tj\
    \ = ti\n                end\n                if d[ti] > d[tk] then\n         \
    \           tk = ti\n                end\n                ti = ti + 1\n      \
    \      end\n            s[j] = tj\n            s[2 * p - j + 1] = tk\n       \
    \ end\n        for j = 1, p do\n            if d[i] > d[s[j]] then\n         \
    \       s[j] = i\n            end\n            if d[i] > d[s[2 * p - j + 1]] then\n\
    \                s[2 * p - j + 1] = i\n            end\n        end\n        m[1]\
    \ = s[1]\n        for j = 2, k do\n            if d[m[j - 1]] > d[s[j]] then\n\
    \                m[j] = m[j - 1]\n            else\n                m[j] = s[j]\n\
    \            end\n        end\n    end\n    for i = 1, k do\n        table.insert(t,\
    \ d[m[i]])\n    end\n    return t\nend", "  local function heap_sort(arr)\n  \
    \  local function heapify(t, root, len)\n      local left = 2 * root\n      local\
    \ right = 2 * root + 1\n      local max = root\n      if left <= len and t[left]\
    \ > t[max] then\n        max = left\n      end\n      if right <= len and t[right]\
    \ > t[max] then\n        max = right\n      end\n      if max ~= root then\n \
    \       t[root], t[max] = t[max], t[root]\n        heapify(t, max, len)\n    \
    \  end\n    end\n    local len = #arr\n    for i = math.floor(len / 2), 1, -1\
    \ do\n      heapify(arr, i, len)\n    end\n    for i = len, 2, -1 do\n      arr[1],\
    \ arr[i] = arr[i], arr[1]\n      heapify(arr, 1, i - 1)\n    end\n  end\n  heap_sort(arr)\n\
    \  local result = {}\n  for i = 1, k do\n    result[i] = arr[i]\n  end\n  return\
    \ result\nend", end, "  table.sort(arr, function(a, b) return a > b end)\n  local\
    \ res = {}\n  for i = 1, k do\n    res[i] = arr[i]\n  end\n  return res\nend",
  "    -- find the minimum k numbers in arr\n    local min_k_arr = {}\n    for i,\
    \ v in ipairs(arr) do\n        local n = #min_k_arr\n        if i <= k then\n\
    \            if n == 0 then\n                min_k_arr[1] = v\n            else\n\
    \                local j = n\n                while j > 0 and v > min_k_arr[j]\
    \ do\n                    min_k_arr[j + 1] = min_k_arr[j]\n                  \
    \  j = j - 1\n                end\n                min_k_arr[j + 1] = v\n    \
    \        end\n        else\n            if v > min_k_arr[1] then\n           \
    \     local j = 1\n                while j < n and v > min_k_arr[j + 1] do\n \
    \                   min_k_arr[j] = min_k_arr[j + 1]\n                    j = j\
    \ + 1\n                end\n                min_k_arr[j] = v\n            end\n\
    \        end\n    end\n    -- reverse\n    local n = #min_k_arr\n    for i = 1,\
    \ (n - 1) / 2 do\n        min_k_arr[i], min_k_arr[n - i + 1] = min_k_arr[n - i\
    \ + 1], min_k_arr[i]\n    end\n    return min_k_arr\nend", "    table.sort(arr,\
    \ function(a, b) return a > b end)\n    local rets = {}\n    for i = 1, k do\n\
    \        table.insert(rets, arr[i])\n    end\n    return rets\nend", "    if #arr\
    \ == 0 then return {} end\n    if k > #arr then k = #arr end\n    local i, j,\
    \ res = 1, #arr, {}\n    while i <= k do\n        local idx, mx = 1, arr[1]\n\
    \        for j = 2, #arr do\n            if arr[j] > mx then\n               \
    \ idx, mx = j, arr[j]\n            end\n        end\n        table.insert(res,\
    \ mx)\n        table.remove(arr, idx)\n        i = i + 1\n    end\n    return\
    \ res\nend", "  local n = #arr\n  if k >= n then\n    table.sort(arr)\n    return\
    \ arr\n  end\n  local copy = {}\n  for i = 1, k do\n    copy[i] = arr[i]\n  end\n\
    \  table.sort(copy)\n  for i = k + 1, n do\n    local a = arr[i]\n    if a > copy[1]\
    \ then\n      copy[1] = a\n      for j = 2, k do\n        if copy[j - 1] > copy[j]\
    \ then\n          copy[j - 1], copy[j] = copy[j], copy[j - 1]\n        else\n\
    \          break\n        end\n      end\n    end\n  end\n  return copy\nend",
  "    local q = {}\n    local res = {}\n    for i = 1, #arr do\n        if #q < k\
    \ then\n            insert(q, arr[i])\n        else\n            for j = #q, 1,\
    \ -1 do\n                if arr[i] > q[j] then\n                    remove(q,\
    \ j)\n                    insert(q, arr[i])\n                    break\n     \
    \           end\n            end\n        end\n    end\n    for i = #q, 1, -1\
    \ do\n        insert(res, q[i])\n    end\n    return res\nend", "  local len =\
    \ #arr\n  if k > len then\n    k = len\n  end\n  local result = {}\n  for i =\
    \ 1, k do\n    result[i] = arr[i]\n  end\n  table.sort(result)\n  for i = k +\
    \ 1, len do\n    local v = arr[i]\n    local j = k\n    while j > 1 and v > result[j]\
    \ do\n      j = j - 1\n    end\n    if j < k then\n      for l = k, j + 1, -1\
    \ do\n        result[l] = result[l - 1]\n      end\n      result[j + 1] = v\n\
    \    end\n  end\n  return result\nend", "  local sorted = {}\n  for i = 1, k do\n\
    \    table.insert(sorted, arr[i])\n  end\n  table.sort(sorted)\n  for i = k +\
    \ 1, #arr do\n    for j = 1, k do\n      if arr[i] > sorted[j] then\n        table.insert(sorted,\
    \ j, arr[i])\n        break\n      end\n    end\n  end\n  return sorted\nend",
  "  -- TODO: Add Code Here\nend", "  local copy = {}\n  for i, v in ipairs(arr) do\n\
    \    table.insert(copy, v)\n  end\n  table.sort(copy, function(a, b) return a\
    \ > b end)\n  return table.sub(copy, 1, k)\nend", "    local sub = {}\n    local\
    \ i = 1\n    while i <= k do\n        table.insert(sub, arr[i])\n        i = i\
    \ + 1\n    end\n    table.sort(sub)\n    for i = k + 1, #arr do\n        for j\
    \ = 1, k do\n            if arr[i] > sub[j] then\n                table.remove(sub,\
    \ j)\n                table.insert(sub, j, arr[i])\n                break\n  \
    \          end\n        end\n    end\n    return sub\nend", "    if #arr == 0\
    \ then return {} end\n    table.sort(arr, function(a, b) return a > b end)\n \
    \   return arr\nend", "    table.sort(arr, function(a, b) return a > b end)\n\
    \    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n \
    \   return res\nend", "    local max = {}\n    for i = 1, k do\n        max[i]\
    \ = math.mininteger\n    end\n    for i = 1, #arr do\n        local a = arr[i]\n\
    \        if a > max[1] then\n            local j = 1\n            while j <= k\
    \ and a > max[j] do\n                j = j + 1\n            end\n            if\
    \ j <= k then\n                for h = 1, j - 1 do\n                    max[h]\
    \ = max[h + 1]\n                end\n                max[j] = a\n            end\n\
    \        end\n    end\n    return max\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
