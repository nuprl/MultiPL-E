name: HumanEval_65_circular_shift
language: lua
prompt: "-- Circular shift the digits of the integer x, shift the digits right by\
  \ shift\n-- and return the result as a string.\n-- If shift > number of digits,\
  \ return digits reversed.\n-- >>> circular_shift(12, 1)\n-- '21'\n-- >>> circular_shift(12,\
  \ 2)\n-- '12'\nlocal function circular_shift(x, shift)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = circular_shift\n\
  \    lu.assertEquals(candidate(100, 2), '001')\n    lu.assertEquals(candidate(12,\
  \ 2), '12')\n    lu.assertEquals(candidate(97, 8), '79')\n    lu.assertEquals(candidate(12,\
  \ 1), '21')\n    lu.assertEquals(candidate(11, 101), '11')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local digits = tostring(x)\n    local shift = shift % #digits\n\
    \    local result = digits:sub(shift + 1) .. digits:sub(1, shift)\n    return\
    \ result\nend", "    local s = tostring(x)\n    local m = #s\n    if shift < m\
    \ then\n        return s:sub(m - shift + 1) .. s:sub(1, m - shift)\n    else\n\
    \        local n = shift % m\n        return s:sub(m - n + 1) .. s:sub(1, m -\
    \ n):reverse()\n    end\nend", "    local x_str = tostring(x)\n    local x_len\
    \ = #x_str\n    if shift > x_len then\n        return x_str:reverse()\n    end\n\
    \    return x_str:sub(x_len-shift+1) .. x_str:sub(1, x_len-shift)\nend", "   \
    \ x = tostring(x)\n    shift = shift % #x\n    return x:sub(shift + 1) .. x:sub(1,\
    \ shift)\nend", "  if shift >= num_digits(x) then\n    return reverse_digits(x)\n\
    \  end\n  return str_tens(x, shift) .. str_ones(x, shift)\nend", "    local str\
    \ = tostring(x)\n    shift = shift % #str\n    if shift == 0 then\n        return\
    \ str\n    end\n    return string.sub(str, shift + 1) .. string.sub(str, 1, shift)\n\
    end", "  return tostring(x):reverse():sub(1,shift):reverse() .. tostring(x):sub(1,\
    \ #tostring(x) - shift)\nend", "  local shifted = tostring(x)\n  shift = shift\
    \ % #shifted\n  local back = shifted:sub(1, -shift - 1)\n  local front = shifted:sub(-shift)\n\
    \  return front .. back\nend", "    local xs = tostring(x)\n    local len = #xs\n\
    \    local shift = shift % len\n    local res = xs:sub(len - shift + 1) .. xs:sub(1,\
    \ len - shift)\n    return res\nend", "\treturn (('%0' .. n_digits(x) .. 'd'):format(x)\
    \ .. (shift > n_digits(x) and '' or ' '):rep(shift)):sub(shift + 1)\nend", " \
    \   x = tostring(x)\n    if shift < #x then\n        x = x:sub(shift + 1) .. x:sub(1,\
    \ shift)\n    else\n        x = x:reverse()\n    end\n    return x\nend", "\t\
    local s = str(x)\n\tif shift >= len(s) then\n\t\treturn s:reverse()\n\tend\n\t\
    return s:sub(shift + 1) .. s:sub(1, shift)\nend", "    if shift > 0 then\n   \
    \     shift = shift % #tostring(x)\n    end\n    return tostring(x):sub(shift\
    \ + 1) .. tostring(x):sub(1, shift)\nend", "  x = tostring(x)\n  shift = shift\
    \ % #x\n  return x:sub(shift + 1) .. x:sub(1, shift)\nend", "\tlocal s = tostring(x)\n\
    \tlocal n = #s\n\tif shift >= n then\n\t\ts = s:reverse()\n\telse\n\t\ts = (s:sub(n-shift+1,\
    \ n) .. s:sub(1, n-shift))\n\tend\n\treturn s\nend", "    local p = x\n    local\
    \ q = x\n    local r = 0\n    local n = 0\n    repeat\n        r = q % 10\n  \
    \      q = q // 10\n        n = n + 1\n    until q == 0\n    if shift < n then\n\
    \        q = x\n        for i = 1, shift do\n            r = q % 10\n        \
    \    q = q // 10\n        end\n        local s = 0\n        for i = 1, n - shift\
    \ do\n            s = s * 10 + q % 10\n            q = q // 10\n        end\n\
    \        p = p // (10 ^ shift)\n        p = p + s * (10 ^ n)\n    else\n     \
    \   local s = 0\n        repeat\n            s = s * 10 + p % 10\n           \
    \ p = p // 10\n        until p == 0\n        p = s\n    end\n    return tostring(p)\n\
    end", "    x = tostring(x)\n    if shift >= #x then\n        x = string.reverse(x)\n\
    \    else\n        x = x:sub(#x - shift + 1) .. x:sub(1, #x - shift)\n    end\n\
    \    return x\nend", "  local str = string.format(\"%d\", x)\n  local len = #str\n\
    \  local shift = shift % len\n  return string.sub(str, len - shift + 1) .. string.sub(str,\
    \ 1, len - shift)\nend", "    if shift == 0 then\n        return tostring(x)\n\
    \    end\n    local x_str = tostring(x)\n    local length = x_str:len()\n    if\
    \ shift >= length then\n        return x_str:reverse()\n    end\n    return x_str:sub(shift\
    \ + 1) .. x_str:sub(1, shift)\nend", "  x = math.abs(x)\n  if x == 0 then return\
    \ '0' end\n  local n = math.floor(math.log10(x))\n  x = x * (10 ^ (shift % (n\
    \ + 1)))\n  x = x % (10 ^ (n + 1))\n  return tostring(x)\nend", "    local str\
    \ = tostring(x)\n    local digits = string.len(str)\n    if shift >= digits then\n\
    \        return str_reverse(str)\n    end\n    return string.sub(str, digits -\
    \ shift + 1) .. string.sub(str, 1, digits - shift)\nend", "  local s = tostring(x)\n\
    \  if #s <= shift then\n    return string.reverse(s)\n  end\n  return string.sub(s,\
    \ shift + 1) .. string.sub(s, 1, shift)\nend", "\tlocal s = tostring(x)\n\tlocal\
    \ shift = shift % #s\n\treturn (s:sub(shift + 1) .. s:sub(1, shift))\nend", " \
    \   if shift == 0 then\n        return tostring(x)\n    end\n    -- Get digits\
    \ in reverse order:\n    local x_digits = {}\n    while x > 0 do\n        x_digits[#x_digits\
    \ + 1] = tostring(x % 10)\n        x = math.floor(x / 10)\n    end\n    if shift\
    \ >= #x_digits then\n        return table.concat(x_digits)\n    end\n    return\
    \ table.concat(x_digits, '', 1 + shift, #x_digits) ..\n           table.concat(x_digits,\
    \ '', 1, shift)\nend", "    local sx = tostring(x)\n    if #sx <= shift then\n\
    \        return string.reverse(sx)\n    end\n    return string.sub(sx, shift +\
    \ 1) .. string.sub(sx, 1, shift)\nend", "    local s = tostring(x)\n    local\
    \ l = s:len()\n    if shift > l then\n        return s:reverse()\n    end\n  \
    \  return s:sub(l-shift+1) .. s:sub(1, l-shift)\nend", "    -- If shift > number\
    \ of digits, return digits reversed.\n    if shift > floor(log10(x)) + 1 then\n\
    \        return rev(to_string(x))\n    end\n    local s = to_string(x)\n    local\
    \ len = len(s)\n    local d1 = sub(s, len - shift + 1, len)\n    local d2 = sub(s,\
    \ 1, len - shift)\n    return d1 .. d2\nend", "  local s = tostring(x)\n  if shift\
    \ > #s then\n    return string.reverse(s)\n  end\n  return string.sub(s, shift+1)\
    \ .. string.sub(s, 1, shift)\nend", "    local digits = tostring(x)\n    local\
    \ rev = string.reverse(digits)\n    local len = string.len(rev)\n    local shift\
    \ = shift % len\n    return string.sub(rev, shift + 1) .. string.sub(rev, 1, shift)\n\
    end", "    x = tostring(x)\n    if shift > #x then\n        return string.reverse(x)\n\
    \    end\n    return string.sub(x, shift+1) .. string.sub(x, 1, shift)\nend",
  "\tlocal sx = tostring(x)\n\tlocal len = #sx\n\tif shift >= len then\n\t\treturn\
    \ sx:reverse()\n\tend\n\treturn sx:sub(len - shift + 1) .. sx:sub(1, len - shift)\n\
    end", "  local digits = {}\n  for digit in tostring(x):gmatch(\".\") do\n    table.insert(digits,\
    \ tonumber(digit))\n  end\n  local last = #digits\n  for i = 1, shift do\n   \
    \ local digit = digits[last]\n    table.remove(digits, last)\n    table.insert(digits,\
    \ 1, digit)\n  end\n  local result = \"\"\n  for _, digit in ipairs(digits) do\n\
    \    result = result .. tostring(digit)\n  end\n  return result\nend", "  local\
    \ result = {}\n  local digits = math.floor(math.log10(x)) + 1\n  if shift > digits\
    \ then\n    shift = shift % digits\n  end\n  local d = digits\n  while x > 0 do\n\
    \    local divisor = math.pow(10, d - 1)\n    local digit = math.floor(x / divisor)\n\
    \    x = x - digit * divisor\n    result[d - shift] = digit\n    d = d - 1\n \
    \ end\n  if shift > 0 then\n    for i = 1, shift do\n      result[i] = result[digits\
    \ - shift + i]\n    end\n  end\n  return table.concat(result)\nend", "  local\
    \ s = tostring(x)\n  local n = #s\n  if shift > n then\n    return string.reverse(s)\n\
    \  end\n  local prefix = string.sub(s, 1, n - shift)\n  local suffix = string.sub(s,\
    \ n - shift + 1, n)\n  return suffix .. prefix\nend", "    local xs = tostring(x)\n\
    \    local xlen = #xs\n    local s = reverse(xs)\n    return sub(s, 1, shift)\
    \ .. sub(s, shift + 1, xlen)\nend", "    local digits = tostring(x)\n    local\
    \ len = string.len(digits)\n    if shift < len then\n        local reverse = string.reverse(digits)\n\
    \        local lhs = string.sub(reverse, 1, shift)\n        local rhs = string.sub(reverse,\
    \ shift + 1, len)\n        return string.reverse(rhs .. lhs)\n    else\n     \
    \   return digits\n    end\nend", "    local shift = shift % #tostring(x)\n  \
    \  local first = tostring(x):sub(1, shift)\n    local second = tostring(x):sub(shift\
    \ + 1)\n    return second .. first\nend", "  -- Check how many digits.\n  local\
    \ num_digits = floor(log10(x)) + 1\n  local res = \"\"\n  for i = num_digits,\
    \ 1, -1 do\n    local digit = 10^(i-1)\n    res = res .. tostring(floor(x / digit))\n\
    \    x = mod(x, digit)\n  end\n  if shift > num_digits then\n    return res\n\
    \  end\n  res = res .. ' ' -- insert a space\n  local res_rev = res:reverse()\n\
    \  return res_rev:sub(1, shift) .. res_rev:sub(shift+2)\nend", "    local s =\
    \ tostring(x)\n    local s2 = string.sub(s, -shift)\n    local s1 = string.sub(s,\
    \ 1, -(shift + 1))\n    local s3 = string.reverse(s2)\n    local s4 = string.reverse(s1)\n\
    \    return s3 .. s4\nend", "    if shift == 0 then\n        return tostring(x)\n\
    \    end\n    local l = #tostring(x)\n    if shift > l then\n        local a =\
    \ tostring(x)\n        return a:reverse()\n    end\n    local a = tostring(x)\n\
    \    return a:sub(shift+1) .. a:sub(1, shift)\nend", "    return (('%0' .. #tostring(x)\
    \ .. 'd'):format(x)):sub(shift+1) .. (('%0' .. #tostring(x) .. 'd'):format(x)):sub(1,\
    \ shift)\nend", "    local digits = utils.digits(x)\n    shift = shift % #digits\n\
    \    return table.concat(utils.right_shift(digits, shift))\nend", "    local str\
    \ = tostring(x)\n    shift = shift % #str\n    return str:sub(shift + 1) .. str:sub(1,\
    \ shift)\nend", "    local s = tostring(x)\n    local n = #s\n    shift = shift\
    \ % n\n    local a = n - shift\n    return s:sub(a + 1) .. s:sub(1, a)\nend",
  "    local str = tostring(x)\n    local digits = string.len(str)\n    shift = shift\
    \ % digits\n    local str1 = string.sub(str, 1, shift)\n    local str2 = string.sub(str,\
    \ shift + 1, digits)\n    return str2 .. str1\nend", "  local s = tostring(x)\n\
    \  local len = #s\n  local last = len - (shift % len)\n  return s:sub(last + 1)\
    \ .. s:sub(1, last)\nend", "    local digits = digittable(x)\n    local s = shift\
    \ % #digits\n    return table.concat(digits, '', s + 1, #digits) .. table.concat(digits,\
    \ '', 1, s)\nend", "    if shift > #x then\n        return x:reverse()\n    end\n\
    \    return x:sub(shift+1) .. x:sub(1, shift)\nend", "    local digits = num_digits(x)\n\
    \    -- Shift more than the number of digits? Return the digits reversed.\n  \
    \  if shift >= digits then\n        local reversed = 0\n        for i = 1, digits\
    \ do\n            reversed = reversed + (x % 10) * 10^(digits - i)\n         \
    \   x = math.floor(x / 10)\n        end\n        return tostring(reversed)\n \
    \   end\n    local left, right = 0, 0\n    -- Iterate through the digits and shift\n\
    \    for i = 1, digits do\n        left = x % 10\n        x = math.floor(x / 10)\n\
    \        right = right + left * 10^(digits - i - shift)\n    end\n    return right\
    \ .. tostring(x)\nend", "\tlocal str = tostring(x)\n\tif shift > str:len() then\n\
    \t\tstr = str:reverse()\n\telse\n\t\tstr = str:sub(shift + 1) .. str:sub(1, shift)\n\
    \tend\n\treturn str\nend", "    local n = digits(x)\n    if shift >= n then\n\
    \        return reverse(x)\n    end\n    local m = n - shift\n    local ten =\
    \ 10^m\n    local a = x % ten\n    local b = (x - a) / ten\n    return concat(b,\
    \ a)\nend", "    local n = num_digits(x)\n    local digits = int_to_digits(x)\n\
    \    local first = table.remove(digits, 1)\n    if shift > n then\n        return\
    \ string.reverse(digits_to_string(digits))\n    end\n    for i = 1, shift do\n\
    \        table.insert(digits, first)\n        first = table.remove(digits, 1)\n\
    \    end\n    return digits_to_string(digits)\nend", "    local digits = string.format(\"\
    %d\", x)\n    local digits_len = #digits\n    if digits_len <= shift then\n  \
    \      return string.reverse(digits)\n    end\n    local ret = string.sub(digits,\
    \ digits_len - shift + 1)\n    ret = ret .. string.sub(digits, 1, digits_len -\
    \ shift)\n    return ret\nend", "    return tostring(x):sub(shift + 1) .. tostring(x):sub(1,\
    \ shift)\nend", "    local s = x .. ''\n    local l = #s\n    shift = shift %\
    \ l\n    if shift == 0 then\n        return s\n    elseif shift < 0 then\n   \
    \     return s:sub(shift + 1) .. s:sub(1, shift)\n    else\n        return s:sub(l\
    \ - shift + 1) .. s:sub(1, l - shift)\n    end\nend", "    local digits = shift_digits(math.abs(x),\
    \ shift)\n    return digits\nend", "  if shift > 0 then\n    local s = tostring(x)\n\
    \    local a, b = string.sub(s, 1, shift), string.sub(s, shift + 1)\n    return\
    \ b .. a\n  else\n    return tostring(x)\n  end\nend", "  local digits = string.split(tostring(x),\
    \ '')\n  local len = #digits\n  if len <= shift then\n    return table.concat(digits,\
    \ '')\n  end\n  local parts = {\n    table.concat(digits, '', 1, shift),\n   \
    \ table.concat(digits, '', shift + 1, len)\n  }\n  return table.concat(parts,\
    \ '')\nend", "    local str = tostring(x)\n    local count = #str\n    local result\
    \ = ''\n    if shift > count then\n        result = reverse(str)\n    else\n \
    \       for i = count - shift + 1, count do\n            result = result .. str:sub(i,\
    \ i)\n        end\n        for i = 1, count - shift do\n            result = result\
    \ .. str:sub(i, i)\n        end\n    end\n    return result\nend", "    local\
    \ xs = tostring(x)\n    local len = #xs\n    local shift = shift % len\n    local\
    \ xsl = xs:sub(1, shift)\n    local xsr = xs:sub(shift + 1, len)\n    return xsr\
    \ .. xsl\nend", "    local x_str = tostring(x)\n    if #x_str <= shift then\n\
    \        return string.reverse(x_str)\n    end\n    local new_str = string.sub(x_str,\
    \ shift + 1) .. string.sub(x_str, 1, shift)\n    return new_str\nend", "  local\
    \ x_str = tostring(x)\n  if #x_str <= shift then\n    return reverse(x_str)\n\
    \  end\n  return x_str:sub(#x_str - shift + 1) .. x_str:sub(1, #x_str - shift)\n\
    end", "    local shift_string = tostring(x)\n    local length = string.len(shift_string)\n\
    \    shift = shift % length", "    local digits = tostring(x)\n    local len =\
    \ #digits\n    if shift > len then\n        return string.reverse(digits)\n  \
    \  end\n    return string.sub(digits, len - shift + 1) .. string.sub(digits, 1,\
    \ len - shift)\nend", "  local ret = tostring(x)\n  if shift > #ret then\n   \
    \ return string.reverse(ret)\n  end\n  return string.sub(ret, shift+1) .. string.sub(ret,\
    \ 1, shift)\nend", "    if shift > x then\n        return reverse(tostring(x))\n\
    \    end\n    local d = 10 ^ shift\n    local m = x % d\n    return tostring(m)\
    \ .. math.floor(x / d)\nend", "    -- check input\n    assert(type(x) == 'number'\
    \ and x > 0 and\n               type(shift) == 'number' and shift > 0,\n     \
    \      'circular_shift: x, shift must be positive integers')\n    -- build list\
    \ of digits\n    local digits = {}\n    for i = 1, math.ceil(math.log10(x)) do\n\
    \        table.insert(digits, x % 10)\n        x = math.floor(x / 10)\n    end\n\
    \    -- circular shift digits\n    for i = 1, shift do\n        local digit =\
    \ table.remove(digits, 1)\n        table.insert(digits, digit)\n    end\n    --\
    \ build string from digits\n    local s = ''\n    for i = 1, #digits do\n    \
    \    s = s .. tostring(digits[i])\n    end\n    return s\nend", "    local s =\
    \ tostring(x)\n    local l = #s\n    shift = shift % l\n    return s:sub(l-shift+1,\
    \ l) .. s:sub(1, l-shift)\nend", "    local digits = digit_list(x)\n    local\
    \ rotated_digits = {}\n    for i = 1, #digits do\n        local index = (i + shift\
    \ - 1) % #digits + 1\n        rotated_digits[i] = digits[index]\n    end\n   \
    \ local digit_string = \"\"\n    for i = 1, #rotated_digits do\n        digit_string\
    \ = digit_string .. rotated_digits[i]\n    end\n    return digit_string\nend",
  "  local t = {}\n  for d in tostring(x):gmatch(\".\") do\n    table.insert(t, 1,\
    \ d)\n  end\n  for i = 1, shift do\n    table.insert(t, 1, table.remove(t))\n\
    \  end\n  return table.concat(t)\nend", "\tx = string.rep(\"0\", shift) .. x\n\
    \tlocal n = #x\n\treturn x:sub(n - shift + 1, n) .. x:sub(1, n - shift)\nend",
  "\t-- Turn number into list of digits\n\tlocal digits = {}\n\tlocal i = 0\n\twhile\
    \ x > 0 do\n\t\tdigits[i] = x % 10\n\t\tx = math.floor(x / 10)\n\t\ti = i + 1\n\
    \tend\n\t-- Circular shift digits\n\tlocal result = ''\n\tfor j = 1, shift do\n\
    \t\tlocal digit = table.remove(digits, i - 1)\n\t\tresult = digit .. result\n\t\
    \ti = i - 1\n\tend\n\tfor k = 1, i do\n\t\tresult = table.remove(digits, i - 1)\
    \ .. result\n\tend\n\treturn result\nend", "    if shift == 0 then\n        return\
    \ tostring(x)\n    end\n    -- Convert x to a string.\n    local s = tostring(x)\n\
    \    -- Reverse the digits of x.\n    local t = string.reverse(s)\n    -- Shift\
    \ the digits right.\n    local u = string.sub(t, 1, shift)\n    local v = string.sub(t,\
    \ shift + 1)\n    -- Reverse the digits of the shift.\n    u = string.reverse(u)\n\
    \    -- Append the digits of the shift to the digits of x.\n    return u .. v\n\
    end", "    local str = tostring(x)\n    local p, q = str:sub(1, shift), str:sub(shift\
    \ + 1)\n    return (q .. p):reverse()\nend", "    return tostring(x):reverse():sub(1,\
    \ shift):reverse() .. tostring(x):sub(1, tostring(x):len() - shift)\nend", "\t\
    local digits = floor(log10(x)) + 1\n\tif shift >= digits then\n\t\tlocal result\
    \ = {}\n\t\tfor i = 1, digits do\n\t\t\tresult[i] = char(48 + x % 10)\n\t\t\t\
    x = floor(x / 10)\n\t\tend\n\t\treturn table.concat(result)\n\tend\n\treturn tostring(x):sub(digits\
    \ - shift + 1) .. tostring(x):sub(1, digits - shift)\nend", "  -- Convert integer\
    \ to string\n  local y = tostring(x)\n  -- Ignore shift if greater than number\
    \ of digits\n  shift = shift % #y\n  -- Reverse the string, then take the last\
    \ shift characters, then reverse them\n  -- again to return\n  return y:reverse():sub(1,\
    \ shift):reverse()\nend", "    local n = #x\n    shift = shift % n\n    if shift\
    \ == 0 then\n        return x\n    elseif shift < 0 then\n        shift = n +\
    \ shift\n    end\n    return x:sub(shift + 1) .. x:sub(1, shift)\nend", "    local\
    \ str = tostring(x)\n    local length = #str\n    shift = shift % length\n   \
    \ local front = str:sub(1, length - shift)\n    local back = str:sub(length -\
    \ shift + 1, length)\n    return back .. front\nend", "  local len = #tostring(x)\n\
    \  if shift >= len then\n    return reverse(tostring(x))\n  end\n  return tostring(x):sub(len-shift+1)\
    \ .. tostring(x):sub(1, len-shift)\nend", "  if shift == 0 then\n    return tostring(x)\n\
    \  end\n  local digits = tostring(x)\n  for i = 1, shift do\n    local d = table.remove(digits,\
    \ 1)\n    table.insert(digits, d)\n  end\n  return table.concat(digits)\nend",
  "    x = tostring(x)\n    local xlen = #x\n    shift = shift % xlen\n    return\
    \ x:sub(xlen-shift+1) .. x:sub(1, xlen-shift)\nend", "  local n = #tostring(x)\n\
    \  if n == 1 then\n    return x\n  end\n  if shift >= n then\n    return string.reverse(tostring(x))\n\
    \  end\n  return string.sub(tostring(x), shift + 1) .. string.sub(tostring(x),\
    \ 1, shift)\nend", "  -- Concatenate the shifted and unshifted digits.\n  local\
    \ digits = tostring(x)\n  if shift > #digits then\n    return digits:reverse()\n\
    \  end\n  local shifted = digits:sub(1, shift)\n  local unshifted = digits:sub(shift\
    \ + 1)\n  return unshifted .. shifted\nend", "    if shift > 0 then\n        local\
    \ s = tostring(x)\n        local len = utf8.len(s)\n        local head = utf8.sub(s,\
    \ len - shift + 1, len)\n        local tail = utf8.sub(s, 1, len - shift)\n  \
    \      return head .. tail\n    else\n        return tostring(x)\n    end\nend",
  "    local str = tostring(x)\n    local n = #str\n    if shift > n then\n      \
    \  str = string.reverse(str)\n    else\n        str = string.sub(str, shift +\
    \ 1) .. string.sub(str, 1, shift)\n    end\n    return str\nend", "  local a =\
    \ tostring(x)\n  if shift >= #a then\n    return a:reverse()\n  end\n  return\
    \ a:sub(shift + 1) .. a:sub(1, shift)\nend", "    local s = tostring(x)\n    local\
    \ l = strlen(s)\n    if shift > l then\n        return strrev(s)\n    end\n  \
    \  local f = substr(s, 1, shift)\n    local r = substr(s, shift + 1)\n    return\
    \ r .. f\nend", "  local x_digits = tonumber(tostring(x):reverse())\n  local x_digits_n\
    \ = #tostring(x_digits)\n  if x_digits_n <= shift then\n    return tostring(x_digits)\n\
    \  end\n  local x_shift = tonumber(tostring(x_digits):sub(1, x_digits_n - shift))\n\
    \  local x_shift_r = tonumber(tostring(x_digits):sub(x_digits_n - shift + 1))\n\
    \  return tostring(x_shift_r) .. tostring(x_shift)\nend", "\tx = tostring(x)\n\
    \tshift = shift % #x\n\treturn x:sub(shift + 1) .. x:sub(1, shift)\nend", "  \
    \  x = ('%d'):format(x)\n    if shift > #x then\n        return x:reverse()\n\
    \    end\n    return x:sub(shift + 1) .. x:sub(1, shift)\nend", "    -- Check\
    \ for a negative shift value\n    if shift < 0 then\n        shift = shift + math.ceil(math.log10(x)\
    \ - 0.0001)\n    end\n    local s = tostring(x)\n    -- if the shift is greater\
    \ than the number of digits, reverse the string\n    if shift > s:len() then\n\
    \        return s:reverse()\n    end\n    return s:sub(shift + 1) .. s:sub(1,\
    \ shift)\nend", "    local s = tostring(x)\n    local l = s:len()\n    shift =\
    \ shift % l\n    return (s:sub(l-shift+1, l) .. s:sub(1, l-shift))\nend", "  \
    \  local digs = {}\n    while x > 0 do\n        digs[#digs + 1] = x % 10\n   \
    \     x = floor(x / 10)\n    end\n    while shift > #digs do\n        shift =\
    \ shift - #digs\n    end\n    while shift > 0 do\n        table.insert(digs, 1,\
    \ table.remove(digs))\n        shift = shift - 1\n    end\n    return table.concat(digs)\n\
    end", "  -- Get the digits of x, reverse them and return a list.\n  local digits\
    \ = {}\n  for i = 1, #(tostring(x)) do\n    digits[i] = math.floor(x / 10^(i -\
    \ 1)) % 10\n  end\n  -- We only need to loop through the first #digits - shift\
    \ digits.\n  local digits_num = #digits - shift\n  for i = 1, digits_num do\n\
    \    -- Swap the current digit with the digit that is shift\n    -- digits from\
    \ it.\n    digits[i], digits[i + shift] = digits[i + shift], digits[i]\n  end\n\
    \  -- Return a string of the shifted digits.\n  return table.concat(digits)\n\
    end", "  local numdigits = math.floor(math.log10(x)) + 1\n  if shift > numdigits\
    \ then\n    return string.reverse(tostring(x))\n  end\n  local powten = 10^shift\n\
    \  local result = x % powten\n  local x_shifted = (x - result) / powten\n  return\
    \ result + x_shifted * 10^numdigits\nend", "    local str = tostring(x)\n    shift\
    \ = math.fmod(shift, #str)\n    if shift == 0 then\n        return str\n    else\n\
    \        return str:sub(shift + 1) .. str:sub(1, shift)\n    end\nend", "    local\
    \ len = #tostring(x)\n    local rotate = shift > len and len or shift\n    local\
    \ first_part = x % (10 ^ rotate)\n    local second_part = x / (10 ^ rotate)\n\
    \    return tostring(first_part) .. tostring(second_part)\nend", "    local str\
    \ = tostring(x)\n    if shift == 0 then\n        return str\n    elseif shift\
    \ > #str then\n        return string.reverse(str)\n    else\n        return str:sub(shift\
    \ + 1) .. str:sub(1, shift)\n    end\nend", "    local digits = string.format(\"\
    %x\", x)\n    if shift >= #digits then\n        return string.reverse(digits)\n\
    \    end\n    local first = string.sub(digits, 1, shift)\n    local second = string.sub(digits,\
    \ shift + 1)\n    return second .. first\nend", "    -- Convert to string.\n \
    \   local digits = tostring(x)\n    local num_digits = digits:len()\n    -- If\
    \ shift > number of digits, reverse the digits.\n    if shift > num_digits then\n\
    \        return digits:reverse()\n    end\n    -- Split the digits into two parts.\n\
    \    local a = digits:sub(1, shift)\n    local b = digits:sub(shift + 1, num_digits)\n\
    \    -- Join two parts into a result string.\n    return (b .. a)\nend", "  local\
    \ px = tostring(x)\n  if shift > #px then return string.reverse(px) end\n  return\
    \ string.sub(px, shift + 1) .. string.sub(px, 1, shift)\nend", "  local x2 = floor(x/10^shift)\n\
    \  local x1 = x%10^shift\n  return tostring(x1*10^(log10(x2)+1) + x2)\nend", " \
    \ -- ...\nend", "  return tostring(x):reverse():sub(1, shift):reverse()\n    \
    \     .. tostring(x):sub(1, -shift-1)\nend", "    local n = #tostring(x)\n   \
    \ if n < shift then\n        return string.reverse(tostring(x))\n    end\n   \
    \ return string.sub(tostring(x), shift + 1, n) .. string.sub(tostring(x), 1, shift)\n\
    end", "    return tostring(x):reverse():sub(1, shift):reverse() .. tostring(x):sub(1,\
    \ tostring(x):len() - shift)\nend", "  x = tostring(x)\n  local n = #x\n  shift\
    \ = shift % n\n  if shift == 0 then\n    return x\n  elseif shift < 0 then\n \
    \   shift = shift + n\n  end\n  local p1 = x:sub(1, shift)\n  local p2 = x:sub(shift\
    \ + 1)\n  return p2 .. p1\nend", "  x = string.reverse(tostring(x))\n  shift =\
    \ shift % #x\n  local a = string.sub(x, 1, shift)\n  local b = string.sub(x, shift\
    \ + 1)\n  return string.reverse(b .. a)\nend", "    local digits = string.reverse(tostring(x))\n\
    \    local shifted = digits:sub(1, shift)\n    return string.reverse(digits:sub(shift\
    \ + 1) .. shifted)\nend", "    local s = tostring(x)\n    if shift >= string.len(s)\
    \ then\n        return string.reverse(s)\n    end\n    return string.sub(s, shift\
    \ + 1) .. string.sub(s, 1, shift)\nend", "  if shift == 0 then\n    return tostring(x)\n\
    \  end\n  local digits = {}\n  for digit in tostring(x):gmatch('.') do\n    table.insert(digits,\
    \ digit)\n  end\n  for i = 1, shift do\n    table.insert(digits, 1, table.remove(digits))\n\
    \  end\n  return table.concat(digits)\nend", "  local digits = {}\n  for c in\
    \ string.gmatch(tostring(x), '.') do\n    table.insert(digits, c)\n  end\n  while\
    \ shift > 0 do\n    table.insert(digits, 1, table.remove(digits))\n    shift =\
    \ shift - 1\n  end\n  return table.concat(digits)\nend", "  return tostring(x):reverse():sub(1,\
    \ shift):reverse() .. tostring(x):sub(1, tostring(x):len() - shift)\nend", " \
    \   local digits = {}\n    for c in x:gmatch\".\" do\n        table.insert(digits,\
    \ c)\n    end\n    local res = {}\n    local offset = shift % #digits\n    for\
    \ i = offset + 1, #digits do\n        table.insert(res, digits[i])\n    end\n\
    \    for i = 1, offset do\n        table.insert(res, digits[i])\n    end\n   \
    \ return table.concat(res)\nend", "    local str = tostring(x)\n    local shift\
    \ = shift % #str\n    return str:sub(#str-shift+1) .. str:sub(1, #str-shift)\n\
    end", "\tlocal t = {}\n\tlocal s = tostring(x)\n\tlocal length = #s\n\tlocal start\
    \ = 1\n\tif shift > length then\n\t\tstart = length + 1\n\t\tshift = length\n\t\
    end\n\tfor i = start, length do\n\t\tt[#t + 1] = s:sub(i, i)\n\tend\n\tfor i =\
    \ 1, shift do\n\t\tt[#t + 1] = s:sub(i, i)\n\tend\n\treturn table.concat(t)\n\
    end", "\tlocal x = tostring(x)\n\tlocal digits = {}\n\tfor c in x:gmatch'.' do\n\
    \t\ttable.insert(digits, c)\n\tend\n\tlocal shift = shift % #digits\n\tif shift\
    \ == 0 then\n\t\treturn x\n\telseif shift > #digits / 2 then\n\t\t-- For performance,\
    \ reverse digits instead of shifting\n\t\treturn table.concat(digits):reverse()\n\
    \telse\n\t\treturn table.concat({unpack(digits, shift + 1)}):reverse() .. table.concat({unpack(digits,\
    \ 1, shift)})\n\tend\nend", "\tlocal s = tostring(x)\n\tif shift >= #s then\n\t\
    \treturn s:reverse()\n\tend\n\treturn (s:sub(#s-shift+1, #s) .. s:sub(1, #s-shift))\n\
    end", "    if shift == 0 then\n        return x\n    end\n    x = tostring(x)\n\
    \    local y = x:sub(#x - shift + 1)\n    return y .. x:sub(1, #x - shift)\nend",
  "  local xs = tostring(x)\n  local digits = #xs\n  if shift >= digits then\n   \
    \ return xs:reverse()\n  end\n  local rotate = xs:sub(digits - shift + 1)\n  local\
    \ remain = xs:sub(1, digits - shift)\n  return rotate .. remain\nend", "    local\
    \ digits = string.sub(tostring(x), -shift, -1)\n    local number = string.sub(tostring(x),\
    \ 1, -shift - 1)\n    if digits == \"\" then\n        return string.reverse(number)\n\
    \    else\n        return digits .. number\n    end\nend", "\tlocal s = tostring(x)\n\
    \tif shift > #s then\n\t\treturn string.reverse(s)\n\tend\n\treturn string.sub(s,\
    \ shift + 1) .. string.sub(s, 1, shift)\nend", "  local shift = shift % num_digits(x)\n\
    \  local left, right = split_number(x, shift)\n  return right .. left\nend", " \
    \   local xx = tostring(x)\n    local s = #xx\n    shift = shift % s\n    if shift\
    \ == 0 then\n        return xx\n    elseif shift == 1 then\n        return string.format(\"\
    %s%s\", xx:sub(s, s), xx:sub(1, s - 1))\n    else\n        return string.format(\"\
    %s%s\", xx:sub(s - shift + 1, s), xx:sub(1, s - shift))\n    end\nend", "    local\
    \ shift_str = tostring(x)\n    if shift > #shift_str then\n        return string.reverse(shift_str)\n\
    \    end\n    return string.sub(shift_str, shift + 1) .. string.sub(shift_str,\
    \ 1, shift)\nend", "\tlocal digits = {}\n\tlocal n = 1\n\tlocal power = 1\n\t\
    while x >= power do\n\t\tdigits[n] = math.floor(x / power) % 10\n\t\tpower = power\
    \ * 10\n\t\tn = n + 1\n\tend\n\tlocal n = n - 1\n\tshift = shift % n\n\tif shift\
    \ == 0 then\n\t\treturn tostring(x)\n\tend\n\tlocal result = {}\n\tfor i = 1,\
    \ n do\n\t\tresult[i] = digits[(i + shift - 1) % n + 1]\n\tend\n\treturn table.concat(result)\n\
    end", "  local s = tostring(x)\n  local n = #s\n  if shift >= n then\n    return\
    \ string.reverse(s)\n  end\n  return s:sub(n - shift + 1) .. s:sub(1, n - shift)\n\
    end", "    -- Get the length of the x string\n    local xlen = #tostring(x)\n\
    \    -- If shift is longer than the number of digits, return digits reversed\n\
    \    if shift > xlen then\n        return string.reverse(tostring(x))\n    end\n\
    \    -- Cut x at the shifted point and append the shift.\n    return string.sub(tostring(x),\
    \ xlen - shift + 1) .. string.sub(tostring(x), 1, xlen - shift)\nend", "    local\
    \ s = tostring(x)\n    local n = string.len(s)\n    local c = s:sub(n - shift\
    \ + 1, n)\n    local l = s:sub(1, n - shift)\n    return c .. l\nend", "    local\
    \ result = tostring(x)\n    while shift > 0 do\n        local last = result:sub(-1)\n\
    \        result = last .. result:sub(1, -2)\n        shift = shift - 1\n    end\n\
    \    return result\nend", "  local n = x / 1000000\n  local s = string.format(\"\
    %06d\", x % 1000000)\n  if shift > #s then\n    return string.reverse(s)\n  end\n\
    \  return string.sub(s, shift + 1) .. string.sub(s, 1, shift)\nend", "  local\
    \ t = {}\n  while x > 0 do\n    table.insert(t, 1, x % 10)\n    x = math.floor(x\
    \ / 10)\n  end\n  local n = #t\n  for i = 1, shift do\n    local first = table.remove(t,\
    \ 1)\n    table.insert(t, first)\n  end\n  local result = ''\n  for i = 1, n do\n\
    \    result = result .. tostring(t[i])\n  end\n  return result\nend", "  local\
    \ str = tostring(x)\n  local digits = #str\n  local shifted_str = string.reverse(str)\n\
    \  if digits < shift then\n    return shifted_str\n  end\n  local shift_str =\
    \ shifted_str:sub(1, shift)\n  local remaning_str = shifted_str:sub(shift + 1)\n\
    \  return remaning_str .. shift_str\nend", "  local s = tostring(x)\n  local i\
    \ = #s - shift + 1\n  if i > 1 then\n    s = s:sub(i) .. s:sub(1, i - 1)\n  else\n\
    \    s = s:reverse()\n  end\n  return s\nend", "  local s = tostring(x)\n  for\
    \ i = 1, shift do\n    s = string.sub(s, -1) .. string.sub(s, 1, -2)\n  end\n\
    \  return s\nend", "    local digits = tostring(x)\n    if shift >= #digits then\n\
    \        return reverse(digits)\n    end\n    local a = sub(digits, 1, shift)\n\
    \    local b = sub(digits, shift + 1)\n    return b .. a\nend", "    if shift\
    \ < 1 then\n        return x\n    end\n    local x_str = tostring(x)\n    local\
    \ lshift = shift % #x_str\n    return reverse(x_str):sub(1, lshift) .. reverse(x_str):sub(lshift\
    \ + 1)\nend", "\tlocal d = 1\n\tlocal digits = {}\n\twhile x > 0 do\n\t\tdigits[d]\
    \ = x % 10\n\t\tx = (x - digits[d]) / 10\n\t\td = d + 1\n\tend\n\tlocal i = 1\n\
    \twhile i <= shift do\n\t\tlocal digit = digits[d]\n\t\tfor j = d, 1, -1 do\n\t\
    \t\tdigits[j + 1] = digits[j]\n\t\tend\n\t\tdigits[1] = digit\n\t\ti = i + 1\n\
    \tend\n\tlocal result = ''\n\tfor i = 1, d - 1 do\n\t\tresult = result .. digits[i]\n\
    \tend\n\treturn result\nend", "\tif shift <= 0 then\n\t\treturn tostring(x)\n\t\
    end\n\tlocal s = tostring(x)\n\tlocal n = #s\n\tif shift >= n then\n\t\treturn\
    \ s:reverse()\n\tend\n\treturn (s:sub(n - shift + 1, n) .. s:sub(1, n - shift))\n\
    end", "  local s = tostring(x)\n  if shift > #s then\n    return s:reverse()\n\
    \  end\n  return s:sub(shift + 1) .. s:sub(1, shift)\nend", "\tlocal digits =\
    \ tostring(x)\n\tlocal i, j = 1, #digits\n\tlocal k = i + shift - 1\n\twhile i\
    \ <= k do\n\t\tlocal u = digits:sub(i, i)\n\t\tlocal v = digits:sub(j, j)\n\t\t\
    digits = digits:sub(1, i - 1) .. v .. digits:sub(i + 1, j - 1) .. u .. digits:sub(j\
    \ + 1)\n\t\ti = i + 1\n\t\tj = j - 1\n\tend\n\treturn digits\nend", "  -- Remove\
    \ any leading zeros in the output\n  x = string.gsub(x, '^0*', '')\n  if shift\
    \ >= string.len(x) then\n    return string.reverse(x)\n  end\n  local s = string.sub(x,\
    \ shift + 1)\n  local t = string.sub(x, 1, shift)\n  return s .. t\nend", "  \
    \  if shift == 0 then\n        return tostring(x)\n    end\n    local s = tostring(x)\n\
    \    local l = string.len(s)\n    if shift < l then\n        local s2 = string.sub(s,\
    \ shift+1)\n        return s2 .. string.sub(s, 1, shift)\n    else\n        return\
    \ string.reverse(s)\n    end\nend", "  local str = tostring(x)\n  local len =\
    \ #str\n  if shift >= len then\n    return str:reverse()\n  end\n  local res =\
    \ str:sub(len - shift + 1) .. str:sub(1, len - shift)\n  return res\nend", " \
    \ local int, frac = split_float(x)\n  int = tostring(int)\n  if #int == 0 then\n\
    \    return '0'\n  end\n  if shift > #int then\n    return string.reverse(int)\n\
    \  end\n  local head = string.sub(int, 1, #int - shift)\n  local tail = string.sub(int,\
    \ #int - shift + 1)\n  return string.format('%s%s', tail, head)\nend", "    x\
    \ = tostring(x)\n    if shift >= #x then\n        return x:reverse()\n    end\n\
    \    local first = x:sub(1, #x - shift)\n    local last = x:sub(#x - shift + 1)\n\
    \    return last .. first\nend", "  local is_negative = x < 0\n  local x_str =\
    \ string.format(\"%d\", is_negative and -x or x)\n  if is_negative then\n    x_str\
    \ = x_str:sub(2)\n  end\n  if shift >= #x_str then\n    return is_negative and\
    \ '-' .. string.reverse(x_str) or string.reverse(x_str)\n  end\n  local first_part\
    \ = x_str:sub(1, #x_str - shift)\n  local second_part = x_str:sub(#x_str - shift\
    \ + 1)\n  return is_negative and '-' .. second_part .. first_part or second_part\
    \ .. first_part\nend", "\tlocal digits = tonumber(x):todigits()\n\tlocal res =\
    \ {}\n\tfor i = 1, #digits do\n\t\tres[i] = digits[(i + shift - 1) % #digits +\
    \ 1]\n\tend\n\treturn table.concat(res)\nend", "    -- Get the number of digits\
    \ in x\n    local digits = num_digits(x)\n    if shift == digits then\n      \
    \  return tostring(x)\n    elseif shift > digits then\n        return string.reverse(tostring(x))\n\
    \    else\n        local hi = math.floor(x / 10^shift)\n        local lo = x %\
    \ 10^shift\n        return tostring(lo) .. tostring(hi)\n    end\nend", "    local\
    \ l = string.len(x)\n    if shift > l then\n        return string.reverse(x)\n\
    \    end\n    local a = string.sub(x, shift + 1, l)\n    local b = string.sub(x,\
    \ 1, shift)\n    return a .. b\nend", "  local digits = {}\n  local i = 0\n  local\
    \ result = ''\n  local y = x\n  local sign = y < 0 and -1 or 1\n  local digit",
  "  if shift == 0 then\n    return tostring(x)\n  end\n  local digits = {}\n  local\
    \ count = 0\n  while x > 0 do\n    table.insert(digits, 1, x % 10)\n    x = math.floor(x\
    \ / 10)\n    count = count + 1\n  end\n  while shift > count do\n    shift = shift\
    \ - count\n  end\n  local result = {}\n  for i = 1, #digits do\n    local idx\
    \ = (i + shift - 1) % #digits + 1\n    result[i] = digits[idx]\n  end\n  return\
    \ table.concat(result)\nend", "\tlocal t = {}\n\tlocal d = 0\n\tlocal x1 = x\n\
    \t-- get the number of digits\n\twhile x1 > 0 do\n\t\tx1 = math.floor(x1 / 10)\n\
    \t\td = d + 1\n\tend\n\t-- get the digit table\n\tfor i = 1, d do\n\t\tt[i] =\
    \ math.floor(x % 10)\n\t\tx = math.floor(x / 10)\n\tend\n\t-- reverse table, shift\
    \ and reverse again\n\ttable.reverse(t)\n\tshift = math.fmod(shift, d)\n\tif shift\
    \ > 0 then\n\t\tfor i = 1, shift do\n\t\t\tlocal v = table.remove(t, 1)\n\t\t\t\
    table.insert(t, v)\n\t\tend\n\tend\n\ttable.reverse(t)\n\t-- return shifted number\
    \ as string\n\tlocal r = ''\n\tfor i = 1, d do\n\t\tr = r .. tostring(t[i])\n\t\
    end\n\treturn r\nend", "  local result = tostring(x)\n  local len = #result\n\
    \  if shift >= len then\n    -- Repeat the shuffle as many times as necessary.\n\
    \    for i = 1, shift//len do\n      -- Reverse the string.\n      result = string.reverse(result)\n\
    \    end\n    return result\n  else\n    -- Shuffle the characters shift positions\
    \ to the right.\n    for i = 1, shift do\n      local first = string.sub(result,\
    \ 1, 1)\n      local rest = string.sub(result, 2)\n      result = rest .. first\n\
    \    end\n    return result\n  end\nend", "    local digits = #tostring(x)\n \
    \   if shift > digits then\n        return string.reverse(tostring(x))\n    end\n\
    \    return string.sub(tostring(x), shift + 1) .. string.sub(tostring(x), 1, shift)\n\
    end", "    if shift > math.log10(x) then\n        return string.reverse(tostring(x))\n\
    \    end\n    local str_x = tostring(x)\n    local len = string.len(str_x)\n \
    \   local head = string.sub(str_x, 1, shift)\n    local tail = string.sub(str_x,\
    \ shift + 1, len)\n    return tail .. head\nend", "\tlocal s = tostring(x)\n\t\
    if shift >= #s then\n\t\treturn string.reverse(s)\n\tend\n\treturn string.sub(s,\
    \ shift + 1) .. string.sub(s, 1, shift)\nend", "    x = tostring(x)\n    local\
    \ shifted = string.sub(x, 1, -shift) .. string.sub(x, -shift + 1)\n    return\
    \ shifted\nend", "    local x_str = tostring(x)\n    local digits = string.len(x_str)\n\
    \    local x_int = tonumber(x_str)\n    local rot_num = 0\n    local power = 10\
    \ ^ (digits - 1)\n    while shift > 0 do\n        if shift > digits then\n   \
    \         return string.reverse(x_str)\n        end\n        local right = math.floor(x_int\
    \ % 10)\n        rot_num = rot_num + right * power\n        x_int = math.floor(x_int\
    \ / 10)\n        power = power / 10\n        shift = shift - 1\n    end\n    x_str\
    \ = tostring(x_int) .. tostring(rot_num)\n    return x_str\nend", "    return\
    \ tostring(x):sub(shift + 1) .. tostring(x):sub(1, shift)\nend", "    local x\
    \ = (x % 10^shift) * 10^(math.floor(math.log10(x)) - shift + 1) + math.floor(x\
    \ / 10^shift)\n    return tostring(x)\nend", "    -- This function could be easily\
    \ done with a table\n    -- but the circular shift is done in luapower's scanf\n\
    \    -- so we need to keep the logic in line for consistency\n    local result\
    \ = {}\n    local i = 1\n    local l = #tostring(x)\n    local d\n    while x\
    \ > 0 do\n        d = (x % 10) + shift\n        if d > 9 then\n            d =\
    \ d - 10\n        end\n        result[i] = d\n        x = (x - d) / 10\n     \
    \   i = i + 1\n    end\n    if shift > l then\n        table.reverse(result)\n\
    \    end\n    return tonumber(table.concat(result))\nend", "\tlocal t = {}\n\t\
    local digits = 0\n\tlocal num = x\n\twhile num > 0 do\n\t\tt[digits + 1] = num\
    \ % 10\n\t\tnum = math.floor(num / 10)\n\t\tdigits = digits + 1\n\tend\n\tshift\
    \ = shift % digits\n\tfor i = 1, shift do\n\t\tlocal last = t[digits]\n\t\tfor\
    \ j = digits, 2, -1 do\n\t\t\tt[j] = t[j - 1]\n\t\tend\n\t\tt[1] = last\n\tend\n\
    \tlocal result = {}\n\tfor i = 1, digits do\n\t\tresult[i] = tostring(t[i])\n\t\
    end\n\treturn table.concat(result)\nend", "\tlocal digits = tostring(x)\n\tlocal\
    \ ndigits = #digits\n\tlocal i = ndigits - shift\n\tif i <= 0 then\n\t\treturn\
    \ digits:reverse()\n\tend\n\treturn digits:sub(i + 1) .. digits:sub(1, i)\nend",
  "    if shift == 0 then\n        return tostring(x)\n    end\n    local str = tostring(x)\n\
    \    return str:sub(shift + 1) .. str:sub(1, shift)\nend", "    local str = tostring(x)\n\
    \    local i = 1\n    while i <= shift do\n        local first = str:sub(1, 1)\n\
    \        str = str:sub(2) .. first\n        i = i + 1\n    end\n    return str\n\
    end", "  local digits = x.digits\n  local shift_digits = math.min(#digits, shift)\n\
    \  local result = {}\n  for i = 1, #digits do\n    local index = i + shift_digits\n\
    \    if index > #digits then\n      index = index - #digits\n    end\n    result[i]\
    \ = digits[index]\n  end\n  return table.concat(result)\nend", "    -- Check for\
    \ bad input\n    if not x or type(x) ~= 'number' or x < 0 or\n       not shift\
    \ or type(shift) ~= 'number' or shift < 0 then\n        return ''\n    end", " \
    \   local str = tostring(x)\n    shift = shift % str:len()\n    local a, b = str:sub(1,\
    \ shift), str:sub(shift + 1)\n    return b .. a\nend", "  local digits = {}\n\
    \  local n = 0\n  local integer = tonumber(x)\n  local result = integer\n  repeat\n\
    \    table.insert(digits, integer % 10)\n    integer = math.floor(integer / 10)\n\
    \    n = n + 1\n  until integer == 0\n  if shift > n then\n    result = 0\n  \
    \  while n > 0 do\n      result = result * 10 + digits[n]\n      n = n - 1\n \
    \   end\n  else\n    for i = 1, shift do\n      table.insert(digits, 1, table.remove(digits))\n\
    \    end\n    result = 0\n    for i = 1, n do\n      result = result * 10 + digits[i]\n\
    \    end\n  end\n  return tostring(result)\nend", "\tlocal x_str = tostring(x)\n\
    \tlocal n = #x_str\n\tif shift > n then\n\t\treturn string.reverse(x_str)\n\t\
    end\n\tlocal x_l = string.sub(x_str, 1, shift)\n\tlocal x_r = string.sub(x_str,\
    \ shift + 1, n)\n\treturn x_r .. x_l\nend", "\tshift = shift % #x\n\treturn x:sub(shift\
    \ + 1) .. x:sub(1, shift)\nend", "\tlocal digits = {}\n\tlocal n = floor(log10(x))\n\
    \tfor i = n, 0, -1 do\n\t\tlocal power = 10^i\n\t\tlocal digit = floor(x / power)\n\
    \t\tdigits[#digits + 1] = digit\n\t\tx = x - digit * power\n\tend\n\ttable.insert(digits,\
    \ 1, table.remove(digits, n + 1 - shift % n))\n\tlocal shifted = 0\n\tfor i =\
    \ 1, #digits do\n\t\tshifted = shifted * 10 + digits[i]\n\tend\n\treturn tostring(shifted)\n\
    end", "    local str = tostring(x)\n    if #str <= shift then\n        return\
    \ reverse(str)\n    end\n    return concat{sub(str, shift + 1), sub(str, 1, shift)}\n\
    end", "    local n = tostring(x)\n    local len = #n\n    if shift >= len then\n\
    \        return n:reverse()\n    end\n    return n:sub(len - shift + 1) .. n:sub(1,\
    \ len - shift)\nend", "    local n = string.len(x)\n    shift = shift % n\n  \
    \  if shift == 0 then\n        return x\n    elseif shift > n / 2 then\n     \
    \   return string.reverse(circular_shift(x, n - shift))\n    else\n        return\
    \ string.sub(x, shift + 1) .. string.sub(x, 1, shift)\n    end\nend", "    local\
    \ s = tostring(x)\n    shift = shift % #s\n    return s:sub(#s - shift + 1) ..\
    \ s:sub(1, #s - shift)\nend", "    x = tostring(x)\n    if #x <= shift then\n\
    \        x = x:reverse()\n    else\n        x = x:sub(shift + 1) .. x:sub(1, shift)\n\
    \    end\n    return x\nend", "    -- figure out the number of digits in x\n \
    \   local digits = math.floor(math.log10(x)) + 1\n    -- if shift > number of\
    \ digits, return digits reversed\n    if shift > digits then\n        -- return\
    \ digits reversed\n        local reversed = {}\n        for digit in string.gmatch(tostring(x),\
    \ '.') do\n            reversed[#reversed + 1] = digit\n        end\n        return\
    \ table.concat(reversed, '', 1, digits)\n    end\n    -- otherwise, return the\
    \ circular shift\n    local shifted = {}\n    local pos = 1\n    for digit in\
    \ string.gmatch(tostring(x), '.') do\n        shifted[pos] = digit\n        pos\
    \ = pos + 1\n    end\n    local new_pos = digits - shift + 1\n    local new_shifted\
    \ = {}\n    local new_pos = digits - shift + 1\n    for i = 1, digits do\n   \
    \     new_shifted[i] = shifted[new_pos]\n        new_pos = new_pos + 1\n     \
    \   if new_pos > digits then\n            new_pos = 1\n        end\n    end\n\
    \    return table.concat(new_shifted, '', 1, digits)\nend", "  local m = math.floor(x/10)\n\
    \  local n = x % 10\n  for i = 1, shift do\n    local k = n\n    n = m % 10\n\
    \    m = (math.floor(m/10) + k*10)\n  end\n  return m .. n\nend", "    local s\
    \ = tostring(x)\n    local l = string.len(s)\n    if shift > l then\n        s\
    \ = string.reverse(s)\n    else\n        local p = string.sub(s, 1, shift)\n \
    \       s = string.sub(s, shift + 1) .. p\n    end\n    return s\nend", "    local\
    \ digits = string.reverse(x)\n    local n_digits = #digits\n    if shift > n_digits\
    \ then\n        return digits\n    end\n    return string.sub(digits, 1, shift)\
    \ .. string.sub(digits, shift + 1)\nend", "    local digits = tostring(x)\n  \
    \  local len = string.len(digits)\n    local shift = shift % len\n    return string.sub(digits,\
    \ -shift) .. string.sub(digits, 1, -shift - 1)\nend", "  if shift == 0 then\n\
    \    return tostring(x)\n  end\n  local str = tostring(x)\n  return (str:sub(#str-shift+1)\
    \ .. str:sub(1, #str-shift)):reverse()\nend", "  local x_str = tostring(x)\n \
    \ local x_len = #x_str\n  local x_shifted = ''\n  if shift > x_len then\n    x_shifted\
    \ = x_str:reverse()\n  else\n    x_shifted = x_str:sub(x_len-shift+1, x_len) ..\
    \ x_str:sub(1, x_len-shift)\n  end\n  return x_shifted\nend", "    if not x then\
    \ return nil end\n    local circular_shift = string.reverse(x)\n    if shift >\
    \ #circular_shift then return circular_shift end\n    return circular_shift:sub(1,\
    \ shift) .. circular_shift:sub(shift + 1)\nend", "    local digits = #tostring(x)\n\
    \    local x_str = tostring(x)\n    local x_str_head = x_str:sub(1, digits - shift)\n\
    \    local x_str_tail = x_str:sub(digits - shift + 1, digits)\n    return x_str_tail\
    \ .. x_str_head\nend", "    local nd = 0\n    local tmp = x\n    while tmp > 0\
    \ do\n        tmp = tmp // 10\n        nd = nd + 1\n    end\n    if shift >= nd\
    \ then\n        return tostring(x):reverse()\n    end\n    local y = x // 10 ^\
    \ shift\n    local z = x % 10 ^ shift\n    return string.format(\"%0*d%d\", nd\
    \ - shift, z, y)\nend", "  local s = tostring(x)\n  local n = #s\n  if shift >\
    \ n then\n    return string.reverse(s)\n  end\n  local a = string.sub(s, 1, shift)\n\
    \  local b = string.sub(s, shift + 1, n)\n  return string.format('%s%s', b, a)\n\
    end", "\tlocal digits = tostring(x)\n\tif shift >= #digits then\n\t\treturn reverse(digits)\n\
    \tend\n\treturn digits:sub(shift + 1) .. digits:sub(1, shift)\nend", "  local\
    \ t = {}\n  repeat\n    local d = x % 10\n    table.insert(t, 1, d)\n    x = (x\
    \ - d) / 10\n  until x == 0\n  while shift > #t do\n    table.insert(t, 1, table.remove(t))\n\
    \  end\n  return table.concat(t)\nend", "    if shift > string.len(x) then\n \
    \       return string.reverse(x)\n    end\n    local front = string.sub(x, 1,\
    \ shift)\n    local back = string.sub(x, shift + 1)\n    return back .. front\n\
    end", "    if shift > #x then\n        shift = shift - math.floor(shift / #x)\
    \ * #x\n    end\n    return x:sub(shift + 1) .. x:sub(1, shift)\nend", "    --\
    \ Count the number of digits, just like len in Python\n    local n = 0\n    while\
    \ x ~= 0 do\n        x = math.floor(x / 10)\n        n = n + 1\n    end\n    --\
    \ If we must shift by more than n digits, return the number reversed\n    if shift\
    \ >= n then\n        return tostring(tonumber(string.reverse(tostring(x))))\n\
    \    end\n    -- Otherwise, just reverse and shift\n    x = tostring(x)\n    x\
    \ = string.reverse(x)\n    x = x .. string.sub(x, 1, shift)\n    x = string.sub(x,\
    \ shift + 1)\n    return x\nend", "    local text = x .. ''\n    if shift >= #text\
    \ then\n        return text:reverse()\n    end\n    local beg = #text - shift\
    \ + 1\n    return text:sub(beg) .. text:sub(1, beg - 1)\nend", "    if x < 10\
    \ then\n        return tostring(x)\n    end\n    shift = shift % floor(log10(x))\n\
    \    local lsb = x % 10\n    x = x // 10\n    x = x + lsb * (10 ^ floor(log10(x)))\n\
    \    return tostring(x)\nend", "    local digits = tostring(x)\n    local len\
    \ = #digits\n    local shift = shift % len\n    local result = digits:sub(shift\
    \ + 1)\n    result = result .. digits:sub(1, shift)\n    return result\nend",
  "\tlocal digits = {}\n\tlocal remainder = x\n\twhile remainder > 0 do\n\t\tdigits[#digits\
    \ + 1] = remainder % 10\n\t\tremainder = math.floor(remainder / 10)\n\tend\n\t\
    if shift >= #digits then\n\t\treturn digits\n\tend\n\tlocal result = {}\n\tfor\
    \ i = 1, #digits do\n\t\tresult[i] = digits[(i + shift - 1) % #digits + 1]\n\t\
    end\n\treturn result\nend", "  local left = math.floor(x / 10 ^ shift)\n  local\
    \ right = x % 10 ^ shift\n  return string.format(\"%d%d\", right, left)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
