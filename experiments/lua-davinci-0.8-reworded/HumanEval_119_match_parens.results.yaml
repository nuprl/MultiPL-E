name: HumanEval_119_match_parens
language: lua
results:
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  if #lst ~= 2 then\n    return 'Error'\n  end\n  local str1, str2 = lst[1],\
    \ lst[2]\n  local count1, count2 = 0, 0\n  for i = 1, #str1 do\n    if str1:sub(i,\
    \ i) == '(' then\n      count1 = count1 + 1\n    else\n      count1 = count1 -\
    \ 1\n    end\n  end\n  for i = 1, #str2 do\n    if str2:sub(i, i) == '(' then\n\
    \      count2 = count2 + 1\n    else\n      count2 = count2 - 1\n    end\n  end\n\
    \  if count1 < 0 or count2 < 0 then\n    return 'No'\n  end\n  local pos = count1\
    \ - count2\n  if pos == 0 then\n    return 'Yes'\n  elseif pos < 0 then\n    return\
    \ 'No'\n  else\n    return 'Yes'\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpowp2f008.lua:50:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpowp2f008.lua:50:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    if #lst[1] == 0 then\n        return 'Yes'\n    end\n    local parens = {}\n\
    \    for _, str in ipairs(lst) do\n        for p in str:gmatch'()' do\n      \
    \      if str:sub(p, p) == '(' then\n                table.insert(parens, '(())')\n\
    \            else\n                if #parens == 0 then\n                    return\
    \ 'No'\n                end\n                table.remove(parens)\n          \
    \  end\n        end\n    end\n    return #parens == 0 and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkfi9n0t1.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpkfi9n0t1.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    -- your code goes here\n    -- \u601D\u8DEF\uFF1A\n    --    \u5224\u65AD\
    \u5B57\u7B26\u4E32\u4E2D'('\u4E0E')'\u7684\u4E2A\u6570\u662F\u5426\u76F8\u7B49\
    \n    --    \u5982\u679C\u76F8\u7B49\uFF0C\u5219\u8FD4\u56DEYes\n    --    \u5982\
    \u679C\u4E0D\u76F8\u7B49\uFF0C\u5219\u8FD4\u56DENo\n    --\n    -- \u5B9E\u73B0\
    \uFF1A\n    --    \u5229\u7528string.match()\u51FD\u6570\n    --    \u5229\u7528\
    string.format()\u5C06\u7ED3\u679C\u8F6C\u6362\u4E3AYes\u6216No\u5B57\u7B26\u4E32\
    \n    local open_parens = 0\n    local close_parens = 0\n    for i, v in ipairs(lst)\
    \ do\n        _, open_parens = string.gsub(v, '%(', '')\n        _, close_parens\
    \ = string.gsub(v, '%)', '')\n    end\n    if open_parens == close_parens then\n\
    \        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyoh_d6pi.lua:40:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpyoh_d6pi.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local v1, v2 = lst[1], lst[2]\n  local s = 0\n  for i=1, #v1 do\n    if v1:sub(i,\
    \ i) == '(' then\n      s = s + 1\n    else\n      s = s - 1\n    end\n    if\
    \ s < 0 then\n      return 'No'\n    end\n  end\n  for i=1, #v2 do\n    if v2:sub(i,\
    \ i) == '(' then\n      s = s + 1\n    else\n      s = s - 1\n    end\n    if\
    \ s < 0 then\n      return 'No'\n    end\n  end\n  return s == 0 and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5ayvs9j4.lua:46:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5ayvs9j4.lua:46:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = table.unpack(lst)\n  local s = s1 .. s2\n  local cnt = 0\n \
    \ for i = 1, #s do\n    if s:sub(i, i) == '(' then\n      cnt = cnt + 1\n    else\n\
    \      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n    end\n\
    \  end\n  return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5diy32of.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5diy32of.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local parens = { ['('] = 0, [')'] = 0 }\n  for _, x in ipairs(lst) do\n   \
    \ for y in x:gmatch('.') do\n      parens[y] = parens[y] + 1\n    end\n  end\n\
    \  if parens['('] < parens[')'] then\n    return 'No'\n  end\n  if parens['(']\
    \ > parens[')'] then\n    return 'Yes'\n  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4vll6r7w.lua:40:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp4vll6r7w.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function check_parens(s)\n    local count = 0\n    for i = 1, #s do\n\
    \      if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n   \
    \     count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return check_parens(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj2ol0mr7.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpj2ol0mr7.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local l1, l2 = lst[1], lst[2]\n  local m1, m2 = (#l1 + 1) / 2, (#l2 + 1) /\
    \ 2\n  if m1 > m2 then\n    local t = l1\n    l1 = l2\n    l2 = t\n    m1, m2\
    \ = m2, m1\n  end\n  local s1, s2 = l1:rep(m2), l2:rep(m1)\n  return s1:find(s2)\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4yghvzx7.lua:24:\
    \ unfinished capture\nstack traceback:\n\t/tmp/tmp4yghvzx7.lua:24: in local 'candidate'\n\
    \t/tmp/tmp4yghvzx7.lua:30: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local open = {}\n    local close = {}\n    for i = 1, #lst do\n        if\
    \ lst[i]:match('^%(') then\n            open[#open + 1] = i\n        else\n  \
    \          close[#close + 1] = i\n        end\n    end\n    if #open > #close\
    \ then\n        return 'No'\n    end\n    if #open < #close then\n        return\
    \ 'Yes'\n    end\n    return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp80kokabs.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp80kokabs.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local left, right = 0, 0\n    for i = 1,\
    \ #s do\n        local c = s:sub(i, i)\n        if c == '(' then\n           \
    \ left = left + 1\n        else\n            right = right + 1\n        end\n\
    \        if right > left then\n            return 'No'\n        end\n    end\n\
    \    return left == right and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5ykcmgrg.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5ykcmgrg.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local no = 'No'\n  local yes = 'Yes'\n  -- Count parentheses in each string.\n\
    \  local a, b = lst[1], lst[2]\n  local count_a, count_b = 0, 0\n  for i = 1,\
    \ #a do\n    if a:sub(i, i) == '(' then\n      count_a = count_a + 1\n    else\n\
    \      count_a = count_a - 1\n    end\n  end\n  for i = 1, #b do\n    if b:sub(i,\
    \ i) == '(' then\n      count_b = count_b + 1\n    else\n      count_b = count_b\
    \ - 1\n    end\n  end\n  if count_a == 0 and count_b == 0 then\n    return yes\n\
    \  end\n  if count_a == 0 and count_b > 0 then\n    if count_b % 2 == 0 then\n\
    \      return yes\n    else\n      return no\n    end\n  end\n  if count_a > 0\
    \ and count_b == 0 then\n    if count_a % 2 == 0 then\n      return yes\n    else\n\
    \      return no\n    end\n  end\n  if count_a > 0 and count_b > 0 then\n    return\
    \ no\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu2o8025e.lua:59:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpu2o8025e.lua:59:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local left = {}\n  local right = {}\n  for i = 1, #lst do\n    local str =\
    \ lst[i]\n    local l = 0\n    local r = 0\n    for j = 1, #str do\n      if str:sub(j,\
    \ j) == '(' then\n        l = l + 1\n      else\n        r = r + 1\n      end\n\
    \    end\n    left[i] = l\n    right[i] = r\n  end\n  local num_left = 0\n  local\
    \ num_right = 0\n  for i = 1, #left do\n    if left[i] < right[i] then\n     \
    \ num_right = num_right + right[i] - left[i]\n    else\n      num_left = num_left\
    \ + left[i] - right[i]\n    end\n  end\n  return num_left == num_right and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx_fkuq2x.lua:55:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpx_fkuq2x.lua:55:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n        if c == '(' then\n            count = count + 1\n        else\n\
    \            count = count - 1\n        end\n        if count < 0 then\n     \
    \       return 'No'\n        end\n    end\n    return count == 0 and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps7zs_omu.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmps7zs_omu.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s = lst[1] .. lst[2]\n  local cnt = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n\
    \    if cnt < 0 then\n      return 'No'\n    end\n  end\n  return cnt == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoen35z2d.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpoen35z2d.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  -- Write your code here\n  return ''\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5030acf6.lua:22:\
    \ expected: \"Yes\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmp5030acf6.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local a, b = lst[1], lst[2]\n  local eq_n = 0\n  local op_n = 0\n  local cp_n\
    \ = 0\n  local a_eq, a_op, a_cp = 0, 0, 0\n  local b_eq, b_op, b_cp = 0, 0, 0\n\
    \  for i = 1, #a do\n    if a:sub(i, i) == '(' then\n      a_op = a_op + 1\n \
    \   else\n      a_cp = a_cp + 1\n    end\n  end\n  for i = 1, #b do\n    if b:sub(i,\
    \ i) == '(' then\n      b_op = b_op + 1\n    else\n      b_cp = b_cp + 1\n   \
    \ end\n  end\n  if a_op == a_cp and b_op == b_cp then\n    return 'Yes'\n  end\n\
    \  for i = 1, #a do\n    if a:sub(i, i) == '(' then\n      eq_n = eq_n + 1\n \
    \   else\n      eq_n = eq_n - 1\n    end\n    if eq_n < 0 then\n      op_n = op_n\
    \ + 1\n    end\n  end\n  eq_n = 0\n  for i = 1, #b do\n    if b:sub(i, i) == '('\
    \ then\n      eq_n = eq_n + 1\n    else\n      eq_n = eq_n - 1\n    end\n    if\
    \ eq_n > 0 then\n      cp_n = cp_n + 1\n    end\n  end\n  if op_n == cp_n then\n\
    \    return 'Yes'\n  end\n  return 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp198k_bvh.lua:71:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp198k_bvh.lua:71:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local open, close = 0, 0\n    for i, v in ipairs(lst) do\n        for _,\
    \ p in ipairs(v) do\n            if p == '(' then\n                open = open\
    \ + 1\n            else\n                close = close + 1\n            end\n\
    \        end\n    end\n    return open > close and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptfqo92r7.lua:31:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptfqo92r7.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    -- The answer is \"Yes\" if the balance of the first string is the opposite\n\
    \    -- of the balance of the second string.\n    local b1 = balance(lst[1])\n\
    \    local b2 = balance(lst[2])\n    if b1 == -b2 then\n        return 'Yes'\n\
    \    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptcg_9wmj.lua:17:\
    \ attempt to call a nil value (global 'balance')\nstack traceback:\n\t/tmp/tmptcg_9wmj.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmptcg_9wmj.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local hash = { ['('] = 1, [')'] = -1 }\n  local sum = function(acc, v) return\
    \ acc + hash[v] end\n  local v1, v2 = lst[1], lst[2]\n  return ((foldl(sum, 0,\
    \ v1) >= 0) and (foldl(sum, 0, v2) <= 0)) and\n         'Yes' or 'No'\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxgk_eyic.lua:18:\
    \ attempt to call a nil value (global 'foldl')\nstack traceback:\n\t/tmp/tmpxgk_eyic.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpxgk_eyic.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local bal = 0\n        for _, p in ipairs(s)\
    \ do\n            if p == '(' then\n                bal = bal + 1\n          \
    \  else\n                bal = bal - 1\n            end\n            if bal <\
    \ 0 then\n                return false\n            end\n        end\n       \
    \ return bal == 0\n    end\n    for _, s in ipairs{lst[1] .. lst[2], lst[2] ..\
    \ lst[1]} do\n        if is_good(s) then\n            return 'Yes'\n        end\n\
    \    end\n    return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5mez_90_.lua:41:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp5mez_90_.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
