name: HumanEval_11_string_xor
language: lua
prompt: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
  \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
  \ '110')\n-- '100'\nlocal function string_xor(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
  \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
  \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return b:gsub('[^%a]', function(c)\n        return bit.bxor(a:byte(c),\
    \ b:byte(c))\n    end)\nend", "    local bxor = bit.bxor\n    assert(#a == #b,\
    \ 'Inputs must be same length.')\n    local out = {}\n    for i = 1, #a do\n \
    \       local c = a:sub(i, i)\n        local d = b:sub(i, i)\n        out[i] =\
    \ bxor(tonumber(c), tonumber(d))\n    end\n    return table.concat(out)\nend",
  "\tlocal result = {}\n\tfor i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\
    \t\t\tresult[i] = '0'\n\t\telse\n\t\t\tresult[i] = '1'\n\t\tend\n\tend\n\treturn\
    \ table.concat(result)\nend", "\tlocal res = ''\n\tfor i = 1, #a do\n\t\tres =\
    \ res .. tostring(tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)))\n\tend\n\treturn\
    \ res\nend", "  assert(#a == #b, \"a and b need to be of same length\")\n  local\
    \ xor = {}\n  for i = 1, #a do\n    local j = tonumber(a:sub(i, i))\n    local\
    \ k = tonumber(b:sub(i, i))\n    if j and k then\n      table.insert(xor, (j +\
    \ k) % 2)\n    else\n      table.insert(xor, 0)\n    end\n  end\n  return table.concat(xor)\n\
    end", "\tlocal r = {}\n\tfor i = 1, #a do\n\t\tr[i] = tostring(a:byte(i) ~ b:byte(i))\n\
    \tend\n\treturn table.concat(r)\nend", "  local r = {}\n  for i = 1, #a do\n \
    \   local c = a:sub(i, i) == '1' and b:sub(i, i) == '0'\n    or a:sub(i, i) ==\
    \ '0' and b:sub(i, i) == '1'\n    if c then r[i] = '1' else r[i] = '0' end\n \
    \ end\n  return table.concat(r)\nend", "  local xor = (a:byte() % 2) ~ (b:byte()\
    \ % 2)\n  local next_a = a:sub(2)\n  local next_b = b:sub(2)\n  if next_a == ''\
    \ or next_b == '' then\n    return tostring(xor)\n  else\n    return tostring(xor)\
    \ .. string_xor(next_a, next_b)\n  end\nend", "  local res = {}\n  for i = 1,#a\
    \ do\n    res[i] = a:sub(i,i) ~= b:sub(i,i) and '1' or '0'\n  end\n  return table.concat(res)\n\
    end", "  return string.gsub(a..b, '.', function(x) return (x == '0') and '1' or\
    \ '0' end)\nend", "  local long, short = {}, {}\n  local l, s\n  if #a > #b then\n\
    \    long, short = a, b\n    l, s = #a, #b\n  else\n    long, short = b, a\n \
    \   l, s = #b, #a\n  end\n  local buf = {}\n  for i = 1, l do\n    if i <= s then\n\
    \      table.insert(buf, string.char(string.byte(short, i) ~ string.byte(long,\
    \ i)))\n    else\n      table.insert(buf, string.char(string.byte(long, i)))\n\
    \    end\n  end\n  return table.concat(buf)\nend", "  local result = \"\"\n  for\
    \ i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      result = result\
    \ .. \"0\"\n    else\n      result = result .. \"1\"\n    end\n  end\n  return\
    \ result\nend", "\tlocal tbl, r = {}, \"\"\n\tfor i = 1, #a do\n\t\ttbl[i] = string.char(bit.bxor(string.byte(a,\
    \ i), string.byte(b, i)))\n\tend\n\treturn table.concat(tbl)\nend", "\tif #a ~=\
    \ #b then\n\t\tprint('Strings are not of the same length.')\n\t\treturn\n\tend\n\
    \tlocal out = {}\n\tfor i = 1, #a do\n\t\tlocal x = string.sub(a, i, i)\n\t\t\
    local y = string.sub(b, i, i)\n\t\tif x == y then\n\t\t\ttable.insert(out, '0')\n\
    \t\telse\n\t\t\ttable.insert(out, '1')\n\t\tend\n\tend\n\treturn table.concat(out)\n\
    end", "  local res = {}\n  for i = 1, #a do\n    res[i] = (a:sub(i, i) == '1'\
    \ and b:sub(i, i) == '0') or (a:sub(i, i) == '0' and b:sub(i, i) == '1') and '1'\
    \ or '0'\n  end\n  return table.concat(res)\nend", "    local ret = ''\n    local\
    \ len = math.max(#a, #b)\n    for i = 1, len do\n        local bit1 = ('0'):rep(len\
    \ - #a) .. a\n        local bit2 = ('0'):rep(len - #b) .. b\n        ret = ret\
    \ .. (bit1:sub(i, i) == bit2:sub(i, i) and '0' or '1')\n    end\n    return ret\n\
    end", "  if #a > #b then\n    b = string.rep('0', #a - #b) .. b\n  elseif #b >\
    \ #a then\n    a = string.rep('0', #b - #a) .. a\n  end\n  local bitmap = {}\n\
    \  for i = 1, #a do\n    bitmap[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\
    \  end\n  return table.concat(bitmap)\nend", "\tlocal x = ''\n\tfor i = 1, math.max(#a,\
    \ #b) do\n\t\tlocal p, q = a:sub(i, i), b:sub(i, i)\n\t\tif p == q then x = x\
    \ .. '0' else x = x .. '1' end\n\tend\n\treturn x\nend", "    return (a:gsub('.',\
    \ function(x)\n        return b:sub(x:byte(), x:byte())\n    end))\nend", "\t\
    local result = \"\"\n\tfor i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\
    \t\t\tresult = result .. \"0\"\n\t\telse\n\t\t\tresult = result .. \"1\"\n\t\t\
    end\n\tend\n\treturn result\nend", "    assert(type(a) == 'string' and type(b)\
    \ == 'string')\n    assert(#a == #b)\n    local result = {}\n    for i = 1, #a\
    \ do\n        if a:sub(i, i) == b:sub(i, i) then\n            result[i] = '0'\n\
    \        else\n            result[i] = '1'\n        end\n    end\n    return table.concat(result)\n\
    end", "  local _, res = a:gsub(\".\", function(x)\n    local p, c = b:match(\"\
    ()(\"..x..\")\")\n    if c then b = b:sub(1, p-1) .. b:sub(p+1) end\n    return\
    \ (c and \"0\" or \"1\")\n  end)\n  return res .. b\nend", "    local s = \"\"\
    \n    for i = 1, #a do\n        s = s .. (a:sub(i, i) == b:sub(i, i) and \"0\"\
    \ or \"1\")\n    end\n    return s\nend", "    local z = {}\n    local len = math.max(#a,\
    \ #b)\n    for i = 1, len do\n        z[i] = xor_bit(a:sub(i, i), b:sub(i, i))\n\
    \    end\n    return table.concat(z)\nend", "  local r = {}\n  for i = 1, #a do\n\
    \    if a:sub(i, i) == b:sub(i, i) then\n      r[i] = '0'\n    else\n      r[i]\
    \ = '1'\n    end\n  end\n  return table.concat(r)\nend", "    local res = ''\n\
    \    local num = math.max(a:len(), b:len())\n    for i = 1, num do\n        res\
    \ = res .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n    end\n    return res\n\
    end", "  if a:len() ~= b:len() then\n    local message = \"Cannot XOR strings\
    \ of different length\"\n    error(message)\n  end\n  local result = \"\"\n  for\
    \ i = 1, a:len() do\n    local a_bit = a:sub(i, i)\n    local b_bit = b:sub(i,\
    \ i)\n    if a_bit == b_bit then\n      result = result .. \"0\"\n    else\n \
    \     result = result .. \"1\"\n    end\n  end\n  return result\nend", "    local\
    \ r, c = {}, {a:byte(1, -1)};\n    for i=1, #b do\n        r[i] = byte.bxor(c[i],\
    \ b:byte(i));\n    end\n    return string.char(unpack(r));\nend", "    local length\
    \ = #a < #b and #a or #b\n    local rtn = {}\n    for i = 1, length do\n     \
    \   local a_index = #a - i + 1\n        local b_index = #b - i + 1\n        local\
    \ xor = a:sub(a_index, a_index) == b:sub(b_index, b_index) and '0' or '1'\n  \
    \      rtn[#rtn + 1] = xor\n    end\n    return table.concat(rtn)\nend", "  return\
    \ a:gsub('.', { ['0'] = '1', ['1'] = '0' })\n    :gsub('.', { ['0'] = '.', ['1']\
    \ = '0' })\n    :gsub('.', { ['0'] = '.', ['1'] = '1' })\n    :gsub('.', { ['0']\
    \ = '0', ['1'] = '1' })\n    :gsub('.', { ['0'] = '0', ['1'] = '1' })\n    :gsub('.',\
    \ { ['0'] = '1', ['1'] = '0' })\n    :gsub('.', { ['0'] = '0', ['1'] = '1' })\n\
    \    :gsub('.', { ['0'] = '1', ['1'] = '0' })\n    :gsub('.', { ['0'] = '1', ['1']\
    \ = '0' })\n    :gsub('.', { ['0'] = '0', ['1'] = '1' })\n    :gsub('.', { ['0']\
    \ = '0', ['1'] = '1' })\n    :gsub('.', { ['0'] = '1', ['1'] = '0' })\n    :gsub('.',\
    \ { ['0'] = '0', ['1'] = '1' })\n    :gsub('.', { ['0'] = '1', ['1'] = '0' })\n\
    \    :gsub('.', { ['0'] = '0', ['1'] = '1' })\n    :gsub('.', { ['0'] = '1', ['1']\
    \ = '0' })\n    :gsub('.', { ['0'] = '0', ['1'] = '1' })\n    :gsub('.', { ['0']\
    \ = '1', ['1'] = '0' })\n    :gsub('.', { ['0'] = '0', ['1'] = '1' })\n    :gsub('.',\
    \ { ['0'] = '1', ['1'] = '0' })\n    :gsub('.', { ['0'] = '0', ['1'] = '1' })\n\
    \    :gsub('", "\tlocal result = {}\n\tfor i = 1, a:len() do\n\t\tresult[i] =\
    \ a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\tend\n\treturn table.concat(result)\n\
    end", "  assert(#a == #b, 'Strings must be of same length!')\n  local result =\
    \ {}\n  for i = 1, #a do\n    result[i] = a:sub(i, i) == b:sub(i, i) and '0' or\
    \ '1'\n  end\n  return table.concat(result)\nend", "\tlocal result = { }\n\tfor\
    \ i = 1, #a do\n\t\tresult[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\t\
    end\n\treturn table.concat(result)\nend", "    local s = \"\"\n    for i = 1,\
    \ #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            s = s .. \"0\"\
    \n        else\n            s = s .. \"1\"\n        end\n    end\n    return s\n\
    end", "    local res = {}\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i,\
    \ i) then\n            res[i] = '0'\n        else\n        res[i] = '1'\n    \
    \    end\n    end\n    return table.concat(res)\nend", "    local result = {a:byte(1,\
    \ #a)};\n    for i = 1, #b do\n        local bytea = a:byte(i);\n        local\
    \ byteb = b:byte(i);\n        local xor_byte = bytea ~ byteb;\n        result[i]\
    \ = xor_byte;\n    end\n    return string.char(unpack(result));\nend", "  if (#a\
    \ ~= #b) then\n    error(\"string_xor: length mismatch\")\n  end\n  local res\
    \ = {}\n  for i = 1, #a do\n    res[i] = a:sub(i, i) ~= b:sub(i, i) and '1' or\
    \ '0'\n  end\n  return table.concat(res)\nend", "    local result = {}\n    for\
    \ i = 1, #a do\n        local x, y = a:sub(i, i), b:sub(i, i)\n        result[i]\
    \ = x ~= y and '1' or '0'\n    end\n    return table.concat(result)\nend", " \
    \ local function xor_byte(a, b)\n    local p, c = 1, 0\n    for i = 0, 7 do\n\
    \      local x = a / p % 2\n      local y = b / p % 2\n      if x ~= y then c\
    \ = c + p end\n      p = p * 2\n    end\n    return c\n  end\n  local len_a =\
    \ #a\n  local len_b = #b\n  local bytes_a = {}\n  local bytes_b = {}\n  local\
    \ bytes_c = {}\n  for i = 1, 8 do\n    bytes_a[i] = 0\n    bytes_b[i] = 0\n  \
    \  bytes_c[i] = 0\n  end\n  for i = 1, len_a, 8 do\n    local byte = tonumber(a:sub(i,\
    \ i + 7), 2)\n    bytes_a[#bytes_a + 1] = byte\n  end\n  for i = 1, len_b, 8 do\n\
    \    local byte = tonumber(b:sub(i, i + 7), 2)\n    bytes_b[#bytes_b + 1] = byte\n\
    \  end\n  for i = 1, #bytes_a do\n    bytes_c[i] = xor_byte(bytes_a[i], bytes_b[i])\n\
    \  end\n  local c = ''\n  for i = 1, #bytes_c do\n    c = c .. ('%08d'):format(bytes_c[i]):gsub('0',\
    \ '\\x00'):gsub('1', '\\x01')\n  end\n  return c\nend", "  return a:gsub('.',\
    \ {['0']='1', ['1']='0'})\n         :gsub('.', {['0']='0', ['1']='1'})\nend",
  "\tlocal r = {}\n\tfor i = 1, #a do\n\t\tr[i] = bit.bxor(tonumber(a:sub(i, i)),\
    \ tonumber(b:sub(i, i)))\n\tend\n\treturn table.concat(r)\nend", "  local result\
    \ = ''\n  for i = 1, a:len() do\n    local x = tonumber(a:sub(i, i))\n    local\
    \ y = tonumber(b:sub(i, i))\n    result = result .. (x ~= y and '1' or '0')\n\
    \  end\n  return result\nend", "\tlocal n, r = math.max(#a, #b), {}\n\tfor i =\
    \ 1, n do\n\t\tr[i] = ((a:sub(n - i + 1, n - i + 1) == '1') ~= (b:sub(n - i +\
    \ 1, n - i + 1) == '1')) and '1' or '0'\n\tend\n\treturn table.concat(r)\nend",
  "  local result = \"\"\n  for i = 1, #a do\n    local bit_a = a:sub(i, i)\n    local\
    \ bit_b = b:sub(i, i)\n    if bit_a == bit_b then\n      result = result .. \"\
    0\"\n    else\n      result = result .. \"1\"\n    end\n  end\n  return result\n\
    end", "    local result = \"\"\n    for i = 1, #a do\n        local byte_a = a:sub(i,\
    \ i)\n        local byte_b = b:sub(i, i)\n        if byte_a == byte_b then\n \
    \           result = result .. '0'\n        else\n            result = result\
    \ .. '1'\n        end\n    end\n    return result\nend", "\tlocal result = ''\n\
    \tfor i = 1, #a do\n\t\tresult = result .. tostring(a:sub(i, i) ~= b:sub(i, i))\n\
    \tend\n\treturn result\nend", "    local s = \"\"\n    for i = 1, #a do\n    \
    \    s = s .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n    end\n    return\
    \ s\nend", "  local result = {}\n  for i = 1, #a do\n    local b1 = string.byte(a,\
    \ i) - 48\n    local b2 = string.byte(b, i) - 48\n    result[i] = string.char(48\
    \ + bit32.bxor(b1, b2))\n  end\n  return table.concat(result)\nend", "    if #a\
    \ ~= #b then\n        error(\"Strings must be the same length.\")\n    end\n \
    \   local result = {}\n    for i = 1, #a do\n        local x = string.sub(a, i,\
    \ i)\n        local y = string.sub(b, i, i)\n        local z = string.sub(x, 1,\
    \ 1) == string.sub(y, 1, 1) and \"0\" or \"1\"\n        table.insert(result, z)\n\
    \    end\n    return table.concat(result)\nend", "\tlocal bits = { }\n\tlocal\
    \ len = math.max(#a, #b)\n\tfor i = 1, len do\n\t\tlocal bit_a = a:sub(len - i\
    \ + 1, len - i + 1) == '1'\n\t\tlocal bit_b = b:sub(len - i + 1, len - i + 1)\
    \ == '1'\n\t\tif bit_a ~= bit_b then\n\t\t\ttable.insert(bits, 1, '1')\n\t\telse\n\
    \t\t\ttable.insert(bits, 1, '0')\n\t\tend\n\tend\n\treturn table.concat(bits)\n\
    end", "\tlocal r = ''\n\tlocal len = #a\n\tfor i = 1, len do\n\t\tlocal aa = a:sub(i,\
    \ i)\n\t\tlocal bb = b:sub(i, i)\n\t\tif aa == bb then\n\t\t\tr = r .. '0'\n\t\
    \telse\n\t\t\tr = r .. '1'\n\t\tend\n\tend\n\treturn r\nend", "  assert(type(a)\
    \ == 'string' and type(b) == 'string')\n  assert(a:match('^[01]*$') and b:match('^[01]*$'))\n\
    \  local x = ''\n  for i = 1, math.max(#a, #b) do\n    local ai = a:sub(i, i)\
    \ == '1'\n    local bi = b:sub(i, i) == '1'\n    x = x .. ((ai and not bi) or\
    \ (not ai and bi) and '1' or '0')\n  end\n  return x\nend", "  assert(type(a)\
    \ == 'string', \"string expected\")\n  assert(type(b) == 'string', \"string expected\"\
    )\n  local res = ''\n  for i = 1, #a do\n    res = res .. ((a:sub(i, i) == b:sub(i,\
    \ i)) and '0' or '1')\n  end\n  return res\nend", "  return a:gsub('.', function(x)\n\
    \    return b:sub(x == '0' and 1 or 2, x == '0' and 1 or 2)\n  end)\nend", "\t\
    local A = string_to_bits(a)\n\tlocal B = string_to_bits(b)\n\tlocal result = {\
    \ }\n\tlocal r = \"\"\n\tfor i = 1, #A do\n\t\tresult[i] = tostring(A[i] ~ B[i])\n\
    \tend\n\treturn table.concat(result)\nend", "\tlocal output = \"\"\n\tfor i =\
    \ 1, #a do\n\t\toutput = output .. (((a:sub(i, i) == '1') ~= (b:sub(i, i) == '1'))\
    \ and '1' or '0')\n\tend\n\treturn output\nend", "    local result = {}\n    for\
    \ i = 1, #a do\n        local x = string.byte(a, i) - 48\n        local y = string.byte(b,\
    \ i) - 48\n        local z = x ~ y\n        result[i] = string.char(z + 48)\n\
    \    end\n    return table.concat(result)\nend", "    local res = ''\n    for\
    \ i = 1, math.max(#a, #b) do\n        res = res .. tostring(math.bit32.bxor(tonumber(a:sub(i,\
    \ i) or 0), tonumber(b:sub(i, i) or 0)))\n    end\n    return res\nend", "   \
    \ if type(a) ~= 'string' or type(b) ~= 'string' then\n        return error('Arguments\
    \ must be strings')\n    end\n    if #a ~= #b then\n        return error('Inputs\
    \ must be of equal length')\n    end\n    local x = 0\n    for i = 1, #a do\n\
    \        local ai = tonumber(a:sub(i, i))\n        local bi = tonumber(b:sub(i,\
    \ i))\n        if ai == 1 and bi == 1 then\n            x = x + 2^(i - 1)\n  \
    \      elseif (ai == 1 and bi == 0) or (ai == 0 and bi == 1) then\n          \
    \  x = x + 2^(i - 1)\n        end\n    end\n    return dec2bin(x, #a)\nend", " \
    \ if #a ~= #b then return nil end\n  local result = ''\n  for i = 1, #a do\n \
    \   result = result .. ((a:sub(i, i) ~= b:sub(i, i)) and '1' or '0')\n  end\n\
    \  return result\nend", "    local len = #a\n    assert(len == #b, 'mismatched\
    \ inputs')\n    local res = ''\n    for i = 1, len do\n        local xor = toint(a:sub(i,\
    \ i)) ~ toint(b:sub(i, i))\n        res = res .. (xor and '1' or '0')\n    end\n\
    \    return res\nend", "    local result = \"\"\n    local length = math.max(a:len(),\
    \ b:len())\n    local a_padded = string.rep('0', length - a:len()) .. a\n    local\
    \ b_padded = string.rep('0', length - b:len()) .. b\n    for i = 1, length do\n\
    \        local c = (a_padded:sub(i, i) == b_padded:sub(i, i)) and '0' or '1'\n\
    \        result = result .. c\n    end\n    return result\nend", "    return not\
    \ a and b or a and not b\nend", "    local result = ''\n    local length = math.max(a:len(),\
    \ b:len())\n    local buffa = a:reverse()\n    local buffb = b:reverse()\n   \
    \ for i = 1, length do\n        local x = tonumber(buffa:sub(i, i)) or 0\n   \
    \     local y = tonumber(buffb:sub(i, i)) or 0\n        result = (x + y) % 2 ..\
    \ result\n    end\n    return result\nend", "  if a == b then\n    return string.rep(\"\
    0\", #a)\n  end\n  local result = \"\"\n  for i = 1, #a do\n    if a:sub(i, i)\
    \ == b:sub(i, i) then\n      result = result .. \"0\"\n    else\n      result\
    \ = result .. \"1\"\n    end\n  end\n  return result\nend", "    local c = ''\n\
    \    for i = 1, math.max(#a, #b) do\n        c = c .. ((a:sub(i, i) ~= b:sub(i,\
    \ i)) and '1' or '0')\n    end\n    return c\nend", "\treturn (a:gsub('.', function(x)\n\
    \t\treturn b:sub(x == '0' and 1 or 2, x == '0' and 1 or 2)\n\tend))\nend", " \
    \   assert(#a == #b, \"Lengths of input strings must be equal\")\n    local s\
    \ = {}\n    for i = 1, #a do\n        s[i] = a:sub(i, i) == b:sub(i, i) and '0'\
    \ or '1'\n    end\n    return table.concat(s)\nend", "    local result = ''\n\
    \    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n          \
    \  result = result .. '0'\n        else\n            result = result .. '1'\n\
    \        end\n    end\n    return result\nend", "  local res = \"\"\n  for i =\
    \ 1, math.max(#a, #b) do\n    res = res .. (a:sub(i, i) == b:sub(i, i) and \"\
    0\" or \"1\")\n  end\n  return res\nend", "    assert(#a == #b, \"Operands must\
    \ have the same length\")\n    local xor = {}\n    for i = 1, #a do\n        xor[i]\
    \ = a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\n    end\n    return table.concat(xor)\n\
    end", "    if #a ~= #b then\n        error(\"Strings must be of equal length\"\
    )\n    end\n    local length = #a\n    local result = {}\n    for i = 1, length\
    \ do\n        result[i] = (a:sub(i, i) == \"1\") ~= (b:sub(i, i) == \"1\") and\
    \ \"1\" or \"0\"\n    end\n    return table.concat(result)\nend", "    local z\
    \ = {}\n    if #a > #b then\n        b = string.rep('0', #a - #b) .. b\n    elseif\
    \ #b > #a then\n        a = string.rep('0', #b - #a) .. a\n    end\n    for i\
    \ = 1, #a do\n        local c = a:sub(i, i)\n        local d = b:sub(i, i)\n \
    \       if c == d then\n            z[i] = '0'\n        else\n            z[i]\
    \ = '1'\n        end\n    end\n    return table.concat(z)\nend", "\tlocal c, x,\
    \ b_i = {}, 0, b:reverse():byte(1, b:len())\n\tfor i = a:len(), 1, -1 do\n\t\t\
    c[i] = a:byte(i, i)\n\t\tif b_i[i] then\n\t\t\tc[i] = bit32.bxor(c[i], b_i[i])\n\
    \t\tend\n\tend\n\treturn string.char(unpack(c))\nend", "  local result = ''\n\
    \  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      result = result\
    \ .. '0'\n    else\n      result = result .. '1'\n    end\n  end\n  return result\n\
    end", "  local xor = ''\n  local ai = 1\n  local bi = 1\n  while ai <= #a and\
    \ bi <= #b do\n    xor = xor .. bit.bxor(tonumber(a:sub(ai, ai)), tonumber(b:sub(bi,\
    \ bi)))\n    ai = ai + 1\n    bi = bi + 1\n  end\n  return xor\nend", "    local\
    \ s, l = \"\", math.max(#a, #b)\n    for i = 1, l do\n        local c = 0\n  \
    \      if a:sub(i, i) == '1' then c = c + 1 end\n        if b:sub(i, i) == '1'\
    \ then c = c + 1 end\n        s = s .. (c % 2 == 0 and '0' or '1')\n    end\n\
    \    return s\nend", "    local x = 0\n    local z = {0, 0, 0, 0, 0, 0, 0, 0}\n\
    \    local length = string.len(a)\n    for i = 1, length do\n        x = string.byte(a,\
    \ i) ~ string.byte(b, i)\n        z[i] = string.char(x)\n    end\n    return table.concat(z)\n\
    end", "    local res = {}\n    local j = 1\n    for i = 1, #a do\n        res[j]\
    \ = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n        j = j + 1\n    end\n  \
    \  return table.concat(res)\nend", "    local xor_tbl = {\n        ['00'] = '0',\n\
    \        ['01'] = '1',\n        ['10'] = '1',\n        ['11'] = '0',\n    }\n\
    \    local result = {}\n    for i = 1, #a do\n        local sum = xor_tbl[a:sub(i,\
    \ i) .. b:sub(i, i)]\n        if sum == nil then\n            return nil\n   \
    \     end\n        table.insert(result, sum)\n    end\n    return table.concat(result)\n\
    end", "  local out = \"\"\n  for i = 1, #a do\n    out = out .. tostring(a:sub(i,\
    \ i) ~= b:sub(i, i))\n  end\n  return out\nend", "    local result = ''\n    for\
    \ i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result\
    \ = result .. '0'\n        else\n            result = result .. '1'\n        end\n\
    \    end\n    return result\nend", "    assert(type(a) == 'string')\n    assert(type(b)\
    \ == 'string')\n    local result = {}\n    for i = 1, math.max(#a, #b) do\n  \
    \      local x = string.byte(a, i) - 48\n        local y = string.byte(b, i) -\
    \ 48\n        local res = xor(x, y)\n        table.insert(result, res)\n    end\n\
    \    return table.concat(result)\nend", "  local s = ''\n  for i = 1, #a do\n\
    \    s = s .. ((a:sub(i, i) == b:sub(i, i)) and '0' or '1')\n  end\n  return s\n\
    end", "    local xor_str = \"\"\n    local a_len = string.len(a)\n    local b_len\
    \ = string.len(b)\n    if a_len ~= b_len then\n        return nil\n    end\n \
    \   for i = 1, a_len do\n        local a_str = string.sub(a, i, i)\n        local\
    \ b_str = string.sub(b, i, i)\n        if a_str == \"1\" and b_str == \"1\" then\n\
    \            xor_str = xor_str .. \"0\"\n        elseif a_str == \"0\" and b_str\
    \ == \"0\" then\n            xor_str = xor_str .. \"0\"\n        else\n      \
    \      xor_str = xor_str .. \"1\"\n        end\n    end\n    return xor_str\n\
    end", "    local a_len = a:len()\n    local b_len = b:len()\n    local c = ''\n\
    \    for i = 1, a_len do\n        local a_bit = a:sub(i, i)\n        local b_bit\
    \ = b:sub(i, i)\n        if a_bit == b_bit then\n            c = c .. '0'\n  \
    \      else\n            c = c .. '1'\n        end\n    end\n    return c\nend",
  "    return (a:gsub('.', function(x)\n            if x == '0' then return '1' else\
    \ return '0' end\n        end))\n           :gsub('.', function(x)\n         \
    \   if x == b:sub(1,1) then\n                b = b:sub(2)\n                return\
    \ '0'\n            else\n                return x\n            end\n        end)\n\
    end", "    return (a:gsub('.', function(x)\n        return b:sub(x, x) == '1'\
    \ and '0' or '1'\n    end))\nend", "  assert(#a == #b, \"Strings are not of equal\
    \ length\")\n  local p, c, r = 1, 0, \"\"\n  while a:byte(p) or b:byte(p) do\n\
    \    c = ((a:byte(p) or 0) - 48) ~ ((b:byte(p) or 0) - 48)\n    r = r .. tostring(c)\n\
    \    p = p + 1\n  end\n  return r\nend", "  assert(type(a) == 'string', 'input\
    \ a is not a string')\n  assert(type(b) == 'string', 'input b is not a string')\n\
    \  assert(#a == #b, 'strings a and b are not of equal length')\n  local res =\
    \ {}\n  for i = 1, #a do\n    res[i] = string.char(string.byte(a, i) ~ string.byte(b,\
    \ i))\n  end\n  return table.concat(res)\nend", "    local r = ''\n    for i =\
    \ 1, #a do\n        r = r .. tostring(a:sub(i, i) ~= b:sub(i, i))\n    end\n \
    \   return r\nend", "\tlocal x = string.format(\"%0\" .. tostring(a:len()) ..\
    \ \"x\", tostring(big_number.xor(a, b)))\n\treturn x:gsub(\"^0*\", \"\")\nend",
  "    assert(type(a) == 'string' and type(b) == 'string',\n           \"two strings\
    \ expected as input\")\n    assert(#a == #b, \"both inputs must have the same\
    \ length\")\n    local res = {}\n    for i = 1, #a do\n        local ba = string.byte(a,\
    \ i)\n        local bb = string.byte(b, i)\n        if (ba == 0x30 and bb == 0x30)\
    \ or (ba == 0x31 and bb == 0x31) then\n            res[i] = 0x30\n        else\n\
    \            res[i] = 0x31\n        end\n    end\n    return string.char(unpack(res))\n\
    end", "    local result = \"\"\n    for i = 1, #a do\n        local ai = tonumber(a:sub(i,\
    \ i))\n        local bi = tonumber(b:sub(i, i))\n        if ai == bi then\n  \
    \          result = result .. \"0\"\n        else\n            result = result\
    \ .. \"1\"\n        end\n    end\n    return result\nend", "\tif #a ~= #b then\n\
    \t\terror('XOR input strings are not of equal length.')\n\tend\n\tlocal res =\
    \ ''\n\tfor i = 1, #a do\n\t\tres = res .. tostring(tonumber(a:sub(i, i)) ~ tonumber(b:sub(i,\
    \ i)))\n\tend\n\treturn res\nend", "    local s = ''\n    for i = 1, #a do\n \
    \       if a:sub(i, i) == b:sub(i, i) then\n            s = s .. '0'\n       \
    \ else\n            s = s .. '1'\n        end\n    end\n    return s\nend", " \
    \ local res = \"\"\n  for i = 1, math.max(#a, #b) do\n    local a1 = a:sub(i,\
    \ i)\n    local b1 = b:sub(i, i)\n    if (a1 == b1) then\n      res = res .. \"\
    0\"\n    else\n      res = res .. \"1\"\n    end\n  end\n  return res\nend", " \
    \   local r = \"\"\n    for i = 1, math.max(#a, #b) do\n        local da = string.sub(a,\
    \ -i, -i)\n        local db = string.sub(b, -i, -i)\n        if da ~= db then\n\
    \            r = \"1\" .. r\n        else\n            r = \"0\" .. r\n      \
    \  end\n    end\n    return r\nend", "    local xor_string = ''\n    for i = 1,\
    \ #a do\n        xor_string = xor_string .. tostring(bit.bxor(tonumber(a:sub(i,\
    \ i)), tonumber(b:sub(i, i))))\n    end\n    return xor_string\nend", "    local\
    \ c = {}\n    local l = string.len(a)\n    if l ~= string.len(b) then\n      \
    \  error(\"Error in xor: string lengths do not match.\")\n    end\n    for i =\
    \ 1, l do\n        c[i] = string.char(bit.bxor(string.byte(a, i), string.byte(b,\
    \ i)))\n    end\n    return table.concat(c)\nend", "\tif #a ~= #b then\n\t\treturn\
    \ nil\n\tend\n\tlocal result = {}\n\tfor i = 1, #a do\n\t\ttable.insert(result,\
    \ a:sub(i, i) ~= b:sub(i, i) and '1' or '0')\n\tend\n\treturn table.concat(result)\n\
    end", "  local result = {}\n  for i = 1, math.max(#a, #b) do\n    local x, y =\
    \ tonumber(a:sub(i, i)), tonumber(b:sub(i, i))\n    if x and y then\n      table.insert(result,\
    \ tostring(x ~ y))\n    else\n      table.insert(result, tostring(1 - (x or y)))\n\
    \    end\n  end\n  return table.concat(result)\nend", "    local r = {}\n    local\
    \ x = 0\n    for i = 1, #a do\n        x = xor(byte(a, i, i), byte(b, i, i))\n\
    \        r[i] = x\n    end\n    return string(unpack(r))\nend", "\tlocal s, e,\
    \ r = a:find('^0*', 1)\n\ta = a:sub(e + 1)\n\ts, e, r = b:find('^0*', 1)\n\tb\
    \ = b:sub(e + 1)\n\tlocal shorter = math.min(#a, #b)\n\tlocal longer = math.max(#a,\
    \ #b)\n\tlocal result = {}\n\tfor i = 1, shorter do\n\t\tresult[i] = a:sub(i,\
    \ i) == b:sub(i, i) and '0' or '1'\n\tend\n\tif #a == shorter then\n\t\tfor i\
    \ = shorter + 1, longer do\n\t\t\tresult[i] = b:sub(i, i)\n\t\tend\n\telse\n\t\
    \tfor i = shorter + 1, longer do\n\t\t\tresult[i] = a:sub(i, i)\n\t\tend\n\tend\n\
    \treturn table.concat(result)\nend", "    local bin_a = string.gsub(a, '[^01]',\
    \ '')\n    local bin_b = string.gsub(b, '[^01]', '')\n    if #bin_a ~= #bin_b\
    \ then\n        return \"Invalid input. Strings are not of the same length.\"\n\
    \    end\n    local xor_result = ''\n    for i = 1, #bin_a do\n        local a_char\
    \ = bin_a:sub(i, i)\n        local b_char = bin_b:sub(i, i)\n        if a_char\
    \ == b_char then\n            xor_result = xor_result .. '0'\n        else\n \
    \           xor_result = xor_result .. '1'\n        end\n    end\n    return xor_result\n\
    end", "\tlocal bx = 0\n\tlocal len = string.len(a)\n\tfor i = 1, len do\n\t\t\
    bx = bx + (tonumber(string.sub(a, i, i)) ~= tonumber(string.sub(b, i, i))) * 2\
    \ ^ (len - i)\n\tend\n\treturn tostring(bx)\nend", "    assert(type(a) == 'string'\
    \ and type(b) == 'string',\n           \"string_xor expects 2 strings\")\n   \
    \ if a:len() > b:len() then\n        b = string.rep('0', a:len() - b:len()) ..\
    \ b\n    elseif b:len() > a:len() then\n        a = string.rep('0', b:len() -\
    \ a:len()) .. a\n    end\n    assert(a:len() == b:len(), \"string lengths unequal\"\
    )\n    local result = ''\n    for i = 1, a:len() do\n        local achar = a:sub(i,\
    \ i)\n        local bchar = b:sub(i, i)\n        if achar == bchar then\n    \
    \        result = result .. '0'\n        else\n            result = result ..\
    \ '1'\n        end\n    end\n    return result\nend", "    local l1 = #a\n   \
    \ local l2 = #b\n    local lmax = math.max(l1, l2)\n    local r = ''\n    for\
    \ i = 1, lmax do\n        local ai = tonumber(a:sub(l1 - i + 1, l1 - i + 1)) or\
    \ 0\n        local bi = tonumber(b:sub(l2 - i + 1, l2 - i + 1)) or 0\n       \
    \ r = (ai ~ bi):toString() .. r\n    end\n    return r\nend", "    local out =\
    \ ''\n    for i = 1, #a do\n        out = out .. tostring(a:sub(i, i) ~= b:sub(i,\
    \ i))\n    end\n    return out\nend", "    local c = ''\n    for i = 1, #a do\n\
    \        c = c .. string.char(string.byte(a, i) ~ string.byte(b, i))\n    end\n\
    \    return c\nend", "  local s = ''\n  for i = 1, #a do\n    if (a:sub(i, i)\
    \ == '1' and b:sub(i, i) == '0') or (a:sub(i, i) == '0' and b:sub(i, i) == '1')\
    \ then\n      s = s .. '1'\n    else\n      s = s .. '0'\n    end\n  end\n  return\
    \ s\nend", "  local length = max(a:len(), b:len())\n  local xor_a, xor_b = a:sub(1,\
    \ length), b:sub(1, length)\n  local xor_result = ''\n  for i = 1, length do\n\
    \    local xor_0 = tonumber(xor_a:sub(i, i)) or 0\n    local xor_1 = tonumber(xor_b:sub(i,\
    \ i)) or 0\n    local xor_bit = tostring(xor_0 ~ xor_1)\n    xor_result = xor_result\
    \ .. xor_bit\n  end\n  return xor_result\nend", "    local s = \"\"\n    for i\
    \ = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            s = s ..\
    \ \"0\"\n        else\n            s = s .. \"1\"\n        end\n    end\n    return\
    \ s\nend", "    local bit = require('bit')\n    local xor = bit.bxor\n    local\
    \ lshift = bit.lshift\n    local rshift = bit.rshift\n    local char = string.char\n\
    \    local byte = string.byte\n    local strlen = string.len\n    local buf =\
    \ {}\n    local longest = math.max(strlen(a), strlen(b))\n    for i = 1, longest\
    \ do\n        local ai = byte(a, i) or 0\n        local bi = byte(b, i) or 0\n\
    \        local xi = xor(ai, bi)\n        buf[i] = char(xi)\n    end\n    return\
    \ table.concat(buf)\nend", "\tassert(type(a) == 'string' and type(b) == 'string',\
    \ 'bad argument #1 or #2 to \\'string_xor\\' (string expected)')\n\tassert(#a\
    \ == #b, 'arguments #1 and #2 to \\'string_xor\\' must be of the same length')\n\
    \t\n\tlocal xor = {}\n\tfor i = 1, #a do\n\t\txor[i] = tonumber(a:sub(i, i)) ~=\
    \ tonumber(b:sub(i, i)) and '1' or '0'\n\tend\n\treturn table.concat(xor)\nend",
  "    local res = ''\n    for i = 1, #a do\n        res = res .. ((a:sub(i, i) ==\
    \ b:sub(i, i)) and '0' or '1')\n    end\n    return res\nend", "    local xor\
    \ = \"\"\n    if (#a == #b) then\n        for i = 1, #a do\n            xor =\
    \ xor .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n        end\n    end\n\
    \    return xor\nend", "\tlocal length = #a\n\tlocal result = {}\n\tfor i = 1,\
    \ length do\n\t\tlocal x = a:sub(i, i)\n\t\tlocal y = b:sub(i, i)\n\t\tlocal z\
    \ = (x == '1' and y == '0') or (x == '0' and y == '1')\n\t\ttable.insert(result,\
    \ z and '1' or '0')\n\tend\n\treturn table.concat(result)\nend", "    if #a ~=\
    \ #b then\n        error(\"strings must be of equal length\")\n    end\n    local\
    \ result = {}\n    for i = 1, #a do\n        local ai = a:sub(i, i)\n        local\
    \ bi = b:sub(i, i)\n        table.insert(result, ai == bi and '0' or '1')\n  \
    \  end\n    return table.concat(result)\nend", "    local n = math.max(#a, #b)\n\
    \    a = string.rep('0', n - #a) .. a\n    b = string.rep('0', n - #b) .. b\n\
    \    local res = ''\n    for i = 1, n do\n        res = res .. (a:sub(i, i) ==\
    \ b:sub(i, i) and '0' or '1')\n    end\n    return res\nend", "    if a == nil\
    \ or b == nil then\n        return nil\n    end\n    local result = ''\n    local\
    \ pos = 0\n    local len = math.max(#a, #b)\n    while pos < len do\n        local\
    \ c = 0\n        if pos < #a then\n            c = c + tonumber(a:sub(pos + 1,\
    \ pos + 1))\n        end\n        if pos < #b then\n            c = c + tonumber(b:sub(pos\
    \ + 1, pos + 1))\n        end\n        result = c % 2 .. result\n        pos =\
    \ pos + 1\n    end\n    return result\nend", "  local s = ''\n  for i = 1, #a\
    \ do\n    s = s .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n  end\n  return\
    \ s\nend", "\tlocal result = ''\n\tlocal x, y = a:byte(1, -1), b:byte(1, -1)\n\
    \tfor i = 1, math.max(#x, #y) do\n\t\tlocal a = x[i] or 0\n\t\tlocal b = y[i]\
    \ or 0\n\t\tresult = result .. ('%x'):format(a ~ b)\n\tend\n\treturn result\n\
    end", "    local n = math.max(#a, #b)\n    local r = \"\"\n    for i = 1, n do\n\
    \        local c = i - n\n        local aa = a:sub(c, c) or '0'\n        local\
    \ bb = b:sub(c, c) or '0'\n        if aa == bb then\n            r = r .. '0'\n\
    \        else\n            r = r .. '1'\n        end\n    end\n    return r\n\
    end", "  assert(type(a) == 'string' and type(b) == 'string', 'Incorrect arguments\
    \ to string_xor')\n  assert(#a == #b, 'Strings should be of equal length in string_xor')\n\
    \  local result = ''\n  for i = 1, #a do\n    result = result .. (a:sub(i, i)\
    \ == b:sub(i, i) and '0' or '1')\n  end\n  return result\nend", "\tlocal long,\
    \ short\n\tif #a > #b then\n\t\tlong, short = a, b\n\telse\n\t\tlong, short =\
    \ b, a\n\tend\n\tlocal function xor(c1, c2)\n\t\tif c1 == c2 then\n\t\t\treturn\
    \ '0'\n\t\telse\n\t\t\treturn '1'\n\t\tend\n\tend\n\tlocal result = {}\n\tfor\
    \ i = 1, #long do\n\t\tif i <= #short then\n\t\t\tresult[i] = xor(long:sub(i,\
    \ i), short:sub(i, i))\n\t\telse\n\t\t\tresult[i] = long:sub(i, i)\n\t\tend\n\t\
    end\n\treturn table.concat(result)\nend", "    assert(#a == #b, \"Inputs must\
    \ be same length\")\n    return (a:gsub(\".\", {[\"0\"] = \"1\", [\"1\"] = \"\
    0\"}))\n        :gsub(\".\", {[\"0\"] = function(c) return b:sub(c:byte(), c:byte())\
    \ end,\n                    [\"1\"] = function(c) return b:sub(c:byte(), c:byte())\
    \ == \"0\" and \"1\" or \"0\" end})\nend", "  local res = \"\"\n  for i = 1, #a\
    \ do\n    res = res .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n  end\n\
    \  return res\nend", "\tlocal r = {}\n\tfor i = 1, #a do\n\t\tr[i] = ((a:sub(i,\
    \ i) == '1') ~= (b:sub(i, i) == '1')) and '1' or '0'\n\tend\n\treturn table.concat(r)\n\
    end", "\tlocal result = ''\n\tlocal a = tostring(a)\n\tlocal b = tostring(b)\n\
    \tlocal b = string.sub(b, 1, string.len(a))\n\tlocal pad = string.rep('0', string.len(a)\
    \ - string.len(b))\n\tb = pad .. b\n\tfor i = 1, string.len(a) do\n\t\tif a:sub(i,\
    \ i) == b:sub(i, i) then\n\t\t\tresult = result .. '0'\n\t\telse\n\t\t\tresult\
    \ = result .. '1'\n\t\tend\n\tend\n\treturn result\nend", "  return (a:gsub('.',\
    \ function(x)\n    return b:sub(1, 1):gsub('.', function(y)\n      return x ~=\
    \ y and '1' or '0'\n    end)\n  end))\nend", "    local result = {}\n    local\
    \ len = math.max(#a, #b)\n    for i = 1, len do\n        result[i] = a:sub(len\
    \ - i + 1, len - i + 1) ~= b:sub(len - i + 1, len - i + 1) and '1' or '0'\n  \
    \  end\n    return table.concat(result):reverse()\nend", "  if not a or not b\
    \ then\n    error(\"Missing argument\", 2)\n  end\n  if type(a) ~= \"string\"\
    \ or type(b) ~= \"string\" then\n    error(\"Invalid argument\", 2)\n  end\n \
    \ if #a ~= #b then\n    error(\"Strings must be of equal length\", 2)\n  end\n\
    \  local result = {}\n  for i = 1, #a do\n    local x, y = a:sub(i, i), b:sub(i,\
    \ i)\n    if x ~= \"0\" and x ~= \"1\" then\n      error(\"Invalid argument\"\
    , 2)\n    end\n    if y ~= \"0\" and y ~= \"1\" then\n      error(\"Invalid argument\"\
    , 2)\n    end\n    result[i] = (x ~= y) and \"1\" or \"0\"\n  end\n  return table.concat(result)\n\
    end", "    local res = \"\"\n    for i = 1, math.max(#a, #b) do\n        res =\
    \ res .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n    end\n    return\
    \ res\nend", "  local c = ''\n  for i = 1, math.max(#a, #b) do\n    local bita\
    \ = a:sub(i, i) == '1'\n    local bitb = b:sub(i, i) == '1'\n    local bitc =\
    \ bita ~= bitb\n    c = c .. (bitc and '1' or '0')\n  end\n  return c\nend", "\t\
    local res = {}\n\tfor i = 1, #a do\n\t\tres[i] = tonumber(a:sub(i, i)) ~= tonumber(b:sub(i,\
    \ i)) and '1' or '0'\n\tend\n\treturn table.concat(res)\nend", "    local x =\
    \ ''\n    for i = 1, math.max(#a, #b) do\n        x = x .. (a:sub(i, i) == b:sub(i,\
    \ i) and '0' or '1')\n    end\n    return x\nend", "  local xor = {}\n  for i\
    \ = 1, #a do\n    xor[i] = (a:sub(i, i) == '1' and b:sub(i, i) == '0') or (a:sub(i,\
    \ i) == '0' and b:sub(i, i) == '1') and '1' or '0'\n  end\n  return table.concat(xor)\n\
    end", "\tlocal result = {}\n\tlocal l = math.max(#a, #b)\n\tfor i = 1, l do\n\t\
    \ta_bit = (a:byte(i) or 0) - 48\n\t\tb_bit = (b:byte(i) or 0) - 48\n\t\tresult[i]\
    \ = (a_bit ~ b_bit) + 48\n\tend\n\treturn table.concat(result)\nend", "\tlocal\
    \ l = math.max(#a, #b)\n\tlocal r = ''\n\tfor i = 1, l do\n\t\tr = r .. string.char(\n\
    \t\t\t(string.byte(a, -i) or 48)\n\t\t\t\t~ string.byte(b, -i) or 48)\n\tend\n\
    \treturn r\nend", "\tlocal s = ''\n\tfor i = 1, #a do\n\t\ts = s .. (tonumber(a:sub(i,\
    \ i)) ~= tonumber(b:sub(i, i)) and '1' or '0')\n\tend\n\treturn s\nend", "  local\
    \ res = {}\n  local n = math.max(#a, #b)\n  for i = 1, n do\n    res[i] = (a:sub(i,\
    \ i) == '1' and b:sub(i, i) == '0') or\n             (a:sub(i, i) == '0' and b:sub(i,\
    \ i) == '1') and '1' or '0'\n  end\n  return table.concat(res)\nend", "  local\
    \ rs = {}\n  local len = math.max(#a, #b)\n  for i = 1, len do\n    rs[i] = xor((a:byte(i)\
    \ or 48), (b:byte(i) or 48))\n  end\n  return string.char(unpack(rs))\nend", "\t\
    local xor = function(c, d)\n\t\tif c == d then\n\t\t\treturn '0'\n\t\telse\n\t\
    \t\treturn '1'\n\t\tend\n\tend\n\tlocal a_ = split(a)\n\tlocal b_ = split(b)\n\
    \tlocal result = {}\n\tfor i=1, #a_ do\n\t\tresult[i] = xor(a_[i], b_[i])\n\t\
    end\n\treturn table.concat(result)\nend", "    local result = {}\n    for i =\
    \ 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result[i]\
    \ = '0'\n        else\n        result[i] = '1'\n        end\n    end\n    return\
    \ table.concat(result)\nend", "    assert(type(a) == 'string')\n    assert(type(b)\
    \ == 'string')\n    assert(#a == #b)\n    local xor_result = {}\n    for i = 1,\
    \ #a do\n        local x, y = a:sub(i, i), b:sub(i, i)\n        if x == y then\n\
    \            table.insert(xor_result, '0')\n        else\n            table.insert(xor_result,\
    \ '1')\n        end\n    end\n    return table.concat(xor_result)\nend", "   \
    \ assert(type(a) == 'string' and type(b) == 'string', 'arguments must be of type\
    \ string')\n    assert(#a == #b, 'arguments must be of equal length')\n    local\
    \ len = #a\n    local res = ''\n    for i = 1, len do\n        res = res .. bit.bxor(tonumber(a:sub(i,\
    \ i)), tonumber(b:sub(i, i)))\n    end\n    return res\nend", "  assert(type(a)\
    \ == 'string', 'string_xor: a must be a string')\n  assert(type(b) == 'string',\
    \ 'string_xor: b must be a string')\n  local out = {}\n  for i = 1, math.max(#a,\
    \ #b) do\n    local x, y = tonumber(a:sub(i, i)), tonumber(b:sub(i, i))\n    assert(x\
    \ == 0 or x == 1, 'string_xor: invalid input')\n    assert(y == 0 or y == 1, 'string_xor:\
    \ invalid input')\n    out[i] = x ~= y and '1' or '0'\n  end\n  return table.concat(out)\n\
    end", "\tassert(#a == #b, 'strings are not of equal length')\n\tlocal c = {}\n\
    \tfor i = 1, #a do\n\t\tc[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\tend\n\
    \treturn table.concat(c)\nend", "    local s = {}\n    for i = 1, #a do\n    \
    \    local x = a:sub(i, i)\n        local y = b:sub(i, i)\n        if x == y then\n\
    \            s[i] = '0'\n        else\n            s[i] = '1'\n        end\n \
    \   end\n    return table.concat(s)\nend", "    local result = \"\"\n    for i\
    \ = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result =\
    \ result .. \"0\"\n        else\n            result = result .. \"1\"\n      \
    \  end\n    end\n    return result\nend", "    local a = bint(a)\n    local b\
    \ = bint(b)\n    local c = a .. b\n    local d = bint()\n    for i = 1, c:len()\
    \ do\n        local ia = tonumber(a:sub(i, i))\n        local ib = tonumber(b:sub(i,\
    \ i))\n        local ic = ia ~ ib\n        d:add_bits(ic)\n    end\n    return\
    \ d:tostring()\nend", "  local t = {}\n  for i = 1, math.max(#a, #b) do\n    local\
    \ ai = tonumber(a:sub(i, i)) or 0\n    local bi = tonumber(b:sub(i, i)) or 0\n\
    \    t[i] = (ai + bi) % 2\n  end\n  return table.concat(t)\nend", "\tif a:len()\
    \ ~= b:len() then\n\t\treturn nil\n\tend\n\tlocal s = ''\n\tfor i = 1, a:len()\
    \ do\n\t\ts = s .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n\tend\n\treturn\
    \ s\nend", "    assert(#a == #b, \"String lengths must be equal.\")\n    local\
    \ res = ''\n    for i = 1, #a do\n        res = res .. tostring(a[i] ~ b[i])\n\
    \    end\n    return res\nend", "\tlocal res = \"\"\n\tfor i = 1, #a do\n\t\t\
    local bit_a = a:sub(i, i)\n\t\tlocal bit_b = b:sub(i, i)\n\t\tif bit_a == bit_b\
    \ then\n\t\t\tres = res .. \"0\"\n\t\telse\n\t\t\tres = res .. \"1\"\n\t\tend\n\
    \tend\n\treturn res\nend", "  local out = {}\n  for i = 1, #a do\n    local va\
    \ = tonumber(a:sub(i, i))\n    local vb = tonumber(b:sub(i, i))\n    out[i] =\
    \ (va ~= vb) and '1' or '0'\n  end\n  return table.concat(out)\nend", "    local\
    \ r = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n \
    \           r = r .. '0'\n        else\n            r = r .. '1'\n        end\n\
    \    end\n    return r\nend", "    assert(#a == #b, \"a, b do not have the same\
    \ length\")\n    local res = {}\n    for i = 1, #a do\n        res[i] = a:sub(i,\
    \ i) == '1' and b:sub(i, i) == '0' and '1' or '0'\n    end\n    return table.concat(res)\n\
    end", "  local result = ''\n  for i = 1, #a do\n    result = result .. ('%01d'):format(\n\
    \      bit.bxor(tonumber(a:sub(i, i)), tonumber(b:sub(i, i)))\n    )\n  end\n\
    \  return result\nend", "    local result = {}\n    local n = math.max(#a, #b)\n\
    \    for i = 1, n do\n        local a_i = tonumber(a:sub(i, i)) or 0\n       \
    \ local b_i = tonumber(b:sub(i, i)) or 0\n        local c_i = (a_i + b_i) % 2\n\
    \        table.insert(result, c_i)\n    end\n    return table.concat(result)\n\
    end", "    local result = \"\"\n    local len = math.max(a:len(), b:len())\n \
    \   for i = 1, len do\n        local x = (a:byte(i) or 0) - 48\n        local\
    \ y = (b:byte(i) or 0) - 48\n        result = result .. tostring(x ~ y)\n    end\n\
    \    return result\nend", "  local l = math.max(a:len(), b:len())\n  local m =\
    \ \"\"\n  local i = 0\n  for i = 1, l do\n    m = m .. (\"%x\"):format(a:sub(i,\
    \ i):byte() ~ b:sub(i, i):byte())\n  end\n  return m\nend", "\tlocal result =\
    \ \"\"\n\tfor i = 1, math.max(#a, #b) do\n\t\tlocal n1 = tonumber(a:sub(i, i))\
    \ or 0\n\t\tlocal n2 = tonumber(b:sub(i, i)) or 0\n\t\tlocal x = n1 ~ n2\n\t\t\
    result = result .. x\n\tend\n\treturn result\nend", "  return (a:gsub('.', function(x)\n\
    \    return b:sub(x:byte(), x:byte())\n  end))\nend", "    return xor_bytes(a:gsub('.',\
    \ function(c) return char(byte(c)) end),\n                     b:gsub('.', function(c)\
    \ return char(byte(c)) end))\nend", "    local result = {}\n    local char_a,\
    \ char_b\n    for i = 1, #a do\n        char_a = string.byte(a, i)\n        char_b\
    \ = string.byte(b, i)\n        table.insert(result, string.char(char_a ~ char_b))\n\
    \    end\n    return table.concat(result)\nend", "  local result = ''\n  for i\
    \ = 1, a:len() do\n    result = result .. (a:sub(i, i) == b:sub(i, i) and '0'\
    \ or '1')\n  end\n  return result\nend", "\tlocal a_len = #a\n\tlocal b_len =\
    \ #b\n\tlocal max_len = math.max(a_len, b_len)\n\tlocal r = {}\n\tlocal r_i =\
    \ 0\n\tfor i = 1, max_len do\n\t\tlocal a_i = a:sub(i, i)\n\t\tlocal b_i = b:sub(i,\
    \ i)\n\t\tif a_i ~= b_i then\n\t\t\tr_i = r_i + 1\n\t\t\tr[r_i] = '1'\n\t\telse\n\
    \t\t\tr_i = r_i + 1\n\t\t\tr[r_i] = '0'\n\t\tend\n\tend\n\treturn table.concat(r)\n\
    end", "\tlocal result = ''\n\tfor i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i,\
    \ i) then\n\t\t\tresult = result .. '0'\n\t\telse\n\t\t\tresult = result .. '1'\n\
    \t\tend\n\tend\n\treturn result\nend", "    local result = {}\n    for i = 1,\
    \ #a do\n        local x = a:sub(i, i)\n        local y = b:sub(i, i)\n      \
    \  if x ~= y then\n            result[i] = '1'\n        else\n            result[i]\
    \ = '0'\n        end\n    end\n    return table.concat(result)\nend", "  local\
    \ result = ''\n  local i = 0\n  while i < a:len() and i < b:len() do\n    local\
    \ ai = a:sub(i+1, i+1)\n    local bi = b:sub(i+1, i+1)\n    if ai == bi then\n\
    \      result = result .. '0'\n    else\n      result = result .. '1'\n    end\n\
    \    i = i + 1\n  end\n  return result\nend", "    if #a ~= #b then return nil\
    \ end\n    local x = ''\n    for i = 1, #a do\n        x = x .. ((a:sub(i, i)\
    \ == b:sub(i, i)) and '0' or '1')\n    end\n    return x\nend", "\tlocal res =\
    \ \"\"\n\tfor i = 1, #a do\n\t\tlocal x = string.sub(a, i, i)\n\t\tlocal y = string.sub(b,\
    \ i, i)\n\t\tres = res .. (x == y and \"0\" or \"1\")\n\tend\n\treturn res\nend",
  "  local p, q = 1, 1\n  local res = {}\n  while a:sub(p, p) or b:sub(q, q) do\n\
    \    local x = a:sub(p, p)\n    local y = b:sub(q, q)\n    if x and y then\n \
    \     local bin = tonumber(x) ~= tonumber(y)\n      table.insert(res, bin and\
    \ '1' or '0')\n    elseif x or y then\n      local bin = x or y\n      table.insert(res,\
    \ bin)\n    end\n    p = p + 1\n    q = q + 1\n  end\n  return table.concat(res)\n\
    end", "  if a:len() < b:len() then\n    local old = a\n    a = b\n    b = old\n\
    \  end\n  local res = \"\"\n  for i = 1, a:len() do\n    if i > b:len() then\n\
    \      res = res .. a:sub(i, i)\n    else\n      local x = a:sub(i, i)\n     \
    \ local y = b:sub(i, i)\n      res = res .. (x ~= y and \"1\" or \"0\")\n    end\n\
    \  end\n  return res\nend", "    return a:gsub('.', function(m)\n        return\
    \ b:sub(m:byte(), m:byte())\n    end)\nend", "\tlocal bit = require \"bit\"\n\t\
    local xor = bit.bxor\n\tlocal lshift = bit.lshift\n\tlocal rshift = bit.rshift\n\
    \tlocal band = bit.band\n\tlocal result = \"\"\n\tlocal len = math.max(a:len(),\
    \ b:len())\n\tlocal rev = function(s) return s:reverse() end\n\ta = rev(a:pad(len,\
    \ '0'))\n\tb = rev(b:pad(len, '0'))\n\tfor i = 1, len do\n\t\tresult = result\
    \ .. (xor(band(lshift(a:byte(i), 0), 1), band(lshift(b:byte(i), 0), 1)) and '1'\
    \ or '0')\n\tend\n\treturn rev(result)\nend", "  local l = math.max(#a, #b)\n\
    \  local c = {}\n  for i = 1, l do\n    local x = (i <= #a) and tostring(a:sub(i,\
    \ i)) or '0'\n    local y = (i <= #b) and tostring(b:sub(i, i)) or '0'\n    c[i]\
    \ = (x == y) and '0' or '1'\n  end\n  return table.concat(c)\nend", "  if string.len(a)\
    \ ~= string.len(b) then\n    return nil\n  end\n  local result = \"\"\n  for i\
    \ = 1, string.len(a) do\n    local a_i = string.sub(a, i, i)\n    local b_i =\
    \ string.sub(b, i, i)\n    if a_i == b_i then\n      result = result .. \"0\"\n\
    \    else\n      result = result .. \"1\"\n    end\n  end\n  return result\nend",
  "\tlocal xor = \"\"\n\tfor i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\
    \t\t\txor = xor .. \"0\"\n\t\telse\n\t\t\txor = xor .. \"1\"\n\t\tend\n\tend\n\
    \treturn xor\nend", "\tlocal ret = {}\n\tfor i = 1, #a do\n\t\tret[i] = (a:sub(i,\
    \ i) == b:sub(i, i)) and '0' or '1'\n\tend\n\treturn table.concat(ret)\nend",
  "    if #a ~= #b then\n        error \"a and b are not of equal length\"\n    end\n\
    \    local res = {}\n    for i = 1, #a do\n        res[i] = bit.bxor(a:byte(i),\
    \ b:byte(i))\n    end\n    return string.char(unpack(res))\nend", "    return\
    \ a:gsub('.', { ['0'] = { ['0'] = '0', ['1'] = '1' }, ['1'] = { ['0'] = '1', ['1']\
    \ = '0' } })\n            :gsub('.', { ['0'] = { ['0'] = '0', ['1'] = '1' }, ['1']\
    \ = { ['0'] = '1', ['1'] = '0' } })\nend", "\tlocal abits = b2bits(a)\n\tlocal\
    \ bbits = b2bits(b)\n\tlocal cbits = {}\n\tfor i=1,#abits do\n\t\tcbits[i] = (abits[i]\
    \ + bbits[i]) % 2\n\tend\n\treturn bits2b(cbits)\nend", "    local a_len = #a\n\
    \    local b_len = #b\n    local bytes = {}\n    local byte\n    local i\n   \
    \ local j", "  assert(type(a) == 'string' and type(b) == 'string')\n  assert(#a\
    \ == #b)\n  local out = ''\n  for i = 1, #a do\n    local x = a:sub(i, i)\n  \
    \  local y = b:sub(i, i)\n    local z = tostring(tonumber(x) ~ tonumber(y))\n\
    \    out = out .. z\n  end\n  return out\nend", "    local r = ''\n    for i =\
    \ 1, #a do\n        r = r .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n   \
    \ end\n    return r\nend", "    local a_len = a:len()\n    local b_len = b:len()\n\
    \    local max_len = math.max(a_len, b_len)\n    local result = \"\"\n    for\
    \ i = 1, max_len do\n        local a_bit = a:sub(i, i) == \"1\"\n        local\
    \ b_bit = b:sub(i, i) == \"1\"\n        if a_bit == b_bit then\n            result\
    \ = result .. \"0\"\n        else\n            result = result .. \"1\"\n    \
    \    end\n    end\n    return result\nend", "  local a_len = #a\n  local b_len\
    \ = #b\n  local c = {}\n  local m = a_len > b_len and a_len or b_len\n  for i\
    \ = 1, m do\n    if i > a_len then\n      c[i] = b:sub(i, i)\n    elseif i > b_len\
    \ then\n      c[i] = a:sub(i, i)\n    else\n      local a_ch = a:sub(i, i)\n \
    \     local b_ch = b:sub(i, i)\n      c[i] = a_ch == b_ch and '0' or '1'\n   \
    \ end\n  end\n  return table.concat(c)\nend", "    local res = ''\n    for i =\
    \ 1, #a do\n        res = res .. tostring(a:sub(i, i) ~= b:sub(i, i))\n    end\n\
    \    return res\nend", "  local n = math.max(#a, #b)\n  local t = {}\n  for i\
    \ = 1, n do\n    t[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n  end\n  return\
    \ table.concat(t)\nend", "\tif not (type(a) == 'string' and type(b) == 'string')\
    \ then\n\t\treturn false\n\tend\n\tif #a ~= #b then\n\t\treturn false\n\tend\n\
    \tlocal result = ''\n\tfor i = 1, #a do\n\t\tlocal a_char = a:sub(i, i)\n\t\t\
    local b_char = b:sub(i, i)\n\t\tlocal xor_result = a_char == b_char and '0' or\
    \ '1'\n\t\tresult = result .. xor_result\n\tend\n\treturn result\nend", "\tlocal\
    \ result = \"\"\n\tfor i = 1, #a do\n\t\tresult = result .. (a:sub(i, i) == b:sub(i,\
    \ i) and \"0\" or \"1\")\n\tend\n\treturn result\nend", "  local ret = {}\n  for\
    \ i = 1, math.max(#a, #b) do\n    local byte_a = byte(a, i) or 0\n    local byte_b\
    \ = byte(b, i) or 0\n    ret[i] = char(bit.bxor(byte_a, byte_b))\n  end\n  return\
    \ concat(ret)\nend", "    if not a or not b then\n        return nil\n    end\n\
    \    if #a ~= #b then\n        return nil\n    end\n    local res = ''\n    for\
    \ i = 1, #a do\n        res = res .. (tonumber(a:sub(i, i)) ~ tonumber(b:sub(i,\
    \ i)))\n    end\n    return res\nend", "    local x = 0\n    for i = 1, 8 do\n\
    \        x = x + ((a:byte(i) - 48) ~ (b:byte(i) - 48)) * 2 ^ (8 - i)\n    end\n\
    \    return string.char(x)\nend", "    local ret = {}\n    for i = 1, #a do\n\
    \        local ai = tonumber(a:sub(i, i))\n        local bi = tonumber(b:sub(i,\
    \ i))\n        ret[i] = (ai == bi) and 0 or 1\n    end\n    return table.concat(ret)\n\
    end", "\tlocal binary_xor = function(v1, v2)\n\t\treturn ((v1 + v2) % 2)\n\tend\n\
    \tlocal xor_result = {}\n\tfor i = 1, a:len() do\n\t\ttable.insert(xor_result,\
    \ binary_xor(tonumber(a:sub(i, i)), tonumber(b:sub(i, i))))\n\tend\n\treturn table.concat(xor_result)\n\
    end", "    local result = ''\n    for i = 1, #a do\n        if a:sub(i, i) ==\
    \ b:sub(i, i) then\n            result = result .. '0'\n        else\n       \
    \     result = result .. '1'\n        end\n    end\n    return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
