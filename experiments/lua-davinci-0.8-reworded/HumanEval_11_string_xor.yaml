name: HumanEval_11_string_xor
language: lua
prompt: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
  \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
  \ '110')\n-- '100'\nlocal function string_xor(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
  \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
  \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return b:gsub('[^%a]', function(c)\n        return bit.bxor(a:byte(c),\
    \ b:byte(c))\n    end)\nend", "    local bxor = bit.bxor\n    assert(#a == #b,\
    \ 'Inputs must be same length.')\n    local out = {}\n    for i = 1, #a do\n \
    \       local c = a:sub(i, i)\n        local d = b:sub(i, i)\n        out[i] =\
    \ bxor(tonumber(c), tonumber(d))\n    end\n    return table.concat(out)\nend",
  "\tlocal result = {}\n\tfor i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\
    \t\t\tresult[i] = '0'\n\t\telse\n\t\t\tresult[i] = '1'\n\t\tend\n\tend\n\treturn\
    \ table.concat(result)\nend", "\tlocal res = ''\n\tfor i = 1, #a do\n\t\tres =\
    \ res .. tostring(tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)))\n\tend\n\treturn\
    \ res\nend", "  assert(#a == #b, \"a and b need to be of same length\")\n  local\
    \ xor = {}\n  for i = 1, #a do\n    local j = tonumber(a:sub(i, i))\n    local\
    \ k = tonumber(b:sub(i, i))\n    if j and k then\n      table.insert(xor, (j +\
    \ k) % 2)\n    else\n      table.insert(xor, 0)\n    end\n  end\n  return table.concat(xor)\n\
    end", "\tlocal r = {}\n\tfor i = 1, #a do\n\t\tr[i] = tostring(a:byte(i) ~ b:byte(i))\n\
    \tend\n\treturn table.concat(r)\nend", "  local r = {}\n  for i = 1, #a do\n \
    \   local c = a:sub(i, i) == '1' and b:sub(i, i) == '0'\n    or a:sub(i, i) ==\
    \ '0' and b:sub(i, i) == '1'\n    if c then r[i] = '1' else r[i] = '0' end\n \
    \ end\n  return table.concat(r)\nend", "  local xor = (a:byte() % 2) ~ (b:byte()\
    \ % 2)\n  local next_a = a:sub(2)\n  local next_b = b:sub(2)\n  if next_a == ''\
    \ or next_b == '' then\n    return tostring(xor)\n  else\n    return tostring(xor)\
    \ .. string_xor(next_a, next_b)\n  end\nend", "  local res = {}\n  for i = 1,#a\
    \ do\n    res[i] = a:sub(i,i) ~= b:sub(i,i) and '1' or '0'\n  end\n  return table.concat(res)\n\
    end", "  return string.gsub(a..b, '.', function(x) return (x == '0') and '1' or\
    \ '0' end)\nend", "  local long, short = {}, {}\n  local l, s\n  if #a > #b then\n\
    \    long, short = a, b\n    l, s = #a, #b\n  else\n    long, short = b, a\n \
    \   l, s = #b, #a\n  end\n  local buf = {}\n  for i = 1, l do\n    if i <= s then\n\
    \      table.insert(buf, string.char(string.byte(short, i) ~ string.byte(long,\
    \ i)))\n    else\n      table.insert(buf, string.char(string.byte(long, i)))\n\
    \    end\n  end\n  return table.concat(buf)\nend", "  local result = \"\"\n  for\
    \ i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      result = result\
    \ .. \"0\"\n    else\n      result = result .. \"1\"\n    end\n  end\n  return\
    \ result\nend", "\tlocal tbl, r = {}, \"\"\n\tfor i = 1, #a do\n\t\ttbl[i] = string.char(bit.bxor(string.byte(a,\
    \ i), string.byte(b, i)))\n\tend\n\treturn table.concat(tbl)\nend", "\tif #a ~=\
    \ #b then\n\t\tprint('Strings are not of the same length.')\n\t\treturn\n\tend\n\
    \tlocal out = {}\n\tfor i = 1, #a do\n\t\tlocal x = string.sub(a, i, i)\n\t\t\
    local y = string.sub(b, i, i)\n\t\tif x == y then\n\t\t\ttable.insert(out, '0')\n\
    \t\telse\n\t\t\ttable.insert(out, '1')\n\t\tend\n\tend\n\treturn table.concat(out)\n\
    end", "  local res = {}\n  for i = 1, #a do\n    res[i] = (a:sub(i, i) == '1'\
    \ and b:sub(i, i) == '0') or (a:sub(i, i) == '0' and b:sub(i, i) == '1') and '1'\
    \ or '0'\n  end\n  return table.concat(res)\nend", "    local ret = ''\n    local\
    \ len = math.max(#a, #b)\n    for i = 1, len do\n        local bit1 = ('0'):rep(len\
    \ - #a) .. a\n        local bit2 = ('0'):rep(len - #b) .. b\n        ret = ret\
    \ .. (bit1:sub(i, i) == bit2:sub(i, i) and '0' or '1')\n    end\n    return ret\n\
    end", "  if #a > #b then\n    b = string.rep('0', #a - #b) .. b\n  elseif #b >\
    \ #a then\n    a = string.rep('0', #b - #a) .. a\n  end\n  local bitmap = {}\n\
    \  for i = 1, #a do\n    bitmap[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\
    \  end\n  return table.concat(bitmap)\nend", "\tlocal x = ''\n\tfor i = 1, math.max(#a,\
    \ #b) do\n\t\tlocal p, q = a:sub(i, i), b:sub(i, i)\n\t\tif p == q then x = x\
    \ .. '0' else x = x .. '1' end\n\tend\n\treturn x\nend", "    return (a:gsub('.',\
    \ function(x)\n        return b:sub(x:byte(), x:byte())\n    end))\nend", "\t\
    local result = \"\"\n\tfor i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\
    \t\t\tresult = result .. \"0\"\n\t\telse\n\t\t\tresult = result .. \"1\"\n\t\t\
    end\n\tend\n\treturn result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
