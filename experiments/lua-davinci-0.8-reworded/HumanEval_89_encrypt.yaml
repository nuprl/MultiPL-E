name: HumanEval_89_encrypt
language: lua
prompt: "-- Create a function encrypt that takes a string as an argument and\n-- returns\
  \ a string encrypted with the alphabet being rotated. \n-- The alphabet should be\
  \ rotated in a manner such that the letters \n-- shift down by two multiplied to\
  \ two places.\n-- For example:\n-- >>> encrypt('hi')\n-- 'lm'\n-- >>> encrypt('asdfghjkl')\n\
  -- 'ewhjklnop'\n-- >>> encrypt('gf')\n-- 'kj'\n-- >>> encrypt('et')\n-- 'ix'\nlocal\
  \ function encrypt(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encrypt\n\
  \    lu.assertEquals(candidate('hi'), 'lm')\n    lu.assertEquals(candidate('asdfghjkl'),\
  \ 'ewhjklnop')\n    lu.assertEquals(candidate('gf'), 'kj')\n    lu.assertEquals(candidate('et'),\
  \ 'ix')\n    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')\n    lu.assertEquals(candidate('hellomyfriend'),\
  \ 'lippsqcjvmirh')\n    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'),\
  \ 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')\n    lu.assertEquals(candidate('a'),\
  \ 'e')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local encryptedString = ''\n    for index = 1, string.len(s) do\n\
    \        local char = string.sub(s, index, index)\n        local charIndex = string.find(alphabet,\
    \ char)\n        if charIndex ~= nil then\n            local newCharIndex = charIndex\
    \ + 2 * 2\n            local newChar = alphabet[newCharIndex]\n            encryptedString\
    \ = encryptedString .. newChar\n        else\n            encryptedString = encryptedString\
    \ .. char\n        end\n    end\n    return encryptedString\nend", "  local alphabet\
    \ = {}\n  local encrypted = {}\n  local i = 0\n  for ch = string.byte('a'), string.byte('z')\
    \ do\n    alphabet[ch - string.byte('a') + 1] = ch\n  end\n  for ch in string.gmatch(s,\
    \ \".\") do\n    i = i + 1\n    encrypted[i] = alphabet[((string.byte(ch) - string.byte('a')\
    \ + 1 + 2) % 26) + 1]\n  end\n  return string.char(unpack(encrypted))\nend", " \
    \ return s:gsub(\".\", function(c)\n    local b = c:byte()\n    if b >= 65 and\
    \ b <= 122 then\n      b = b + 2 * 2\n      if b > 122 then\n        b = b - 26\n\
    \      end\n    end\n    return string.char(b)\n  end)\nend", "    local rot={}\n\
    \    for i=1, string.len(s) do\n        rot[i] = string.char(string.byte(s,i)+2*2)\n\
    \    end\n    local rs = \"\"\n    for k,v in pairs(rot) do\n        rs = rs ..\
    \ v\n    end\n    return rs\nend", "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local s_out = \"\"\n    for i = 1, #s do\n        local c = s:sub(i, i)\n\
    \        local index = alphabet:find(c)\n        local index_out = index - (2\
    \ * 2)\n        if index_out <= 0 then\n            index_out = index_out + #alphabet\n\
    \        end\n        s_out = s_out .. alphabet:sub(index_out, index_out)\n  \
    \  end\n    return s_out\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local lowercase = string.lower(s)\n  local start = 1\n  local end_ = string.len(alphabet)\n\
    \  local new_str = \"\"\n  for i = 1, string.len(lowercase) do\n    for i2 = start,\
    \ end_ do\n      if string.sub(lowercase, i, i) == string.sub(alphabet, i2, i2)\
    \ then\n        if i2 == 25 then\n          new_str = new_str .. \"a\"\n     \
    \   elseif i2 == 26 then\n          new_str = new_str .. \"b\"\n        else\n\
    \          new_str = new_str .. string.sub(alphabet, i2 + 2, i2 + 2)\n       \
    \ end\n      end\n    end\n  end\n  return new_str\nend", "\tlocal alphabet =\
    \ 'abcdefghijklmnopqrstuvwxyz'\n\tlocal res = ''\n\tfor i = 1, #s do\n\t\tlocal\
    \ ch = s:sub(i, i)\n\t\tlocal offset = alphabet:find(ch)\n\t\tlocal place = (offset\
    \ + 4) % 26\n\t\tres = res .. alphabet:sub(place, place)\n\tend\n\treturn res\n\
    end", "    local i = 1\n    return s:gsub('.', function(c)\n        local x =\
    \ i * 2\n        i = i + 1\n        return string.char(c:byte() + x)\n    end)\n\
    end", "    local length = #s\n    local encrypted_s = ''\n    local dictionary\
    \ = {\n        a = 'c',\n        b = 'd',\n        c = 'e',\n        d = 'f',\n\
    \        e = 'g',\n        f = 'h',\n        g = 'i',\n        h = 'j',\n    \
    \    i = 'k',\n        j = 'l',\n        k = 'm',\n        l = 'n',\n        m\
    \ = 'o',\n        n = 'p',\n        o = 'q',\n        p = 'r',\n        q = 's',\n\
    \        r = 't',\n        s = 'u',\n        t = 'v',\n        u = 'w',\n    \
    \    v = 'x',\n        w = 'y',\n        x = 'z',\n        y = 'a',\n        z\
    \ = 'b'\n    }\n    for i = 1, length do\n        local char = s:sub(i, i)\n \
    \       encrypted_s = encrypted_s .. dictionary[char]\n    end\n    return encrypted_s\n\
    end", "    -- Implement me\nend", "  -- Code goes here\nend", "    local alpha\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    local enc = ''\n    for i = 1, #s do\n \
    \       enc = enc .. alpha:sub(alpha:find(s:sub(i,i)) + 4, alpha:find(s:sub(i,i))\
    \ + 4)\n    end\n    return enc\nend", "  -- TODO: Implement me!\nend", "  local\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  local my_list = {}\n  for i = 1,\
    \ string.len(s) do\n    local c = string.sub(s, i, i)\n    local value = string.byte(c)\
    \ - 96\n    value = value + 2 * 2\n    if value > 26 then\n      value = value\
    \ - 26\n    end\n    local w = string.sub(alphabet, value, value)\n    table.insert(my_list,\
    \ w)\n  end\n  return table.concat(my_list)\nend", "\tlocal str = \"\"\n\tfor\
    \ c in s:gmatch(\".\") do\n\t\tlocal n = string.byte(c)\n\t\tif c == \"z\" then\n\
    \t\t\tstr = str .. \"b\"\n\t\telseif c == \"y\" then\n\t\t\tstr = str .. \"a\"\
    \n\t\telse\n\t\t\tstr = str .. string.char(n + 2)\n\t\tend\n\tend\n\treturn str\n\
    end", "\tlocal len = #s\n\tlocal s2 = \"\"\n\tfor i = 1, len do\n\t\ts2 = s2 ..\
    \ string.char(string.byte(s, i) + 2*2)\n\tend\n\treturn s2\nend", "  alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  dict = {}\n  for i = 1,#alphabet do\n    dict[alphabet:sub(i,i)]\
    \ = alphabet:sub((i + 4) % 26 + 1, (i + 4) % 26 + 1)\n  end\n  local s = s:lower()\n\
    \  local ans = ''\n  for i = 1,#s do\n    ans = ans .. dict[s:sub(i,i)]\n  end\n\
    \  return ans\nend", "    s = string.gsub(s, '[A-Za-z]', alphabet)\n    return\
    \ s\nend", "\t--[[\n\t\tHINT:\n\t\tYou can access the characters in the string\
    \ using square brackets.\n\t\tSo you can use s[1] to get the first character in\
    \ the string. \n\t\tYou can use string.char(97) to get the character a.", "  \
    \  local res = {}\n    local alpha = 'abcdefghijklmnopqrstuvwxyz'\n    for i =\
    \ 1, #s do\n        local c = s:sub(i, i)\n        local o = alpha:find(c)\n \
    \       if o then\n            res[#res + 1] = alpha:sub((o + 2) % #alpha + 1,\
    \ (o + 2) % #alpha + 1)\n        else\n            res[#res + 1] = c\n       \
    \ end\n    end\n    return table.concat(res)\nend", "    local result = \"\"\n\
    \    for i = 1, s:len() do\n        local c = s:sub(i, i)\n        local code\
    \ = c:byte()\n        if code >= 97 and code <= 122 then\n            code = code\
    \ + 2\n            if code > 122 then\n                code = code - 26\n    \
    \        end\n        elseif code >= 65 and code <= 90 then\n            code\
    \ = code + 2\n            if code > 90 then\n                code = code - 26\n\
    \            end\n        end\n        result = result .. string.char(code)\n\
    \    end\n    return result\nend", "\treturn s:gsub(\"%a\",function(c)\n\t\treturn\
    \ string.char(97 + ((c:byte() - 97 + 2 * 2) % 26))\n\tend)\nend", "    return\
    \ \"\"\nend", "    local newstr = \"\"\n    for i = 1, #s do\n        local c\
    \ = s:sub(i,i)\n        if c ~= \" \" then\n            local ascii = string.byte(c)\
    \ + 2 * 2\n            if ascii > 122 then\n                ascii = ascii - 26\n\
    \            end\n            newstr = newstr .. string.char(ascii)\n        else\n\
    \            newstr = newstr .. \" \"\n        end\n    end\n    return newstr\n\
    end", "    local result = \"\"\n    for i = 1, #s do\n        result = result\
    \ .. string.char(string.byte(s, i) + 4)\n    end\n    return result\nend", " \
    \ local t = {}\n  local offset = 2\n  local limit = string.len(s)\n  for i = 1,\
    \ limit do\n    t[i] = string.char(s:byte(i) + offset)\n  end\n  return table.concat(t)\n\
    end", "    local crypt = ''\n    for i = 1, #s do\n        crypt = crypt .. string.char(string.byte(s,\
    \ i) + 2*2)\n    end\n    return crypt\nend", "\tlocal u,v = split(s)\n\tlocal\
    \ w,x = split(v)\n\tlocal y,z = split(w)\n\tlocal a,b = split(x)\n\tlocal c,d\
    \ = split(y)\n\tlocal e,f = split(z)\n\tlocal g,h = split(a)\n\tlocal i,j = split(b)\n\
    \tlocal k,l = split(c)\n\tlocal m,n = split(d)\n\tlocal o,p = split(e)\n\tlocal\
    \ q,r = split(f)\n\tlocal t,u = split(g)\n\tlocal v,w = split(h)\n\tlocal x,y\
    \ = split(i)\n\tlocal z,a1 = split(j)\n\tlocal b1,c1 = split(k)\n\tlocal d1,e1\
    \ = split(l)\n\tlocal f1,g1 = split(m)\n\tlocal h1,i1 = split(n)\n\tlocal j1,k1\
    \ = split(o)\n\tlocal l1,m1 = split(p)\n\tlocal n1,o1 = split(q)\n\tlocal p1,q1\
    \ = split(r)\n\tlocal r1,s1 = split(t)\n\tlocal t1,u1 = split(u)\n\tlocal v1,w1\
    \ = split(v)\n\tlocal x1,y1 = split(w)\n\tlocal z1,a2 = split(x)\n\tlocal b2,c2\
    \ = split(y)\n\tlocal d2,e2 = split(z)\n\tlocal f2,g2 = split(a1)\n\tlocal h2,i2\
    \ = split(b1)\n\tlocal j2,k2 = split(c1)\n\tlocal l2,m2 = split(d1)\n\tlocal n2,o2\
    \ = split(e1)\n\tlocal p2,q2 = split(f1)\n\tlocal r2,s2 = split(g1)\n\tlocal t2,u2\
    \ = split(h1)\n\tlocal v2,w2 = split(i1)\n\tlocal x2,y2 = split(j1)", "  local\
    \ list = split(s)\n  local j = 1\n  for i, v in ipairs(list) do\n    if j == 2\
    \ then\n      list[i] = string.char(string.byte(v) + 2 * 2)\n      j = 1\n   \
    \ else\n      list[i] = string.char(string.byte(v) + 2)\n      j = j + 1\n   \
    \ end\n  end\n  return table.concat(list)\nend", "  local half = string.len(s)\
    \ / 2\n  local left = string.sub(s, 1, half)\n  local right = string.sub(s, half\
    \ + 1)\n  local function rotate(s)\n    return string.sub(s, 3) .. string.sub(s,\
    \ 1, 2)\n  end\n  return string.gsub(left, '(.)', rotate) .. string.gsub(right,\
    \ '(.)', rotate)\nend", "  local s = s:lower()\n  local out = \"\"\n  for i =\
    \ 1, #s do\n    if s:sub(i,i) == \" \" then\n      out = out .. \" \"\n    else\n\
    \      out = out .. ALPHABET:sub((ALPHABET:find(s:sub(i,i)) - 1) * 2 % 26 + 1,\
    \ (ALPHABET:find(s:sub(i,i)) - 1) * 2 % 26 + 1)\n    end\n  end\n  return out\n\
    end", "  \nend", "    -- INSERT CODE HERE\n    return s\nend", "    local s =\
    \ s:lower()\n    local char = {}\n    local ans = {}\n    local a = {}\n    local\
    \ temp = \"\"\n    local str = \"\"\n    a = {\"a\",\"b\",\"c\",\"d\",\"e\",\"\
    f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"\
    s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}\n    for i=1,#s do\n        char[i]\
    \ = s:sub(i,i)\n    end\n    for j=1,#char do\n        for i=1,#a do\n       \
    \     if char[j] == a[i] then\n                if i+4 > #a then\n            \
    \        temp = a[i+4-#a]\n                else\n                    temp = a[i+4]\n\
    \                end\n                ans[j] = temp\n            end\n       \
    \ end\n    end\n    for k=1,#ans do\n        str = str..ans[k]\n    end\n    return\
    \ str\nend", "\tlocal t = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \tlocal new_string = \"\"\n\tfor i=1,#s do\n\t\tfor j=1,#t do\n\t\t\tif string.sub(s,i,i)\
    \ == t[j] then\n\t\t\t\tlocal n = (j + (2*2))%(#t)\n\t\t\t\tif n == 0 then\n\t\
    \t\t\t\tn = #t\n\t\t\t\tend\n\t\t\t\tnew_string = new_string .. t[n]\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn new_string\nend", "  if #s == 0 then\n    return ''\n\
    \  else\n    return encrypt(string.sub(s, 1, #s - 1)) .. encrypt_char(string.sub(s,\
    \ #s, #s))\n  end\nend", "    if s == \"\" then return \"\" end\n    local s0\
    \ = s:sub(1,1)\n    local s1 = s:sub(2)\n    return encrypt(s1) .. get_cipher(s0)\n\
    end", "\tlocal e = \"\"\n\tfor i = 1, #s do\n\t\tif s:sub(i,i) == \" \" then\n\
    \t\t\te = e .. \" \"\n\t\telse\n\t\t\tlocal n = (s:sub(i,i):byte() - 96) * 2\n\
    \t\t\tif n > 26 then\n\t\t\t\tn = n - 26\n\t\t\tend\n\t\t\te = e .. string.char(n\
    \ + 96)\n\t\tend\n\tend\n\treturn e\nend", "    s = s:lower()\n    local str =\
    \ \"\"\n    for i=1, #s do\n        local c = s:sub(i,i)\n        if c == 'z'\
    \ then\n            str = str .. 'b'\n        elseif c == 'y' then\n         \
    \   str = str .. 'a'\n        else\n            local ascii = string.byte(c)\n\
    \            str = str .. string.char(ascii + 2)\n        end\n    end\n    return\
    \ str\nend", "  local l = s:len()\n  local ns = ''\n  for i = 1, l do\n    local\
    \ c = s:sub(i, i)\n    if c == ' ' then\n      ns = ns .. ' '\n    else\n    \
    \  ns = ns .. alphabet[s:sub(i, i) + 2 * i]\n    end\n  end\n  return ns\nend",
  "  return nil\nend", "  --[[local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local\
    \ cipher = ''\n  for i = 1, s:len() do\n    local newChar = alphabet:sub(s:sub(i,i):byte()-96+2*2,\
    \ s:sub(i,i):byte()-96+2*2)\n    cipher = cipher .. newChar\n  end\n  return cipher\n\
    \  --]]\n  local encrypt = {}\n  for c in s:gmatch\".\" do\n    encrypt[#encrypt+1]\
    \ = string.char(c:byte()+2*2)\n  end\n  return table.concat(encrypt)\nend", " \
    \   if s:len() == 0 then return '' end\n    local _,ascii = s:byte(1)\n    return\
    \  string.char((ascii+6-65)%26+65)..encrypt(s:sub(2))\nend", "  -- local temp\
    \ = {}\n  -- for i = 1, #s do\n  --   local char = s:sub(i, i)\n  --   temp[i]\
    \ = cipher[char]\n  -- end\n  -- return table.concat(temp)\n  --\n  -- OR\n  --\n\
    \  local enc = {}\n  for c in s:gmatch(\".\") do\n    table.insert(enc, cipher[c])\n\
    \  end\n  return table.concat(enc)\nend", "  s = string.lower(s)\n  local result\
    \ = ''\n  for i = 1, #s do\n    if (string.byte(s, i) >= string.byte('a') and\
    \ string.byte(s, i) <= string.byte('y')) then\n      result = result .. string.char(string.byte(s,\
    \ i) + 2)\n    elseif (string.byte(s, i) == string.byte('z')) then\n      result\
    \ = result .. 'b'\n    elseif (string.byte(s, i) == string.byte('z')) then\n \
    \     result = result .. 'a'\n    end\n  end\n  return result\nend", "    local\
    \ alphabet = {}\n    for i = 0, 25 do\n        alphabet[i] = string.char(i + string.byte('a'))\n\
    \    end\n    local r = ''\n    for i = 1, #s do\n        local c = string.byte(s,\
    \ i) - string.byte('a')\n        r = r .. alphabet[(c + 2) % 26]\n    end\n  \
    \  return r\nend", "    local s = rot(s, 4)\n    return s\nend", "    local result\
    \ = {}\n    for i=1, #s do\n        table.insert(result, string.char(string.byte(s,\
    \ i)+2*2))\n    end\n    return table.concat(result)\nend", "  -- insert code\
    \ here\nend", "  -- new empty string to hold the encrypted word\n  local encrypted_word\
    \ = ''\n  -- for loop\n  for i = 1, #s do\n    -- get the encrypted letter and\
    \ concatenate to the encrypted word\n    encrypted_word = encrypted_word .. encrypt_letter(s:sub(i,\
    \ i))\n  end\n  -- return the encrypted word\n  return encrypted_word\nend", " \
    \   -- Write your code here\n    local str = \"\"\n    for i = 1, #s do\n    \
    \    local c = s:sub(i, i)\n        local b = string.byte(c)\n        b = b -\
    \ 2\n        str = str .. string.char(b)\n    end\n    return str\nend", "   \
    \ local function shift_one(c)\n        local start = string.byte('a')\n      \
    \  local limit = string.byte('z')\n        local byte = string.byte(c)\n     \
    \   if byte + 2 > limit then\n            byte = byte + 2 - 26\n        else\n\
    \            byte = byte + 2\n        end\n        return string.char(byte)\n\
    \    end\n    local function lower(c)\n        local byte = string.byte(c)\n \
    \       if byte >= 65 and byte <= 90 then\n            return string.char(byte\
    \ + 32)\n        else\n            return c\n        end\n    end\n    local s\
    \ = s:lower()\n    local new_string = ''\n    for i = 1, s:len() do\n        new_string\
    \ = new_string .. shift_one(lower(s:sub(i, i)))\n    end\n    return new_string\n\
    end", "  -- define the amount to shift the letters by in the alphabet\n  local\
    \ shift = 2 * 2\n  -- create a table that maps each letter to a shifted version\n\
    \  local t = {}\n  -- add each upper-case letter to the table\n  for i = 65, 90\
    \ do\n    -- shift the letter by 'shift' and wrap around if necessary\n    t[string.char(i)]\
    \ = string.char((i + shift - 1) % 26 + 65)\n  end\n  -- add each lower-case letter\
    \ to the table\n  for i = 97, 122 do\n    -- shift the letter by 'shift' and wrap\
    \ around if necessary\n    t[string.char(i)] = string.char((i + shift - 1) % 26\
    \ + 97)\n  end\n  -- replace every letter in 's' with the corresponding letter\
    \ in 't'\n  return string.gsub(s, '%a', t)\nend", "  local result = ''\n  local\
    \ alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  for i = 1, s:len() do\n    local\
    \ c = s:sub(i, i)\n    local position = alphabet:find(c)\n    if position then\n\
    \      result = result .. alphabet:sub((position + 2 * 2 - 1) % 26 + 1, (position\
    \ + 2 * 2 - 1) % 26 + 1)\n    else\n      result = result .. c\n    end\n  end\n\
    \  return result\nend", "\tlocal new_string = ''\n\tlocal letter_values = {\n\t\
    \ta = 1,\n\t\tb = 2,\n\t\tc = 3,\n\t\td = 4,\n\t\te = 5,\n\t\tf = 6,\n\t\tg =\
    \ 7,\n\t\th = 8,\n\t\ti = 9,\n\t\tj = 10,\n\t\tk = 11,\n\t\tl = 12,\n\t\tm = 13,\n\
    \t\tn = 14,\n\t\to = 15,\n\t\tp = 16,\n\t\tq = 17,\n\t\tr = 18,\n\t\ts = 19,\n\
    \t\tt = 20,\n\t\tu = 21,\n\t\tv = 22,\n\t\tw = 23,\n\t\tx = 24,\n\t\ty = 25,\n\
    \t\tz = 26\n\t}\n\t\n\tfor i = 1, #s do\n\t\tlocal letter = string.sub(s, i, i)\n\
    \t\tlocal new_letter = letter_values[letter]\n\t\tnew_letter = new_letter + 2\n\
    \t\tif new_letter > 26 then\n\t\t\tnew_letter = new_letter - 26\n\t\tend\n\t\t\
    for j, k in pairs(letter_values) do\n\t\t\tif k == new_letter then\n\t\t\t\tnew_string\
    \ = new_string .. j\n\t\t\tend\n\t\tend\n\tend\n\treturn new_string\nend", " \
    \ local out = ''\n  for c in s:gmatch('.') do\n    local d = ''\n    local x =\
    \ c:byte()\n    if x >= 97 and x <= 122 then\n      x = x + 4\n      if x > 122\
    \ then\n        x = x - 26\n      end\n    elseif x >= 65 and x <= 90 then\n \
    \     x = x + 4\n      if x > 90 then\n        x = x - 26\n      end\n    end\n\
    \    d = string.char(x)\n    out = out .. d\n  end\n  return out\nend", "    return\
    \ \nend", "    return map(s, alphabet, 2*2)\nend", "\t-- YOUR CODE HERE\n\tlocal\
    \ new = \"\"\n\tfor i = 1, string.len(s) do\n\t\tlocal c = string.sub(s, i, i)\n\
    \t\tlocal b = string.byte(c)\n\t\tif b == 122 then b = 97\n\t\telseif b == 121\
    \ then b = 96\n\t\telse b = b + 2 end\n\t\tnew = new .. string.char(b)\n\tend\n\
    \treturn new\nend", "  local e = {}\n  for char in s:gmatch('.') do\n    local\
    \ i = char:byte()\n    e[#e+1] = string.char(i+4)\n  end\n  return table.concat(e)\n\
    end", "    return rotate(s, 2)\nend", "    if #s == 0 then\n        return ''\n\
    \    else\n        local first = string.sub(s, 1, 1)\n        local rest = string.sub(s,\
    \ 2)\n        local first_shift = shift_by_two(first)\n        return first_shift\
    \ .. encrypt(rest)\n    end\nend", "  -- your code here\nend", "\tlocal l = {}\n\
    \tfor i = 1, string.len(s) do\n\t\tlocal c = string.sub(s, i, i)\n\t\tfor k, v\
    \ in pairs(alphabet) do\n\t\t\tif v == c then\n\t\t\t\tl[i] = alphabet[k + (2\
    \ * i)]\n\t\t\tend\n\t\tend\n\tend\n\treturn table.concat(l)\nend", "  return\
    \ string.gsub(s, '.', function(s)\n    return string.char(string.byte(s) + 2 *\
    \ 2)\n  end)\nend\nassert(encrypt('hi') == 'lm')\nassert(encrypt('asdfghjkl')\
    \ == 'ewhjklnop')\nassert(encrypt('gf') == 'kj')\nassert(encrypt('et') == 'ix')",
  '    local rotated = 0', "\tfor i=1,string.len(s) do\n\t\tlocal char = string.sub(s,i,i)\n\
    \t\tfor j=1,string.len(alphabet) do\n\t\t\tif char == string.sub(alphabet,j,j)\
    \ then\n\t\t\t\tif j > 12 then\n\t\t\t\t\tj = j - 26\n\t\t\t\tend\n\t\t\t\tj =\
    \ j + 4\n\t\t\t\tchar = string.sub(alphabet,j,j)\n\t\t\t\tbreak\n\t\t\tend\n\t\
    \tend\n\t\ts = string.sub(s,1,i-1) .. char .. string.sub(s,i+1)\n\tend\n\treturn\
    \ s\nend", "  local t = {}\n  for i = 1, #s do\n    local n = s:byte(i)\n    if\
    \ n > 64 and n < 91 then\n      n = n + (2 * 2) - 64\n      if n > 26 then\n \
    \       n = n - 26\n      end\n      n = n + 64\n    elseif n > 96 and n < 123\
    \ then\n      n = n + (2 * 2) - 96\n      if n > 26 then\n        n = n - 26\n\
    \      end\n      n = n + 96\n    end\n    t[i] = string.char(n)\n  end\n  return\
    \ table.concat(t)\nend", "  -- your code here\nend", "\ts = string.lower(s)\n\t\
    \n\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\tlocal encrypted = {}\n\t\n\
    \tfor i = 1, #s do\n\t\tlocal char = string.sub(s, i, i)\n\t\tlocal index = string.find(alphabet,\
    \ char)\n\t\tif index == nil then\n\t\t\ttable.insert(encrypted, char)\n\t\telse\n\
    \t\t\tlocal new_index = (index + 2) * 2\n\t\t\t\n\t\t\tif new_index > #alphabet\
    \ then\n\t\t\t\tnew_index = new_index - #alphabet\n\t\t\tend\n\t\t\t\n\t\t\ttable.insert(encrypted,\
    \ string.sub(alphabet, new_index, new_index))\n\t\tend\n\tend\n\t\n\treturn table.concat(encrypted)\n\
    end", "    local letters = {}\n    local encrypted = ''\n    for i = 1, #s do\n\
    \        table.insert(letters, s:sub(i, i))\n    end\n    for _, v in ipairs(letters)\
    \ do\n        local index = string.find(alphabet, v)\n        local shifted_index\
    \ = index + 4\n        local letter = alphabet:sub(shifted_index, shifted_index)\n\
    \        encrypted = encrypted .. letter\n    end\n    return encrypted\nend",
  "  -- This function takes one argument, s.\n  -- Then it takes the string length\
    \ of the string and stores it in len.\n  -- Next it takes the characters of the\
    \ string s and stores them in a table named chars.\n  -- After that we create\
    \ two varables, max and min and assign them values of zero and 127.\n  -- Then\
    \ we create a function that will take a value, a, and return the remainder of\
    \ it \n  -- divided by 26 plus 97.\n  -- Then we use the function and a for loop\
    \ to change the characters from their ASCII code to their \n  -- corresponding\
    \ alphabetical character. Then it returns the string with the string.char function.\n\
    \  local len = string.len(s)\n  local chars = {}\n  local max = 0\n  local min\
    \ = 127\n  local subtractVal = function(a)\n    return (a % 26) + 97\n  end\n\
    \  for i = 1, len do\n    chars[i] = string.byte(s, i)\n    chars[i] = subtractVal(chars[i]\
    \ + 2)\n    chars[i] = string.char(chars[i])\n  end\n  return table.concat(chars)\n\
    end", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local newAlphabet =\
    \ 'cdefghijklmnopqrstuvwxyzab'\n  local newString = ''\n  local char = ''\n  local\
    \ charIdx = 0\n  for i = 1, #s do\n    char = s:sub(i, i)\n    charIdx = string.find(alphabet,\
    \ char)\n    newString = newString .. newAlphabet:sub(charIdx, charIdx)\n  end\n\
    \  return newString\nend", "\tlocal alpha = \"abcdefghijklmnopqrstuvwxyz\"\n\t\
    local new_alpha = alpha\n\tlocal new_word = \"\"\n\tfor i=1,#s do\n\t\tlocal char\
    \ = string.sub(s,i,i)\n\t\tlocal char_index = string.find(alpha,char)\n\t\tif\
    \ char_index == nil then\n\t\t\tnew_word = new_word .. char\n\t\telse\n\t\t\t\
    local new_char_index = char_index + 2*2\n\t\t\tif new_char_index > #alpha then\n\
    \t\t\t\tnew_char_index = new_char_index - #alpha\n\t\t\tend\n\t\t\tnew_word =\
    \ new_word .. string.sub(new_alpha,new_char_index,new_char_index)\n\t\tend\n\t\
    end\n\treturn new_word\nend", "  local encrypt = \"\"\n  for char in s:gmatch(\"\
    .\") do\n    local num = string.byte(char)\n    local num_count = 0\n    while\
    \ num_count ~= 4 do\n      num = num + 1\n      if num == 91 then\n        num\
    \ = 65\n      end\n      num_count = num_count + 1\n    end\n    local new_char\
    \ = string.char(num)\n    encrypt = encrypt .. new_char\n  end\n  return encrypt\n\
    end", "    local sLength = s:len()\n    local encryptString = ''\n    for i =\
    \ 1, sLength do\n        local letter = s:sub(i, i)\n        local letterNum =\
    \ letter:byte() + 4\n        if letterNum > 122 then\n            letterNum =\
    \ letterNum - 26\n        end\n        local letterEncrypt = string.char(letterNum)\n\
    \        encryptString = encryptString .. letterEncrypt\n    end\n    return encryptString\n\
    end", "  local result = ''\n  for i = 1, string.len(s) do\n    local c = string.sub(s,\
    \ i, i)\n    result = result .. string.char(string.byte(c) + 2 * 2)\n  end\n \
    \ return result\nend", "    -- TODO: write code here\n    return ''\nend", "\t\n\
    \tlocal i,l=#s,#s\n\tlocal str,newStr,e=s:byte(),0,string.char\n\tlocal shift=2*2\n\
    \t\n\twhile i>0 do\n\t\tnewStr=str[i]\n\t\tif newStr<=65+shift and newStr>65 then\n\
    \t\t\tnewStr=newStr+26-shift\n\t\telseif newStr<=90+shift and newStr>90 then\n\
    \t\t\tnewStr=newStr+26-shift\n\t\telseif newStr<=97+shift and newStr>97 then\n\
    \t\t\tnewStr=newStr+26-shift\n\t\telseif newStr<=122+shift and newStr>122 then\n\
    \t\t\tnewStr=newStr+26-shift\n\t\telse\n\t\t\tnewStr=newStr-shift\n\t\tend\n\t\
    \t\n\t\tnewStr=e(newStr)\n\t\t\n\t\ts=s:sub(1,i-1)..newStr..s:sub(i+1,l)\n\t\t\
    i=i-1\n\tend\n\t\n\treturn s\nend", "    local t = {}\n    local abc = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local shifts = string.sub(abc, 3) .. string.sub(abc, 1, 2)\n    for i = 1,\
    \ string.len(s) do\n        for j = 1, string.len(abc) do\n            if string.sub(s,\
    \ i, i) == string.sub(abc, j, j) then\n                table.insert(t, string.sub(shifts,\
    \ j, j))\n            end\n        end\n    end\n    return table.concat(t)\n\
    end", "\t-- Replace this with the correct code\n\treturn s\nend", "  local encrypted\
    \ = \"\"\n  for i=1,#s do\n    local c = s:sub(i,i)\n    local ord = string.byte(c)\n\
    \    local encrypted_ord = (ord - 97 + 4) % 26 + 97\n    encrypted = encrypted\
    \ .. string.char(encrypted_ord)\n  end\n  return encrypted\nend", "  local s =\
    \ s:lower()\n  local result = ''\n  for i = 1, #s do\n    local c = s:sub(i, i)\n\
    \    local ascii = string.byte(c)\n    ascii = ascii + 2*2\n    if ascii > 122\
    \ then\n      ascii = ascii - 26\n    end\n    local shift = string.char(ascii)\n\
    \    result = result .. shift\n  end\n  return result\nend", "  local alphabet\
    \ = string.lower('abcdefghijklmnopqrstuvwxyz')\n  local encrypted_string = ''\n\
    \  for char in s:gmatch('.') do\n    local char_index = alphabet:find(char)\n\
    \    if char_index then\n      local shift = (char_index + (2 * 2)) % alphabet:len()\n\
    \      encrypted_string = encrypted_string .. alphabet:sub(shift, shift)\n   \
    \ else\n      encrypted_string = encrypted_string .. char\n    end\n  end\n  return\
    \ encrypted_string\nend", "  -- s = \"abcd\"\n  -- for i=1,string.len(s) do\n\
    \  --   local char = string.sub(s,i,i)\n  --   print (char)\n  -- end\n  local\
    \ encryptedString = \"\"\n  for i=1,string.len(s) do\n    local char = string.sub(s,i,i)\n\
    \    local charCode = string.byte(char)\n    if (charCode+2 > 122) then\n    \
    \  charCode = 96 + ((charCode+2) % 122)\n    else\n      charCode = charCode +\
    \ 2\n    end\n    local newChar = string.char(charCode)\n    encryptedString =\
    \ encryptedString .. newChar\n  end\n  return encryptedString\nend", "    local\
    \ result = {}\n    for i = 1, #s do\n        local idx = string.byte(s, i) - 97\n\
    \        local encrypted_idx = (idx + 4) % 26\n        table.insert(result, string.char(encrypted_idx\
    \ + 97))\n    end\n    return table.concat(result)\nend", "    local function\
    \ f(c)\n        if c < 'a' or c > 'z' then\n            return c\n        end\n\
    \        local d = c + 4\n        if d > 'z' then\n            d = d - 26\n  \
    \      end\n        return d\n    end\n    return (s:gsub('.', f))\nend", "  \
    \  return map(function(c) return string.char(string.byte(c) + 2*2) end, s)\nend",
  "  local rs = \"\"\n  for i = 1, #s do\n    local j = (string.byte(s, i) - 96 +\
    \ 2) % 26\n    if j == 0 then j = 26 end\n    rs = rs .. string.char(j + 96)\n\
    \  end\n  return rs\nend", "  -- CODE\nend", "    return s:gsub('[a-z]', function(c)\n\
    \        local c = c:byte()\n        c = c + 2 * 2\n        if c > 122 then\n\
    \            c = c - 26\n        end\n        return string.char(c)\n    end)\n\
    end", "   -- Your code here\nend", "  return s\nend", "  local chars = {}\n  for\
    \ i = 1, #s do\n    chars[i] = string.char(string.byte(s, i) + i)\n  end\n  return\
    \ table.concat(chars)\nend", "\tres = \"\"\n\tfor i = 1, #s do\n\t\tres = res\
    \ .. string.char(string.byte(s, i) + (i % 2) * 2)\n\tend\n\treturn res\nend",
  "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  local new_s = \"\"\n  local\
    \ length = string.len(s)\n  for i = 1, length do\n    local c = string.sub(s,\
    \ i, i)\n    local pos = string.find(alphabet, c)\n    local new_pos = (pos +\
    \ 2 * 2) % 26\n    local new_c = string.sub(alphabet, new_pos, new_pos)\n    new_s\
    \ = new_s .. new_c\n  end\n  return new_s\nend", "  return s:gsub('.', function(c)\n\
    \    local ascii = string.byte(c)\n    if ascii >= 65 and ascii <= 90 then\n \
    \     return string.char((ascii - 65 + 2*2) % 26 + 65)\n    elseif ascii >= 97\
    \ and ascii <= 122 then\n      return string.char((ascii - 97 + 2*2) % 26 + 97)\n\
    \    else\n      return c\n    end\n  end)\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local function helper(l, n)\n    if l == nil then\n      return\n    else\n\
    \      return helper(l:sub(2), n .. string.char(string.byte(l:sub(1)) + 2 * 2))\n\
    \    end\n  end\n  return helper(s, \"\")\nend", "  -- YOUR CODE HERE\n  local\
    \ my_text = string.lower(s)\n  local my_num = {}\n  local my_dict = {}\n  local\
    \ my_string = ''\n  for i = 1,26 do\n    my_num[i] = i + 4\n    if my_num[i] >\
    \ 26 then\n      my_num[i] = my_num[i] - 26\n    end\n  end\n  my_dict['a'] =\
    \ 'e'\n  my_dict['b'] = 'f'\n  my_dict['c'] = 'g'\n  my_dict['d'] = 'h'\n  my_dict['e']\
    \ = 'i'\n  my_dict['f'] = 'j'\n  my_dict['g'] = 'k'\n  my_dict['h'] = 'l'\n  my_dict['i']\
    \ = 'm'\n  my_dict['j'] = 'n'\n  my_dict['k'] = 'o'\n  my_dict['l'] = 'p'\n  my_dict['m']\
    \ = 'q'\n  my_dict['n'] = 'r'\n  my_dict['o'] = 's'\n  my_dict['p'] = 't'\n  my_dict['q']\
    \ = 'u'\n  my_dict['r'] = 'v'\n  my_dict['s'] = 'w'\n  my_dict['t'] = 'x'\n  my_dict['u']\
    \ = 'y'\n  my_dict['v'] = 'z'\n  my_dict['w'] = 'a'\n  my_dict['x'] = 'b'\n  my_dict['y']\
    \ = 'c'\n  my_dict['z'] = 'd'\n  for i = 1,#my_text do\n    if my_dict[my_text:sub(i,i)]\
    \ then\n      my_string = my_string .. my_dict[my_text:sub(i,i)]\n    else\n \
    \     my_string = my_string .. my_text:sub(i,i)\n    end\n  end\n  return my_string\n\
    end", "\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\tlocal result = {}\n\t\
    for i = 1, #s do\n\t\tlocal letter = s:sub(i, i)\n\t\tlocal idx = alphabet:find(letter)\n\
    \t\tif idx == nil then\n\t\t\tresult[i] = letter\n\t\telse\n\t\t\tresult[i] =\
    \ alphabet:sub((idx + 2) * 2 - 1, (idx + 2) * 2)\n\t\tend\n\tend\n\treturn table.concat(result)\n\
    end", "\t-- Your code here\n\tanswer = \"\"\n\talphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \tfor i = 1, #s do\n\t\tfor x = 1, 26 do\n\t\t\tif (string.sub(s,i,i) == alphabet[x])\
    \ then\n\t\t\t\tif (x + (2*2) > 26) then\n\t\t\t\t\tanswer = answer .. alphabet[((x\
    \ + (2*2))-26)]\n\t\t\t\telse\n\t\t\t\t\tanswer = answer .. alphabet[x + (2*2)]\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn answer\nend", "    local cyphertext\
    \ = ''\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        local ascii\
    \ = string.byte(c)\n        local shifted = ascii + 2 * 2\n        if shifted\
    \ > 122 then\n            local remainder = shifted - 122\n            shifted\
    \ = 96 + remainder\n        end\n        cyphertext = cyphertext .. string.char(shifted)\n\
    \    end\n    return cyphertext\nend", "  -- TODO: Implement this function\nend",
  "  local encode = {\n    ['a'] = 'c', ['b'] = 'd', ['c'] = 'e', ['d'] = 'f', ['e']\
    \ = 'g',\n    ['f'] = 'h', ['g'] = 'i', ['h'] = 'j', ['i'] = 'k', ['j'] = 'l',\n\
    \    ['k'] = 'm', ['l'] = 'n', ['m'] = 'o', ['n'] = 'p', ['o'] = 'q',\n    ['p']\
    \ = 'r', ['q'] = 's', ['r'] = 't', ['s'] = 'u', ['t'] = 'v',\n    ['u'] = 'w',\
    \ ['v'] = 'x', ['w'] = 'y', ['x'] = 'z', ['y'] = 'a',\n    ['z'] = 'b'\n  }\n\
    \  local result = ''\n  for i = 1, #s do\n    result = result .. encode[s:sub(i,\
    \ i)]\n  end\n  return result\nend", "    return encrypt_helper(encrypt_helper(s))\n\
    end", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local new_string = ''\n\
    \  for i = 1, #s do\n    local char = s:sub(i, i)\n    for j = 1, #alphabet do\n\
    \      if char == alphabet:sub(j, j) then\n        new_string = new_string ..\
    \ alphabet:sub((j + 2) % 26 + 1, (j + 2) % 26 + 1)\n      end\n    end\n  end\n\
    \  return new_string\nend", "  return(string.gsub(s, '%a', function(c) return\
    \ string.char(string.byte(c) + 2 * 2) end))\nend", "\tlocal new_str = ''\n\tfor\
    \ char in s:gmatch('.') do\n\t\tlocal _, i = string.find(alphabet, char)\n\t\t\
    new_str = new_str .. alphabet:sub(i + 2 * 2, i + 2 * 2)\n\tend\n\treturn new_str\n\
    end", "    local s_enc = \"\"\n    for i=1, string.len(s) do\n        -- This\
    \ converts a character to the number it represents.\n        local c_num = string.byte(s,\
    \ i)\n        -- The formula for the encrypted letter is:\n        -- (c_num -\
    \ (c_num - 2)) + ((c_num - 2) * 2) - 97\n        -- Which is equivalent to c_num\
    \ + c_num + c_num - c_num - c_num - c_num - c_num - c_num - 97\n        -- Which\
    \ is equivalent to c_num + c_num - 97\n        -- Which is equivalent to 2 * c_num\
    \ - 97\n        -- Which is equivalent to 2 * (c_num - 97) + 97\n        -- Which\
    \ is equivalent to 2 * (c_num - 97) + 97\n        -- Which is equivalent to (2\
    \ * (c_num - 97)) + 97\n        -- However, we need to make sure that a letter\
    \ that wraps around the end of the alphabet\n        -- stays in the bounds of\
    \ the alphabet. To do this, we add 26 to the result if it is less than 97.\n \
    \       if ((2 * (c_num - 97)) + 97) < 97 then\n            c_num = (2 * (c_num\
    \ - 97)) + 97 + 26\n        else\n            c_num = (2 * (c_num - 97)) + 97\n\
    \        end\n        -- This converts the number c_num represents to a character.\n\
    \        s_enc = s_enc .. string.char(c_num)\n    end\n    return s_enc\nend",
  "\tlocal res = ''\n\tfor i = 1, #s do\n\t\tlocal char = s:sub(i, i)\n\t\tlocal offset\
    \ = ((string.byte(char) - string.byte('a')) * 2) % 26\n\t\tres = res .. string.char(string.byte('a')\
    \ + offset)\n\tend\n\treturn res\nend\nassert(encrypt('hi') == 'lm')\nassert(encrypt('asdfghjkl')\
    \ == 'ewhjklnop')\nassert(encrypt('gf') == 'kj')\nassert(encrypt('et') == 'ix')\n\
    print(\"Passed!\")", end, "  -- your code here\nend", "    local alph = {\"a\"\
    , \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\"}\n    local s = s:lower()\n    local res = ''\n    for i\
    \ = 1, string.len(s) do\n        local ch = string.sub(s, i, i)\n        local\
    \ index = nil\n        for k, v in pairs(alph) do\n            if v == ch then\n\
    \                index = k\n            end\n        end\n        if index ==\
    \ nil then\n            res = res .. ch\n        else\n            res = res ..\
    \ alph[(index + 2) * 2]\n        end\n    end\n    return res\nend", "  local\
    \ encoding = \"\"\n  for i = 1, #s do\n    local letter = s:sub(i, i)\n    local\
    \ position = string.find(ALPHABET, letter)\n    local addition = 2 * 2\n    local\
    \ sum = (position + addition) % #ALPHABET\n    local new_letter = ALPHABET:sub(sum,\
    \ sum)\n    encoding = encoding .. new_letter\n  end\n  return encoding\nend",
  "    local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local\
    \ n = string.len(s)\n    local t = {}\n    local index\n    for i = 1, n do\n\
    \        local c = string.sub(s, i, i)\n        local pos = string.find(alphabet,\
    \ c)\n        index = pos + 2 * 2\n        if index > 26 then\n            index\
    \ = index - 26\n        end\n        t[i] = alphabet[index]\n    end\n    local\
    \ ret = table.concat(t)\n    return ret\nend", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  local rotated = string.sub(alphabet, 3) .. string.sub(alphabet, 1, 2)\n  return\
    \ string.gsub(s, alphabet, rotated)\nend", "    s = s:lower()\n    local arr =\
    \ {}\n    for i=1,#s do\n        local place = s:byte(i) - 96\n        place =\
    \ (place + 2) * 2\n        if place > 26 then\n            place = place - 26\n\
    \        end\n        arr[i] = string.char(place + 96)\n    end\n    return table.concat(arr)\n\
    end", "    local encrypting = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \    local encrString = ''\n    local encrypted = ''\n    local c = ''\n    local\
    \ ind = 0\n    local ind1 = 0\n    local ind2 = 0\n    local ind3 = 0\n    local\
    \ ind4 = 0\n    for i = 1, string.len(s) do\n        c = string.sub(s, i, i)\n\
    \        ind = string.find(encrString, c)\n        if ind == nil then\n      \
    \      encrString = encrString .. c\n        end\n    end\n    for i = 1, string.len(encrString)\
    \ do\n        c = string.sub(encrString, i, i)\n        ind1 = string.find(encrypting,\
    \ c)\n        ind2 = ind1 + 2\n        ind3 = ind2 + 2\n        ind4 = ind3 +\
    \ 2\n        if ind1 < 22 then\n            encrypted = encrypted .. encrypting[ind2]\
    \ .. encrypting[ind3] .. encrypting[ind4]\n        elseif ind1 < 25 then\n   \
    \         encrypted = encrypted .. encrypting[ind2] .. encrypting[ind3] .. encrypting[ind1\
    \ + 2]\n        elseif ind1 < 26 then\n            encrypted = encrypted .. encrypting[ind2]\
    \ .. encrypting[ind1 + 2] .. encrypting[ind1 + 4]\n        end\n    end\n    return\
    \ encrypted\nend", "    --local alphabet = string.lower('abcdefghijklmnopqrstuvwxyz')\n\
    \    local alphabet = string.lower('abcdefghijklmnopqrstuvwxyz')\n    local encryptedString\
    \ = \"\"\n    for i = 1, #s do\n        local c = string.sub(s, i, i)\n      \
    \  local index = string.find(alphabet, c)\n        if index ~= nil then\n    \
    \        local shiftedIndex = index + 2 * 2\n            -- if the shift puts\
    \ us over the last character index\n            -- we go back to the beginning\
    \ of the alphabet\n            if shiftedIndex > 26 then\n                shiftedIndex\
    \ = shiftedIndex - 26\n            end\n            local c2 = string.sub(alphabet,\
    \ shiftedIndex, shiftedIndex)\n            encryptedString = encryptedString ..\
    \ c2\n        else\n            encryptedString = encryptedString .. c\n     \
    \   end\n    end\n    return encryptedString\nend", "    return (s:gsub(\".\"\
    , function(c) return string.char(c:byte()+4) end))\nend", "  return\nend", " \
    \   local res = ''\n    for i = 1, #s do\n        res = res .. alphabet[(((alphabet[s:sub(i,\
    \ i)] - 1) * 2) % 26) + 1]\n    end\n    return res\nend", "  local cipher = \"\
    \"\n  for i = 1, #s do\n    local b = string.byte(s, i)\n    if b < 119 then\n\
    \      b = b + 2\n    elseif b == 119 then\n      b = 97\n    elseif b == 120\
    \ then\n      b = 98\n    end\n    cipher = cipher .. string.char(b)\n  end\n\
    \  return cipher\nend", "\tlocal encrypts = {}\n\tfor c in s:gmatch('.') do\n\t\
    \tencrypts[#encrypts+1] = encrypt_char(c)\n\tend\n\treturn table.concat(encrypts)\n\
    end", "    local ret = {}\n    local ascii = {}\n    for i = 1, string.len(s)\
    \ do\n        ascii[i] = string.byte(s, i)\n    end\n    for i = 1, #ascii do\n\
    \        if ascii[i] >= 97 and ascii[i] <= 122 then\n            ascii[i] = ascii[i]\
    \ + 2 * 2\n            if ascii[i] > 122 then\n                ascii[i] = ascii[i]\
    \ - 122\n                ascii[i] = 96 + ascii[i]\n            end\n        end\n\
    \        ret[i] = string.char(ascii[i])\n    end\n    return table.concat(ret)\n\
    end", "\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\tlocal rot = {'c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','a','b'}\n\
    \tlocal new = ''\n\tfor i = 1, #s do\n\t\tlocal r = string.sub(s, i, i)\n\t\t\
    for j = 1, #alphabet do\n\t\t\tif r == string.sub(alphabet, j, j) then\n\t\t\t\
    \tnew = new .. rot[j]\n\t\t\tend\n\t\tend\n\tend\n\treturn new\nend", "    --\
    \ to be completed\nend", "  local alphabet = {}\n  local encrypted = ''\n  for\
    \ i = 1, string.len(s) do\n    table.insert(alphabet, string.sub(s, i, i))\n \
    \ end\n  for _, v in ipairs(alphabet) do\n    encrypted = encrypted .. string.char(string.byte(v)\
    \ + 2 * 2)\n  end\n  return encrypted\nend", "  -- YOUR CODE GOES HERE\n  local\
    \ result = \"\"\n  local stringLen = string.len(s)\n  local alphabetSize = 26\n\
    \  local firstChar = string.byte('a')\n  local lastChar = string.byte('z')\n \
    \ for i = 1, stringLen do\n    local currentChar = string.byte(s, i)\n    local\
    \ newChar = nil\n    if currentChar >= firstChar and currentChar <= lastChar then\n\
    \      newChar = (currentChar - firstChar + alphabetSize - 2) % alphabetSize +\
    \ firstChar\n    else\n      newChar = currentChar\n    end\n    result = result\
    \ .. string.char(newChar)\n  end\n  return result\nend", "    -- Create a alphabet\
    \ table\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    -- Create a new\
    \ empty string\n    local result = ''\n    -- For every character in string we\
    \ will\n    -- add two multiplied to two to the index and\n    -- get the character\
    \ and add it to result\n    for i = 1, #s do\n        local char = s:sub(i, i)\n\
    \        local index = alphabet:find(char)\n        if index then\n          \
    \  index = index + (2 * 2)\n            if index > #alphabet then\n          \
    \      index = index - #alphabet\n            end\n            result = result\
    \ .. alphabet:sub(index, index)\n        else\n            result = result ..\
    \ char\n        end\n    end\n    return result\nend", "  if type(s) ~= 'string'\
    \ then\n    return ''\n  end\n  local enc = ''\n  for i = 1, #s do\n    local\
    \ char = s:sub(i, i)\n    local n = string.byte(char)\n    if n >= 97 and n <=\
    \ 119 then\n      enc = enc .. string.char(n + 4)\n    elseif n >= 120 and n <=\
    \ 122 then\n      enc = enc .. string.char(n - 22)\n    elseif n >= 65 and n <=\
    \ 87 then\n      enc = enc .. string.char(n + 4)\n    elseif n >= 88 and n <=\
    \ 90 then\n      enc = enc .. string.char(n - 22)\n    else\n      enc = enc ..\
    \ char\n    end\n  end\n  return enc\nend", "  local t = alphabet()\n  local n\
    \ = {}\n  local r = {}\n  local x\n  local y\n  --for each letter in s, move x\
    \ spots down the alphabet,\n  --x is x%2^2, y is the letter in that position\n\
    \  for i=1,#s do\n    x = i%2^2\n    y = string.find(t,s:sub(i,i)) + x\n    if\
    \ y > #t then\n      y = y - #t\n    end\n    table.insert(n,y)\n  end\n  --for\
    \ each number in n, find that number in the alphabet\n  --and save it to r\n \
    \ for i=1,#n do\n    table.insert(r,t:sub(n[i],n[i]))\n  end\n  return table.concat(r)\n\
    end", "  local s = s:lower()\n  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local encrypted = \"\"\n  for i=1,s:len() do\n    local cur = s:sub(i,i)\n\
    \    local index = alphabet:find(cur)\n    encrypted = encrypted .. (index+4 <\
    \ alphabet:len() and alphabet:sub(index+4,index+4) or alphabet:sub(index+4-alphabet:len(),index+4-alphabet:len()))\n\
    \  end\n  return encrypted\nend", "\t-- create a new empty string variable to\
    \ store the encrypted string\n\tlocal newString = ''", "    local alphabet = {\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    local lower_case = {}\n    local upper_case = {}\n\
    \    local encrypted = {}\n    local a = false\n    local i = 0\n    local j =\
    \ 0\n    local b = false\n    local c = false\n    local n = 0\n    local x =\
    \ 0\n    local y = 0\n    local z = 0\n    for i = 1, #alphabet do\n        lower_case[i]\
    \ = alphabet[i]\n        upper_case[i] = string.upper(alphabet[i])\n    end\n\
    \    for i = 1, #s do\n        for j = 1, #lower_case do\n            if s[i]\
    \ == lower_case[j] then\n                a = true\n                b = false\n\
    \                n = j\n            elseif s[i] == upper_case[j] then\n      \
    \          a = true\n                b = true\n                n = j\n       \
    \     end\n        end\n        if a == true then\n            if n < 23 then\n\
    \                if b == true then\n                    encrypted[i] = upper_case[n\
    \ + 2]\n                else\n                    encrypted[i] = lower_case[n\
    \ + 2]\n                end\n            elseif n >= 23 then\n               \
    \ if b == true then\n                    encrypted[i] = upper_case[(n + 2) - 24]\n\
    \                else\n                    encrypted[i] = lower_case[(n + 2) -\
    \ 24]\n                end\n            end\n        else\n            encrypted[i]\
    \ = s[i]\n        end\n        a = false\n    end\n    local e = \"\"\n    for\
    \ x = 1, #encrypted do\n        e = e .. encrypted[x]\n    end\n    return e\n\
    end", "    local new_s = ''\n    for i = 1, string.len(s) do\n        local c\
    \ = string.sub(s, i, i)\n        local ascii = string.byte(c)\n        if ascii\
    \ >= 112 then\n            new_s = new_s .. string.char(ascii + 2 - 26)\n    \
    \    else\n            new_s = new_s .. string.char(ascii + 2)\n        end\n\
    \    end\n    return new_s\nend", "\tlocal char_to_num = {}\n\tlocal num_to_char\
    \ = {}\n\tfor i = 0,255 do\n\t\tchar_to_num[string.char(i)] = i\n\t\tnum_to_char[i]\
    \ = string.char(i)\n\tend\n\tlocal len = string.len(s)\n\tlocal encrypted = ''\n\
    \tfor i = 1,len do\n\t\tlocal value = char_to_num[string.sub(s,i,i)]\n\t\tlocal\
    \ encrypted_value = value + 2 * 2\n\t\tif encrypted_value > 255 then\n\t\t\tencrypted_value\
    \ = encrypted_value - 255\n\t\tend\n\t\tencrypted = encrypted .. num_to_char[encrypted_value]\n\
    \tend\n\treturn encrypted\nend", "    local alphabet = {}\n    for i = 1, 26 do\n\
    \        alphabet[i] = string.char(64 + i)\n    end\n    local newStr = \"\"\n\
    \    for i = 1, #s do\n        local oldChar = string.byte(s, i)\n        local\
    \ newChar\n        if oldChar == 65 or oldChar == 69 then\n            newChar\
    \ = string.char(oldChar + 6)\n        elseif oldChar == 66 or oldChar == 70 then\n\
    \            newChar = string.char(oldChar + 6)\n        elseif oldChar == 67\
    \ or oldChar == 71 then\n            newChar = string.char(oldChar + 6)\n    \
    \    elseif oldChar == 68 or oldChar == 72 then\n            newChar = string.char(oldChar\
    \ + 6)\n        elseif oldChar == 73 or oldChar == 77 then\n            newChar\
    \ = string.char(oldChar + 4)\n        elseif oldChar == 74 or oldChar == 78 then\n\
    \            newChar = string.char(oldChar + 4)\n        elseif oldChar == 75\
    \ or oldChar == 79 then\n            newChar = string.char(oldChar + 4)\n    \
    \    elseif oldChar == 76 or oldChar == 80 then\n            newChar = string.char(oldChar\
    \ + 4)\n        elseif oldChar == 81 or oldChar == 85 then\n            newChar\
    \ = string.char(oldChar + 2)\n        elseif oldChar == 82 or oldChar == 86 then\n\
    \            newChar = string.char(oldChar + 2)\n        elseif oldChar == 83\
    \ or oldChar == 87 then\n            newChar = string.char(oldChar + 2)\n    \
    \    elseif oldChar == 84 or oldChar == 88 then\n            newChar = string.char(oldChar\
    \ + 2)\n        elseif oldChar == 89 or oldChar == 93 then\n            newChar\
    \ = string.char(oldChar - 6)\n        elseif oldChar == 90 or oldChar == 94 then\n\
    \            newChar = string.char(oldChar - 6)\n        elseif oldChar == 97\
    \ or oldChar == 101 then\n            newChar = string.char(oldChar + 6)\n   \
    \     elseif oldChar == 98 or oldChar == 102 then\n            newChar = string.char(old",
  "    -- code here\nend", "  return 'gj'\nend", "  local f = function(c)\n    if\
    \ c == 'z' then return 'b'\n    elseif c == 'y' then return 'a'\n    else return\
    \ string.char(string.byte(c) + 2 * 2)\n    end\n  end\n  return string.gsub(s,\
    \ \"(%w)\", f)\nend", "\tlocal r = ''\n\tfor i = 1, #s do\n\t\tr = r .. rotate(s:sub(i,\
    \ i), i*2)\n\tend\n\treturn r\nend", "    local alphabet = {a = 1, b = 2, c =\
    \ 3, d = 4, e = 5, f = 6, g = 7, h = 8, i = 9, j = 10, k = 11, l = 12, m = 13,\
    \ n = 14, o = 15, p = 16, q = 17, r = 18, s = 19, t = 20, u = 21, v = 22, w =\
    \ 23, x = 24, y = 25, z = 26}\n    local alphabet_rev = {a = 1, b = 2, c = 3,\
    \ d = 4, e = 5, f = 6, g = 7, h = 8, i = 9, j = 10, k = 11, l = 12, m = 13, n\
    \ = 14, o = 15, p = 16, q = 17, r = 18, s = 19, t = 20, u = 21, v = 22, w = 23,\
    \ x = 24, y = 25, z = 26}\n    local i = 1\n    for k, v in pairs(alphabet) do\n\
    \        alphabet_rev[i] = k\n        i = i + 1\n    end\n    local result = ''\n\
    \    for c in s:gmatch('.') do\n        local pos = alphabet[c]\n        local\
    \ new_pos = ((pos - 1) * 2) % 26 + 1\n        result = result .. alphabet_rev[new_pos]\n\
    \    end\n    return result\nend", "    local chars = {}\n    for c in s:gmatch'.'\
    \ do\n        local b, e = c:byte(), c:byte() + 2 * 2\n        if e > 122 then\n\
    \            e = e - 26\n        end\n        chars[#chars + 1] = string.char(e)\n\
    \    end\n    return table.concat(chars)\nend", "  local encrypt_alphabet = {}\n\
    \  for i = 1,#alphabet do\n    local j = i - 2*2\n    if j < 1 then j = #alphabet\
    \ + j end\n    encrypt_alphabet[alphabet[i]] = alphabet[j]\n  end\n  local result\
    \ = ''\n  for c in s:gmatch('.') do\n    result = result .. encrypt_alphabet[c]\n\
    \  end\n  return result\nend", "   return nil -- this is a stub\nend", "  local\
    \ cipher = ''\n  for i = 1, #s do\n    local i = string.byte(s, i)\n    if i >=\
    \ 97 and i <= 122 then\n      i = (i + 4 - 97) % 26 + 97\n    elseif i >= 65 and\
    \ i <= 90 then\n      i = (i + 4 - 65) % 26 + 65\n    end\n    cipher = cipher\
    \ .. string.char(i)\n  end\n  return cipher\nend", "    local c, f = {}, {}\n\
    \    for k, v in pairs(string.byte(s, 1, #s)) do\n        table.insert(c, string.char(v))\n\
    \    end\n    for k, v in pairs(c) do\n        if string.match(v, '[a-m]') then\n\
    \            table.insert(f, string.char(string.byte(v) + 2 * 2))\n        elseif\
    \ string.match(v, '[n-z]') then\n            table.insert(f, string.char(string.byte(v)\
    \ - 2 * 2))\n        end\n    end\n    return table.concat(f)\nend", "  local\
    \ result = ''\n  for i = 1, #s do\n    local ascii = string.byte(s, i)\n    if\
    \ ascii >= 97 and ascii <= 122 then\n      local new = ascii + 2\n      if new\
    \ > 122 then\n        new = new - 26\n      end\n      result = result .. string.char(new)\n\
    \    elseif ascii >= 65 and ascii <= 90 then\n      local new = ascii + 2\n  \
    \    if new > 90 then\n        new = new - 26\n      end\n      result = result\
    \ .. string.char(new)\n    else\n      result = result .. string.char(ascii)\n\
    \    end\n  end\n  return result\nend", "    local newstring = ''\n    for i =\
    \ 1, #s do\n        local letter = s:sub(i,i)\n        local place = alphabet:find(letter)\n\
    \        local newplace = place - 2*2\n        newstring = newstring .. alphabet:sub(newplace,\
    \ newplace)\n    end\n    return newstring\nend", "  return s:gsub(\"%a\", rot_x(2))\n\
    end", "    -- This function takes the first character of a string and rotates\
    \ it\n    -- by 2*2 places.\n    local function rotateChar(c)\n        -- First\
    \ we check whether it is a letter at all.\n        if not string.match(c, \"[a-zA-Z]\"\
    ) then\n            return c\n        end\n        -- Determine the index of the\
    \ character, starting from 'a' or 'A'\n        local index = (string.byte(c) -\
    \ string.byte('a')) % 26\n        -- Add the rotation.\n        index = (index\
    \ + 2*2) % 26\n        -- Convert back to a character.\n        return string.char(string.byte('a')\
    \ + index)\n    end\n    -- Applies the rotation to each individual character.\n\
    \    return string.gsub(s, \".\", rotateChar)\nend", "  local sNew = ''\n  for\
    \ i = 1, #s do\n    local l = string.sub(s, i, i)\n    local lNew = string.char(\n\
    \      (string.byte(l) + (2 * 2) - 97) % 26 + 97\n    )\n    sNew = sNew .. lNew\n\
    \  end\n  return sNew\nend", end, "    local function change(c)\n        local\
    \ a = string.byte('a')\n        local z = string.byte('z')\n        local l =\
    \ string.byte(c)\n        local r = l + 4\n        if l >= a and l <= z then\n\
    \            if r > z then\n                r = r - 26\n            end\n    \
    \    end\n        return string.char(r)\n    end\n    return (string.gsub(s, '.',\
    \ change))\nend", "  local str = ''\n  local cipher = {}\n  local alpha = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  for i = 1, string.len(alpha) do\n    table.insert(cipher, string.sub(alpha,\
    \ i, i))\n  end\n  for i = 1, #s do\n    local letter = string.sub(s, i, i)\n\
    \    local index = nil\n    for j = 1, #cipher do\n      if letter == cipher[j]\
    \ then\n        index = j\n      end\n    end\n    local new_index = index + 4\n\
    \    if new_index > #cipher then\n      new_index = new_index - #cipher\n    end\n\
    \    str = str .. cipher[new_index]\n  end\n  return str\nend", "\ts = string.lower(s)\n\
    \ts = string.gsub(s, 'a', 'c')\n\ts = string.gsub(s, 'b', 'd')\n\ts = string.gsub(s,\
    \ 'c', 'e')\n\ts = string.gsub(s, 'd', 'f')\n\ts = string.gsub(s, 'e', 'g')\n\t\
    s = string.gsub(s, 'f', 'h')\n\ts = string.gsub(s, 'g', 'i')\n\ts = string.gsub(s,\
    \ 'h', 'j')\n\ts = string.gsub(s, 'i', 'k')\n\ts = string.gsub(s, 'j', 'l')\n\t\
    s = string.gsub(s, 'k', 'm')\n\ts = string.gsub(s, 'l', 'n')\n\ts = string.gsub(s,\
    \ 'm', 'o')\n\ts = string.gsub(s, 'n', 'p')\n\ts = string.gsub(s, 'o', 'q')\n\t\
    s = string.gsub(s, 'p', 'r')\n\ts = string.gsub(s, 'q', 's')\n\ts = string.gsub(s,\
    \ 'r', 't')\n\ts = string.gsub(s, 's', 'u')\n\ts = string.gsub(s, 't', 'v')\n\t\
    s = string.gsub(s, 'u', 'w')\n\ts = string.gsub(s, 'v', 'x')\n\ts = string.gsub(s,\
    \ 'w', 'y')\n\ts = string.gsub(s, 'x', 'z')\n\ts = string.gsub(s, 'y', 'a')\n\t\
    s = string.gsub(s, 'z', 'b')\n\treturn s\nend", "   -- create the alphabet\n \
    \  local alphabet = {\n      a = 1,\n      b = 2,\n      c = 3,\n      d = 4,\n\
    \      e = 5,\n      f = 6,\n      g = 7,\n      h = 8,\n      i = 9,\n      j\
    \ = 10,\n      k = 11,\n      l = 12,\n      m = 13,\n      n = 14,\n      o =\
    \ 15,\n      p = 16,\n      q = 17,\n      r = 18,\n      s = 19,\n      t = 20,\n\
    \      u = 21,\n      v = 22,\n      w = 23,\n      x = 24,\n      y = 25,\n \
    \     z = 26\n   }\n   -- split the string into a table\n   local t = split(s)\n\
    \   -- define the encrypted string\n   local encrypted_string = ''\n   -- go through\
    \ the items in the table\n   for i = 1, #t do\n      -- get the current letter\n\
    \      local current_letter = t[i]\n      -- get the current index\n      local\
    \ current_index = alphabet[current_letter]\n      -- create a new index, rotated\
    \ by two multiplied to two places\n      local new_index = current_index + (2\
    \ * 2)\n      -- add the new letter to the encrypted string\n      encrypted_string\
    \ = encrypted_string .. get_new_letter(new_index)\n   end\n   -- return the encrypted\
    \ string\n   return encrypted_string\nend", "  local result = {}\n  for i = 1,\
    \ #s do\n    local c = s:sub(i, i)\n    local i1 = c:byte()\n    local i2 = i1\
    \ + 2 * 2\n    if i2 > 122 then\n      i2 = i2 - 26\n    end\n    local c2 = string.char(i2)\n\
    \    table.insert(result, c2)\n  end\n  return table.concat(result)\nend", " \
    \ local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local alphlen = string.len(alphabet)\n\
    \  local s = s:lower()\n  local len = string.len(s)\n  local new = ''\n  for c\
    \ = 1, len do\n    local char = string.sub(s, c, c)\n    local pos = string.find(alphabet,\
    \ char)\n    if pos ~= nil then\n      if pos < alphlen - 2 then\n        new\
    \ = new .. string.sub(alphabet, pos + 2, pos + 2)\n      else\n        new = new\
    \ .. string.sub(alphabet, pos - alphlen + 2, pos - alphlen + 2)\n      end\n \
    \   else\n      new = new .. char\n    end\n  end\n  return new\nend", "    --\
    \ Get the alphabet.\n    local alphabet = string.ascii_lowercase\n    -- Get the\
    \ length of the alphabet.\n    local alphabet_len = #alphabet\n    -- Create a\
    \ new string that will be our encrypted string.\n    local encrypted_string =\
    \ ''\n    -- For each character in the provided string.\n    for i = 1, #s do\n\
    \        -- If the current char is not a letter, just skip it.\n        if not\
    \ s:sub(i, i):isalpha() then\n            -- Continue to the next iteration of\
    \ the loop.\n            goto continue\n        end\n        -- Get the current\
    \ character.\n        local c = s:sub(i, i)\n        -- Get the position of the\
    \ current character.\n        local c_index = alphabet:find(c)\n        -- Multiply\
    \ the index of the current character by two.\n        local c_index_times_two\
    \ = c_index * 2\n        -- Get the new character based on the new position.\n\
    \        local c_new = alphabet:sub(c_index_times_two, c_index_times_two)\n  \
    \      -- If the new character is not found in the alphabet, we know\n       \
    \ -- it is out of bounds and we need to start at the beginning again.\n      \
    \  if not c_new then\n            -- Mod the multiplied index by the length of\
    \ the alphabet.\n            c_index_times_two = c_index_times_two % alphabet_len\n\
    \            -- Get the new character based on the new position.\n           \
    \ c_new = alphabet:sub(c_index_times_two, c_index_times_two)\n        end\n  \
    \      -- Add the new character to the encrypted string.\n        encrypted_string\
    \ = encrypted_string .. c_new\n        -- Jump to the next iteration of the loop.\n\
    \        ::continue::\n    end\n    -- Return the encrypted string.\n    return\
    \ encrypted_string\nend", end, "  return s:gsub(\".\", function(c)\n    return\
    \ string.char(c:byte() + 2 * 2)\n  end)\nend", "  -- Your code here\nend", " \
    \   -- This function will return the encrypted string.\n    -- Rotating the alphabet\
    \ increases by two.\n    local function rotate(s)\n        -- Convert the string\
    \ to lower case.\n        local lower = s:lower()\n        -- Find the index of\
    \ each character in the alphabet.\n        local idx = {}\n        for i = 1,\
    \ #lower do\n            local letter = lower:sub(i, i)\n            table.insert(idx,\
    \ string.find(alphabet, letter))\n        end\n        -- Find the character of\
    \ each index in the alphabet.\n        local new = {}\n        for i = 1, #idx\
    \ do\n            local position = idx[i] + 2\n            if position > #alphabet\
    \ then\n                position = position - #alphabet\n            end\n   \
    \         table.insert(new, string.sub(alphabet, position, position))\n      \
    \  end\n        -- Return the encrypted string.\n        return table.concat(new)\n\
    \    end\n    -- This function will return the string with the capitalization\n\
    \    -- of the original string.\n    local function cap(s)\n        -- This function\
    \ will return the capitalization of a letter.\n        local function caps(s)\n\
    \            local upper = s:upper()\n            if upper == s then\n       \
    \         return '1'\n            else\n                return '0'\n         \
    \   end\n        end\n        -- Find the capitalization of each letter in the\
    \ string.\n        local cap = {}\n        for i = 1, #s do\n            local\
    \ letter = s:sub(i, i)\n            table.insert(cap, caps(letter))\n        end\n\
    \        -- Return the capitalization of the string.\n        return table.concat(cap)\n\
    \    end\n    -- Return the encrypted string with the correct capitalization.\n\
    \    return cap(s) .. rotate(s)\nend", "\ts = string.lower(s)\n\ts = string.gsub(s,\
    \ 'a', 'c')\n\ts = string.gsub(s, 'b', 'd')\n\ts = string.gsub(s, 'c', 'e')\n\t\
    s = string.gsub(s, 'd', 'f')\n\ts = string.gsub(s, 'e', 'g')\n\ts = string.gsub(s,\
    \ 'f', 'h')\n\ts = string.gsub(s, 'g', 'i')\n\ts = string.gsub(s, 'h', 'j')\n\t\
    s = string.gsub(s, 'i', 'k')\n\ts = string.gsub(s, 'j', 'l')\n\ts = string.gsub(s,\
    \ 'k', 'm')\n\ts = string.gsub(s, 'l', 'n')\n\ts = string.gsub(s, 'm', 'o')\n\t\
    s = string.gsub(s, 'n', 'p')\n\ts = string.gsub(s, 'o', 'q')\n\ts = string.gsub(s,\
    \ 'p', 'r')\n\ts = string.gsub(s, 'q', 's')\n\ts = string.gsub(s, 'r', 't')\n\t\
    s = string.gsub(s, 's', 'u')\n\ts = string.gsub(s, 't', 'v')\n\ts = string.gsub(s,\
    \ 'u', 'w')\n\ts = string.gsub(s, 'v', 'x')\n\ts = string.gsub(s, 'w', 'y')\n\t\
    s = string.gsub(s, 'x', 'z')\n\ts = string.gsub(s, 'y', 'a')\n\ts = string.gsub(s,\
    \ 'z', 'b')\n\treturn s\nend", "    local result = {}\n    local start_char =\
    \ string.byte('a')\n    local end_char = string.byte('z')\n    local offset =\
    \ 2 * 2\n    for i = 1, #s do\n        local c = string.byte(s, i)\n        if\
    \ c >= start_char and c <= end_char then\n            c = c + offset\n       \
    \     if c > end_char then\n                c = start_char + (c - end_char) -\
    \ 1\n            end\n        end\n        result[i] = string.char(c)\n    end\n\
    \    return table.concat(result)\nend", "  local s = s\n  local alphabet = {a\
    \ = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8, i = 9, j = 10, k = 11,\
    \ l = 12, m = 13, n = 14, o = 15, p = 16, q = 17, r = 18, s = 19, t = 20, u =\
    \ 21, v = 22, w = 23, x = 24, y = 25, z = 26}\n  local encrypted\n  local length\
    \ = string.len(s)\n  for i = 1, length do\n    local letter = string.sub(s, i,\
    \ i)\n    local letter = alphabet[letter]\n    local number = letter + 2 * 2\n\
    \    if number > 26 then\n      number = number - 26\n    end\n    if number ==\
    \ 1 then\n      encrypted = encrypted .. 'a'\n    elseif number == 2 then\n  \
    \    encrypted = encrypted .. 'b'\n    elseif number == 3 then\n      encrypted\
    \ = encrypted .. 'c'\n    elseif number == 4 then\n      encrypted = encrypted\
    \ .. 'd'\n    elseif number == 5 then\n      encrypted = encrypted .. 'e'\n  \
    \  elseif number == 6 then\n      encrypted = encrypted .. 'f'\n    elseif number\
    \ == 7 then\n      encrypted = encrypted .. 'g'\n    elseif number == 8 then\n\
    \      encrypted = encrypted .. 'h'\n    elseif number == 9 then\n      encrypted\
    \ = encrypted .. 'i'\n    elseif number == 10 then\n      encrypted = encrypted\
    \ .. 'j'\n    elseif number == 11 then\n      encrypted = encrypted .. 'k'\n \
    \   elseif number == 12 then\n      encrypted = encrypted .. 'l'\n    elseif number\
    \ == 13 then\n      encrypted = encrypted .. 'm'\n    elseif number == 14 then\n\
    \      encrypted = encrypted .. 'n'\n    elseif number == 15 then\n      encrypted\
    \ = encrypted .. 'o'\n    elseif number == 16 then\n      encrypted = encrypted\
    \ .. 'p'\n    elseif number == 17 then\n      encrypted = encrypted .. 'q'\n \
    \   elseif number == 18 then\n      encrypted = encrypted .. 'r'\n    elseif number\
    \ == 19 then\n      encrypted = encrypted .. 's", "  s = s:lower()\n  local e\
    \ = ''\n  for i = 1, #s do\n    local c = s:sub(i, i)\n    local p = char_pos[c]\n\
    \    if p then\n      e = e .. CHARACTERS[(p + (2 * 2)) % #CHARACTERS + 1]\n \
    \   else\n      e = e .. c\n    end\n  end\n  return e\nend", "  local len = #s\n\
    \  local t = {}\n  for i = 1, len do\n    t[i] = s:sub(i, i)\n  end\n  for i =\
    \ 1, len do\n    if t[i] == 'z' then\n      t[i] = 'b'\n    elseif t[i] == 'y'\
    \ then\n      t[i] = 'a'\n    else\n      t[i] = string.char(string.byte(t[i])\
    \ + 2)\n    end\n  end\n  return table.concat(t)\nend", "  -- YOUR CODE GOES HERE\n\
    end", "    error(\"Not implemented\")\nend", "    local string1 = {}\n    local\
    \ string2 = {}\n    local string3 = {}\n    local t = {}\n    local v = {}\n \
    \   local c = 1\n    local u = 1\n    for i = 1,string.len(s) do\n        table.insert(string1,string.sub(s,i,i))\n\
    \    end\n    for _,i in ipairs(string1) do\n        local a = string.byte(i)\n\
    \        if a >= 97 and a <= 122 then\n            local b = a + (2 * 2)\n   \
    \         if b > 122 then\n                local b = (b - 122) + 96\n        \
    \        table.insert(string2,string.char(b))\n            else\n            \
    \    table.insert(string2,string.char(b))\n            end\n        elseif a >=\
    \ 65 and a <= 90 then\n            local b = a + (2 * 2)\n            if b > 90\
    \ then\n                local b = (b - 90) + 64\n                table.insert(string2,string.char(b))\n\
    \            else\n                table.insert(string2,string.char(b))\n    \
    \        end\n        else\n            table.insert(string2,string.char(a))\n\
    \        end\n    end\n    for _,j in ipairs(string2) do\n        local a = string.byte(j)\n\
    \        if a >= 97 and a <= 122 then\n            local b = a + (2 * 2)\n   \
    \         if b > 122 then\n                local b = (b - 122) + 96\n        \
    \        table.insert(string3,string.char(b))\n            else\n            \
    \    table.insert(string3,string.char(b))\n            end\n        elseif a >=\
    \ 65 and a <= 90 then\n            local b = a + (2 * 2)\n            if b > 90\
    \ then\n                local b = (b - 90) + 64\n                table.insert(string3,string.char(b))\n\
    \            else\n                table.insert(string3,string.char(b))\n    \
    \        end\n        else\n            table.insert(string3,string.char(a))\n\
    \        end\n    end\n    for _,k in ipairs(string3) do\n        local a =",
  "  local t = {}\n  local l = string.len(s)\n  for i = 1, l do\n    local c = string.byte(s,\
    \ i)\n    if c >= 97 and c <= 109 then\n      c = c + 20\n    elseif c >= 110\
    \ and c <= 122 then\n      c = c - 4\n    end\n    t[i] = string.char(c)\n  end\n\
    \  return table.concat(t)\nend", "    local rotated_alphabet = 'cdefghijklmnopqrstuvwxyzab'\n\
    \    local key = {}\n    for i = 1, #ALPHABET do\n        key[ALPHABET:sub(i,\
    \ i)] = rotated_alphabet:sub(i, i)\n    end\n    local res = {}\n    for c in\
    \ s:gmatch('.') do\n        res[#res + 1] = key[c]\n    end\n    return table.concat(res)\n\
    end", "  return nil\nend", "    local str = \"\"\n    for i = 1, #s do\n     \
    \   local ascii = string.byte(s, i)\n        local intVal = ascii - 97\n     \
    \   intVal = (intVal + 2) % 26\n        ascii = intVal + 97\n        str = str\
    \ .. string.char(ascii)\n    end\n    return str\nend", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  local start_index = 1\n  local new_string = ''\n  local ch\n  while start_index\
    \ <= #s do\n    ch = string.sub(s, start_index, start_index)\n    local index\
    \ = string.find(alphabet, ch)\n    if index then\n      index = index + #alphabet\
    \ / 2\n      if index > #alphabet then\n        index = index - #alphabet\n  \
    \    end\n      new_string = new_string .. string.sub(alphabet, index, index)\n\
    \    else\n      new_string = new_string .. ch\n    end\n    start_index = start_index\
    \ + 1\n  end\n  return new_string\nend", "    local ret = \"\"\n    local alpha\
    \ = getAlpha()\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        local\
    \ idx = alpha:find(c)\n        if idx then\n            local offset = math.floor((idx\
    \ - 1) / 2) * 2\n            local newIdx = offset + 2 + (idx - offset)\n    \
    \        ret = ret .. alpha:sub(newIdx, newIdx)\n        else\n            ret\
    \ = ret .. c\n        end\n    end\n    return ret\nend", end, "   return string.char(string.byte(s,\
    \ 1) + 2, string.byte(s, 2) + 2)\nend", "    local t = {}\n    for i=1,#s do\n\
    \        table.insert(t, string.char(string.byte(s,i)+string.byte(s,i)-96))\n\
    \    end\n    return table.concat(t)\nend", "\treturn \"ewhjklnop\"\nend", " \
    \ -- body\nend", "  local result = {}\n  for i=1,#s do\n    local n = string.byte(s,i)\n\
    \    n = n + (n-96)*2\n    n = n % 26\n    if n == 0 then n = 26 end\n    table.insert(result,string.char(n+96))\n\
    \  end\n  return table.concat(result)\nend", "    local alphabet = {}\n    for\
    \ i = 1, 26 do\n        alphabet[i] = {}\n        alphabet[i][1] = string.char(96\
    \ + i)\n        alphabet[i][2] = string.char(96 + (i + 2 * 2) % 26)\n    end\n\
    \    local encrypted = ''\n    for c in s:gmatch('.') do\n        for i = 1, 26\
    \ do\n            if c == alphabet[i][1] then\n                encrypted = encrypted\
    \ .. alphabet[i][2]\n            end\n        end\n    end\n    return encrypted\n\
    end", "   -- your code here\nend", "  local newString = ''\n  for i = 1,#s do\n\
    \    local newChar = (string.byte(s,i) + 2*2)\n    newString = newString .. string.char(newChar)\n\
    \  end\n  return newString\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local encrypted = ''\n    local len = string.len(s)\n    for i = 1, len do\n\
    \        local ch = string.sub(s, i, i)\n        local letter = string.find(alphabet,\
    \ ch)\n        local newLetter = letter + (2 * 2)\n        if newLetter > 26 then\n\
    \            newLetter = newLetter - 26\n        end\n        encrypted = encrypted\
    \ .. string.sub(alphabet, newLetter, newLetter)\n    end\n    return encrypted\n\
    end", "\ts = s:lower()\n\tlocal encrypted = ''\n\tfor i = 1,#s do\n\t\tlocal code\
    \ = s:byte(i)\n\t\tlocal shifted = code + 2 * 2\n\t\tif shifted > 122 then\n\t\
    \t\tshifted = shifted - 26\n\t\tend\n\t\tif shifted < 97 then\n\t\t\tshifted =\
    \ shifted + 26\n\t\tend\n\t\tencrypted = encrypted .. string.char(shifted)\n\t\
    end\n\treturn encrypted\nend", "    local result = ''\n    for i = 1, #s do\n\
    \        local char = s:sub(i, i)\n        local ascii = char:byte()\n       \
    \ if ascii < 98 then\n            ascii = ascii + 24\n        else\n         \
    \   ascii = ascii - 2\n        end\n        result = result .. string.char(ascii)\n\
    \    end\n    return result\nend", "\tif (s == nil) then return s end\n\tlocal\
    \ cipher = {}\n\tfor i=1,#s do\n\t\tcipher[i] = s:sub(i,i):byte() + (2 * 2)\n\t\
    \tif (cipher[i] > 122) then\n\t\t\tcipher[i] = cipher[i] - 26\n\t\tend\n\tend\n\
    \treturn string.char(unpack(cipher))\nend", "\tlocal ord = {}\n\tlocal inx = 0\n\
    \tfor x in s:gmatch'.' do\n\t\tord[inx] = x:byte()\n\t\tinx = inx + 1\n\tend\n\
    \tfor i, v in ipairs(ord) do\n\t\tif v > 122 or v > 90 and v < 97 then\n\t\t\t\
    ord[i] = (v + 5) % 122 + 96\n\t\telse\n\t\t\tord[i] = (v + 3) % 122 + 96\n\t\t\
    end\n\tend\n\treturn string.char(unpack(ord))\nend", "    local alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n    local lower = string.lower(s)\n    local e =\
    \ \"\"\n    for i = 1, #lower do\n        local c = string.sub(lower, i, i)\n\
    \        local pos = string.find(alphabet, c)\n        if pos == nil then\n  \
    \          e = e .. c\n        else\n            local r = pos + 2 * 2\n     \
    \       if r > #alphabet then\n                r = r - #alphabet\n           \
    \ end\n            local echar = string.sub(alphabet, r, r)\n            e = e\
    \ .. echar\n        end\n    end\n    return e\nend", "  return rot(s, 2)\nend",
  "  return s:gsub(\".\", function(c)\n    local l = c:byte()\n    if l <= 122 and\
    \ l >= 97 then\n      return (l + 4 > 122) and string.char(l - 22) or string.char(l\
    \ + 4)\n    elseif l <= 90 and l >= 65 then\n      return (l + 4 > 90) and string.char(l\
    \ - 22) or string.char(l + 4)\n    else\n      return c\n    end\n  end)\nend",
  "    local res = ''\n    for i = 1, #s do\n        res = res .. string.char(string.byte(s,\
    \ i) + 2 * 2)\n    end\n    return res\nend", "    local a = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local b = a:sub(3) .. a:sub(1,2)\n    return s:gsub('.', function(c) return\
    \ b:sub(a:find(c, 1, true)) end)\nend\nprint(encrypt('hi'))\nprint(encrypt('asdfghjkl'))\n\
    print(encrypt('gf'))\nprint(encrypt('et'))", "    return s:gsub('.', function(s)\
    \ return string.char(string.byte(s) + 2) end)\nend", "    -- TODO\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
