name: HumanEval_136_largest_smallest_integers
language: lua
prompt: "-- Create a function that returns a table (a, b), where 'a' is\n-- the largest\
  \ of negative integers, and 'b' is the smallest\n-- of positive integers in a table.\n\
  -- If there is no negative or positive integers, return them as None.\n-- Examples:\n\
  -- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n\
  -- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function\
  \ largest_smallest_integers(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_smallest_integers\n\
  \    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})\n    lu.assertEquals(candidate({2,\
  \ 4, 1, 3, 5, 7, 0}), {None, 1})\n    lu.assertEquals(candidate({1, 3, 2, 4, 5,\
  \ 6, -2}), {-2, 1})\n    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7,\
  \ 2})\n    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})\n    lu.assertEquals(candidate({}),\
  \ {None, None})\n    lu.assertEquals(candidate({0}), {None, None})\n    lu.assertEquals(candidate({-1,\
  \ -3, -5, -6}), {-1, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6, 0}),\
  \ {-1, None})\n    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})\n  \
  \  lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local a, b = None, None\n    for _, i in ipairs(lst) do\n     \
    \   if i < 0 and a == None then\n            a = i\n        elseif i < 0 and a\
    \ < i then\n            a = i\n        elseif i > 0 and b == None then\n     \
    \       b = i\n        elseif i > 0 and b > i then\n            b = i\n      \
    \  end\n    end\n    return {a, b}\nend", "    local smallest, largest\n    for\
    \ _, v in ipairs(lst) do\n        if v > 0 then\n            if smallest == nil\
    \ or v < smallest then\n                smallest = v\n            end\n      \
    \  elseif v < 0 then\n            if largest == nil or v > largest then\n    \
    \            largest = v\n            end\n        end\n    end\n    return {largest,\
    \ smallest}\nend", "    if #lst == 0 then\n        return {None, None}\n    end\n\
    \    local largest = -1\n    local smallest = 1\n    for _, v in ipairs(lst) do\n\
    \        if v > 0 then\n            if v < smallest then\n                smallest\
    \ = v\n            end\n        elseif v < 0 then\n            if v > largest\
    \ then\n                largest = v\n            end\n        end\n    end\n \
    \   if largest == -1 then\n        largest = None\n    end\n    if smallest ==\
    \ 1 then\n        smallest = None\n    end\n    return {largest, smallest}\nend",
  "  local largest = None\n  local smallest = None\n  for _, v in ipairs(lst) do\n\
    \    if v < 0 then\n      if largest == None or v > largest then\n        largest\
    \ = v\n      end\n    elseif v > 0 then\n      if smallest == None or v < smallest\
    \ then\n        smallest = v\n      end\n    end\n  end\n  return {largest, smallest}\n\
    end", "  local largest_negative = nil\n  local smallest_positive = nil\n  for\
    \ _, value in ipairs(lst) do\n    if value > 0 then\n      if smallest_positive\
    \ == nil or value < smallest_positive then\n        smallest_positive = value\n\
    \      end\n    elseif value < 0 then\n      if largest_negative == nil or value\
    \ > largest_negative then\n        largest_negative = value\n      end\n    end\n\
    \  end\n  return {largest_negative, smallest_positive}\nend", "\tlocal min = nil\n\
    \tlocal max = nil\n\tfor _, num in ipairs(lst) do\n\t\tif num > 0 then\n\t\t\t\
    if not min or num < min then\n\t\t\t\tmin = num\n\t\t\tend\n\t\telseif num < 0\
    \ then\n\t\t\tif not max or num > max then\n\t\t\t\tmax = num\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn {max, min}\nend", "    local negatives = {}\n    local positives\
    \ = {}\n    for _, v in ipairs(lst) do\n        if v < 0 then\n            table.insert(negatives,\
    \ v)\n        elseif v > 0 then\n            table.insert(positives, v)\n    \
    \    end\n    end\n    local a = #negatives > 0 and table.max(negatives) or nil\n\
    \    local b = #positives > 0 and table.min(positives) or nil\n    return {a,\
    \ b}\nend", "  --[[\n  local biggest_negative, smallest_positive = None, None\n\
    \  for i = 1, #lst do\n    local x = lst[i]\n    if x < 0 and (biggest_negative\
    \ == None or x > biggest_negative) then\n      biggest_negative = x\n    elseif\
    \ x > 0 and (smallest_positive == None or x < smallest_positive) then\n      smallest_positive\
    \ = x\n    end\n  end\n  return {biggest_negative, smallest_positive}\n  --]]\n\
    \  -- It can be done with one loop:\n  local biggest_negative, smallest_positive\
    \ = None, None\n  for i = 1, #lst do\n    local x = lst[i]\n    if x < 0 then\n\
    \      if biggest_negative == None or x > biggest_negative then\n        biggest_negative\
    \ = x\n      end\n    elseif x > 0 then\n      if smallest_positive == None or\
    \ x < smallest_positive then\n        smallest_positive = x\n      end\n    end\n\
    \  end\n  return {biggest_negative, smallest_positive}\nend", "    -- body\nend",
  "    return { }\nend", "    if #lst == 0 then\n        return {None, None}\n   \
    \ end\n    local ans = {None, None}\n    for _, v in ipairs(lst) do\n        if\
    \ v > 0 then\n            if ans[2] == None or v < ans[2] then\n             \
    \   ans[2] = v\n            end\n        elseif v < 0 then\n            if ans[1]\
    \ == None or v > ans[1] then\n                ans[1] = v\n            end\n  \
    \      end\n    end\n    return ans\nend", "\tlocal ls, s, l\n\tfor k, v in pairs(lst)\
    \ do\n\t\tif v > 0 then\n\t\t\tif not s or v < s then\n\t\t\t\ts = v\n\t\t\tend\n\
    \t\telseif v < 0 then\n\t\t\tif not l or v > l then\n\t\t\t\tl = v\n\t\t\tend\n\
    \t\tend\n\tend\n\tif not l then\n\t\tl = None\n\tend\n\tif not s then\n\t\ts =\
    \ None\n\tend\n\treturn {l, s}\nend", "  lst = table.sort(lst)\n  local a = nil\n\
    \  local b = nil\n  local found = false\n  for i = 1, #lst do\n    if lst[i] <\
    \ 0 then\n      a = lst[i]\n      found = true\n    elseif lst[i] > 0 and not\
    \ found then\n      b = lst[i]\n    end\n  end\n  return {a, b}\nend", "\tlocal\
    \ largest_neg = None\n\tlocal smallest_pos = None\n\tfor i = 1, len(lst) do\n\t\
    \tlocal cur = lst[i]\n\t\tif cur < 0 then\n\t\t\tif largest_neg == None or cur\
    \ > largest_neg then\n\t\t\t\tlargest_neg = cur\n\t\t\tend\n\t\telseif cur > 0\
    \ then\n\t\t\tif smallest_pos == None or cur < smallest_pos then\n\t\t\t\tsmallest_pos\
    \ = cur\n\t\t\tend\n\t\tend\n\tend\n\treturn {largest_neg, smallest_pos}\nend",
  "  local min_positive, max_negative = nil, nil\n  for _, val in ipairs(lst) do\n\
    \    if val > 0 then\n      if min_positive == nil or val < min_positive then\n\
    \        min_positive = val\n      end\n    elseif val < 0 then\n      if max_negative\
    \ == nil or val > max_negative then\n        max_negative = val\n      end\n \
    \   end\n  end\n  return {max_negative, min_positive}\nend", "  local max = None\n\
    \  local min = None\n  local function is_positive(x)\n    return x > 0\n  end\n\
    \  local function is_negative(x)\n    return x < 0\n  end\n  local function is_integers(x)\n\
    \    return x % 1 == 0\n  end\n  for _, val in ipairs(lst) do\n    if is_integers(val)\
    \ then\n      if max == None and is_negative(val) then\n        max = val\n  \
    \    elseif min == None and is_positive(val) then\n        min = val\n      elseif\
    \ is_negative(val) and val > max then\n        max = val\n      elseif is_positive(val)\
    \ and val < min then\n        min = val\n      end\n    end\n  end\n  return {max,\
    \ min}\nend", "  return {None, None}\nend", "\tlocal a, b\n\tfor _, v in ipairs(lst)\
    \ do\n\t\tif v >= 0 then\n\t\t\tif not b or v < b then\n\t\t\t\tb = v\n\t\t\t\
    end\n\t\telse\n\t\t\tif not a or v > a then\n\t\t\t\ta = v\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn {a, b}\nend", "    local a, b = None, None\n    for i = 1, #lst\
    \ do\n        if lst[i] < 0 and (a == None or lst[i] > a) then\n            a\
    \ = lst[i]\n        elseif lst[i] > 0 and (b == None or lst[i] < b) then\n   \
    \         b = lst[i]\n        end\n    end\n    return {a, b}\nend", "    -- your\
    \ code here\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
