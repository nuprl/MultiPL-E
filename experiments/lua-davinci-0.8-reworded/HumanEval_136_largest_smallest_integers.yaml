name: HumanEval_136_largest_smallest_integers
language: lua
prompt: "-- Create a function that returns a table (a, b), where 'a' is\n-- the largest\
  \ of negative integers, and 'b' is the smallest\n-- of positive integers in a table.\n\
  -- If there is no negative or positive integers, return them as None.\n-- Examples:\n\
  -- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n\
  -- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function\
  \ largest_smallest_integers(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_smallest_integers\n\
  \    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})\n    lu.assertEquals(candidate({2,\
  \ 4, 1, 3, 5, 7, 0}), {None, 1})\n    lu.assertEquals(candidate({1, 3, 2, 4, 5,\
  \ 6, -2}), {-2, 1})\n    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7,\
  \ 2})\n    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})\n    lu.assertEquals(candidate({}),\
  \ {None, None})\n    lu.assertEquals(candidate({0}), {None, None})\n    lu.assertEquals(candidate({-1,\
  \ -3, -5, -6}), {-1, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6, 0}),\
  \ {-1, None})\n    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})\n  \
  \  lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local a, b = None, None\n    for _, i in ipairs(lst) do\n     \
    \   if i < 0 and a == None then\n            a = i\n        elseif i < 0 and a\
    \ < i then\n            a = i\n        elseif i > 0 and b == None then\n     \
    \       b = i\n        elseif i > 0 and b > i then\n            b = i\n      \
    \  end\n    end\n    return {a, b}\nend", "    local smallest, largest\n    for\
    \ _, v in ipairs(lst) do\n        if v > 0 then\n            if smallest == nil\
    \ or v < smallest then\n                smallest = v\n            end\n      \
    \  elseif v < 0 then\n            if largest == nil or v > largest then\n    \
    \            largest = v\n            end\n        end\n    end\n    return {largest,\
    \ smallest}\nend", "    if #lst == 0 then\n        return {None, None}\n    end\n\
    \    local largest = -1\n    local smallest = 1\n    for _, v in ipairs(lst) do\n\
    \        if v > 0 then\n            if v < smallest then\n                smallest\
    \ = v\n            end\n        elseif v < 0 then\n            if v > largest\
    \ then\n                largest = v\n            end\n        end\n    end\n \
    \   if largest == -1 then\n        largest = None\n    end\n    if smallest ==\
    \ 1 then\n        smallest = None\n    end\n    return {largest, smallest}\nend",
  "  local largest = None\n  local smallest = None\n  for _, v in ipairs(lst) do\n\
    \    if v < 0 then\n      if largest == None or v > largest then\n        largest\
    \ = v\n      end\n    elseif v > 0 then\n      if smallest == None or v < smallest\
    \ then\n        smallest = v\n      end\n    end\n  end\n  return {largest, smallest}\n\
    end", "  local largest_negative = nil\n  local smallest_positive = nil\n  for\
    \ _, value in ipairs(lst) do\n    if value > 0 then\n      if smallest_positive\
    \ == nil or value < smallest_positive then\n        smallest_positive = value\n\
    \      end\n    elseif value < 0 then\n      if largest_negative == nil or value\
    \ > largest_negative then\n        largest_negative = value\n      end\n    end\n\
    \  end\n  return {largest_negative, smallest_positive}\nend", "\tlocal min = nil\n\
    \tlocal max = nil\n\tfor _, num in ipairs(lst) do\n\t\tif num > 0 then\n\t\t\t\
    if not min or num < min then\n\t\t\t\tmin = num\n\t\t\tend\n\t\telseif num < 0\
    \ then\n\t\t\tif not max or num > max then\n\t\t\t\tmax = num\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn {max, min}\nend", "    local negatives = {}\n    local positives\
    \ = {}\n    for _, v in ipairs(lst) do\n        if v < 0 then\n            table.insert(negatives,\
    \ v)\n        elseif v > 0 then\n            table.insert(positives, v)\n    \
    \    end\n    end\n    local a = #negatives > 0 and table.max(negatives) or nil\n\
    \    local b = #positives > 0 and table.min(positives) or nil\n    return {a,\
    \ b}\nend", "  --[[\n  local biggest_negative, smallest_positive = None, None\n\
    \  for i = 1, #lst do\n    local x = lst[i]\n    if x < 0 and (biggest_negative\
    \ == None or x > biggest_negative) then\n      biggest_negative = x\n    elseif\
    \ x > 0 and (smallest_positive == None or x < smallest_positive) then\n      smallest_positive\
    \ = x\n    end\n  end\n  return {biggest_negative, smallest_positive}\n  --]]\n\
    \  -- It can be done with one loop:\n  local biggest_negative, smallest_positive\
    \ = None, None\n  for i = 1, #lst do\n    local x = lst[i]\n    if x < 0 then\n\
    \      if biggest_negative == None or x > biggest_negative then\n        biggest_negative\
    \ = x\n      end\n    elseif x > 0 then\n      if smallest_positive == None or\
    \ x < smallest_positive then\n        smallest_positive = x\n      end\n    end\n\
    \  end\n  return {biggest_negative, smallest_positive}\nend", "    -- body\nend",
  "    return { }\nend", "    if #lst == 0 then\n        return {None, None}\n   \
    \ end\n    local ans = {None, None}\n    for _, v in ipairs(lst) do\n        if\
    \ v > 0 then\n            if ans[2] == None or v < ans[2] then\n             \
    \   ans[2] = v\n            end\n        elseif v < 0 then\n            if ans[1]\
    \ == None or v > ans[1] then\n                ans[1] = v\n            end\n  \
    \      end\n    end\n    return ans\nend", "\tlocal ls, s, l\n\tfor k, v in pairs(lst)\
    \ do\n\t\tif v > 0 then\n\t\t\tif not s or v < s then\n\t\t\t\ts = v\n\t\t\tend\n\
    \t\telseif v < 0 then\n\t\t\tif not l or v > l then\n\t\t\t\tl = v\n\t\t\tend\n\
    \t\tend\n\tend\n\tif not l then\n\t\tl = None\n\tend\n\tif not s then\n\t\ts =\
    \ None\n\tend\n\treturn {l, s}\nend", "  lst = table.sort(lst)\n  local a = nil\n\
    \  local b = nil\n  local found = false\n  for i = 1, #lst do\n    if lst[i] <\
    \ 0 then\n      a = lst[i]\n      found = true\n    elseif lst[i] > 0 and not\
    \ found then\n      b = lst[i]\n    end\n  end\n  return {a, b}\nend", "\tlocal\
    \ largest_neg = None\n\tlocal smallest_pos = None\n\tfor i = 1, len(lst) do\n\t\
    \tlocal cur = lst[i]\n\t\tif cur < 0 then\n\t\t\tif largest_neg == None or cur\
    \ > largest_neg then\n\t\t\t\tlargest_neg = cur\n\t\t\tend\n\t\telseif cur > 0\
    \ then\n\t\t\tif smallest_pos == None or cur < smallest_pos then\n\t\t\t\tsmallest_pos\
    \ = cur\n\t\t\tend\n\t\tend\n\tend\n\treturn {largest_neg, smallest_pos}\nend",
  "  local min_positive, max_negative = nil, nil\n  for _, val in ipairs(lst) do\n\
    \    if val > 0 then\n      if min_positive == nil or val < min_positive then\n\
    \        min_positive = val\n      end\n    elseif val < 0 then\n      if max_negative\
    \ == nil or val > max_negative then\n        max_negative = val\n      end\n \
    \   end\n  end\n  return {max_negative, min_positive}\nend", "  local max = None\n\
    \  local min = None\n  local function is_positive(x)\n    return x > 0\n  end\n\
    \  local function is_negative(x)\n    return x < 0\n  end\n  local function is_integers(x)\n\
    \    return x % 1 == 0\n  end\n  for _, val in ipairs(lst) do\n    if is_integers(val)\
    \ then\n      if max == None and is_negative(val) then\n        max = val\n  \
    \    elseif min == None and is_positive(val) then\n        min = val\n      elseif\
    \ is_negative(val) and val > max then\n        max = val\n      elseif is_positive(val)\
    \ and val < min then\n        min = val\n      end\n    end\n  end\n  return {max,\
    \ min}\nend", "  return {None, None}\nend", "\tlocal a, b\n\tfor _, v in ipairs(lst)\
    \ do\n\t\tif v >= 0 then\n\t\t\tif not b or v < b then\n\t\t\t\tb = v\n\t\t\t\
    end\n\t\telse\n\t\t\tif not a or v > a then\n\t\t\t\ta = v\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn {a, b}\nend", "    local a, b = None, None\n    for i = 1, #lst\
    \ do\n        if lst[i] < 0 and (a == None or lst[i] > a) then\n            a\
    \ = lst[i]\n        elseif lst[i] > 0 and (b == None or lst[i] < b) then\n   \
    \         b = lst[i]\n        end\n    end\n    return {a, b}\nend", "    -- your\
    \ code here\nend", "\t-- body\nend", end, "    local min, max = nil, nil\n   \
    \ for _, v in ipairs(lst) do\n        if v > 0 then\n            if min == nil\
    \ or v < min then\n                min = v\n            end\n        elseif v\
    \ < 0 then\n            if max == nil or v > max then\n                max = v\n\
    \            end\n        end\n    end\n    return {max, min}\nend", "    local\
    \ sorted = table.sort(lst)\n    local largest = None\n    local smallest = None\n\
    \    for i,v in pairs(sorted) do\n        if largest and smallest then\n     \
    \       if v > largest then\n                largest = v\n            end\n  \
    \          if v < smallest then\n                smallest = v\n            end\n\
    \        elseif v < 0 then\n            largest = v\n        elseif v > 0 then\n\
    \            smallest = v\n        end\n    end\n    return {largest, smallest}\n\
    end", "  -- insert your code here\n  local neg = {}\n  local pos = {}\n  for _,\
    \ num in ipairs(lst) do\n    if num > 0 then\n      pos[#pos + 1] = num\n    elseif\
    \ num < 0 then\n      neg[#neg + 1] = num\n    end\n  end\n  local a, b\n  if\
    \ #neg > 0 then\n    a = math.max(unpack(neg))\n  end\n  if #pos > 0 then\n  \
    \  b = math.min(unpack(pos))\n  end\n  return {a, b}\nend", "  lst = list.filter(lst,\
    \ is_integer)\n  lst = list.sort(lst)\n  local a, b = None, None\n  for _, v in\
    \ ipairs(lst) do\n    if v < 0 then\n      a = math.max(a, v)\n    elseif v >\
    \ 0 then\n      b = math.min(b, v)\n    end\n  end\n  return {a, b}\nend", " \
    \   return {None, None}\nend", "\treturn {nil, nil}\nend", "    -- your code here\n\
    \    local largest = 0\n    local smallest = 0\n    local flag = false\n    local\
    \ flag_s = false\n    local flag_l = false\n    for i, v in ipairs(lst) do\n \
    \       if (v > 0) then\n            flag_s = true\n            if (flag == false)\
    \ then\n                smallest = v\n                flag = true\n          \
    \  else\n                if (v < smallest) then\n                    smallest\
    \ = v\n                end\n            end\n        elseif (v < 0) then\n   \
    \         flag_l = true\n            if (flag == false) then\n               \
    \ largest = v\n                flag = true\n            else\n               \
    \ if (v > largest) then\n                    largest = v\n                end\n\
    \            end\n        end\n    end\n    if (flag_s == false) then\n      \
    \  smallest = nil\n    end\n    if (flag_l == false) then\n        largest = nil\n\
    \    end\n    return {largest, smallest}\nend", "    return {None, None}\nend",
  "  -- return {None, None}\n  -- END\n  local large, small\n  for _, v in ipairs(lst)\
    \ do\n    if not large and v < 0 then\n      large = v\n    elseif v < 0 and v\
    \ > large then\n      large = v\n    end\n    if not small and v > 0 then\n  \
    \    small = v\n    elseif v > 0 and v < small then\n      small = v\n    end\n\
    \  end\n  return {large, small}\nend", end, "    local a, b\n    for i, v in ipairs(lst)\
    \ do\n        if v < 0 then\n            if a == nil or v > a then\n         \
    \       a = v\n            end\n        elseif v > 0 then\n            if b ==\
    \ nil or v < b then\n                b = v\n            end\n        end\n   \
    \ end\n    return {a, b}\nend", "    error('Not implemented')\nend", "    local\
    \ minimum, maximum = nil, nil\n    for _, v in ipairs(lst) do\n        if v <\
    \ 0 then\n            if not minimum or v > minimum then\n                minimum\
    \ = v\n            end\n        elseif v > 0 then\n            if not maximum\
    \ or v < maximum then\n                maximum = v\n            end\n        end\n\
    \    end\n    return {minimum, maximum}\nend", "\tlocal positive = nil\n\tlocal\
    \ negative = nil\n\tfor i = 1, #lst do\n\t\tif lst[i] >= 0 then\n\t\t\tif not\
    \ positive or lst[i] < positive then\n\t\t\t\tpositive = lst[i]\n\t\t\tend\n\t\
    \telse\n\t\t\tif not negative or lst[i] > negative then\n\t\t\t\tnegative = lst[i]\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn {negative, positive}\nend", "    -- Write\
    \ your code here\nend", end, "    local largest_neg = nil\n    local smallest_pos\
    \ = nil\n    for _, v in ipairs(lst) do\n        if v < 0 then\n            if\
    \ largest_neg == nil or v > largest_neg then\n                largest_neg = v\n\
    \            end\n        elseif v > 0 then\n            if smallest_pos == nil\
    \ or v < smallest_pos then\n                smallest_pos = v\n            end\n\
    \        end\n    end\n    return {largest_neg, smallest_pos}\nend", "  -- Implement\
    \ your function here\n  -- Find the first negative and postive integer\n  local\
    \ smallestPositive = nil\n  local largestNegative = nil\n  for i = 1, #lst do\n\
    \    if (lst[i] > 0) and (smallestPositive == nil or lst[i] < smallestPositive)\
    \ then\n      smallestPositive = lst[i]\n    end\n    if (lst[i] < 0) and (largestNegative\
    \ == nil or lst[i] > largestNegative) then\n      largestNegative = lst[i]\n \
    \   end\n  end\n  return {largestNegative, smallestPositive}\nend", "  -- Fill\
    \ in here\n  local smallest = nil\n  local largest = nil\n  for key,val in pairs(lst)\
    \ do\n    if val > 0 then\n      if smallest == nil then\n        smallest = val\n\
    \      elseif val < smallest then\n        smallest = val\n      end\n    elseif\
    \ val < 0 then\n      if largest == nil then\n        largest = val\n      elseif\
    \ val > largest then\n        largest = val\n      end\n    end\n  end\n  return\
    \ {largest, smallest}\nend", "\treturn {nil, nil}\nend", "    local min = nil\n\
    \    local max = nil\n    for i = 1, #lst do\n        local v = lst[i]\n     \
    \   if v > 0 then\n            if min == nil or v < min then\n               \
    \ min = v\n            end\n        elseif v < 0 then\n            if max == nil\
    \ or v > max then\n                max = v\n            end\n        end\n   \
    \ end\n    return {max, min}\nend", "    local largest_negative, smallest_positive\n\
    \    for _, value in ipairs(lst) do\n        if value < 0 then\n            if\
    \ largest_negative == nil or value > largest_negative then\n                largest_negative\
    \ = value\n            end\n        elseif value > 0 then\n            if smallest_positive\
    \ == nil or value < smallest_positive then\n                smallest_positive\
    \ = value\n            end\n        end\n    end\n    return {largest_negative,\
    \ smallest_positive}\nend", "  local n_max, n_min, p_max, p_min = -math.huge,\
    \ math.huge, math.huge, -math.huge\n  for i = 1, #lst do\n    if lst[i] > 0 then\n\
    \      if lst[i] < p_min then\n        p_min = lst[i]\n      end\n      if lst[i]\
    \ > p_max then\n        p_max = lst[i]\n      end\n    elseif lst[i] < 0 then\n\
    \      if lst[i] > n_max then\n        n_max = lst[i]\n      end\n      if lst[i]\
    \ < n_min then\n        n_min = lst[i]\n      end\n    end\n  end\n  if n_max\
    \ == -math.huge then\n    n_max = nil\n  end\n  if n_min == math.huge then\n \
    \   n_min = nil\n  end\n  if p_max == math.huge then\n    p_max = nil\n  end\n\
    \  if p_min == -math.huge then\n    p_min = nil\n  end\n  return {n_max, n_min,\
    \ p_max, p_min}\nend", "    -- Code here\nend", "    local min, max\n    for _,\
    \ v in ipairs(lst) do\n        if v > 0 then\n            if min == nil or v <\
    \ min then\n                min = v\n            end\n        elseif v < 0 then\n\
    \            if max == nil or v > max then\n                max = v\n        \
    \    end\n        end\n    end\n    return {max, min}\nend", "    -- How to find\
    \ the largest of negative integers and the smallest of positive ones\n    -- in\
    \ a list?\n    -- To do this, we need to find positive numbers, find negative\
    \ numbers\n    -- and then compare these numbers.\n    -- To find positive numbers,\
    \ write a function that takes a number and a list,\n    -- adds this number to\
    \ the list if it is positive, otherwise returns the list.\n    -- Do the same\
    \ for negative numbers.\n    -- Then, to find the largest of negative integers\
    \ and the smallest of positive ones,\n    -- pass our list to these functions.\n\
    \    local function is_positive(t, e)\n        if e > 0 then\n            table.insert(t,\
    \ e)\n        end\n        return t\n    end", "  if next(lst) == nil then\n \
    \   return {None, None}\n  end\n  -- negative numbers\n  local neg = {}\n  for\
    \ k, v in pairs(lst) do\n    if v < 0 then\n      table.insert(neg, v)\n    end\n\
    \  end\n  -- positive numbers\n  local pos = {}\n  for k, v in pairs(lst) do\n\
    \    if v > 0 then\n      table.insert(pos, v)\n    end\n  end\n  local a = None\n\
    \  local b = None\n  if next(neg) ~= nil then\n    a = neg[1]\n    for k, v in\
    \ pairs(neg) do\n      if v > a then\n        a = v\n      end\n    end\n  end\n\
    \  if next(pos) ~= nil then\n    b = pos[1]\n    for k, v in pairs(pos) do\n \
    \     if v < b then\n        b = v\n      end\n    end\n  end\n  return {a, b}\n\
    end", end, "  -- Fill here!\n  return nil\nend", "  local neg = math.huge\n  local\
    \ pos = -math.huge\n  for _, v in ipairs(lst) do\n    if v < 0 then\n      neg\
    \ = math.max(neg, v)\n    elseif v > 0 then\n      pos = math.min(pos, v)\n  \
    \  end\n  end\n  if neg == math.huge then\n    neg = nil\n  end\n  if pos == -math.huge\
    \ then\n    pos = nil\n  end\n  return {neg, pos}\nend", "    return {0, 0}\n\
    end", "  error(\"Not implemented\")\nend", "    local a, b = nil, nil\n    for\
    \ _, i in ipairs(lst) do\n        if i < 0 then\n            if not a or i > a\
    \ then\n                a = i\n            end\n        elseif i > 0 then\n  \
    \          if not b or i < b then\n                b = i\n            end\n  \
    \      end\n    end\n    return {a, b}\nend", "    -- your code goes here\nend",
  "  local smallest_positive_integer = nil\n  local largest_negative_integer = nil\n\
    \  for _, n in ipairs(lst) do\n    if n > 0 then\n      if smallest_positive_integer\
    \ == nil or n < smallest_positive_integer then\n        smallest_positive_integer\
    \ = n\n      end\n    elseif n < 0 then\n      if largest_negative_integer ==\
    \ nil or n > largest_negative_integer then\n        largest_negative_integer =\
    \ n\n      end\n    end\n  end\n  return {largest_negative_integer, smallest_positive_integer}\n\
    end", "  return {None, None}\nend", "    local negative = {}\n    local positive\
    \ = {}\n    for _, v in ipairs(lst) do\n        if v > 0 then\n            table.insert(positive,\
    \ v)\n        elseif v < 0 then\n            table.insert(negative, v)\n     \
    \   end\n    end\n    if #negative == 0 and #positive == 0 then\n        return\
    \ {nil, nil}\n    elseif #negative == 0 then\n        return {nil, table.min(positive)}\n\
    \    elseif #positive == 0 then\n        return {table.max(negative), nil}\n \
    \   else\n        return {table.max(negative), table.min(positive)}\n    end\n\
    end", "    local pos = {None, None}\n    local neg = {None, None}\n    for _,\
    \ v in ipairs(lst) do\n        if v > 0 then\n            if not pos[1] or v <\
    \ pos[1] then\n                pos[1] = v\n            end\n            if not\
    \ pos[2] or v > pos[2] then\n                pos[2] = v\n            end\n   \
    \     elseif v < 0 then\n            if not neg[1] or v < neg[1] then\n      \
    \          neg[1] = v\n            end\n            if not neg[2] or v > neg[2]\
    \ then\n                neg[2] = v\n            end\n        end\n    end\n  \
    \  return {neg[2], pos[1]}\nend", "    local largest_negative = nil\n    local\
    \ smallest_positive = nil\n    for _, n in ipairs(lst) do\n        if n < 0 then\n\
    \            if largest_negative == nil or n > largest_negative then\n       \
    \         largest_negative = n\n            end\n        elseif n > 0 then\n \
    \           if smallest_positive == nil or n < smallest_positive then\n      \
    \          smallest_positive = n\n            end\n        end\n    end\n    return\
    \ {largest_negative, smallest_positive}\nend", "    local mi, mx = math.huge,\
    \ -math.huge\n    for _, v in ipairs(lst) do\n        if v < 0 then\n        \
    \    mi = math.min(mi, v)\n        elseif v > 0 then\n            mx = math.max(mx,\
    \ v)\n        end\n    end\n    if mi == math.huge then\n        mi = nil\n  \
    \  end\n    if mx == -math.huge then\n        mx = nil\n    end\n    return {mi,\
    \ mx}\nend", "  local mn = nil\n  local mx = nil\n  for _, elem in ipairs(lst)\
    \ do\n    if elem > 0 then\n      if mx == nil or elem < mx then\n        mx =\
    \ elem\n      end\n    elseif elem < 0 then\n      if mn == nil or elem > mn then\n\
    \        mn = elem\n      end\n    end\n  end\n  return {mn, mx}\nend", "    --\
    \ your code here\nend", "    local largest_of_negative, smallest_of_positive\n\
    \    for _, v in ipairs(lst) do\n        if v > 0 then\n            if smallest_of_positive\
    \ == nil or v < smallest_of_positive then\n                smallest_of_positive\
    \ = v\n            end\n        elseif v < 0 then\n            if largest_of_negative\
    \ == nil or v > largest_of_negative then\n                largest_of_negative\
    \ = v\n            end\n        end\n    end\n    return {largest_of_negative,\
    \ smallest_of_positive}\nend", "    -- your code here\n    return {None, None}\n\
    end", "    local max, min = nil, nil\n    for i = 1, #lst do\n        if lst[i]\
    \ < 0 then\n            if max == nil or lst[i] > max then\n                max\
    \ = lst[i]\n            end\n        elseif lst[i] > 0 then\n            if min\
    \ == nil or lst[i] < min then\n                min = lst[i]\n            end\n\
    \        end\n    end\n    return {max, min}\nend", end, "    local a, b\n   \
    \ for _, x in ipairs(lst) do\n        if x > 0 then\n            if not b or x\
    \ < b then\n                b = x\n            end\n        elseif x < 0 then\n\
    \            if not a or x > a then\n                a = x\n            end\n\
    \        end\n    end\n    return {a, b}\nend", "  local max, min = nil, nil\n\
    \  for _, num in ipairs(lst) do\n    if num > 0 then\n      if min == nil or num\
    \ < min then\n        min = num\n      end\n    elseif num < 0 then\n      if\
    \ max == nil or num > max then\n        max = num\n      end\n    end\n  end\n\
    \  return {max, min}\nend", "    if not lst then return {None, None} end\n   \
    \ local a, b = None, None\n    for i, v in ipairs(lst) do\n        if v < 0 then\n\
    \            if a == None or v > a then\n                a = v\n            end\n\
    \        elseif v > 0 then\n            if b == None or v < b then\n         \
    \       b = v\n            end\n        end\n    end\n    return {a, b}\nend",
  "  -- TODO: Implement\nend", "    local a, b = nil, nil\n    for i=1, #lst do\n\
    \        if lst[i] < 0 then\n            if a == nil or lst[i] > a then\n    \
    \            a = lst[i]\n            end\n        elseif lst[i] > 0 then\n   \
    \         if b == nil or lst[i] < b then\n                b = lst[i]\n       \
    \     end\n        end\n    end\n    return {a, b}\nend", "\tlocal neg, pos =\
    \ None, None\n\tfor _, v in ipairs(lst) do\n\t\tif v < 0 then\n\t\t\tif neg ==\
    \ None or v > neg then\n\t\t\t\tneg = v\n\t\t\tend\n\t\telseif v > 0 then\n\t\t\
    \tif pos == None or v < pos then\n\t\t\t\tpos = v\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn {neg, pos}\nend", "    local minp, maxn = nil, nil\n    for _, v in ipairs(lst)\
    \ do\n        if v > 0 then\n            if minp == nil or v < minp then\n   \
    \             minp = v\n            end\n        elseif v < 0 then\n         \
    \   if maxn == nil or v > maxn then\n                maxn = v\n            end\n\
    \        end\n    end\n    return {maxn, minp}\nend", "    local mn, mx\n    for\
    \ _, v in ipairs(lst) do\n        if v > 0 then\n            if not mx or v <\
    \ mx then\n                mx = v\n            end\n        elseif v < 0 then\n\
    \            if not mn or v > mn then\n                mn = v\n            end\n\
    \        end\n    end\n    return {mn, mx}\nend", "    -- TODO: your code here\n\
    end", "    local largest = nil\n    local smallest = nil\n    local found_positive\
    \ = false\n    local found_negative = false\n    for i, v in ipairs(lst) do\n\
    \        if v > 0 then\n            if not found_positive or v < smallest then\n\
    \                smallest = v\n            end\n            found_positive = true\n\
    \        elseif v < 0 then\n            if not found_negative or v > largest then\n\
    \                largest = v\n            end\n            found_negative = true\n\
    \        end\n    end\n    return {largest, smallest}\nend", "  local min_pos,\
    \ max_neg\n  for _, num in ipairs(lst) do\n    if num > 0 then\n      if not min_pos\
    \ or num < min_pos then\n        min_pos = num\n      end\n    elseif num < 0\
    \ then\n      if not max_neg or num > max_neg then\n        max_neg = num\n  \
    \    end\n    end\n  end\n  return {max_neg, min_pos}\nend", "    -- your code\
    \ here\nend", "    -- YOUR CODE HERE\n    local maxNegative, minPositive = nil,\
    \ nil\n    for _, num in ipairs(lst) do\n        if num > 0 then\n           \
    \ if not minPositive or num < minPositive then\n                minPositive =\
    \ num\n            end\n        elseif num < 0 then\n            if not maxNegative\
    \ or num > maxNegative then\n                maxNegative = num\n            end\n\
    \        end\n    end\n    return {maxNegative, minPositive}\nend", "    local\
    \ largest_negative, smallest_positive\n    for i, val in ipairs(lst) do\n    \
    \    if val < 0 then\n            if not largest_negative or val > largest_negative\
    \ then\n                largest_negative = val\n            end\n        elseif\
    \ val > 0 then\n            if not smallest_positive or val < smallest_positive\
    \ then\n                smallest_positive = val\n            end\n        end\n\
    \    end\n    return {largest_negative, smallest_positive}\nend", end, "    --\
    \ YOUR CODE HERE\nend", "  -- WRITE YOUR CODE HERE\n  --  local t ={}\n  --  local\
    \ a,b = \"None\",\"None\"\n  --  for i,v in ipairs(lst) do\n  --  \tif v<0 then\n\
    \  --  \t\ta = v\n  --  \telseif v>0 then\n  --  \t\tb = v\n  --  \tend\n  --\
    \  end\n  --  table.insert(t,a)\n  --  table.insert(t,b)\n  --  return t\n  local\
    \ t={}\n  local a,b = \"None\",\"None\"\n  for i,v in ipairs(lst) do\n  \tif v<0\
    \ then\n  \t\tif a==\"None\" then\n  \t\t\ta = v\n  \t\telseif v>a then\n  \t\t\
    \ta = v\n  \t\tend\n  \telseif v>0 then\n  \t\tif b==\"None\" then\n  \t\t\tb\
    \ = v\n  \t\telseif v<b then\n  \t\t\tb = v\n  \t\tend\n  \tend\n  end\n  table.insert(t,a)\n\
    \  table.insert(t,b)\n  return t\nend", "  local largest, smallest = lst[1], lst[1]\n\
    \  for _, v in ipairs(lst) do\n    if v > 0 then\n      if smallest > v then smallest\
    \ = v end\n    elseif v < 0 then\n      if largest < v then largest = v end\n\
    \    end\n  end\n  if largest >= 0 then largest = nil end\n  if smallest <= 0\
    \ then smallest = nil end\n  return {largest, smallest}\nend", "  local a, b =\
    \ nil, nil\n  for _, x in ipairs(lst) do\n    if x < 0 then\n      if not a or\
    \ x > a then\n        a = x\n      end\n    elseif x > 0 then\n      if not b\
    \ or x < b then\n        b = x\n      end\n    end\n  end\n  return {a, b}\nend",
  "    local largest = nil\n    local smallest = nil\n    for _, x in ipairs(lst)\
    \ do\n        if x < 0 then\n            if largest == nil or x > largest then\n\
    \                largest = x\n            end\n        elseif x > 0 then\n   \
    \         if smallest == nil or x < smallest then\n                smallest =\
    \ x\n            end\n        end\n    end\n    return {largest, smallest}\nend",
  "  local mn, mx = nil, nil\n  for _, v in ipairs(lst) do\n    if v > 0 then\n  \
    \    if mx == nil or v < mx then\n        mx = v\n      end\n    elseif v < 0\
    \ then\n      if mn == nil or v > mn then\n        mn = v\n      end\n    end\n\
    \  end\n  return {mn, mx}\nend", "\tlocal a, b = None, None\n\tfor _, v in ipairs(lst)\
    \ do\n\t\tif v < 0 and (a == None or v > a) then\n\t\t\ta = v\n\t\telseif v >\
    \ 0 and (b == None or v < b) then\n\t\t\tb = v\n\t\tend\n\tend\n\treturn {a, b}\n\
    end", "    -- Your code here\nend", "  -- Your code here\nend", "    local a,\
    \ b = None, None\n    for _, i in ipairs(lst) do\n        if i > 0 then\n    \
    \        if b == None or i < b then\n                b = i\n            end\n\
    \        elseif i < 0 then\n            if a == None or i > a then\n         \
    \       a = i\n            end\n        end\n    end\n    return {a, b}\nend",
  "  local min_pos = math.maxinteger\n  local max_neg = math.mininteger\n  for _,x\
    \ in ipairs(lst) do\n    if x > 0 and x < min_pos then\n      min_pos = x\n  \
    \  elseif x < 0 and x > max_neg then\n      max_neg = x\n    end\n  end\n  return\
    \ {max_neg == math.mininteger and nil or max_neg,\n          min_pos == math.maxinteger\
    \ and nil or min_pos}\nend", "    -- your code here\nend", "  local min_positive,\
    \ max_negative = nil, nil\n  for _, v in ipairs(lst) do\n    if v < 0 then\n \
    \     if not max_negative or v > max_negative then\n        max_negative = v\n\
    \      end\n    elseif v > 0 then\n      if not min_positive or v < min_positive\
    \ then\n        min_positive = v\n      end\n    end\n  end\n  return {max_negative,\
    \ min_positive}\nend", "\tlocal pos, neg, max_pos, min_neg = nil, nil, nil, nil\n\
    \tfor _, v in ipairs(lst) do\n\t\tif v < 0 then\n\t\t\tif neg == nil or v > max_pos\
    \ then\n\t\t\t\tmax_pos = v\n\t\t\tend\n\t\telseif v > 0 then\n\t\t\tif pos ==\
    \ nil or v < min_neg then\n\t\t\t\tmin_neg = v\n\t\t\tend\n\t\tend\n\tend\n\t\
    return {max_pos, min_neg}\nend", end, "  -- YOUR CODE HERE\n  return {}\nend",
  "    local largest, smallest = nil, nil\n    for _, v in ipairs(lst) do\n      \
    \  if not largest and v < 0 then\n            largest = v\n        elseif v <\
    \ 0 and v > largest then\n            largest = v\n        end\n        if not\
    \ smallest and v > 0 then\n            smallest = v\n        elseif v > 0 and\
    \ v < smallest then\n            smallest = v\n        end\n    end\n    return\
    \ {largest, smallest}\nend", "    -- your code here\n    -- Get all negative values\n\
    \    local negatives = {}\n    local positives = {}\n    local largest_negative\
    \ = nil\n    local smallest_positive = nil\n    for _,v in ipairs(lst) do\n  \
    \      if v < 0 then\n            table.insert(negatives, v)\n        elseif v\
    \ > 0 then\n            table.insert(positives, v)\n        end\n    end\n   \
    \ if #negatives > 0 then\n        largest_negative = math.max(unpack(negatives))\n\
    \    end\n    if #positives > 0 then\n        smallest_positive = math.min(unpack(positives))\n\
    \    end\n    return {largest_negative, smallest_positive}\nend", "    if #lst\
    \ == 0 then\n        return nil, nil\n    end\n    table.sort(lst)\n    return\
    \ lst[1], lst[#lst]\nend", "    return {None, None}\nend", "    local min = false\n\
    \    local max = false\n    for k, v in pairs(lst) do\n        if type(v) == \"\
    number\" then\n            if v > 0 then\n                if not min or v < min\
    \ then\n                    min = v\n                end\n            elseif v\
    \ < 0 then\n                if not max or v > max then\n                    max\
    \ = v\n                end\n            end\n        end\n    end\n    return\
    \ {max, min}\nend", "    local smallest = nil\n    local largest = nil\n    for\
    \ i = 1, #lst do\n        local v = lst[i]\n        if v > 0 then\n          \
    \  if smallest == nil or v < smallest then\n                smallest = v\n   \
    \         end\n        elseif v < 0 then\n            if largest == nil or v >\
    \ largest then\n                largest = v\n            end\n        end\n  \
    \  end\n    return {largest, smallest}\nend", "    assert(type(lst) == \"table\"\
    )\n    -- your code here\nend", "  error('Not Implemented')\nend", "    return\
    \ {None, None}\nend", "  -- TODO: Your code here\nend", "    local smallest_positive\
    \ = nil\n    local largest_negative = nil\n    for _, n in ipairs(lst) do\n  \
    \      if n >= 0 then\n            if smallest_positive == nil or n < smallest_positive\
    \ then\n                smallest_positive = n\n            end\n        else\n\
    \            if largest_negative == nil or n > largest_negative then\n       \
    \         largest_negative = n\n            end\n        end\n    end\n    return\
    \ {largest_negative, smallest_positive}\nend", "    -- your code here\n    local\
    \ max = 0\n    local min = 0\n    local first = true\n    for k, v in pairs(lst)\
    \ do\n        if v < 0 then\n            if first == true then\n             \
    \   first = false\n                max = v\n            elseif v > max then\n\
    \                max = v\n            end\n        elseif v > 0 then\n       \
    \     if first == true then\n                first = false\n                min\
    \ = v\n            elseif v < min then\n                min = v\n            end\n\
    \        end\n    end\n    if first == true then\n        return {nil, nil}\n\
    \    else\n        return {max, min}\n    end\nend", "    -- your code here\n\
    \    --return None\nend", "  local largest_negative = nil\n  local smallest_positive\
    \ = nil\n  for _, v in ipairs(lst) do\n    if v > 0 then\n      if not smallest_positive\
    \ or v < smallest_positive then\n        smallest_positive = v\n      end\n  \
    \  elseif v < 0 then\n      if not largest_negative or v > largest_negative then\n\
    \        largest_negative = v\n      end\n    end\n  end\n  return {largest_negative,\
    \ smallest_positive}\nend", "    local pos_min, pos_max = math.huge, -math.huge\n\
    \    local neg_min, neg_max = -math.huge, math.huge\n    for _, v in ipairs(lst)\
    \ do\n        if v > 0 then\n            pos_min = math.min(pos_min, v)\n    \
    \        pos_max = math.max(pos_max, v)\n        elseif v < 0 then\n         \
    \   neg_min = math.min(neg_min, v)\n            neg_max = math.max(neg_max, v)\n\
    \        end\n    end\n    return {\n        (neg_min == math.huge and None or\
    \ neg_max),\n        (pos_min == math.huge and None or pos_min)\n    }\nend",
  "  if #lst == 0 then\n    return {None, None}\n  end\n  local a, b = None, None\n\
    \  for _, v in ipairs(lst) do\n    if v < 0 then\n      if a == None or v > a\
    \ then\n        a = v\n      end\n    elseif v > 0 then\n      if b == None or\
    \ v < b then\n        b = v\n      end\n    end\n  end\n  return {a, b}\nend",
  "  local a, b = None, None\n  for _, v in ipairs(lst) do\n    if v < 0 then\n  \
    \    if a == None or v > a then\n        a = v\n      end\n    elseif v > 0 then\n\
    \      if b == None or v < b then\n        b = v\n      end\n    end\n  end\n\
    \  return {a, b}\nend", "    local largest = 0\n    local smallest = 0\n    local\
    \ pos = false\n    local neg = false\n    for _, v in ipairs(lst) do\n       \
    \ if v < 0 then\n            if not neg then\n                largest = v\n  \
    \              neg = true\n            elseif v > largest then\n             \
    \   largest = v\n            end\n        elseif v > 0 then\n            if not\
    \ pos then\n                smallest = v\n                pos = true\n       \
    \     elseif v < smallest then\n                smallest = v\n            end\n\
    \        end\n    end\n    if not neg then\n        largest = nil\n    end\n \
    \   if not pos then\n        smallest = nil\n    end\n    return {largest, smallest}\n\
    end", "    local neg, pos = None, None\n    for _, num in ipairs(lst) do\n   \
    \     if num > 0 then\n            if pos == None or num < pos then\n        \
    \        pos = num\n            end\n        elseif num < 0 then\n           \
    \ if neg == None or num > neg then\n                neg = num\n            end\n\
    \        end\n    end\n    return {neg, pos}\nend", "    local max_neg, min_pos\
    \ = 0, 0\n    local has_neg, has_pos = false, false\n    for _, v in ipairs(lst)\
    \ do\n        if v < 0 then\n            has_neg = true\n            if v > max_neg\
    \ then\n                max_neg = v\n            end\n        elseif v > 0 then\n\
    \            has_pos = true\n            if v < min_pos or min_pos == 0 then\n\
    \                min_pos = v\n            end\n        end\n    end\n    return\
    \ has_neg and max_neg or None, has_pos and min_pos or None\nend", "  if #lst ==\
    \ 0 then\n    return {None, None}\n  end\n  local smallest_positive, largest_negative\n\
    \  for i, v in ipairs(lst) do\n    if v < 0 then\n      if largest_negative ==\
    \ nil or v > largest_negative then\n        largest_negative = v\n      end\n\
    \    elseif v > 0 then\n      if smallest_positive == nil or v < smallest_positive\
    \ then\n        smallest_positive = v\n      end\n    end\n  end\n  return {largest_negative,\
    \ smallest_positive}\nend", "    -- body\nend", "  -- Fill this up\nend", "  local\
    \ smallest_positive, largest_negative = nil, nil\n  for _, i in ipairs(lst) do\n\
    \    if i > 0 then\n      if smallest_positive == nil or i < smallest_positive\
    \ then\n        smallest_positive = i\n      end\n    elseif i < 0 then\n    \
    \  if largest_negative == nil or i > largest_negative then\n        largest_negative\
    \ = i\n      end\n    end\n  end\n  return {largest_negative, smallest_positive}\n\
    end", "  return {}\nend", "    return {None, None}\nend", "  -- TODO: your code\
    \ here\nend", "    local positives = {}\n    local negatives = {}\n    for _,\
    \ i in ipairs(lst) do\n        if i > 0 then\n            table.insert(positives,\
    \ i)\n        elseif i < 0 then\n            table.insert(negatives, i)\n    \
    \    end\n    end\n    if #positives > 0 then\n        table.sort(positives)\n\
    \    end\n    if #negatives > 0 then\n        table.sort(negatives, function(a,\
    \ b) return a > b end)\n    end\n    return {#negatives > 0 and negatives[1] or\
    \ nil, #positives > 0 and positives[1] or nil}\nend", "    local res = {nil, nil}\n\
    \    for _, v in ipairs(lst) do\n        if v > 0 then\n            if res[2]\
    \ == nil or v < res[2] then\n                res[2] = v\n            end\n   \
    \     elseif v < 0 then\n            if res[1] == nil or v > res[1] then\n   \
    \             res[1] = v\n            end\n        end\n    end\n    return res\n\
    end", "    -- your code here\n    return {None, None}\nend", "  if not lst then\n\
    \    return {None, None}\n  end\n  return {None, None}\nend", "\tlocal small_val,\
    \ small_key, large_val, large_key = nil, nil, nil, nil\n\tfor k, v in pairs(lst)\
    \ do\n\t\tif v > 0 then\n\t\t\tif not small_val or v < small_val then\n\t\t\t\t\
    small_val = v\n\t\t\t\tsmall_key = k\n\t\t\tend\n\t\telseif v < 0 then\n\t\t\t\
    if not large_val or v > large_val then\n\t\t\t\tlarge_val = v\n\t\t\t\tlarge_key\
    \ = k\n\t\t\tend\n\t\tend\n\tend\n\treturn {large_val, small_val}\nend", "  local\
    \ positive = nil\n  local negative = nil\n  for _, v in ipairs(lst) do\n    if\
    \ v > 0 then\n      if positive == nil or v < positive then\n        positive\
    \ = v\n      end\n    elseif v < 0 then\n      if negative == nil or v > negative\
    \ then\n        negative = v\n      end\n    end\n  end\n  return {negative, positive}\n\
    end", "    -- YOUR CODE HERE\n    local maximum_neg, minimum_pos = nil, nil\n\
    \    for _, v in ipairs(lst) do\n        if v < 0 then\n            if maximum_neg\
    \ == nil or v > maximum_neg then\n                maximum_neg = v\n          \
    \  end\n        elseif v > 0 then\n            if minimum_pos == nil or v < minimum_pos\
    \ then\n                minimum_pos = v\n            end\n        end\n    end\n\
    \    return {maximum_neg, minimum_pos}\nend", "  local max_neg, min_pos = nil,\
    \ nil\n  for i, v in ipairs(lst) do\n    if v < 0 then\n      if max_neg == nil\
    \ or v > max_neg then\n        max_neg = v\n      end\n    elseif v > 0 then\n\
    \      if min_pos == nil or v < min_pos then\n        min_pos = v\n      end\n\
    \    end\n  end\n  return {max_neg, min_pos}\nend", "  local a, b = nil, nil\n\
    \  local is_first_pos = true\n  for i = 1, #lst do\n    local v = lst[i]\n   \
    \ if v >= 0 then\n      if is_first_pos then\n        b = v\n        is_first_pos\
    \ = false\n      else\n        b = math.min(b, v)\n      end\n    else\n     \
    \ a = math.max(a or v, v)\n    end\n  end\n  return {a, b}\nend", "  local positive_min,\
    \ negative_max = nil, nil\n  for _, v in ipairs(lst) do\n    if v > 0 then\n \
    \     if positive_min == nil or v < positive_min then\n        positive_min =\
    \ v\n      end\n    elseif v < 0 then\n      if negative_max == nil or v > negative_max\
    \ then\n        negative_max = v\n      end\n    end\n  end\n  return {negative_max,\
    \ positive_min}\nend", "    local largest_neg_int, smallest_pos_int\n    for _,\
    \ i in ipairs(lst) do\n        if i < 0 then\n            if largest_neg_int ==\
    \ nil or i > largest_neg_int then\n                largest_neg_int = i\n     \
    \       end\n        elseif i > 0 then\n            if smallest_pos_int == nil\
    \ or i < smallest_pos_int then\n                smallest_pos_int = i\n       \
    \     end\n        end\n    end\n    return {largest_neg_int, smallest_pos_int}\n\
    end", "\tlocal min, max = math.min, math.max\n\tlocal minn, maxn = math.huge,\
    \ -math.huge\n\tfor i = 1, #lst do\n\t\tlocal v = lst[i]\n\t\tif v < 0 then\n\t\
    \t\tminn = min(minn, v)\n\t\telseif v > 0 then\n\t\t\tmaxn = max(maxn, v)\n\t\t\
    end\n\tend\n\treturn minn == math.huge and None or minn, maxn == -math.huge and\
    \ None or maxn\nend", "    --your code here\n    return nil\nend", "  local largest,\
    \ smallest = nil, nil\n  for _, num in ipairs(lst) do\n    if num > 0 then\n \
    \     if smallest == nil or num < smallest then\n        smallest = num\n    \
    \  end\n    elseif num < 0 then\n      if largest == nil or num > largest then\n\
    \        largest = num\n      end\n    end\n  end\n  return {largest, smallest}\n\
    end", "    local positive_list = {}\n    local negative_list = {}\n    for i,\
    \ v in ipairs(lst) do\n        if v > 0 then\n            table.insert(positive_list,\
    \ v)\n        elseif v < 0 then\n            table.insert(negative_list, v)\n\
    \        end\n    end\n    if #positive_list == 0 then\n        return {None,\
    \ None}\n    elseif #negative_list == 0 then\n        return {None, None}\n  \
    \  else\n        return {table.max(negative_list), table.min(positive_list)}\n\
    \    end\nend", "    local min, max\n    for _, i in ipairs(lst) do\n        if\
    \ i > 0 then\n            if min == nil or i < min then\n                min =\
    \ i\n            end\n        elseif i < 0 then\n            if max == nil or\
    \ i > max then\n                max = i\n            end\n        end\n    end\n\
    \    return {max, min}\nend", "    local a, b = None, None\n    for k, v in pairs(lst)\
    \ do\n        if v > 0 then\n            if b == None or v < b then\n        \
    \        b = v\n            end\n        elseif v < 0 then\n            if a ==\
    \ None or v > a then\n                a = v\n            end\n        end\n  \
    \  end\n    return {a, b}\nend", "  local large, small = None, None\n  for k,\
    \ v in pairs(lst) do\n    if large == None and v < 0 then\n      large = v\n \
    \   elseif large ~= None and v < 0 and v > large then\n      large = v\n    end\n\
    \    if small == None and v > 0 then\n      small = v\n    elseif small ~= None\
    \ and v > 0 and v < small then\n      small = v\n    end\n  end\n  return {large,\
    \ small}\nend", "  local smallest, largest = nil, nil\n  for i = 1, #lst do\n\
    \    local x = lst[i]\n    if x >= 0 then\n      if smallest == nil or x < smallest\
    \ then\n        smallest = x\n      end\n    else\n      if largest == nil or\
    \ x > largest then\n        largest = x\n      end\n    end\n  end\n  return {largest,\
    \ smallest}\nend", "  -- TODO: Your code here!\nend", "    -- body\nend", "  --\
    \ your code here\nend", "    -- TODO: Implement this function\nend", "    local\
    \ min = math.huge\n    local max = -math.huge\n    for _, v in ipairs(lst) do\n\
    \        if v < 0 then\n            max = math.max(max, v)\n        elseif v >\
    \ 0 then\n            min = math.min(min, v)\n        end\n    end\n    if min\
    \ == math.huge then\n        min = nil\n    end\n    if max == -math.huge then\n\
    \        max = nil\n    end\n    return {max, min}\nend", "    -- write your code\
    \ here\n    local a, b = None, None\n    for _, v in ipairs(lst) do\n        if\
    \ v < 0 then\n            if a == None or v > a then\n                a = v\n\
    \            end\n        elseif v > 0 then\n            if b == None or v < b\
    \ then\n                b = v\n            end\n        end\n    end\n    return\
    \ {a, b}\nend", "    local largest, smallest = None, None\n    for _, v in ipairs(lst)\
    \ do\n        if v < 0 and (largest == None or v > largest) then\n           \
    \ largest = v\n        elseif v > 0 and (smallest == None or v < smallest) then\n\
    \            smallest = v\n        end\n    end\n    return {largest, smallest}\n\
    end", "  local a, b = nil, nil\n  for k, v in pairs(lst) do\n    if v < 0 then\n\
    \      if a == nil or v > a then\n        a = v\n      end\n    elseif v > 0 then\n\
    \      if b == nil or v < b then\n        b = v\n      end\n    end\n  end\n \
    \ return {a, b}\nend", "    local largest, smallest = None, None\n    for _, x\
    \ in ipairs(lst) do\n        if x < 0 and (largest == None or x > largest) then\n\
    \            largest = x\n        elseif x > 0 and (smallest == None or x < smallest)\
    \ then\n            smallest = x\n        end\n    end\n    return {largest, smallest}\n\
    end", "  local smallest = nil\n  local largest = nil\n  for _, num in ipairs(lst)\
    \ do\n    if num < 0 then\n      if largest == nil or num > largest then\n   \
    \     largest = num\n      end\n    elseif num > 0 then\n      if smallest ==\
    \ nil or num < smallest then\n        smallest = num\n      end\n    end\n  end\n\
    \  return {largest, smallest}\nend", end, "  local a, b = None, None\n  for _,\
    \ v in ipairs(lst) do\n    if v < 0 then\n      if a == None or v > a then\n \
    \       a = v\n      end\n    elseif v > 0 then\n      if b == None or v < b then\n\
    \        b = v\n      end\n    end\n  end\n  return {a, b}\nend", "    local max_neg,\
    \ min_pos = None, None\n    for i, e in ipairs(lst) do\n        if max_neg ==\
    \ None and e < 0 then\n            max_neg = e\n        elseif e < 0 and e > max_neg\
    \ then\n            max_neg = e\n        end\n        if min_pos == None and e\
    \ > 0 then\n            min_pos = e\n        elseif e > 0 and e < min_pos then\n\
    \            min_pos = e\n        end\n    end\n    return {max_neg, min_pos}\n\
    end", "    local min, max = nil, nil\n    for i, v in ipairs(lst) do\n       \
    \ if v > 0 then\n            if min == nil or v < min then\n                min\
    \ = v\n            end\n        elseif v < 0 then\n            if max == nil or\
    \ v > max then\n                max = v\n            end\n        end\n    end\n\
    \    return {max, min}\nend", "    local largest_neg, smallest_pos = None, None\n\
    \    for _, num in ipairs(lst) do\n        if num < 0 and (largest_neg == None\
    \ or num > largest_neg) then\n            largest_neg = num\n        elseif num\
    \ > 0 and (smallest_pos == None or num < smallest_pos) then\n            smallest_pos\
    \ = num\n        end\n    end\n    return {largest_neg, smallest_pos}\nend", " \
    \   local largest_negative, smallest_positive = nil, nil\n    for _, v in ipairs(lst)\
    \ do\n        if largest_negative == nil and v < 0 then\n            largest_negative\
    \ = v\n        elseif largest_negative ~= nil and v < 0 and v > largest_negative\
    \ then\n            largest_negative = v\n        end\n        if smallest_positive\
    \ == nil and v > 0 then\n            smallest_positive = v\n        elseif smallest_positive\
    \ ~= nil and v > 0 and v < smallest_positive then\n            smallest_positive\
    \ = v\n        end\n    end\n    return {largest_negative, smallest_positive}\n\
    end", "    -- your solution here\n    local max_neg_num = {}\n    local min_pos_num\
    \ = {}\n    for i, x in ipairs(lst) do\n        if x < 0 then\n            table.insert(max_neg_num,\
    \ x)\n        elseif x > 0 then\n            table.insert(min_pos_num, x)\n  \
    \      end\n    end\n    if #max_neg_num == 0 then\n        max_neg_num = nil\n\
    \    else\n        max_neg_num = table.reduce(max_neg_num, function(x, y) return\
    \ x > y and x or y end)\n    end\n    if #min_pos_num == 0 then\n        min_pos_num\
    \ = nil\n    else\n        min_pos_num = table.reduce(min_pos_num, function(x,\
    \ y) return x < y and x or y end)\n    end\n    return {max_neg_num, min_pos_num}\n\
    end", "    local a, b\n    for _, x in ipairs(lst) do\n        if x > 0 then\n\
    \            if not b or x < b then\n                b = x\n            end\n\
    \        elseif x < 0 then\n            if not a or x > a then\n             \
    \   a = x\n            end\n        end\n    end\n    return {a, b}\nend", " \
    \ local max_negative = nil\n  local min_positive = nil\n  for _, n in ipairs(lst)\
    \ do\n    if n < 0 then\n      if max_negative == nil or n > max_negative then\n\
    \        max_negative = n\n      end\n    elseif n > 0 then\n      if min_positive\
    \ == nil or n < min_positive then\n        min_positive = n\n      end\n    end\n\
    \  end\n  return {max_negative, min_positive}\nend", "  -- TODO: Please implement\
    \ this function\nend", "\tlocal min_positive, max_negative = nil, nil\n\tfor _,\
    \ number in ipairs(lst) do\n\t\tif number > 0 then\n\t\t\tif min_positive == nil\
    \ or number < min_positive then\n\t\t\t\tmin_positive = number\n\t\t\tend\n\t\t\
    elseif number < 0 then\n\t\t\tif max_negative == nil or number > max_negative\
    \ then\n\t\t\t\tmax_negative = number\n\t\t\tend\n\t\tend\n\tend\n\treturn {max_negative,\
    \ min_positive}\nend", "    return lst\nend", "  local min_positive = 0\n  local\
    \ max_negative = 0\n  local is_negative = false\n  local is_positive = false\n\
    \  for i, v in ipairs(lst) do\n    if v > 0 then\n      if is_positive then\n\
    \        if v < min_positive then\n          min_positive = v\n        end\n \
    \     else\n        min_positive = v\n        is_positive = true\n      end\n\
    \    elseif v < 0 then\n      if is_negative then\n        if v > max_negative\
    \ then\n          max_negative = v\n        end\n      else\n        max_negative\
    \ = v\n        is_negative = true\n      end\n    end\n  end\n  return {\n   \
    \ is_negative and max_negative or nil,\n    is_positive and min_positive or nil\n\
    \  }\nend", "  local maxn, minp = nil, nil\n  for _, v in ipairs(lst) do\n   \
    \ if v < 0 then\n      if not maxn or v > maxn then\n        maxn = v\n      end\n\
    \    elseif v > 0 then\n      if not minp or v < minp then\n        minp = v\n\
    \      end\n    end\n  end\n  return {maxn, minp}\nend", "  local l, s = {}, {}\n\
    \  for i, v in ipairs(lst) do\n    if v > 0 then\n      table.insert(s, v)\n \
    \   elseif v < 0 then\n      table.insert(l, v)\n    end\n  end\n  if #l == 0\
    \ then\n    l = nil\n  else\n    table.sort(l)\n    l = l[#l]\n  end\n  if #s\
    \ == 0 then\n    s = nil\n  else\n    table.sort(s)\n    s = s[1]\n  end\n  return\
    \ {l, s}\nend", "    local max_neg, min_pos = nil, nil\n    for _, val in ipairs(lst)\
    \ do\n        if val < 0 then\n            if not max_neg or val > max_neg then\n\
    \                max_neg = val\n            end\n        elseif val > 0 then\n\
    \            if not min_pos or val < min_pos then\n                min_pos = val\n\
    \            end\n        end\n    end\n    return {max_neg, min_pos}\nend", " \
    \   -- Read more: http://lua-users.org/wiki/TableUtils\n    -- Insert your code\
    \ here\n    return table.pack(None, None)\nend", "    local min_pos, max_neg =\
    \ None, None\n    for x in values(lst) do\n        if x > 0 then\n           \
    \ if min_pos == None or x < min_pos then\n                min_pos = x\n      \
    \      end\n        elseif x < 0 then\n            if max_neg == None or x > max_neg\
    \ then\n                max_neg = x\n            end\n        end\n    end\n \
    \   return {max_neg, min_pos}\nend", "    return {None, None}\nend", "    local\
    \ a, b = None, None\n    for _, v in ipairs(lst) do\n        if v < 0 and (a ==\
    \ None or v > a) then\n            a = v\n        elseif v > 0 and (b == None\
    \ or v < b) then\n            b = v\n        end\n    end\n    return {a, b}\n\
    end", "    local smallest_positive, largest_negative\n    for i, v in ipairs(lst)\
    \ do\n        if v > 0 then\n            if smallest_positive == nil or v < smallest_positive\
    \ then\n                smallest_positive = v\n            end\n        elseif\
    \ v < 0 then\n            if largest_negative == nil or v > largest_negative then\n\
    \                largest_negative = v\n            end\n        end\n    end\n\
    \    return {largest_negative, smallest_positive}\nend", "  local min_pos, max_neg\
    \ = math.huge, -math.huge\n  for _, value in ipairs(lst) do\n    if value < 0\
    \ then\n      max_neg = math.max(max_neg, value)\n    elseif value > 0 then\n\
    \      min_pos = math.min(min_pos, value)\n    end\n  end\n  if min_pos == math.huge\
    \ then\n    min_pos = nil\n  end\n  if max_neg == -math.huge then\n    max_neg\
    \ = nil\n  end\n  return {max_neg, min_pos}\nend", "    local largest_negative,\
    \ smallest_positive = nil, nil\n    for _, n in ipairs(lst) do\n        if n <\
    \ 0 then\n            if largest_negative == nil or n > largest_negative then\n\
    \                largest_negative = n\n            end\n        elseif n > 0 then\n\
    \            if smallest_positive == nil or n < smallest_positive then\n     \
    \           smallest_positive = n\n            end\n        end\n    end\n   \
    \ return {largest_negative, smallest_positive}\nend", "  local a, b = nil, nil\n\
    \  for _, v in ipairs(lst) do\n    if v < 0 then\n      if a == nil or v > a then\n\
    \        a = v\n      end\n    elseif v > 0 then\n      if b == nil or v < b then\n\
    \        b = v\n      end\n    end\n  end\n  return {a, b}\nend", "\tlocal largest,\
    \ smallest = None, None\n\tfor i = 1, #lst do\n\t\tif lst[i] > 0 then\n\t\t\t\
    if smallest == None or lst[i] < smallest then\n\t\t\t\tsmallest = lst[i]\n\t\t\
    \tend\n\t\telseif lst[i] < 0 then\n\t\t\tif largest == None or lst[i] > largest\
    \ then\n\t\t\t\tlargest = lst[i]\n\t\t\tend\n\t\tend\n\tend\n\treturn {largest,\
    \ smallest}\nend", "    local min, max\n    for _, v in ipairs(lst) do\n     \
    \   if v > 0 then\n            min = (not min or v < min) and v or min\n     \
    \   elseif v < 0 then\n            max = (not max or v > max) and v or max\n \
    \       end\n    end\n    return {max, min}\nend", "  -- your code here\nend",
  end, "  -- This is your job. :)\nend", "  local max = nil\n  local min = nil\n \
    \ for k, v in pairs(lst) do\n    if v < 0 then\n      if not max or v > max then\n\
    \        max = v\n      end\n    elseif v > 0 then\n      if not min or v < min\
    \ then\n        min = v\n      end\n    end\n  end\n  return {max, min}\nend",
  "    if #lst == 0 then\n        return {None, None}\n    end\n    local minus =\
    \ {}\n    local plus = {}\n    for i = 1, #lst do\n        if lst[i] > 0 then\n\
    \            table.insert(plus, lst[i])\n        elseif lst[i] < 0 then\n    \
    \        table.insert(minus, lst[i])\n        end\n    end\n    if #minus == 0\
    \ then\n        minus = None\n    else\n        table.sort(minus)\n        minus\
    \ = minus[#minus]\n    end\n    if #plus == 0 then\n        plus = None\n    else\n\
    \        table.sort(plus)\n        plus = plus[1]\n    end\n    return {minus,\
    \ plus}\nend", "    local res = {None, None}\n    local max = 1/0\n    local min\
    \ = -1/0\n    for _, v in ipairs(lst) do\n        if v < 0 and v > max then\n\
    \            max = v\n        elseif v > 0 and v < min then\n            min =\
    \ v\n        end\n    end\n    if max ~= 1/0 then\n        res[1] = max\n    end\n\
    \    if min ~= -1/0 then\n        res[2] = min\n    end\n    return res\nend",
  "  -- your code here\nend", "    -- Insert your code here\nend", "    local min_pos,\
    \ max_neg = nil, nil\n    for _, v in ipairs(lst) do\n        if v < 0 then\n\
    \            if max_neg == nil or v > max_neg then\n                max_neg =\
    \ v\n            end\n        elseif v > 0 then\n            if min_pos == nil\
    \ or v < min_pos then\n                min_pos = v\n            end\n        end\n\
    \    end\n    return {max_neg, min_pos}\nend", "    -- your code here\n    return\
    \ None\nend", "  local largest = nil\n  local smallest = nil\n  for _, v in ipairs(lst)\
    \ do\n    if v > 0 then\n      if smallest == nil or v < smallest then\n     \
    \   smallest = v\n      end\n    elseif v < 0 then\n      if largest == nil or\
    \ v > largest then\n        largest = v\n      end\n    end\n  end\n  return {largest,\
    \ smallest}\nend", "  -- TODO: implementation\nend", "  local smallest, largest\
    \ = nil, nil\n  for k, v in pairs(lst) do\n    if v < 0 then\n      if not largest\
    \ or v > largest then\n        largest = v\n      end\n    elseif v > 0 then\n\
    \      if not smallest or v < smallest then\n        smallest = v\n      end\n\
    \    end\n  end\n  return {largest, smallest}\nend", "    return {lst:filter(function(x)\
    \ return x < 0 end):max(), lst:filter(function(x) return x > 0 end):min()}\nend",
  "    local minPos = math.huge\n    local maxNeg = -math.huge\n    for _, v in ipairs(lst)\
    \ do\n        if v < 0 then\n            maxNeg = math.max(maxNeg, v)\n      \
    \  elseif v > 0 then\n            minPos = math.min(minPos, v)\n        end\n\
    \    end\n    return { maxNeg ~= -math.huge and maxNeg or nil, minPos ~= math.huge\
    \ and minPos or nil }\nend", "\tlocal min, max = math.huge, -math.huge\n\tfor\
    \ _, n in ipairs(lst) do\n\t\tif n < 0 then\n\t\t\tmax = math.max(max, n)\n\t\t\
    elseif n > 0 then\n\t\t\tmin = math.min(min, n)\n\t\tend\n\tend\n\tif min == math.huge\
    \ then min = nil end\n\tif max == -math.huge then max = nil end\n\treturn {max,\
    \ min}\nend", "    -- local state = {max = nil, min = nil}\n    -- for _, val\
    \ in ipairs(lst) do\n    --     local new_max, new_min = val, val\n    --    \
    \ if val < 0 then\n    --         if state.max then\n    --             new_max\
    \ = math.max(state.max, val)\n    --         end\n    --     else\n    --    \
    \     if state.min then\n    --             new_min = math.min(state.min, val)\n\
    \    --         end\n    --     end\n    --     state.max = new_max\n    --  \
    \   state.min = new_min\n    -- end\n    -- return {state.max, state.min}\n  \
    \  return {reduce(lst, function(acc, val) return val < 0 and math.max(acc or -math.huge,\
    \ val) or acc end),\n            reduce(lst, function(acc, val) return val > 0\
    \ and math.min(acc or math.huge, val) or acc end)}\nend", "    -- your solution\
    \ here\n    -- do not use max or min\n    local largest, smallest = None, None\n\
    \    for k, v in pairs(lst) do\n        if v < 0 then\n            if largest\
    \ == None or v > largest then\n                largest = v\n            end\n\
    \        elseif v > 0 then\n            if smallest == None or v < smallest then\n\
    \                smallest = v\n            end\n        end\n    end\n    return\
    \ {largest, smallest}\nend", "    -- your code goes here\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
