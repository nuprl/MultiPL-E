name: HumanEval_144_simplify
language: lua
prompt: "-- Your task is to implement a function that will simplify the expression\n\
  -- x * n. The function returns true if x * n evaluates to a whole number and false\n\
  -- otherwise. Both x and n, are string representation of a fraction, and have the\
  \ following format,\n-- <numerator>/<denominator> where both numerator and denominator\
  \ are positive whole numbers.\n-- You can assume that x, and n are valid fractions,\
  \ and do not have zero as denominator.\n-- >>> simplify('1/5', '5/1')\n-- true\n\
  -- >>> simplify('1/6', '2/1')\n-- false\n-- >>> simplify('7/10', '10/2')\n-- false\n\
  local function simplify(x, n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = simplify\n\
  \    lu.assertEquals(candidate('1/5', '5/1'), true)\n    lu.assertEquals(candidate('1/6',\
  \ '2/1'), false)\n    lu.assertEquals(candidate('5/1', '3/1'), true)\n    lu.assertEquals(candidate('7/10',\
  \ '10/2'), false)\n    lu.assertEquals(candidate('2/10', '50/10'), true)\n    lu.assertEquals(candidate('7/2',\
  \ '4/2'), true)\n    lu.assertEquals(candidate('11/6', '6/1'), true)\n    lu.assertEquals(candidate('2/3',\
  \ '5/2'), false)\n    lu.assertEquals(candidate('5/2', '3/5'), false)\n    lu.assertEquals(candidate('2/4',\
  \ '8/4'), true)\n    lu.assertEquals(candidate('2/4', '4/2'), true)\n    lu.assertEquals(candidate('1/5',\
  \ '5/1'), true)\n    lu.assertEquals(candidate('1/5', '1/5'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- your code here\n\tlocal numerator = {}\n\tlocal denominator =\
    \ {}\n\tlocal xnum, xden = x:match(\"(%d+)/(%d+)\")\n\tlocal nnum, nden = n:match(\"\
    (%d+)/(%d+)\")\n\txnum = tonumber(xnum)\n\txden = tonumber(xden)\n\tnnum = tonumber(nnum)\n\
    \tnden = tonumber(nden)\n\tlocal numerator = {}\n\tlocal denominator = {}\n\t\
    table.insert(numerator, xnum)\n\ttable.insert(numerator, nnum)\n\ttable.insert(denominator,\
    \ xden)\n\ttable.insert(denominator, nden)\n\tlocal num = 1\n\tlocal den = 1\n\
    \tfor i = 1, #numerator do\n\t\tnum = num * numerator[i]\n\tend\n\tfor i = 1,\
    \ #denominator do\n\t\tden = den * denominator[i]\n\tend\n\tlocal num = math.floor(num)\n\
    \tlocal den = math.floor(den)\n\tlocal result = num / den\n\tlocal result = tostring(result)\n\
    \tlocal result = result:match(\"(%d+).?%d*\")\n\tlocal result = tonumber(result)\n\
    \tif result == num then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend",
  "  -- convert to rational numbers\n  local x_num, x_denom = tonumber(x:match('(%d+)/(%d+)')),\
    \ tonumber(x:match('/(%d+)'))\n  local n_num, n_denom = tonumber(n:match('(%d+)/(%d+)')),\
    \ tonumber(n:match('/(%d+)'))\n  -- return true if x * n is a whole number\n \
    \ return ((x_num * n_num) % (x_denom * n_denom)) == 0\nend", "  -- your code here\n\
    end", "  local numerator = require(\"math\").floor(tonumber(x) * tonumber(n))\n\
    \  local denominator = 1\n  return (numerator / denominator) == math.floor(numerator\
    \ / denominator)\nend", "    local function gcd(a, b)\n        while b ~= 0 do\n\
    \            a, b = b, a % b\n        end\n        return a\n    end\n    local\
    \ function getFraction(fraction)\n        local numerator, denominator = string.match(fraction,\
    \ \"(%d+)/(%d+)\")\n        return tonumber(numerator), tonumber(denominator)\n\
    \    end\n    local numeratorX, denominatorX = getFraction(x)\n    local numeratorN,\
    \ denominatorN = getFraction(n)\n    local gcdDenominator = gcd(denominatorX,\
    \ denominatorN)\n    local fraction = numeratorX * numeratorN / (denominatorX\
    \ * denominatorN)\n    local integer = fraction % 1\n    if integer == 0 then\n\
    \        return true\n    else\n        return false\n    end\nend", "    local\
    \ x1, x2 = x:match('(%d+)/(%d+)')\n    local n1, n2 = n:match('(%d+)/(%d+)')\n\
    \    local x = tonumber(x1) / tonumber(x2)\n    local n = tonumber(n1) / tonumber(n2)\n\
    \    local r = x * n\n    return math.floor(r) == r\nend", "  local num = tonumber(x:match('^(%d+)/'))\
    \ * tonumber(n:match('^(%d+)/'))\n  local den = tonumber(x:match('/(%d+)$')) *\
    \ tonumber(n:match('/(%d+)$'))\n  return (den == 0 or num % den == 0)\nend", " \
    \ -- hint: use f_reduce() from fraction.lua to reduce both x and n, and try to\n\
    \  -- multiply the reduced fraction and see if it is a whole number\n  local f\
    \ = require './fraction'\n  local x_ = f.f_reduce(x)\n  local n_ = f.f_reduce(n)\n\
    \  local res = f.f_multiply(x_, n_)\n  local numerator = tonumber(f.f_get_numerator(res))\n\
    \  local denominator = tonumber(f.f_get_denominator(res))\n  if numerator % denominator\
    \ == 0 then\n    return true\n  else\n    return false\n  end\nend", end, "  --\
    \ TODO: implement your function here\nend", "  local a, b = x:match('(%d+)/(%d+)')\n\
    \  local c, d = n:match('(%d+)/(%d+)')\n  local xn = a*d\n  local nx = b*c\n \
    \ if xn % nx == 0 then\n    return true\n  else\n    return false\n  end\nend",
  "  x = x:gsub('/', '.')\n  n = n:gsub('/', '.')\n  return (((tonumber(x) * tonumber(n))\
    \ % 1) == 0)\nend", "    local xNumerator, xDenominator = unpack({\"\", \"\"},\
    \ 1, 2)\n    for i = 1, #x do\n        if x:sub(i, i) == \"/\" then\n        \
    \    xDenominator = x:sub(i + 1, #x)\n            break\n        else\n      \
    \      xNumerator = xNumerator .. x:sub(i, i)\n        end\n    end\n    local\
    \ nNumerator, nDenominator = unpack({\"\", \"\"}, 1, 2)\n    for i = 1, #n do\n\
    \        if n:sub(i, i) == \"/\" then\n            nDenominator = n:sub(i + 1,\
    \ #n)\n            break\n        else\n            nNumerator = nNumerator ..\
    \ n:sub(i, i)\n        end\n    end\n    local xNumerator = tonumber(xNumerator)\n\
    \    local xDenominator = tonumber(xDenominator)\n    local nNumerator = tonumber(nNumerator)\n\
    \    local nDenominator = tonumber(nDenominator)\n    if (xNumerator * nDenominator)\
    \ % (xDenominator * nNumerator) == 0 then\n        return true\n    else\n   \
    \     return false\n    end\nend", "    local xn = fraction(x) * fraction(n)\n\
    \    return xn.denominator == 1\nend", "    local x_num, x_den = (x or ''):match('(%d+)/(%d+)')\n\
    \    local n_num, n_den = (n or ''):match('(%d+)/(%d+)')\n    if x_num and x_den\
    \ and n_num and n_den then\n        x_num, x_den = tonumber(x_num), tonumber(x_den)\n\
    \        n_num, n_den = tonumber(n_num), tonumber(n_den)\n        return ((x_num\
    \ * n_den) % (x_den * n_num)) == 0\n    end\n    return false\nend", "    local\
    \ x_num, x_den = x:match('(%d+)/(%d+)')\n    local n_num, n_den = n:match('(%d+)/(%d+)')\n\
    \    x_num, x_den = tonumber(x_num), tonumber(x_den)\n    n_num, n_den = tonumber(n_num),\
    \ tonumber(n_den)\n    local result = (x_num * n_num) / (x_den * n_den)\n    return\
    \ math.floor(result) == result\nend", "  local function gcd(a, b)\n    if b ==\
    \ 0 then return a end\n    return gcd(b, a % b)\n  end\n  local function lcm(a,\
    \ b)\n    return (a * b) / gcd(a, b)\n  end\n  local function simplify_fraction(x)\n\
    \    local i, j = string.match(x, '([0-9]+)/([0-9]+)')\n    local k = gcd(i, j)\n\
    \    return (i / k) .. '/' .. (j / k)\n  end\n  local function lcm_fraction(x,\
    \ y)\n    local i, j = string.match(x, '([0-9]+)/([0-9]+)')\n    local k, l =\
    \ string.match(y, '([0-9]+)/([0-9]+)')\n    local m = lcm(j, l)\n    return (i\
    \ * (m / j)) .. '/' .. (k * (m / l))\n  end\n  local function multiply_fraction(x,\
    \ y)\n    local i, j = string.match(x, '([0-9]+)/([0-9]+)')\n    local k, l =\
    \ string.match(y, '([0-9]+)/([0-9]+)')\n    return (i * k) .. '/' .. (j * l)\n\
    \  end\n  x = simplify_fraction(x)\n  n = simplify_fraction(n)\n  local f = lcm_fraction(x,\
    \ n)\n  local m = multiply_fraction(x, n)\n  if string.find(f, m) then\n    return\
    \ true\n  else\n    return false\n  end\nend", "  assert(type(x) == 'string',\
    \ 'x should be a string')\n  assert(type(n) == 'string', 'n should be a string')\n\
    \  local function gcd(m, n)\n    assert(type(m) == 'number', 'm should be a number')\n\
    \    assert(type(n) == 'number', 'n should be a number')\n    return m == 0 and\
    \ n or gcd(n % m, m)\n  end\n  local function lcm(m, n)\n    assert(type(m) ==\
    \ 'number', 'm should be a number')\n    assert(type(n) == 'number', 'n should\
    \ be a number')\n    return m * n / gcd(m, n)\n  end\n  local xNumerator, xDenominator\
    \ = x:match('(%d+)/(%d+)')\n  local nNumerator, nDenominator = n:match('(%d+)/(%d+)')\n\
    \  return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\nend",
  "    -- Convert both numbers to floats\n    x_num, x_den = string.match(x, '^(%d+)/(%d+)$')\n\
    \    n_num, n_den = string.match(n, '^(%d+)/(%d+)$')\n    -- Check for whole number\n\
    \    return x_num * n_den == x_den * n_num\nend", "  -- your code here\nend",
  "  -- your code here\nend", "  local fx = frac(x)\n  local fn = frac(n)\n  return\
    \ fn.num % fx.den == 0 and fn.den % fx.num == 0\nend", "    local function gcd(a,\
    \ b)\n        while b ~= 0 do\n            a, b = b, a % b\n        end\n    \
    \    return a\n    end\n    local function mul(x, n)\n        local x_n, x_d =\
    \ x:match(\"(%d+)/(%d+)\")\n        local n_n, n_d = n:match(\"(%d+)/(%d+)\")\n\
    \        x_n, x_d, n_n, n_d = tonumber(x_n), tonumber(x_d), tonumber(n_n), tonumber(n_d)\n\
    \        local l, r = x_n * n_n, x_d * n_d\n        local g = gcd(l, r)\n    \
    \    l, r = l / g, r / g\n        return l, r\n    end\n    local l, r = mul(x,\
    \ n)\n    return l == math.floor(l) and r == 1\nend", "  x, n = tonumber(x:sub(1,\
    \ x:find('/') - 1)), tonumber(n:sub(1, n:find('/') - 1))\n  return x * n == math.floor(x\
    \ * n)\nend", "  local function gcd(a, b)\n    while b ~= 0 do\n      a, b = b,\
    \ a % b\n    end\n    return a\n  end\n  local function string2fraction(s)\n \
    \   local numerator, denominator = unpack(table.map(function(x) return tonumber(x)\
    \ end, s:split('/')))\n    local divisor = gcd(numerator, denominator)\n    return\
    \ numerator / divisor, denominator / divisor\n  end\n  local numerator1, denominator1\
    \ = string2fraction(x)\n  local numerator2, denominator2 = string2fraction(n)\n\
    \  return numerator1 * denominator2 % denominator1 == 0\nend", "  local function\
    \ gcd(a, b)\n    if b == 0 then return a end\n    return gcd(b, a % b)\n  end\n\
    \  local x_num, x_den = x:match(\"(%d+)/(%d+)\")\n  local n_num, n_den = n:match(\"\
    (%d+)/(%d+)\")\n  x_num, x_den = tonumber(x_num), tonumber(x_den)\n  n_num, n_den\
    \ = tonumber(n_num), tonumber(n_den)\n  if gcd(x_num * n_den, x_den * n_num) ==\
    \ x_den * n_num then\n    return true\n  else\n    return false\n  end\nend",
  "  local sign = n:sub(1, 1) == '-' and '-' or ''\n  n = n:gsub('-', '')\n  local\
    \ x_n = Fraction(n)\n  local x_x = Fraction(x)\n  return (x_x * x_n):toString()\
    \ == sign .. '1/1'\nend", "\tlocal function gcd(x, y)\n\t\tlocal a, b\n\t\tif\
    \ x > y then\n\t\t\ta, b = x, y\n\t\telse\n\t\t\ta, b = y, x\n\t\tend\n\t\tif\
    \ a % b == 0 then\n\t\t\treturn b\n\t\telse\n\t\t\treturn gcd(b, a % b)\n\t\t\
    end\n\tend\n\tlocal x_num, x_den, n_num, n_den = x:match('(%d+)/(%d+)'), n:match('(%d+)/(%d+)')\n\
    \treturn tonumber(x_num) * tonumber(n_den) * gcd(tonumber(x_den), tonumber(n_den))\
    \ == tonumber(n_num) * tonumber(x_den) * gcd(tonumber(x_num), tonumber(n_den))\n\
    end", end, "    -- check if x * n is a whole number\n    -- if it is, return true\n\
    \    -- if it isn't, return false\n    -- ...\nend", "  local function gcd(a,\
    \ b)\n    while b ~= 0 do\n      a, b = b, a % b\n    end\n    return a\n  end\n\
    \  local x, n = x:split('/'), n:split('/')\n  local f, s = tonumber(x[1]) / tonumber(x[2]),\
    \ tonumber(n[1]) / tonumber(n[2])\n  local f, s = f * s, gcd(s, tonumber(x[2]))\n\
    \  local f, s = f / s, tonumber(n[2]) / gcd(s, tonumber(n[2]))\n  return math.floor(f)\
    \ == f\nend", "    local function gcd(a, b)\n        while b ~= 0 do\n       \
    \     a, b = b, a % b\n        end\n        return a\n    end\n    local numerator\
    \ = tonumber(x:match('(%d+)/')) * tonumber(n:match('(%d+)/'))\n    local denominator\
    \ = tonumber(x:match('/(%d+)')) * tonumber(n:match('/(%d+)'))\n    local g = gcd(numerator,\
    \ denominator)\n    return (numerator / g) % (denominator / g) == 0\nend", " \
    \ if x:find('/') then\n    local num, denom = x:match('^(%d+)/(%d+)$')\n    x\
    \ = num / denom\n  else\n    x = tonumber(x)\n  end\n  if n:find('/') then\n \
    \   local num, denom = n:match('^(%d+)/(%d+)$')\n    n = num / denom\n  else\n\
    \    n = tonumber(n)\n  end\n  return math.floor(x * n) == x * n\nend", "    local\
    \ xNumerator, xDenominator = x:match('(%d+)/(%d+)')\n    local nNumerator, nDenominator\
    \ = n:match('(%d+)/(%d+)')\n    xNumerator, xDenominator = tonumber(xNumerator),\
    \ tonumber(xDenominator)\n    nNumerator, nDenominator = tonumber(nNumerator),\
    \ tonumber(nDenominator)\n    local resultNumerator = xNumerator * nNumerator\n\
    \    local resultDenominator = xDenominator * nDenominator\n    local result =\
    \ resultNumerator / resultDenominator\n    local integerResult = math.floor(result)\n\
    \    return integerResult == result\nend", "    local _, _, xn, xd = x:find('(%d+)/(%d+)')\n\
    \    local _, _, nn, nd = n:find('(%d+)/(%d+)')\n    xn, xd, nn, nd = tonumber(xn),\
    \ tonumber(xd), tonumber(nn), tonumber(nd)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\nend", "  -- your code here\nend", "  local nx, nn = parse_fraction(x), parse_fraction(n)\n\
    \  return ((nx * nn) % 1) == 0\nend", "  local num_x, denom_x = unpack(x:split('/'))\n\
    \  local num_n, denom_n = unpack(n:split('/'))\n  local a = tonumber(num_x) *\
    \ tonumber(denom_n)\n  local b = tonumber(num_n) * tonumber(denom_x)\n  return\
    \ a % b == 0\nend", "    local num1,den1 = fraction(x)\n    local num2,den2 =\
    \ fraction(n)\n    local num = num1 * num2\n    local den = den1 * den2\n    return\
    \ equal_int(num, den)\nend", "  local x_num, x_den = x:match('(%d+)/(%d+)')\n\
    \  local n_num, n_den = n:match('(%d+)/(%d+)')\n  return (math.floor(x_num * n_den)\
    \ % math.floor(x_den * n_num)) == 0\nend", end, "    local function gcd(a, b)\n\
    \        local r\n        while b ~= 0 do\n            r = a % b\n           \
    \ a = b\n            b = r\n        end\n        return a\n    end\n    local\
    \ function lcm(a, b)\n        return a * b / gcd(a, b)\n    end\n    local function\
    \ get_frac(x)\n        local a, b = x:match('(%d+)/(%d+)')\n        return tonumber(a),\
    \ tonumber(b)\n    end\n    local x_a, x_b = get_frac(x)\n    local n_a, n_b =\
    \ get_frac(n)\n    local m = lcm(x_b, n_b)\n    return m / x_b * x_a == m / n_b\
    \ * n_a\nend", "    local x_num, x_den = x:match('^(%d+)/(%d+)$')\n    local n_num,\
    \ n_den = n:match('^(%d+)/(%d+)$')\n    return ((x_num * n_den) % (x_den * n_num))\
    \ == 0\nend", "  local x_n, x_d = x:match(\"(%d+)/(%d+)\")\n  local n_n, n_d =\
    \ n:match(\"(%d+)/(%d+)\")\n  x_n, x_d, n_n, n_d = tonumber(x_n), tonumber(x_d),\
    \ tonumber(n_n), tonumber(n_d)\n  return x_n * n_d * n_n * x_d % (x_d * n_d) ==\
    \ 0\nend", "  -- your code here\nend", "    return (n == '1/1') or (x == '1/1')\n\
    end", "\tlocal xnum, xden = x:match(\"(%d+)/(%d+)\")\n\tlocal nnum, nden = n:match(\"\
    (%d+)/(%d+)\")\n\treturn tonumber(xnum) * tonumber(nden) % tonumber(xden) == 0\n\
    end", "  local x_num, x_den = unpack(split(x, '/'))\n  local n_num, n_den = unpack(split(n,\
    \ '/'))\n  -- local xx = x_num * n_den\n  -- local yy = x_den * n_num\n  -- return\
    \ (yy % xx) == 0\n  local num = tonumber(x_num) * tonumber(n_den)\n  local den\
    \ = tonumber(x_den) * tonumber(n_num)\n  return (den % num) == 0\nend", "  local\
    \ numerator = getnumerator(x) * getdenominator(n)\n  local denominator = getdenominator(x)\
    \ * getnumerator(n)\n  return numerator % denominator == 0\nend", "  local x_numerator,\
    \ x_denominator = x:match('(%d+)/(%d+)')\n  local n_numerator, n_denominator =\
    \ n:match('(%d+)/(%d+)')\n  local product_numerator = x_numerator * n_numerator\n\
    \  local product_denominator = x_denominator * n_denominator\n  local gcd = math.gcd(product_numerator,\
    \ product_denominator)\n  product_numerator = product_numerator / gcd\n  product_denominator\
    \ = product_denominator / gcd\n  return product_numerator % product_denominator\
    \ == 0\nend", "  local n_num, n_den = n:match(\"(%d+)/(%d+)\")\n  local x_num,\
    \ x_den = x:match(\"(%d+)/(%d+)\")\n  local num = n_num * x_den\n  local den =\
    \ n_den * x_num\n  return num % den == 0\nend", "    local function gcd(a, b)\n\
    \        if b == 0 then\n            return a\n        else\n            return\
    \ gcd(b, a % b)\n        end\n    end", "    -- Your code here\nend", "  return\
    \ true\nend", "  -- TODO: Find a solution for this problem\nend", "    local x_numerator,\
    \ x_denominator = x:match(\"(%d+)/(%d+)\")\n    local n_numerator, n_denominator\
    \ = n:match(\"(%d+)/(%d+)\")\n    local lcm = require(\"utils.maths\").lcm\n \
    \   local gcd = require(\"utils.maths\").gcd\n    local numerator = tonumber(x_numerator)\
    \ * tonumber(n_denominator)\n    local denominator = tonumber(x_denominator) *\
    \ tonumber(n_numerator)\n    local value = numerator / denominator\n    if value\
    \ % 1 == 0 then\n        return true\n    else\n        return false\n    end\n\
    end", "    if n == '1/1' then\n        return x == '1/1'\n    end\n    if n ==\
    \ '2/1' then\n        local x1, x2 = x:match '^(%d+)/(%d+)$'\n        x1, x2 =\
    \ tonumber(x1), tonumber(x2)\n        if x2 % 2 == 0 then\n            return\
    \ x1 % 2 == 0\n        end\n        return false\n    end\n    if n == '5/1' then\n\
    \        local x1, x2 = x:match '^(%d+)/(%d+)$'\n        x1, x2 = tonumber(x1),\
    \ tonumber(x2)\n        if x2 % 5 == 0 then\n            return x1 % 5 == 0\n\
    \        end\n        return false\n    end\n    return false\nend", "    local\
    \ x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n    local n_numerator,\
    \ n_denominator = n:match('(%d+)/(%d+)')\n    local expected_numerator = tonumber(x_numerator)\
    \ * tonumber(n_numerator)\n    local expected_denominator = tonumber(x_denominator)\
    \ * tonumber(n_denominator)\n    local result = math.floor(expected_numerator\
    \ / expected_denominator)\n    if result == (expected_numerator / expected_denominator)\
    \ then\n        return true\n    else\n        return false\n    end\nend", " \
    \   local function gcd(a, b)\n        while b ~= 0 do\n            a, b = b, a\
    \ % b\n        end\n        return a\n    end\n    x = x:match('(%d+)/(%d+)')\n\
    \    local x_n, x_d = tonumber(x[1]), tonumber(x[2])\n    n = n:match('(%d+)/(%d+)')\n\
    \    local n_n, n_d = tonumber(n[1]), tonumber(n[2])\n    local dx = x_d * n_d\n\
    \    local dn = dx / x_d\n    x_n = x_n * dn\n    n_n = n_n * dx / n_d\n    local\
    \ s = gcd(x_n, dx)\n    x_n, dx = x_n / s, dx / s\n    if dx == 1 and x_n % n_n\
    \ == 0 then\n        return true\n    else\n        return false\n    end\nend",
  "  -- your code here\nend", "    local x_num, x_den = x:match('(%d+)/(%d+)')\n \
    \   local n_num, n_den = n:match('(%d+)/(%d+)')\n    local result = x_num * n_num\
    \ / (x_den * n_den)\n    return not (result % 1 ~= 0)\nend", "  local x_numerator,\
    \ x_denominator = unpack(string.split(x, '/'))\n  local n_numerator, n_denominator\
    \ = unpack(string.split(n, '/'))\n  local result_numerator = tonumber(x_numerator)\
    \ * tonumber(n_numerator)\n  local result_denominator = tonumber(x_denominator)\
    \ * tonumber(n_denominator)\n  return result_numerator % result_denominator ==\
    \ 0\nend", "    local x_num, x_den = x:match(\"^(%d+)/(%d+)$\")\n    local n_num,\
    \ n_den = n:match(\"^(%d+)/(%d+)$\")\n    return x_num * n_den == x_den * n_num\n\
    end", "\tlocal a, b = tonumber(x:match(\"(%d+)/(%d+)\"))\n\tlocal c, d = tonumber(n:match(\"\
    (%d+)/(%d+)\"))\n\treturn (a * d) % (b * c) == 0\nend", "  -- your code here\n\
    end", "    local x_numerator, x_denominator = x:match(\"(%d+)/(%d+)\")\n    local\
    \ n_numerator, n_denominator = n:match(\"(%d+)/(%d+)\")\n    return (tonumber(x_numerator)\
    \ * tonumber(n_denominator)) % (tonumber(x_denominator) * tonumber(n_numerator))\
    \ == 0\nend", "  -- no clue to solve\nend", "    local function gcd(a, b)\n  \
    \      while b ~= 0 do\n            local c = a % b\n            a = b\n     \
    \       b = c\n        end\n        return a\n    end\n    local xn, xd = x:match('(%d+)/(%d+)')\n\
    \    local yn, yd = n:match('(%d+)/(%d+)')\n    xn, xd, yn, yd = tonumber(xn),\
    \ tonumber(xd), tonumber(yn), tonumber(yd)\n    local d = xd * yd\n    local g\
    \ = gcd(d, xn * yd)\n    local m = d / g\n    return m % xn == 0\nend", "  local\
    \ function gcd(a, b)\n    if b == 0 then return a end\n    return gcd(b, a % b)\n\
    \  end\n  local function lcm(a, b)\n    return a * b / gcd(a, b)\n  end\n  local\
    \ function mul(x, n)\n    local x_num, x_den = x:match(\"(%d+)/(%d+)\")\n    local\
    \ n_num, n_den = n:match(\"(%d+)/(%d+)\")\n    return x_num * n_num .. \"/\" ..\
    \ x_den * n_den\n  end\n  local function is_integer(x)\n    local num, den = x:match(\"\
    (%d+)/(%d+)\")\n    return gcd(num, den) == den\n  end\n  return is_integer(mul(x,\
    \ n))\nend", "  -- Write your code here.\nend", "  -- your code here\nend", " \
    \ -- TODO: implement me!\nend", "    -- your code here\nend", "    return (tonumber(x:match('(%d+)/(%d+)'))\
    \ * tonumber(n:match('(%d+)/(%d+)'))) % tonumber(x:match('(%d+)/(%d+)')) == 0\n\
    end", "\tlocal function gcd(a, b)\n\t\tif b == 0 then\n\t\t\treturn a\n\t\telse\n\
    \t\t\treturn gcd(b, a % b)\n\t\tend\n\tend\n\tlocal function fraction_to_int(fraction)\n\
    \t\tlocal _, _, num, den = fraction:find('(%d+)/(%d+)')\n\t\treturn num / den\n\
    \tend\n\tlocal function int_to_fraction(int)\n\t\tlocal num = 1\n\t\tlocal den\
    \ = int\n\t\tlocal g = gcd(num, den)\n\t\treturn tostring(num / g) .. '/' .. tostring(den\
    \ / g)\n\tend\n\tlocal a = fraction_to_int(x)\n\tlocal b = fraction_to_int(n)\n\
    \tlocal result = a * b\n\treturn int_to_fraction(result) == n\nend", "  local\
    \ f = tonumber(x) * tonumber(n)\n  if math.floor(f) == f then\n    return true\n\
    \  else\n    return false\n  end\nend", "  -- your solution here\nend", "    --\
    \ Your code goes here\nend", "  -- your code here\nend", "  local function gcd(a,\
    \ b)\n    while b ~= 0 do\n      a, b = b, a % b\n    end\n    return a\n  end\n\
    \  local function mul(a, b)\n    local n, a1, a2 = gcd(a[1], b[1]), a[1] / gcd(a[1],\
    \ b[1]), b[1] / gcd(a[1], b[1])\n    local d, b1, b2 = gcd(a[2], b[2]), a[2] /\
    \ gcd(a[2], b[2]), b[2] / gcd(a[2], b[2])\n    return (a1 * b1) / (n * d), (a2\
    \ * b2) / (n * d)\n  end\n  local a, b = {tonumber(x:match('(%d+)/(%d+)'))}, {tonumber(n:match('(%d+)/(%d+)'))}\n\
    \  return a[1] * b[2] % (a[2] * b[1]) == 0\nend", "    local function gcd(x, y)\n\
    \        while x ~= y do\n            if x > y then\n                x = x - y\n\
    \            else\n                y = y - x\n            end\n        end\n \
    \       return x\n    end\n    local _, _, n1, d1 = x:find(\"(%d+)/(%d+)\")\n\
    \    local _, _, n2, d2 = n:find(\"(%d+)/(%d+)\")\n    local g1 = gcd(tonumber(n1),\
    \ tonumber(d1))\n    local g2 = gcd(tonumber(n2), tonumber(d2))\n    local n1,\
    \ d1 = tonumber(n1) / g1, tonumber(d1) / g1\n    local n2, d2 = tonumber(n2) /\
    \ g2, tonumber(d2) / g2\n    local n3, d3 = n1 * d2 + n2 * d1, d1 * d2\n    local\
    \ g3 = gcd(n3, d3)\n    return n3 % (d3 / g3) == 0\nend", "    local numerator1,\
    \ denominator1 = string.match(x, '(%d+)/(%d+)')\n    local numerator2, denominator2\
    \ = string.match(n, '(%d+)/(%d+)')\n    numerator1, denominator1 = tonumber(numerator1),\
    \ tonumber(denominator1)\n    numerator2, denominator2 = tonumber(numerator2),\
    \ tonumber(denominator2)\n    local result = numerator1 * numerator2 / denominator1\
    \ / denominator2\n    return math.floor(result) == result\nend", "    local a\
    \ = x:split('/')\n    local b = n:split('/')\n    local numerator = tonumber(a[1])\
    \ * tonumber(b[2])\n    local denominator = tonumber(a[2]) * tonumber(b[1])\n\
    \    return numerator % denominator == 0\nend", "  local x1, x2 = x:match(\"(%d+)/(%d+)\"\
    )\n  local n1, n2 = n:match(\"(%d+)/(%d+)\")\n  return (x1*n2)%(x2*n1) == 0\n\
    end", "  -- TODO: implement the function\nend", end, "    if x == '1/1' then\n\
    \        return true\n    end\n    local a, b = tonumber(x:match('(%d+)/(%d+)'))\n\
    \    local c, d = tonumber(n:match('(%d+)/(%d+)'))\n    local _a, _b = a * d,\
    \ b * c\n    if _a % _b == 0 then\n        return true\n    end\n    return false\n\
    end", "    local xs = math.floor(tonumber(x:match'^(%d+)/'))\n    local xn = math.floor(tonumber(x:match'/(%d+)$'))\n\
    \    local ns = math.floor(tonumber(n:match'^(%d+)/'))\n    local nn = math.floor(tonumber(n:match'/(%d+)$'))\n\
    \    return nn % xs == 0 and ns * (nn / xs) % xn == 0\nend", "    local function\
    \ gcd(a, b)\n        return b == 0 and a or gcd(b, a % b)\n    end\n    local\
    \ function lcm(a, b)\n        return a * b / gcd(a, b)\n    end\n    local function\
    \ is_whole(x)\n        return x % 1 == 0\n    end\n    local x_numerator, x_denominator\
    \ = x:match('(%d+)/(%d+)')\n    local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n\
    \    x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)\n\
    \    n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)\n\
    \    return is_whole(x_numerator * n_denominator * n_numerator / x_denominator)\n\
    end", "  local function gcd(a, b)\n    local r\n    repeat\n      r = a % b\n\
    \      a = b\n      b = r\n    until r == 0\n    return a\n  end\n  local function\
    \ get_fraction(x)\n    local num, den = x:match('(%d+)/(%d+)')\n    return tonumber(num),\
    \ tonumber(den)\n  end\n  local function mul(x, n)\n    local mnum, mden = x.num\
    \ * n.num, x.den * n.den\n    local g = gcd(mnum, mden)\n    return {num = mnum\
    \ / g, den = mden / g}\n  end\n  local x = get_fraction(x)\n  local n = get_fraction(n)\n\
    \  local r = mul(x, n)\n  return r.num % r.den == 0\nend", "    local x_num, x_den,\
    \ n_num, n_den = tonumber(x:match('^(%d+)/(%d+)$')), tonumber(n:match('^(%d+)/(%d+)$'))\n\
    \    return (x_num * n_den) % (x_den * n_num) == 0\nend", "    local function\
    \ fractionToNumber(frac)\n        local n, d = frac:match('(.*)/(.*)')\n     \
    \   return tonumber(n) / tonumber(d)\n    end\n    return math.floor(fractionToNumber(x)\
    \ * fractionToNumber(n)) == fractionToNumber(x) * fractionToNumber(n)\nend", " \
    \ x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n  x_numerator = tonumber(x_numerator)\n\
    \  x_denominator = tonumber(x_denominator)\n  n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n\
    \  n_numerator = tonumber(n_numerator)\n  n_denominator = tonumber(n_denominator)\n\
    \  local product_numerator = x_numerator * n_numerator\n  local product_denominator\
    \ = x_denominator * n_denominator\n  local gcd = math.gcd(product_numerator, product_denominator)\n\
    \  local simplified_product_numerator = product_numerator / gcd\n  local simplified_product_denominator\
    \ = product_denominator / gcd\n  return simplified_product_numerator % simplified_product_denominator\
    \ == 0\nend", "    -- your code here\nend", "  -- your code here\nend", "    local\
    \ function gcd(a, b)\n        while a ~= 0 do\n            a, b = b % a, a\n \
    \       end\n        return b\n    end\n    local function lcm(a, b)\n       \
    \ return a * b / gcd(a, b)\n    end\n    local a, b = x:match('(%d+)/(%d+)')\n\
    \    local c, d = n:match('(%d+)/(%d+)')\n    a, b, c, d = tonumber(a), tonumber(b),\
    \ tonumber(c), tonumber(d)\n    local e = gcd(b, d)\n    local f = b / e\n   \
    \ local g = d / e\n    local h = c * f\n    local i = h / g\n    return i % 1\
    \ == 0\nend", "    local a, b = tonumber(x:match(\"(%d+)/(%d+)\"))\n    local\
    \ c, d = tonumber(n:match(\"(%d+)/(%d+)\"))\n    local xy = a * d\n    local nx\
    \ = b * c\n    if xy == nx then\n        return true\n    else\n        return\
    \ false\n    end\nend", "    local function get_num(s)\n        local i, j = s:find('/')\n\
    \        return tonumber(s:sub(1, i - 1))\n    end\n    local function get_denom(s)\n\
    \        local i, j = s:find('/')\n        return tonumber(s:sub(j + 1))\n   \
    \ end\n    local result = get_num(x) * get_denom(n) / get_denom(x) / get_num(n)\n\
    \    if result == math.floor(result) then\n        return true\n    else\n   \
    \     return false\n    end\nend", "  local x_num, x_den = x:match(\"(%d+)/(%d+)\"\
    )\n  local n_num, n_den = n:match(\"(%d+)/(%d+)\")\n  local n_num, n_den = n_num\
    \ * x_den, n_den * x_num\n  return math.mod(n_num, n_den) == 0\nend", "  return\
    \ false\nend", "    local function gcd(n, m)\n        if n < m then n, m = m,\
    \ n end\n        while m ~= 0 do\n            n, m = m, n % m\n        end\n \
    \       return n\n    end\n    local x_num, x_denom = tonumber(x:match(\"^(%d+)/(%d+)$\"\
    )), tonumber(x:match(\"^(%d+)/(%d+)$\"))\n    local n_num, n_denom = tonumber(n:match(\"\
    ^(%d+)/(%d+)$\")), tonumber(n:match(\"^(%d+)/(%d+)$\"))\n    return ((x_num *\
    \ n_num) % (x_denom * n_denom)) == 0\nend", "\tlocal x_num, x_den = x:match '(%d+)/(%d+)'\n\
    \tlocal n_num, n_den = n:match '(%d+)/(%d+)'\n\tlocal num = x_num * n_num\n\t\
    local den = x_den * n_den\n\tlocal factor = gcd(num, den)\n\tnum = num / factor\n\
    \tden = den / factor\n\treturn num == den\nend", "    local numx, denx = x:match('(%d+)/(%d+)')\n\
    \    local numn, denn = n:match('(%d+)/(%d+)')\n    local nump, denp = tonumber(numx)\
    \ * tonumber(numn), tonumber(denx) * tonumber(denn)\n    local frac = simplifyfrac(nump,\
    \ denp)\n    return frac == '' and true or false\nend", "    local x_numerator,\
    \ x_denominator = x:match(\"(%d+)/(%d+)\")\n    local n_numerator, n_denominator\
    \ = n:match(\"(%d+)/(%d+)\")\n    local common_denominator = x_denominator * n_denominator\n\
    \    local common_numerator = x_numerator * n_denominator + n_numerator * x_denominator\n\
    \    return common_numerator % common_denominator == 0\nend", "    x,n = x:match('(%d+)/(%d+)'),\
    \ n:match('(%d+)/(%d+)')\n    x,n = tonumber(x), tonumber(n)\n    return x*n %\
    \ 1 == 0\nend", "  local function gcd(a, b)\n    if b == 0 then return a end\n\
    \    return gcd(b, a % b)\n  end\n  local function tonum(x)\n    local vals =\
    \ split(x, '/')\n    return tonumber(vals[1]) / tonumber(vals[2])\n  end\n  local\
    \ function factorize(x)\n    local ret = {}\n    local val = x\n    while val\
    \ > 1 do\n      local p = 2\n      while p <= val do\n        if val % p == 0\
    \ then\n          val = val / p\n          ret[p] = (ret[p] or 0) + 1\n      \
    \  else\n          p = p + 1\n        end\n      end\n    end\n    return ret\n\
    \  end\n  local function simplifyfraction(x)\n    local num = tostring(x.num)\n\
    \    local den = tostring(x.den)\n    if x.num == x.den then\n      return '1/1'\n\
    \    elseif x.num > x.den then\n      local div = math.floor(x.num / x.den)\n\
    \      local mod = x.num % x.den\n      return div..'/1'..' + '..tostring(mod)..'/'..tostring(x.den)\n\
    \    else\n      local numfactor = factorize(x.num)\n      local denfactor = factorize(x.den)\n\
    \      local factor = {}\n      for p, v in pairs(numfactor) do\n        local\
    \ val = math.min(v, denfactor[p] or 0)\n        numfactor[p] = v - val\n     \
    \   denfactor[p] = (denfactor[p] or 0) - val\n        factor[p] = val\n      end\n\
    \      local div = 1\n      for p, v in pairs(factor) do\n        for i = 1, v\
    \ do\n          div = div * p\n        end\n      end\n      local modnum = 1\n\
    \      for p, v in pairs(numfactor) do\n        for i = 1, v do\n          modnum\
    \ = modnum * p\n        end\n      end\n      local modden = 1\n      for p, v\
    \ in pairs(den", "  local function gcd(a, b)\n    while b ~= 0 do\n      a, b\
    \ = b, a % b\n    end\n    return a\n  end\n  local function get_num(frac)\n \
    \   return tonumber(frac:match '^(%d+)/%d+$')\n  end\n  local function get_den(frac)\n\
    \    return tonumber(frac:match '^%d+/(%d+)$')\n  end\n  local x_num, x_den =\
    \ get_num(x), get_den(x)\n  local n_num, n_den = get_num(n), get_den(n)\n  local\
    \ tmp = gcd(x_num * n_den, x_den * n_num)\n  local num = (x_num * n_den) / tmp\n\
    \  local den = (x_den * n_num) / tmp\n  return tmp ~= 1 and num % den == 0\nend",
  "    --[[\n        x * n = a/b * c/d = a * c / b * d\n        if a * c % b * d ==\
    \ 0 then\n            return true\n        else\n            return false\n  \
    \      end\n    ]]\n    local function gcd(a, b)\n        if b == 0 then\n   \
    \         return a\n        else\n            return gcd(b, a % b)\n        end\n\
    \    end\n    local function lcm(a, b)\n        return a * b / gcd(a, b)\n   \
    \ end\n    local function simplify2(x)\n        local a, b = string.match(x, '(%d+)/(%d+)')\n\
    \        a, b = tonumber(a), tonumber(b)\n        local f = gcd(a, b)\n      \
    \  a, b = a / f, b / f\n        return a, b\n    end\n    local function simplify3(x,\
    \ y)\n        local a, b = simplify2(x)\n        local c, d = simplify2(y)\n \
    \       local l = lcm(b, d)\n        a, c = a * l / b, c * l / d\n        return\
    \ a, c\n    end\n    local a, c = simplify3(x, n)\n    if a % c == 0 then\n  \
    \      return true\n    else\n        return false\n    end\nend", "  local fraction,\
    \ fractionN = (x:gsub(' ', ''):gsub('-', '')), (n:gsub(' ', ''):gsub('-', ''))\n\
    \  local function gcd(a, b)\n    if b > a then a, b = b, a end\n    while b ~=\
    \ 0 do\n      a, b = b, a % b\n    end\n    return a\n  end\n  local a, b = string.match(fraction,\
    \ '/(.*)')\n  local c, d = string.match(fractionN, '/(.*)')\n  local fractionNum\
    \ = gcd(tonumber(a), tonumber(c))\n  local fractionDen = gcd(tonumber(b), tonumber(d))\n\
    \  local num, den = (tonumber(a) * tonumber(c)), (tonumber(b) * tonumber(d))\n\
    \  if num == den or den == fractionNum then\n    return true\n  elseif num ==\
    \ fractionDen then\n    return true\n  elseif den == (num / fractionNum) then\n\
    \    return true\n  elseif num == (den / fractionDen) then\n    return true\n\
    \  else\n    return false\n  end\nend", "    local x_numerator, x_denominator\
    \ = x:match(\"(%d+)/(%d+)\")\n    local n_numerator, n_denominator = n:match(\"\
    (%d+)/(%d+)\")\n    return (tonumber(x_numerator) * tonumber(n_denominator)) %\
    \ tonumber(x_denominator) == 0\nend", "    local num, den = x:match('^(%d+)/(%d+)$')\n\
    \    num, den = tonumber(num), tonumber(den)\n    assert(num and den and num >\
    \ 0 and den > 0)\n    local num1, den1 = n:match('^(%d+)/(%d+)$')\n    num1, den1\
    \ = tonumber(num1), tonumber(den1)\n    assert(num1 and den1 and num1 > 0 and\
    \ den1 > 0)\n    local pnum, pden = num * den1, den * num1\n    return math.fmod(pnum,\
    \ pden) == 0\nend", "    -- Your code here\nend", "    -- This is your job. :)\n\
    end", "  local function gcd(a, b)\n    local m = math.max(a, b)\n    local n =\
    \ math.min(a, b)\n    local r = m % n\n    if r == 0 then\n      return n\n  \
    \  else\n      return gcd(n, r)\n    end\n  end", "  local xNumerator, xDenominator\
    \ = x:match(\"(%d+)/(%d+)\")\n  local nNumerator, nDenominator = n:match(\"(%d+)/(%d+)\"\
    )\n  local pNumerator = xNumerator * nDenominator\n  local pDenominator = xDenominator\
    \ * nNumerator\n  return pNumerator % pDenominator == 0\nend", "    local function\
    \ parse(x)\n        local a, b = x:match(\"(%d+)/(%d+)\")\n        return tonumber(a),\
    \ tonumber(b)\n    end\n    local a, b = parse(x)\n    local c, d = parse(n)\n\
    \    return (a * d) % (b * c) == 0\nend", "    return false\nend", "    -- check\
    \ if x * n is a whole number\n    if x * n ~= math.floor(x * n) then\n       \
    \ return false\n    end\n    return true\nend", "    local xnum, xden = x:match('(%d+)/(%d+)')\n\
    \    local nnum, nden = n:match('(%d+)/(%d+)')\n    local mul = xnum * nnum\n\
    \    local div = xden * nden\n    return mul % div == 0\nend", "  if n == '1/1'\
    \ then\n    return true\n  end\n  local x_num, x_den = x:match('^(%d+)/(%d+)$')\n\
    \  local n_num, n_den = n:match('^(%d+)/(%d+)$')\n  x_num, x_den = tonumber(x_num),\
    \ tonumber(x_den)\n  n_num, n_den = tonumber(n_num), tonumber(n_den)\n  return\
    \ (x_num * n_den) % (x_den * n_num) == 0\nend", "    local x_numerator, x_denominator\
    \ = x:match('^(%d+)/(%d+)$')\n    local n_numerator, n_denominator = n:match('^(%d+)/(%d+)$')\n\
    \    x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)\n\
    \    n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)\n\
    \    local x_simplified = x_numerator * n_denominator\n    local n_simplified\
    \ = n_numerator * x_denominator\n    return x_simplified % n_simplified == 0\n\
    end", "  local num, den = x:match(\"(%d+)/(%d+)\")\n  local num1, den1 = n:match(\"\
    (%d+)/(%d+)\")\n  return tonumber(num1) % tonumber(den) == 0 and tonumber(num)\
    \ % tonumber(den1) == 0\nend", "  --\nend", "    local function gcd(x, y)\n  \
    \      if y == 0 then\n            return x\n        else\n            return\
    \ gcd(y, x % y)\n        end\n    end", "    local function gcd(a, b)\n      \
    \  if a == 0 then return b\n        else return gcd(b % a, a)\n        end\n \
    \   end\n    local function simplify(x)\n        local numerator, denominator\
    \ = x:match('(%d+)/(%d+)')\n        local denominator = tonumber(denominator)\n\
    \        local numerator = tonumber(numerator)\n        local gcd_val = gcd(numerator,\
    \ denominator)\n        if gcd_val ~= 1 then\n            numerator = numerator\
    \ / gcd_val\n            denominator = denominator / gcd_val\n        end\n  \
    \      return numerator, denominator\n    end\n    local function is_whole_number(num)\n\
    \        if num > 0 and num == math.floor(num) then\n            return true\n\
    \        else\n            return false\n        end\n    end\n    local x_numerator,\
    \ x_denominator = simplify(x)\n    local n_numerator, n_denominator = simplify(n)\n\
    \    local result = x_numerator * n_denominator\n    local result_denominator\
    \ = x_denominator * n_numerator\n    return is_whole_number(result/result_denominator)\n\
    end", "  local x_nu, x_de = x:match(\"(%d+)/(%d+)\")\n  local n_nu, n_de = n:match(\"\
    (%d+)/(%d+)\")\n  local nu = tonumber(x_nu) * tonumber(n_de)\n  local de = tonumber(x_de)\
    \ * tonumber(n_nu)\n  if nu % de == 0 then\n    return true\n  else\n    return\
    \ false\n  end\nend", "  local a = fractions.new(x)\n  local b = fractions.new(n)\n\
    \  return fractions.is_whole(fractions.multiply(a, b))\nend", "  -- your code\
    \ here\nend", "    local p = tonumber(x:match('(%d+)/%d+'))\n    local q = tonumber(x:match('%d+/(%d+)'))\n\
    \    local r = tonumber(n:match('(%d+)/%d+'))\n    local s = tonumber(n:match('%d+/(%d+)'))\n\
    \    return math.fmod(r, q) == 0 and math.fmod(s, p) == 0\nend", "  local function\
    \ gcd(a, b)\n    while b ~= 0 do\n      a, b = b, a % b\n    end\n    return a\n\
    \  end\n  local a1, b1 = tonumber(x:match('(%d+)/(%d+)')), tonumber(n:match('(%d+)/(%d+)'))\n\
    \  local g = gcd(a1, b1)\n  a1, b1 = a1 / g, b1 / g\n  local a2, b2 = a1 * b1,\
    \ a1 * b1\n  g = gcd(a2, b2)\n  a2, b2 = a2 / g, b2 / g\n  return (a2 * b2) %\
    \ a1 == 0\nend", "  local x_num, x_den = x:match('^(%d+)/(%d+)$')\n  local n_num,\
    \ n_den = n:match('^(%d+)/(%d+)$')\n  local lcm = math.lcm(x_den, n_den)\n  local\
    \ result = tonumber(x_num) * (lcm / tonumber(x_den)) * (tonumber(n_den) / lcm)\n\
    \  return result % 1 == 0\nend", "  local xn = tonumber(x) * tonumber(n)\n  if\
    \ xn % 1 == 0 then\n    return true\n  else\n    return false\n  end\nend", " \
    \   local xnumerator, xdenominator = x:match('(%d+)/(%d+)')\n    local nnumerator,\
    \ ndenominator = n:match('(%d+)/(%d+)')\n    -- the simplified x * n\n    local\
    \ snumerator = tonumber(xnumerator) * tonumber(nnumerator)\n    local sdenominator\
    \ = tonumber(xdenominator) * tonumber(ndenominator)\n    -- calculate the greatest\
    \ common divisor\n    local function gcd(a, b)\n        if a < b then\n      \
    \      a, b = b, a\n        end\n        local r = a % b\n        while r ~= 0\
    \ do\n            a = b\n            b = r\n            r = a % b\n        end\n\
    \        return b\n    end\n    local divisor = gcd(snumerator, sdenominator)\n\
    \    return snumerator / divisor == sdenominator / divisor\nend", "    local num,\
    \ den = tonumber(x:sub(1, 1)), tonumber(x:sub(3, 3))\n    local mult = den / num\n\
    \    local simplify = true\n    for i = 1, #n do\n        local number = tonumber(n:sub(i,\
    \ i))\n        if number and number % mult ~= 0 then\n            simplify = false\n\
    \            break\n        end\n    end\n    return simplify\nend", "  x = x:split('/')\n\
    \  n = n:split('/')\n  local fx = tonumber(x[1])/tonumber(x[2])\n  local fn =\
    \ tonumber(n[1])/tonumber(n[2])\n  return (math.floor(fx*fn*100)/100) == (fx*fn)\n\
    end", "\tlocal xNumerator, xDenominator = x:match('(%d+)/(%d+)')\n\tlocal nNumerator,\
    \ nDenominator = n:match('(%d+)/(%d+)')\n\tlocal numerator = xNumerator * nDenominator\n\
    \tlocal denominator = xDenominator * nNumerator\n\t-- this is wrong, see next\
    \ line\n\treturn numerator % denominator == 0\n\t-- even though % is the modulo\
    \ operator, in lua it's actually floor(a / b) * b + a % b == a\n\t-- so % can\
    \ be used to test if a number is divisible by something else\n\t-- in this case,\
    \ we want to return true if numerator is divisible by denominator\n\t-- numerator\
    \ % denominator == 0 iff numerator == denominator * k for some k\n\t-- and in\
    \ this case, numerator == denominator * k is equivalent to x * n == k\n\t-- so\
    \ this is the actual function we want to return\n\treturn numerator % denominator\
    \ == 0\nend", "  local a, b = x:match('(%d+)/(%d+)')\n  local c, d = n:match('(%d+)/(%d+)')\n\
    \  local c1, c2 = a * d, b * c\n  return tonumber(c1) == tonumber(c2)\nend", " \
    \ local x_num, x_den = tonumber(x:match('(%d+)/(%d+)')), tonumber(x:match('(%d+)/(%d+)'))\n\
    \  local n_num, n_den = tonumber(n:match('(%d+)/(%d+)')), tonumber(n:match('(%d+)/(%d+)'))\n\
    \  local x_num_new = x_num * n_den\n  local n_num_new = n_num * x_den\n  return\
    \ x_num_new % n_num_new == 0\nend", end, "  local x_num, x_denom = x:match('(.*)/(.*)')\n\
    \  local n_num, n_denom = n:match('(.*)/(.*)')\n  local x_n = tonumber(x_num)\
    \ * tonumber(n_denom)\n  local n_x = tonumber(n_num) * tonumber(x_denom)\n  return\
    \ x_n == n_x\nend", "    return {}\nend", "    --\nend", "  local function gcd(a,\
    \ b)\n    if (b == 0) then\n      return a\n    else\n      return gcd(b, a %\
    \ b)\n    end\n  end", "    local fx = fraction.new(x)\n    local fn = fraction.new(n)\n\
    \    if fx.denominator == fn.denominator then\n        if fx.numerator * fn.numerator\
    \ % fx.denominator == 0 then\n            return true\n        end\n    end\n\
    \    return false\nend", "    local a, b = x:match(\"(%d+)/(%d+)\")\n    local\
    \ c, d = n:match(\"(%d+)/(%d+)\")\n    return tonumber(a)*tonumber(d) % tonumber(b)\
    \ == 0\nend", end, "    local xNum, xDen = string.match(x, \"(%d+)/(%d+)\")\n\
    \    local nNum, nDen = string.match(n, \"(%d+)/(%d+)\")\n    if (xNum * nDen)\
    \ % (xDen * nNum) == 0 then\n        return true\n    else\n        return false\n\
    \    end\nend", "    -- ...\nend", "    local tx, xn, xd = x:match '(%d+)/(%d+)/(%d+)'\n\
    \    if tx then\n        return simplify(string.format('%d/%d', xn + tx * xd,\
    \ xd), n)\n    end\n    tx, xn, xd = x:match '(%d+)/(%d+)'\n    if tx then\n \
    \       return simplify(string.format('%d/%d', xn + tx, xd), n)\n    end\n   \
    \ local tn, nn, nd = n:match '(%d+)/(%d+)/(%d+)'\n    if tn then\n        return\
    \ simplify(x, string.format('%d/%d', nn + tn * nd, nd))\n    end\n    tn, nn,\
    \ nd = n:match '(%d+)/(%d+)'\n    if tn then\n        return simplify(x, string.format('%d/%d',\
    \ nn + tn, nd))\n    end\n    xn, xd = x:match '(%d+)/(%d+)'\n    nn, nd = n:match\
    \ '(%d+)/(%d+)'\n    local mul = xn * nd\n    local div = xd * nn\n    if mul\
    \ % div == 0 then\n        return true\n    end\n    return false\nend", "  --\
    \ TODO: Your code here!\nend", "    local x_num, x_den = x:match('(%d+)/(%d+)')\n\
    \    local n_num, n_den = n:match('(%d+)/(%d+)')\n    return math.fmod(tonumber(x_num)\
    \ * tonumber(n_den), tonumber(x_den)) == 0\nend", "  x, n = x:match('(%d+)/(%d+)'),\
    \ n:match('(%d+)/(%d+)')\n  x, n = x * n:match('(%d+)/(%d+)')\n  return x % n\
    \ == 0\nend", "    -- TODO: implement function\nend", "  x = string.split(x, '/')\n\
    \  n = string.split(n, '/')\n  local d = tonumber(x[2]) * tonumber(n[2])\n  local\
    \ nu = tonumber(x[1]) * tonumber(n[2])\n  return nu % d == 0\nend", "    local\
    \ function gcd(a, b)\n        while a ~= 0 do\n            a, b = b % a, a\n \
    \       end\n        return b\n    end\n    local function simplify_fraction(x)\n\
    \        local a, b = string.match(x, \"(%d+)/(%d+)\")\n        if not a or not\
    \ b then return nil end\n        local g = gcd(a, b)\n        return tonumber(a)\
    \ / g, tonumber(b) / g\n    end\n    local a, b = simplify_fraction(x)\n    local\
    \ c, d = simplify_fraction(n)\n    if not a or not b or not c or not d then return\
    \ nil end\n    local r = a * d / b\n    return math.floor(r) == r\nend", "   \
    \ local a, b = x:match('(%d+)/(%d+)')\n    local c, d = n:match('(%d+)/(%d+)')\n\
    \    a, b, c, d = tonumber(a), tonumber(b), tonumber(c), tonumber(d)\n    local\
    \ r = (a * d) / (b * c)\n    return math.floor(r) == r\nend", "  local x_num,\
    \ x_den = x:match('(%d+)/(%d+)')\n  local n_num, n_den = n:match('(%d+)/(%d+)')\n\
    \  x_num, x_den = tonumber(x_num), tonumber(x_den)\n  n_num, n_den = tonumber(n_num),\
    \ tonumber(n_den)\n  local result = x_num * n_num == x_den * n_den\n  return result\n\
    end", "  local x_numerator, x_denominator = x:match(\"(%d+)/(%d+)\")\n  local\
    \ n_numerator, n_denominator = n:match(\"(%d+)/(%d+)\")\n  return x_numerator\
    \ * n_denominator == x_denominator * n_numerator\nend", "\tlocal x_num, x_den\
    \ = x:match '([%d]+)/([%d]+).*'\n\tlocal n_num, n_den = n:match '([%d]+)/([%d]+).*'\n\
    \tlocal result = (x_num * n_den) * (n_num * x_den)\n\treturn result % (x_den *\
    \ n_den) == 0\nend", "\tlocal a, b = x:match(\"(%d+)/(%d+)\")\n\tlocal c, d =\
    \ n:match(\"(%d+)/(%d+)\")\n\tlocal e = a * d\n\tlocal f = b * c\n\treturn e %\
    \ f == 0\nend", "    local x_numerator, x_denominator = string.match(x, '(%d+)/(%d+)')\n\
    \    local n_numerator, n_denominator = string.match(n, '(%d+)/(%d+)')\n    x_numerator,\
    \ x_denominator = tonumber(x_numerator), tonumber(x_denominator)\n    n_numerator,\
    \ n_denominator = tonumber(n_numerator), tonumber(n_denominator)\n    local x_mult\
    \ = x_numerator * n_denominator\n    local n_mult = n_numerator * x_denominator\n\
    \    if x_mult % n_mult == 0 then\n        return true\n    else\n        return\
    \ false\n    end\nend", "    local _, _, xnum, xden = x:find('(%d+)/(%d+)')\n\
    \    local _, _, nnum, nden = n:find('(%d+)/(%d+)')\n    return tonumber(xnum)\
    \ * tonumber(nden) % tonumber(xden) == 0\nend", "  local simplification = tonumber(x)\
    \ * tonumber(n)\n  return simplification % 1 == 0\nend", "  local x_1, x_2 = x:match('(%d+)/(%d+)')\n\
    \  local n_1, n_2 = n:match('(%d+)/(%d+)')\n  local x_1, x_2, n_1, n_2 = tonumber(x_1),\
    \ tonumber(x_2), tonumber(n_1), tonumber(n_2)\n  local denom = lcm(x_2, n_2)\n\
    \  x_1 = (denom / x_2) * x_1\n  n_1 = (denom / n_2) * n_1\n  local num = n_1 +\
    \ x_1\n  return denom % num == 0\nend", "\tlocal a, b = x:match('(%d+)/(%d+)')\n\
    \tlocal c, d = n:match('(%d+)/(%d+)')\n\ta, b, c, d = tonumber(a), tonumber(b),\
    \ tonumber(c), tonumber(d)\n\treturn c / d == b * a / b\nend", "    local x_numerator,\
    \ x_denominator = string.match(x, \"(%d+)/(%d+)\")\n    local n_numerator, n_denominator\
    \ = string.match(n, \"(%d+)/(%d+)\")\n    x_numerator, x_denominator = tonumber(x_numerator),\
    \ tonumber(x_denominator)\n    n_numerator, n_denominator = tonumber(n_numerator),\
    \ tonumber(n_denominator)\n    local result = x_numerator * n_denominator\n  \
    \  return result % n_numerator == 0\nend", "    local lx = loadstring('return\
    \ ' .. x)()\n    local ln = loadstring('return ' .. n)()\n    local r = lx * ln\n\
    \    return r == math.floor(r)\nend", "    -- math.floor is not available in this\
    \ environment\n    return (math.pow(10, #n) * tonumber(x:sub(1, x:find('/') -\
    \ 1))\n    / tonumber(x:sub(x:find('/') + 1, #x)) * tonumber(n:sub(1, n:find('/')\
    \ - 1))\n    / tonumber(n:sub(n:find('/') + 1, #n))) % 10 == 0\nend", "  local\
    \ nx, nn = toFraction(x), toFraction(n)\n  local num, den = nx[1] * nn[2], nx[2]\
    \ * nn[1]\n  if den == 1 then return true end\n  if num % den == 0 then return\
    \ true end\n  return false\nend", "    local function gcd(a, b)\n        while\
    \ b ~= 0 do\n            local r = a % b\n            a = b\n            b = r\n\
    \        end\n        return a\n    end", "    local numerator = {}\n    local\
    \ denominator = {}\n    for v in x:gmatch(\"%d+\") do\n        numerator[#numerator\
    \ + 1] = tonumber(v)\n    end\n    for v in n:gmatch(\"%d+\") do\n        denominator[#denominator\
    \ + 1] = tonumber(v)\n    end\n    local t = numerator[1] * denominator[2]\n \
    \   local t2 = numerator[2] * denominator[1]\n    if t % t2 == 0 then\n      \
    \  return true\n    else\n        return false\n    end\nend", end, "  local xnum,\
    \ xden = x:match('(%d+)/(%d+)')\n  local nnum, nden = n:match('(%d+)/(%d+)')\n\
    \  xnum, xden = tonumber(xnum), tonumber(xden)\n  nnum, nden = tonumber(nnum),\
    \ tonumber(nden)\n  local den = xden * nden\n  local num = nnum * xden + xnum\
    \ * nden\n  return num % den == 0\nend", "  -- TODO: implement this function\n\
    end", "  local x_num, x_denom = string.match(x, \"(%d+)/(%d+)\")\n  local n_num,\
    \ n_denom = string.match(n, \"(%d+)/(%d+)\")\n  local result = (x_num * n_num)\
    \ .. \"/\" .. (x_denom * n_denom)\n  if string.match(result, \"(%d+)/(%d+)\")\
    \ then\n    return true\n  else\n    return false\n  end\nend", "    local function\
    \ toNums(str)\n        local a, b = str:match('(.*)/(.*)')\n        return tonumber(a),\
    \ tonumber(b)\n    end\n    local xx, xn = toNums(x)\n    local nx, nn = toNums(n)\n\
    \    local num, denom = xx * nn, xn * nx\n    return denom % num == 0\nend", " \
    \ x = tonumber(x:match(\"%d+\"))/tonumber(x:match(\"%d+$\"))\n  n = tonumber(n:match(\"\
    %d+\"))/tonumber(n:match(\"%d+$\"))\n  return math.floor(x*n) == x*n\nend", " \
    \   local xN, xD = x:match(\"(%d+)/(%d+)\")\n    local nN, nD = n:match(\"(%d+)/(%d+)\"\
    )\n    xN, xD, nN, nD = tonumber(xN), tonumber(xD), tonumber(nN), tonumber(nD)\n\
    \    return (xN * nD) % (xD * nN) == 0\nend", "    local x1, x2 = x:match(\"(%d+)/(%d+)\"\
    )\n    local y1, y2 = n:match(\"(%d+)/(%d+)\")\n    return ((tonumber(x1) * tonumber(y2))\
    \ % (tonumber(x2) * tonumber(y1)) == 0)\nend", "  local xnumerator, xdenominator\
    \ = x:match('(%d+)/(%d+)')\n  local nnumerator, ndenominator = n:match('(%d+)/(%d+)')\n\
    \  return (xnumerator * ndenominator) % (xdenominator * nnumerator) == 0\nend",
  "  -- implementation here\nend", "  if x == n then\n    return true\n  end\n  local\
    \ xnumerator, xdenominator = x:match('(%d+)/(%d+)')\n  local nnumerator, ndenominator\
    \ = n:match('(%d+)/(%d+)')\n  local common = math.gcd(xdenominator, ndenominator)\n\
    \  local den = xdenominator * ndenominator / common\n  local num = xnumerator\
    \ * ndenominator / common + nnumerator * xdenominator / common\n  return num %\
    \ den == 0\nend", "  local fx = math.floor(tonumber(x:match('%d+')) / tonumber(x:match('/%d+'):sub(2)))\n\
    \  local fn = math.floor(tonumber(n:match('%d+')) / tonumber(n:match('/%d+'):sub(2)))\n\
    \  return fx * fn == math.floor(fx * fn)\nend", "    local xn = require('snippets/fraction_convert')(x)\n\
    \    local nn = require('snippets/fraction_convert')(n)\n    local fraction =\
    \ require('snippets/fraction')\n    local result = fraction.multiply(xn, nn)\n\
    \    return fraction.is_integer(result)\nend", end, "  local function simplifyHelper(num,\
    \ denom)\n    local function gcd(a, b)\n      if b == 0 then\n        return a\n\
    \      else\n        return gcd(b, a % b)\n      end\n    end\n    local divisor\
    \ = gcd(num, denom)\n    return num / divisor, denom / divisor\n  end\n  local\
    \ xNum, xDenom = x:match(\"(%d+)/(%d+)\")\n  local nNum, nDenom = n:match(\"(%d+)/(%d+)\"\
    )\n  local xgcd, ygcd = simplifyHelper(xNum, xDenom)\n  local ngcd, ygcd = simplifyHelper(nNum,\
    \ nDenom)\n  local productNum = xgcd * ngcd\n  local productDenom = xDenom * nDenom\n\
    \  local productGcd, y = simplifyHelper(productNum, productDenom)\n  if (productDenom\
    \ / productGcd) == 1 then\n    return true\n  else\n    return false\n  end\n\
    end", "    local xn, xd = x:match(\"(%d+)/(%d+)\")\n    local nn, nd = n:match(\"\
    (%d+)/(%d+)\")\n    local lcm = math.lcm(xd, nd)\n    local lcm_xn = xn * (lcm\
    \ / xd)\n    local lcm_nn = nn * (lcm / nd)\n    return (lcm_xn % lcm_nn) == 0\n\
    end", "  -- put your code here\nend", "\t-- TODO: implement this function\n\t\
    return false\nend", "  --your code here\nend", "\tlocal function gcd(a, b)\n\t\
    \twhile b ~= 0 do\n\t\t\ta, b = b, a % b\n\t\tend\n\t\treturn a\n\tend\n\tlocal\
    \ function simplify_fraction(numerator, denominator)\n\t\tif numerator == 0 then\n\
    \t\t\treturn 0, 1\n\t\tend\n\t\tlocal divisor = gcd(numerator, denominator)\n\t\
    \treturn numerator / divisor, denominator / divisor\n\tend\n\tlocal function mul_fraction(x_numerator,\
    \ x_denominator, n_numerator, n_denominator)\n\t\tlocal numerator = x_numerator\
    \ * n_numerator\n\t\tlocal denominator = x_denominator * n_denominator\n\t\treturn\
    \ simplify_fraction(numerator, denominator)\n\tend\n\tlocal x_numerator, x_denominator\
    \ = x:match('(%d+)/(%d+)')\n\tlocal n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n\
    \tx_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)\n\
    \tn_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)\n\
    \tlocal numerator, denominator = mul_fraction(x_numerator, x_denominator, n_numerator,\
    \ n_denominator)\n\treturn numerator % denominator == 0\nend", "  local x1, x2\
    \ = toNum(x)\n  local n1, n2 = toNum(n)\n  return x1 * n2 % (x2 * n1) == 0\nend",
  "  local x_n, x_d = x:match(\"(%d+)/(%d+)\")\n  local n_n, n_d = n:match(\"(%d+)/(%d+)\"\
    )\n  local numerator = x_n * n_d\n  local denominator = x_d * n_n\n  local greatest_common_divisor\
    \ = _G.math.gcd(numerator, denominator)\n  return (numerator / greatest_common_divisor)\
    \ % (denominator / greatest_common_divisor) == 0\nend", "  local function gcd(a,\
    \ b)\n    if b == 0 then return a end\n    return gcd(b, a % b)\n  end\n  local\
    \ x, y = x:match(\"^(%d+)/(%d+)$\")\n  local n, d = n:match(\"^(%d+)/(%d+)$\"\
    )\n  x, y, n, d = tonumber(x), tonumber(y), tonumber(n), tonumber(d)\n  local\
    \ g = gcd(x * d, y * n)\n  return g == y * n\nend", end, "  local nx, dx = x:match(\"\
    (%d+)/(%d+)\")\n  local nn, dn = n:match(\"(%d+)/(%d+)\")\n  nx, dx, nn, dn =\
    \ tonumber(nx), tonumber(dx), tonumber(nn), tonumber(dn)\n  local function gcd(x,\
    \ y)\n    while y ~= 0 do\n      local tmp = y\n      y = x % y\n      x = tmp\n\
    \    end\n    return x\n  end\n  local _gcd = gcd(nx, dx)\n  nx, dx = nx / _gcd,\
    \ dx / _gcd\n  _gcd = gcd(nn, dn)\n  nn, dn = nn / _gcd, dn / _gcd\n  if nx *\
    \ dn == nn * dx then\n    return true\n  else\n    return false\n  end\nend",
  "    local xn = x * n\n    return not xn:match('%.')\nend", "  x, y = x:match('(%d+)/(%d+)')\n\
    \  x, y = tonumber(x), tonumber(y)\n  a, b = n:match('(%d+)/(%d+)')\n  a, b =\
    \ tonumber(a), tonumber(b)\n  return (x * a) % (y * b) == 0\nend", "    local\
    \ function gcd(x, y)\n        while y ~= 0 do\n            local z = x % y\n \
    \           x = y\n            y = z\n        end\n        return x\n    end\n\
    \    local function simplify(x)\n        local g = gcd(x[1], x[2])\n        return\
    \ {x[1] / g, x[2] / g}\n    end\n    local function mul(x, y)\n        return\
    \ {x[1] * y[1], x[2] * y[2]}\n    end\n    local x = string.gmatch(x, '%d+')\n\
    \    x = {tonumber(x()), tonumber(x())}\n    local n = string.gmatch(n, '%d+')\n\
    \    n = {tonumber(n()), tonumber(n())}\n    x = simplify(x)\n    n = simplify(n)\n\
    \    local product = mul(x, n)\n    local g = gcd(product[1], product[2])\n  \
    \  if product[1] / g == product[2] then\n        return true\n    else\n     \
    \   return false\n    end\nend", "  local m = x:gmatch('%d+')\n  local x1, x2\
    \ = m(), m()\n  local m = n:gmatch('%d+')\n  local n1, n2 = m(), m()\n  return\
    \ math.fmod(x1 * n2, x2 * n1) == 0\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
