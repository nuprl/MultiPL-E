name: HumanEval_132_is_nested
language: lua
prompt: "-- Create a function that takes a string as input which contains only square\
  \ brackets.\n-- The function should return true if and only if there is a valid\
  \ subsequence of brackets \n-- where at least one bracket in the subsequence is\
  \ nested.\n-- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n\
  -- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n\
  -- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal\
  \ function is_nested(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_nested\n\
  \    lu.assertEquals(candidate('[[]]'), true)\n    lu.assertEquals(candidate('[]]]]]]][[[[[]'),\
  \ false)\n    lu.assertEquals(candidate('[][]'), false)\n    lu.assertEquals(candidate('[]'),\
  \ false)\n    lu.assertEquals(candidate('[[[[]]]]'), true)\n    lu.assertEquals(candidate('[]]]]]]]]]]'),\
  \ false)\n    lu.assertEquals(candidate('[][][[]]'), true)\n    lu.assertEquals(candidate('[[]'),\
  \ false)\n    lu.assertEquals(candidate('[]]'), false)\n    lu.assertEquals(candidate('[[]][['),\
  \ true)\n    lu.assertEquals(candidate('[[][]]'), true)\n    lu.assertEquals(candidate(''),\
  \ false)\n    lu.assertEquals(candidate('[[[[[[[['), false)\n    lu.assertEquals(candidate(']]]]]]]]'),\
  \ false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local stack = Stack()\n  for i=1, #string do\n    local char = string:sub(i,i)\n\
    \    if char == '[' then\n      stack:push(char)\n    elseif char == ']' then\n\
    \      if stack:isempty() then\n        return false\n      else\n        stack:pop()\n\
    \      end\n    end\n  end\n  return not stack:isempty()\nend", "    if type(string)\
    \ ~= 'string' then\n        error('Function is_nested requires a string')\n  \
    \  end\n    return string:find('%[%[')\nend", "    local i = 1\n    while i <=\
    \ #string do\n        local prev_bracket = string:sub(i, i)\n        local next_bracket\
    \ = string:sub(i + 1, i + 1)\n        if prev_bracket == '[' and next_bracket\
    \ == ']' then\n            return true\n        end\n        i = i + 1\n    end\n\
    \    return false\nend", "\tlocal function _is_valid(string)\n\t\tlocal stack\
    \ = {}\n\t\tlocal top = 0\n\t\tfor i = 1, #string do\n\t\t\tlocal char = string:sub(i,\
    \ i)\n\t\t\tif char == '[' then\n\t\t\t\ttop = top + 1\n\t\t\t\tstack[top] = char\n\
    \t\t\telseif char == ']' then\n\t\t\t\tif top > 0 then\n\t\t\t\t\ttop = top -\
    \ 1\n\t\t\t\telse\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\
    \treturn top == 0\n\tend\n\t\n\tlocal function _is_empty(string)\n\t\treturn string:len()\
    \ == 0\n\tend\n\t\n\tlocal function _is_nested(string)\n\t\tif _is_empty(string)\
    \ then\n\t\t\treturn false\n\t\tend\n\t\t\n\t\tif _is_valid(string) then\n\t\t\
    \treturn true\n\t\tend\n\t\t\n\t\tif string:sub(1, 1) == '[' then\n\t\t\tif string:sub(#string,\
    \ #string) == ']' then\n\t\t\t\treturn _is_nested(string:sub(2, #string - 1))\n\
    \t\t\tend\n\t\tend\n\t\t\n\t\treturn _is_nested(string:sub(2, #string)) or _is_nested(string:sub(1,\
    \ #string - 1))\n\tend\n\t\n\treturn _is_nested(string)\nend", "  local count\
    \ = 0\n  for _, c in utf8.codes(string) do\n    if c == string.byte('[') then\n\
    \      count = count + 1\n    elseif c == string.byte(']') then\n      count =\
    \ count - 1\n    end\n    if count < 0 then\n      return false\n    end\n  end\n\
    \  return count > 0\nend", "  local open = 0\n  local close = 0\n  for i = 1,\
    \ #string do\n    if string[i] == '[' then\n      open = open + 1\n    elseif\
    \ string[i] == ']' then\n      close = close + 1\n    end\n  end\n  if open ==\
    \ close then\n    return false\n  else\n    return true\n  end\nend", "  -- Just\
    \ make sure there is no unbalanced sequence\n  -- and that the first bracket is\
    \ an opening bracket\n  return is_balanced(string) and string:sub(1,1) == '['\n\
    end", "\tlocal open = {'[', '{', '('}\n\tlocal close = {']', '}', ')'}\n\tlocal\
    \ stack = Stack:new()\n\tfor i = 1, string.len(string) do\n\t\tlocal current =\
    \ string.sub(string, i, i)\n\t\tif stack:is_empty() then\n\t\t\tstack:push(current)\n\
    \t\telse\n\t\t\tlocal previous = stack:peek()\n\t\t\tlocal pindex = nil\n\t\t\t\
    local cindex = nil\n\t\t\tfor i = 1, #open do\n\t\t\t\tif open[i] == previous\
    \ then\n\t\t\t\t\tpindex = i\n\t\t\t\tend\n\t\t\t\tif open[i] == current then\n\
    \t\t\t\t\tcindex = i\n\t\t\t\tend\n\t\t\tend\n\t\t\tif cindex ~= nil and (cindex\
    \ < pindex or previous == '(') then\n\t\t\t\tstack:push(current)\n\t\t\telseif\
    \ cindex ~= nil and (cindex > pindex or previous == ')') then\n\t\t\t\treturn\
    \ false\n\t\t\telseif previous == '[' and current == ']' then\n\t\t\t\tstack:pop()\n\
    \t\t\telseif previous == '{' and current == '}' then\n\t\t\t\tstack:pop()\n\t\t\
    \telseif previous == '(' and current == ')' then\n\t\t\t\tstack:pop()\n\t\t\t\
    else\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\treturn stack:is_empty()\n\
    end", "    local stack = Stack:new()\n    for i = 1, string.len(string) do\n \
    \       local c = string.sub(string, i, i)\n        if c == '[' then\n       \
    \     stack:push(c)\n        elseif c == ']' then\n            if stack:is_empty()\
    \ then\n                return false\n            else\n                stack:pop()\n\
    \            end\n        end\n    end\n    return not stack:is_empty()\nend",
  "    stack = {}\n    for character in string:gmatch('.') do\n        if character\
    \ == '[' then\n            table.insert(stack, character)\n        elseif #stack\
    \ == 0 then\n            return false\n        else\n            table.remove(stack)\n\
    \        end\n    end\n    return #stack == 0\nend", "    local stack = Stack()\n\
    \    local open = {\n        [\"[\"] = true,\n    }\n    local close = {\n   \
    \     [\"]\"] = true,\n    }\n    local match = {\n        [\"[\"] = \"]\",\n\
    \    }\n    for char in string:gmatch('.') do\n        if open[char] then\n  \
    \          stack:push(char)\n        elseif close[char] then\n            if stack:is_empty()\
    \ then\n                return false\n            end\n            local top =\
    \ stack:peek()\n            if char == match[top] then\n                stack:pop()\n\
    \            else\n                return false\n            end\n        end\n\
    \    end\n    return not stack:is_empty()\nend", "\twhile string:match('%[%]')\
    \ do\n\t\tstring = string:gsub('%[%]', '')\n\tend\n\treturn string:len() == 0\n\
    end", "    local sum = 0\n    for i = 1, #string do\n        if string[i] == '['\
    \ then\n            sum = sum + 1\n        elseif string[i] == ']' then\n    \
    \        sum = sum - 1\n        end\n        if sum < 0 then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    return stack.does_nest(stack.to_bracket_stack(string))\n\
    end", "  if not type(string) == 'string' then\n    return nil\n  end\n  local\
    \ open_brackets = 0\n  local closed_brackets = 0\n  for i=1,#string do\n    if\
    \ string:sub(i,i) == '[' then\n      open_brackets = open_brackets + 1\n    elseif\
    \ string:sub(i,i) == ']' then\n      closed_brackets = closed_brackets + 1\n \
    \   end\n  end\n  if open_brackets > closed_brackets then\n    return false\n\
    \  end\n  local i = 1\n  local level = 0\n  while i <= #string do\n    local c\
    \ = string:sub(i,i)\n    if c == '[' then\n      level = level + 1\n    elseif\
    \ c == ']' then\n      level = level - 1\n    end\n    if level == 0 then\n  \
    \    return true\n    end\n    i = i + 1\n  end\n  return false\nend", "\tlocal\
    \ s, level = string:gsub('%b[]', function(s)\n\t\t\t\t\t\t\t\treturn (level +\
    \ 1) % 2 == 0 and s or ''\n\t\t\t\t\t\t\tend)\n\treturn #s == 0 and level % 2\
    \ == 0\nend", "    local a, b = 0, 0\n    for i = 1, #string do\n        if string:sub(i,\
    \ i) == '[' then\n            a = a + 1\n        else\n            b = b + 1\n\
    \        end\n    end\n    return a > 0 and b > 0\nend", "\tassert(type(string)\
    \ == 'string', 'is_nested(): argument must be a string')\n\tlocal stack = Stack.new()\n\
    \tfor i = 1, #string do\n\t\tlocal ch = string:sub(i, i)\n\t\tif ch == '[' then\n\
    \t\t\tstack:push(ch)\n\t\telseif ch == ']' then\n\t\t\tlocal top = stack:pop()\n\
    \t\t\tif top == nil then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\t\
    return stack:empty()\nend", "  local result = false\n  local nesting = 0\n  local\
    \ first_open = -1\n  local last_open = -1\n  local first_close = -1\n  local last_close\
    \ = -1\n  for i = 1, #string do\n    if string[i] == '[' then\n      nesting =\
    \ nesting + 1\n      if nesting == 1 then\n        first_open = i\n      end\n\
    \      last_open = i\n    elseif string[i] == ']' then\n      nesting = nesting\
    \ - 1\n      if nesting == 0 then\n        first_close = i\n        last_close\
    \ = i\n      end\n    end\n    if first_open > -1 and first_close > -1 then\n\
    \      if first_open < first_close then\n        result = true\n      end\n  \
    \  end\n  end\n  if first_open > -1 and first_close > -1 then\n    if last_open\
    \ > last_close then\n      result = true\n    end\n  end\n  return result\nend",
  "  local stack = Stack:new()\n  for char in string:gmatch('[%[%]]') do\n    if char\
    \ == '[' then\n      stack:push('[')\n    else\n      if stack:empty() then\n\
    \        return false\n      else\n        stack:pop()\n      end\n    end\n \
    \ end\n  return not stack:empty()\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
