name: HumanEval_132_is_nested
language: lua
prompt: "-- Create a function that takes a string as input which contains only square\
  \ brackets.\n-- The function should return true if and only if there is a valid\
  \ subsequence of brackets \n-- where at least one bracket in the subsequence is\
  \ nested.\n-- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n\
  -- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n\
  -- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal\
  \ function is_nested(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_nested\n\
  \    lu.assertEquals(candidate('[[]]'), true)\n    lu.assertEquals(candidate('[]]]]]]][[[[[]'),\
  \ false)\n    lu.assertEquals(candidate('[][]'), false)\n    lu.assertEquals(candidate('[]'),\
  \ false)\n    lu.assertEquals(candidate('[[[[]]]]'), true)\n    lu.assertEquals(candidate('[]]]]]]]]]]'),\
  \ false)\n    lu.assertEquals(candidate('[][][[]]'), true)\n    lu.assertEquals(candidate('[[]'),\
  \ false)\n    lu.assertEquals(candidate('[]]'), false)\n    lu.assertEquals(candidate('[[]][['),\
  \ true)\n    lu.assertEquals(candidate('[[][]]'), true)\n    lu.assertEquals(candidate(''),\
  \ false)\n    lu.assertEquals(candidate('[[[[[[[['), false)\n    lu.assertEquals(candidate(']]]]]]]]'),\
  \ false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local stack = Stack()\n  for i=1, #string do\n    local char = string:sub(i,i)\n\
    \    if char == '[' then\n      stack:push(char)\n    elseif char == ']' then\n\
    \      if stack:isempty() then\n        return false\n      else\n        stack:pop()\n\
    \      end\n    end\n  end\n  return not stack:isempty()\nend", "    if type(string)\
    \ ~= 'string' then\n        error('Function is_nested requires a string')\n  \
    \  end\n    return string:find('%[%[')\nend", "    local i = 1\n    while i <=\
    \ #string do\n        local prev_bracket = string:sub(i, i)\n        local next_bracket\
    \ = string:sub(i + 1, i + 1)\n        if prev_bracket == '[' and next_bracket\
    \ == ']' then\n            return true\n        end\n        i = i + 1\n    end\n\
    \    return false\nend", "\tlocal function _is_valid(string)\n\t\tlocal stack\
    \ = {}\n\t\tlocal top = 0\n\t\tfor i = 1, #string do\n\t\t\tlocal char = string:sub(i,\
    \ i)\n\t\t\tif char == '[' then\n\t\t\t\ttop = top + 1\n\t\t\t\tstack[top] = char\n\
    \t\t\telseif char == ']' then\n\t\t\t\tif top > 0 then\n\t\t\t\t\ttop = top -\
    \ 1\n\t\t\t\telse\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\
    \treturn top == 0\n\tend\n\t\n\tlocal function _is_empty(string)\n\t\treturn string:len()\
    \ == 0\n\tend\n\t\n\tlocal function _is_nested(string)\n\t\tif _is_empty(string)\
    \ then\n\t\t\treturn false\n\t\tend\n\t\t\n\t\tif _is_valid(string) then\n\t\t\
    \treturn true\n\t\tend\n\t\t\n\t\tif string:sub(1, 1) == '[' then\n\t\t\tif string:sub(#string,\
    \ #string) == ']' then\n\t\t\t\treturn _is_nested(string:sub(2, #string - 1))\n\
    \t\t\tend\n\t\tend\n\t\t\n\t\treturn _is_nested(string:sub(2, #string)) or _is_nested(string:sub(1,\
    \ #string - 1))\n\tend\n\t\n\treturn _is_nested(string)\nend", "  local count\
    \ = 0\n  for _, c in utf8.codes(string) do\n    if c == string.byte('[') then\n\
    \      count = count + 1\n    elseif c == string.byte(']') then\n      count =\
    \ count - 1\n    end\n    if count < 0 then\n      return false\n    end\n  end\n\
    \  return count > 0\nend", "  local open = 0\n  local close = 0\n  for i = 1,\
    \ #string do\n    if string[i] == '[' then\n      open = open + 1\n    elseif\
    \ string[i] == ']' then\n      close = close + 1\n    end\n  end\n  if open ==\
    \ close then\n    return false\n  else\n    return true\n  end\nend", "  -- Just\
    \ make sure there is no unbalanced sequence\n  -- and that the first bracket is\
    \ an opening bracket\n  return is_balanced(string) and string:sub(1,1) == '['\n\
    end", "\tlocal open = {'[', '{', '('}\n\tlocal close = {']', '}', ')'}\n\tlocal\
    \ stack = Stack:new()\n\tfor i = 1, string.len(string) do\n\t\tlocal current =\
    \ string.sub(string, i, i)\n\t\tif stack:is_empty() then\n\t\t\tstack:push(current)\n\
    \t\telse\n\t\t\tlocal previous = stack:peek()\n\t\t\tlocal pindex = nil\n\t\t\t\
    local cindex = nil\n\t\t\tfor i = 1, #open do\n\t\t\t\tif open[i] == previous\
    \ then\n\t\t\t\t\tpindex = i\n\t\t\t\tend\n\t\t\t\tif open[i] == current then\n\
    \t\t\t\t\tcindex = i\n\t\t\t\tend\n\t\t\tend\n\t\t\tif cindex ~= nil and (cindex\
    \ < pindex or previous == '(') then\n\t\t\t\tstack:push(current)\n\t\t\telseif\
    \ cindex ~= nil and (cindex > pindex or previous == ')') then\n\t\t\t\treturn\
    \ false\n\t\t\telseif previous == '[' and current == ']' then\n\t\t\t\tstack:pop()\n\
    \t\t\telseif previous == '{' and current == '}' then\n\t\t\t\tstack:pop()\n\t\t\
    \telseif previous == '(' and current == ')' then\n\t\t\t\tstack:pop()\n\t\t\t\
    else\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\treturn stack:is_empty()\n\
    end", "    local stack = Stack:new()\n    for i = 1, string.len(string) do\n \
    \       local c = string.sub(string, i, i)\n        if c == '[' then\n       \
    \     stack:push(c)\n        elseif c == ']' then\n            if stack:is_empty()\
    \ then\n                return false\n            else\n                stack:pop()\n\
    \            end\n        end\n    end\n    return not stack:is_empty()\nend",
  "    stack = {}\n    for character in string:gmatch('.') do\n        if character\
    \ == '[' then\n            table.insert(stack, character)\n        elseif #stack\
    \ == 0 then\n            return false\n        else\n            table.remove(stack)\n\
    \        end\n    end\n    return #stack == 0\nend", "    local stack = Stack()\n\
    \    local open = {\n        [\"[\"] = true,\n    }\n    local close = {\n   \
    \     [\"]\"] = true,\n    }\n    local match = {\n        [\"[\"] = \"]\",\n\
    \    }\n    for char in string:gmatch('.') do\n        if open[char] then\n  \
    \          stack:push(char)\n        elseif close[char] then\n            if stack:is_empty()\
    \ then\n                return false\n            end\n            local top =\
    \ stack:peek()\n            if char == match[top] then\n                stack:pop()\n\
    \            else\n                return false\n            end\n        end\n\
    \    end\n    return not stack:is_empty()\nend", "\twhile string:match('%[%]')\
    \ do\n\t\tstring = string:gsub('%[%]', '')\n\tend\n\treturn string:len() == 0\n\
    end", "    local sum = 0\n    for i = 1, #string do\n        if string[i] == '['\
    \ then\n            sum = sum + 1\n        elseif string[i] == ']' then\n    \
    \        sum = sum - 1\n        end\n        if sum < 0 then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    return stack.does_nest(stack.to_bracket_stack(string))\n\
    end", "  if not type(string) == 'string' then\n    return nil\n  end\n  local\
    \ open_brackets = 0\n  local closed_brackets = 0\n  for i=1,#string do\n    if\
    \ string:sub(i,i) == '[' then\n      open_brackets = open_brackets + 1\n    elseif\
    \ string:sub(i,i) == ']' then\n      closed_brackets = closed_brackets + 1\n \
    \   end\n  end\n  if open_brackets > closed_brackets then\n    return false\n\
    \  end\n  local i = 1\n  local level = 0\n  while i <= #string do\n    local c\
    \ = string:sub(i,i)\n    if c == '[' then\n      level = level + 1\n    elseif\
    \ c == ']' then\n      level = level - 1\n    end\n    if level == 0 then\n  \
    \    return true\n    end\n    i = i + 1\n  end\n  return false\nend", "\tlocal\
    \ s, level = string:gsub('%b[]', function(s)\n\t\t\t\t\t\t\t\treturn (level +\
    \ 1) % 2 == 0 and s or ''\n\t\t\t\t\t\t\tend)\n\treturn #s == 0 and level % 2\
    \ == 0\nend", "    local a, b = 0, 0\n    for i = 1, #string do\n        if string:sub(i,\
    \ i) == '[' then\n            a = a + 1\n        else\n            b = b + 1\n\
    \        end\n    end\n    return a > 0 and b > 0\nend", "\tassert(type(string)\
    \ == 'string', 'is_nested(): argument must be a string')\n\tlocal stack = Stack.new()\n\
    \tfor i = 1, #string do\n\t\tlocal ch = string:sub(i, i)\n\t\tif ch == '[' then\n\
    \t\t\tstack:push(ch)\n\t\telseif ch == ']' then\n\t\t\tlocal top = stack:pop()\n\
    \t\t\tif top == nil then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\t\
    return stack:empty()\nend", "  local result = false\n  local nesting = 0\n  local\
    \ first_open = -1\n  local last_open = -1\n  local first_close = -1\n  local last_close\
    \ = -1\n  for i = 1, #string do\n    if string[i] == '[' then\n      nesting =\
    \ nesting + 1\n      if nesting == 1 then\n        first_open = i\n      end\n\
    \      last_open = i\n    elseif string[i] == ']' then\n      nesting = nesting\
    \ - 1\n      if nesting == 0 then\n        first_close = i\n        last_close\
    \ = i\n      end\n    end\n    if first_open > -1 and first_close > -1 then\n\
    \      if first_open < first_close then\n        result = true\n      end\n  \
    \  end\n  end\n  if first_open > -1 and first_close > -1 then\n    if last_open\
    \ > last_close then\n      result = true\n    end\n  end\n  return result\nend",
  "  local stack = Stack:new()\n  for char in string:gmatch('[%[%]]') do\n    if char\
    \ == '[' then\n      stack:push('[')\n    else\n      if stack:empty() then\n\
    \        return false\n      else\n        stack:pop()\n      end\n    end\n \
    \ end\n  return not stack:empty()\nend", "    local left = 0\n    local right\
    \ = 0\n    for i = 1, #string do\n        if string:sub(i, i) == '[' then\n  \
    \          left = left + 1\n        else\n            right = right + 1\n    \
    \    end\n        if right > left then\n            return false\n        end\n\
    \    end\n    return true\nend", "  return true\nend", "  -- While the string\
    \ is non-empty\n  while string ~= '' do\n    -- If there is no opening bracket\
    \ in the string\n    if string:find('%[') == nil then\n      -- Return false\n\
    \      return false\n    -- Else if there is an opening bracket in the string\n\
    \    else\n      -- Replace the first opening bracket with an empty string\n \
    \     string = string:gsub('%[', '', 1)\n      -- If there is no closing bracket\
    \ in the string\n      if string:find('%]') == nil then\n        -- Return false\n\
    \        return false\n      -- Else if there is a closing bracket in the string\n\
    \      else\n        -- Replace the first closing bracket with an empty string\n\
    \        string = string:gsub('%]', '', 1)\n      end\n    end\n  end\n  -- Return\
    \ true\n  return true\nend", "    local l = #string\n    local i = 1\n    local\
    \ left, right = 0, 0\n    while i <= l do\n        if string:sub(i, i) == '['\
    \ then\n            left = left + 1\n        else\n            right = right +\
    \ 1\n        end\n        if right > left then\n            return false\n   \
    \     end\n        i = i + 1\n    end\n    return true\nend", "    local count\
    \ = 0\n    for i = 1, #string do\n        if count < 0 then return false end\n\
    \        if string:sub(i, i) == '[' then\n            count = count + 1\n    \
    \    else\n            count = count - 1\n        end\n    end\n    return count\
    \ > 0\nend", "  local depth = 0\n  for i = 1, #string do\n    if string[i] ==\
    \ '[' then\n      depth = depth + 1\n    elseif string[i] == ']' then\n      depth\
    \ = depth - 1\n    end\n    if depth < 0 then\n      return false\n    end\n \
    \ end\n  return depth > 0\nend", "  return true\nend", "    local left = 0\n \
    \   local right = 0\n    local nested = false\n    local seq = string:lower()\n\
    \    local idx = 1\n    while idx <= #seq do\n        if seq:sub(idx, idx) ==\
    \ '[' then\n            left = left + 1\n        elseif seq:sub(idx, idx) == ']'\
    \ then\n            right = right + 1\n        end\n        if right > left then\n\
    \            break\n        end\n        if right == left then\n            nested\
    \ = true\n        end\n        idx = idx + 1\n    end\n    return nested\nend",
  "    local stack = Stack()\n    for c in string:gmatch('.') do\n        if c ==\
    \ '[' then\n            stack:push(c)\n        elseif c == ']' then\n        \
    \    if stack:isempty() then\n                return false\n            else\n\
    \                stack:pop()\n            end\n        end\n    end\n    return\
    \ not stack:isempty()\nend", "  -- TODO\nend", "    local n = 0\n    for i = 1,\
    \ #string do\n        local c = string:sub(i, i)\n        if c == '[' then\n \
    \           n = n + 1\n        elseif c == ']' then\n            n = n - 1\n \
    \       end\n        if n < 0 then\n            return false\n        end\n  \
    \  end\n    return n == 0\nend", "    local stack = {}\n    for i=1, #string do\n\
    \        if (string[i] == '[') then\n            table.insert(stack, '[');\n \
    \       elseif (string[i] == ']') then\n            if (stack[#stack] == '[')\
    \ then\n                table.remove(stack);\n            else\n             \
    \   return false;\n            end\n        end\n    end\n    return #stack ==\
    \ 0;\nend", "  local subsequence = 0\n  for i=1, #string do\n    local c = string:sub(i,i)\n\
    \    if c == '[' then\n      subsequence = subsequence + 1\n    elseif c == ']'\
    \ then\n      subsequence = subsequence - 1\n    end\n    if subsequence < 0 then\n\
    \      return false\n    end\n  end\n  return subsequence > 0\nend", "    local\
    \ opened = 0\n    local closed = 0\n    for _, s in ipairs(string) do\n      \
    \  if s == '[' then\n            opened = opened + 1\n        elseif s == ']'\
    \ then\n            closed = closed + 1\n        end\n    end\n    return closed\
    \ < opened\nend", "  return true\nend", "    local dp = {}\n    local left = 0\n\
    \    local right = 0\n    local count = 0\n    for i = 1, #string do\n       \
    \ if string:sub(i, i) == '[' then\n            count = count + 1\n           \
    \ left = left + 1\n        else\n            count = count - 1\n            right\
    \ = right + 1\n        end\n        if count < 0 then\n            dp[i] = -1\n\
    \        else\n            dp[i] = 1\n        end\n    end\n    if count ~= 0\
    \ then\n        return false\n    end\n    return left > 0 and right > 0\nend",
  "  local stack = {}\n  for _, c in utf8.codes(string) do\n    local b = string.char(c)\n\
    \    if b == '[' then\n      table.insert(stack, 1, b)\n    elseif b == ']' then\n\
    \      if #stack == 0 then\n        return false\n      else\n        if stack[1]\
    \ == '[' then\n          table.remove(stack, 1)\n        else\n          return\
    \ false\n        end\n      end\n    end\n  end\n  return #stack == 0\nend", " \
    \ -- YOUR CODE HERE\nend", end, "\tif #string%2 ~= 0 then return false end\n\t\
    local counter = 0\n\tfor i = 1, #string do\n\t\tif string:sub(i,i) == '[' then\
    \ counter = counter + 1\n\t\telseif string:sub(i,i) == ']' then counter = counter\
    \ - 1 end\n\t\tif counter < 0 then return false end\n\tend\n\treturn counter ==\
    \ 0\nend", "  -- \nend", "  local stack = {}\n  for i = 1, #string do\n    local\
    \ c = string:sub(i, i)\n    if c == '[' then\n      table.insert(stack, 1, ']')\n\
    \    elseif c == ']' then\n      if stack[1] == c then\n        table.remove(stack,\
    \ 1)\n      else\n        return false\n      end\n    end\n  end\n  return #stack\
    \ > 0\nend", "    local set_of_chars = {['['] = ']', ['{'] = '}', ['('] = ')'}\n\
    \    local stack = {}\n    for i = 1, #string do\n        if set_of_chars[string[i]]\
    \ then\n            table.insert(stack, set_of_chars[string[i]])\n        else\n\
    \            local last = table.remove(stack)\n            if string[i] ~= last\
    \ then\n                return false\n            end\n        end\n    end\n\
    \    return #stack == 0\nend", "    local stack = Stack:new()\n    local in_nested\
    \ = false\n    local in_nested_count = 0\n    for i = 1, #string do\n        local\
    \ bracket = string:sub(i, i)\n        if bracket == '[' then\n            stack:push(bracket)\n\
    \        elseif bracket == ']' then\n            if not stack:empty() then\n \
    \               stack:pop()\n                if not in_nested then\n         \
    \           in_nested = true\n                    in_nested_count = in_nested_count\
    \ + 1\n                end\n            else\n                return false\n \
    \           end\n        end\n    end\n    return not stack:empty() and in_nested_count\
    \ > 1\nend", "    local stack = Stack:new()\n    for char in string:gmatch('.')\
    \ do\n        if char == '[' then\n            stack:push(char)\n        elseif\
    \ char == ']' then\n            if stack:is_empty() then\n                return\
    \ false\n            else\n                stack:pop()\n            end\n    \
    \    end\n    end\n    return not stack:is_empty()\nend", "  local depth = 0\n\
    \  for i = 1, string.len(string) do\n    if string:sub(i, i) == '[' then\n   \
    \   depth = depth + 1\n    elseif string:sub(i, i) == ']' then\n      depth =\
    \ depth - 1\n    end\n    if depth < 0 then\n      return false\n    end\n  end\n\
    \  return depth > 0\nend", "\tlocal r = 0 -- #open\n\tlocal l = 0 -- #close\n\t\
    for c in string:gmatch('.') do\n\t\tif c == '[' then r = r + 1 else l = l + 1\
    \ end\n\t\tif l > r then return false end\n\tend\n\treturn r > l\nend", "    local\
    \ counter = 0\n    for i = 1, #string do\n        if string:sub(i, i) == '[' then\n\
    \            counter = counter + 1\n        elseif string:sub(i, i) == ']' then\n\
    \            counter = counter - 1\n        end\n        if counter < 0 then\n\
    \            return false\n        end\n    end\n    return counter > 0\nend",
  "    local nesting = 0\n    for i = 1, #string do\n        local s = string:sub(i,\
    \ i)\n        if s == '[' then\n            nesting = nesting + 1\n        elseif\
    \ s == ']' then\n            nesting = nesting - 1\n        end\n        if nesting\
    \ < 0 then\n            return false\n        end\n    end\n    return nesting\
    \ > 0\nend", "  -- TODO: your code here!\nend", "  local left = '['\n  local right\
    \ = ']'\n  local count = 0\n  for i=1, #string do\n    if string:sub(i,i) == left\
    \ then\n      count = count + 1\n    elseif string:sub(i,i) == right then\n  \
    \    count = count - 1\n    end\n    if count == 0 then\n      return true\n \
    \   end\n  end\n  return false\nend", "  -- YOUR CODE HERE\nend", "    local open\
    \ = false\n    local close = false\n    for i = 1, #string do\n        if string[i]\
    \ == '[' then\n            open = true\n        elseif string[i] == ']' then\n\
    \            close = true\n        end\n    end\n    return open and close\nend",
  "    local stack = Stack()\n    local brackets = { ['['] = ']', ['{'] = '}', ['(']\
    \ = ')' }\n    for i = 1, #string do\n        local ch = string:sub(i, i)\n  \
    \      if brackets[ch] then\n            stack:push(ch)\n        elseif stack:isempty()\
    \ or brackets[stack:pop()] ~= ch then\n            return false\n        end\n\
    \    end\n    return stack:isempty()\nend", "\tlocal length = #string\n\tlocal\
    \ brackets = 0\n\tfor i = 1, length do\n\t\tif string:sub(i, i) == '[' then\n\t\
    \t\tbrackets = brackets + 1\n\t\telse\n\t\t\tbrackets = brackets - 1\n\t\tend\n\
    \t\tif brackets < 0 then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn brackets\
    \ == 0\nend", end, "    -- TODO\nend", "    local stack = Stack()\n    for i =\
    \ 1, #string do\n        if string[i] == '[' then\n            stack:push('[')\n\
    \        elseif string[i] == ']' then\n            if stack:is_empty() then\n\
    \                return false\n            else\n                stack:pop()\n\
    \            end\n        end\n    end\n    return stack:is_empty()\nend", " \
    \   local bracket_stack = { }\n    for bracket in string:gmatch('%b[]') do\n \
    \       if bracket:sub(1, 1) == '[' then\n            bracket_stack[#bracket_stack\
    \ + 1] = bracket\n        else\n            if bracket_stack[#bracket_stack] then\n\
    \                bracket_stack[#bracket_stack] = nil\n            else\n     \
    \           return false\n            end\n        end\n    end\n    return not\
    \ bracket_stack[1]\nend", "    if string == '' then\n        return false\n  \
    \  end\n    local c = 0\n    for i = 1, #string do\n        if string[i] == '['\
    \ then\n            c = c + 1\n        else\n            c = c - 1\n        end\n\
    \        if c < 0 then\n            return false\n        end\n    end\n    return\
    \ c > 0\nend", "\tlocal stack = Stack:new()\n\tlocal processed = 0\n\tfor i =\
    \ 1, #string do\n\t\tlocal c = string:sub(i, i)\n\t\tif c == '[' then\n\t\t\t\
    stack:push(c)\n\t\telseif c == ']' then\n\t\t\tif stack:top() == '[' then\n\t\t\
    \t\tstack:pop()\n\t\t\telse\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\tprocessed\
    \ = processed + 1\n\tend\n\treturn (processed == #string) and stack:size() ==\
    \ 0\nend", "  local stack = {}\n  for char in string:gmatch'.' do\n    if char\
    \ == '[' then table.insert(stack, 1) end\n    if char == ']' then \n      if #stack\
    \ == 0 then return false end\n      table.remove(stack, 1)\n    end\n  end\n \
    \ return #stack > 0\nend", "    assert(type(string) == 'string')\n    local brackets\
    \ = 0\n    for _, char in ipairs(string) do\n        if char == '[' then\n   \
    \         brackets = brackets + 1\n        elseif char == ']' then\n         \
    \   brackets = brackets - 1\n        end\n        if brackets < 0 then\n     \
    \       return false\n        end\n    end\n    return brackets > 0\nend", " \
    \ local state, level = 'start', 0\n  local valid_transitions = {\n    start =\
    \ { ['['] = {state = 'open', level = level + 1}, [']]]]]]]'] = 'reject' },\n \
    \   open = { ['['] = {state = 'open', level = level + 1}, [']'] = {state = 'close',\
    \ level = level - 1} },\n    close = { ['['] = {state = 'open', level = level\
    \ + 1}, [']'] = {state = 'close', level = level - 1} }\n  }\n  for i=1,#string\
    \ do\n    local current_state = state\n    if valid_transitions[state][string:sub(i,i)]\
    \ then\n      state = valid_transitions[state][string:sub(i,i)].state\n      level\
    \ = valid_transitions[state][string:sub(i,i)].level\n    else\n      state = 'reject'\n\
    \    end\n    if state == 'reject' then\n      return false\n    end\n  end\n\
    \  return state == 'close' and level == 0\nend", "    local function is_open(char)\n\
    \        return char == '['\n    end\n    local function is_close(char)\n    \
    \    return char == ']'\n    end\n    local function is_same_type(char1, char2)\n\
    \        return is_open(char1) == is_open(char2)\n    end\n    local function\
    \ is_opposite_type(char1, char2)\n        return is_open(char1) ~= is_open(char2)\n\
    \    end\n    local stack = Stack:new()\n    for i = 1, #string do\n        local\
    \ char = string:sub(i, i)\n        if is_open(char) then\n            stack:push(char)\n\
    \        elseif is_close(char) then\n            if stack:isempty() then\n   \
    \             return false\n            elseif is_same_type(stack:peek(), char)\
    \ then\n                stack:pop()\n            elseif is_opposite_type(stack:peek(),\
    \ char) then\n                stack:pop()\n                return true\n     \
    \       end\n        end\n    end\n    return false\nend", "  local chars = {}\n\
    \  for i = 1, #string do\n    if string[i] == '[' then\n      table.insert(chars,\
    \ '[')\n    elseif string[i] == ']' then\n      if chars[#chars] == '[' then\n\
    \        table.remove(chars, #chars)\n      else\n        return false\n     \
    \ end\n    end\n  end\n  return #chars == 0\nend", "    --local stack = Stack()\n\
    \    local nested = false\n    local count = 0\n    for i = 1, #string do\n  \
    \      if string[i] == '[' then\n            --stack:push('[')\n            count\
    \ = count + 1\n        elseif string[i] == ']' then\n            --stack:pop()\n\
    \            count = count - 1\n        end\n        if count == 0 then\n    \
    \        nested = true\n        end\n    end\n    return nested\nend", "    local\
    \ r = {}\n    for i=1, #string do\n        if string:sub(i,i) == '[' then\n  \
    \          r[#r+1] = string:sub(i,i)\n        elseif #r == 0 then\n          \
    \  return false\n        else\n            r[#r] = nil\n        end\n    end\n\
    \    return #r == 0\nend", "  local stack = {}\n  for i = 1, #string do\n    if\
    \ string:sub(i, i) == '[' then\n      table.insert(stack, 1, string:sub(i, i))\n\
    \    elseif string:sub(i, i) == ']' then\n      table.remove(stack, 1)\n    end\n\
    \  end\n  return #stack == 0\nend", "  local stack = Stack()\n  for i=1,#string\
    \ do\n    local current_char = string:sub(i,i)\n    if current_char == '[' then\n\
    \      stack:push(current_char)\n    elseif current_char == ']' then\n      if\
    \ stack:pop() == nil then\n        return false\n      end\n    end\n  end\n \
    \ return stack:pop() == nil\nend", "    -- TODO: write your code here\n    return\
    \ false\nend", "  local table = {}\n  local top = 0\n  for i = 1, #string do\n\
    \    if string.sub(string, i, i) == '[' then\n      top = top + 1\n      table[top]\
    \ = i\n    elseif string.sub(string, i, i) == ']' then\n      if table[top] ~=\
    \ nil then\n        top = top - 1\n      else\n        return false\n      end\n\
    \    end\n  end\n  if table[top] == nil then\n    return true\n  else\n    return\
    \ false\n  end\nend", "  local bracket_depth = 0\n  for c in string:gmatch(\"\
    %a\") do\n    if c == '[' then\n      bracket_depth = bracket_depth + 1\n    elseif\
    \ c == ']' then\n      bracket_depth = bracket_depth - 1\n    end\n    if bracket_depth\
    \ == -1 then\n      return false\n    end\n  end\n  return bracket_depth ~= 0\n\
    end", "\tlocal stack = Stack()\n\tfor idx = 1, #string do\n\t\tlocal bracket =\
    \ string:sub(idx, idx)\n\t\tif bracket == '[' then\n\t\t\tstack:push(bracket)\n\
    \t\telseif stack:empty() then\n\t\t\treturn false\n\t\telse\n\t\t\tstack:pop()\n\
    \t\tend\n\tend\n\treturn stack:empty()\nend", "  -- your code here\nend", "  return\
    \ true\nend", "\tlocal left = string:gsub(']', '')\n\tlocal right = string:gsub('%[',\
    \ '')\n\tif left == '' or right == '' then\n\t\treturn false\n\tend\n\treturn\
    \ string:gsub('%[[^%[%]]-%]', '') ~= ''\nend", "    -- ...\nend", '  if string
    == "" then return false end', "    -- Implement this function.\n    while string:match('%[%]')\
    \ do\n        string = string:gsub('%[%]', '')\n    end\n    return #string ==\
    \ 0\nend", "    local function is_valid(brackets)\n        local bracket_map =\
    \ {['['] = ']', ['{'] = '}', ['('] = ')'}\n        local stack = Stack()\n   \
    \     for _, bracket in ipairs(brackets) do\n            if bracket_map[bracket]\
    \ then\n                stack:push(bracket)\n            else\n              \
    \  if stack:peek() ~= bracket_map[bracket] then\n                    return false\n\
    \                end\n                stack:pop()\n            end\n        end\n\
    \        return stack:isempty()\n    end", "\tlocal i, j, k = 0, 0, 0\n\twhile\
    \ i <= #string do\n\t\tif string.sub(string, i, i) == '[' then\n\t\t\tj = j +\
    \ 1\n\t\t\tk = k + 1\n\t\telseif string.sub(string, i, i) == ']' then\n\t\t\t\
    j = j - 1\n\t\t\tk = k + 1\n\t\tend\n\t\tif j < 0 then\n\t\t\treturn false\n\t\
    \tend\n\t\ti = i + 1\n\tend\n\tif j == 0 and k > 1 then\n\t\treturn true\n\telse\n\
    \t\treturn false\n\tend\nend", "    -- Will create a stack and push any opening\
    \ brackets on to it\n    -- If a closing bracket is seen, pop the stack, if the\
    \ stack is empty, the\n    -- stack is invalid, return false.\n    local stack\
    \ = Stack()\n    for i = 1, #string do\n        if string:sub(i, i) == '[' then\n\
    \            stack:push('[')\n        elseif string:sub(i, i) == ']' then\n  \
    \          if stack:is_empty() then\n                return false\n          \
    \  else\n                stack:pop()\n            end\n        end\n    end\n\
    \    if stack:is_empty() then\n        return true\n    else\n        return false\n\
    \    end\nend", "  local s = ''\n  for i = 1, #string do\n    if string.sub(string,\
    \ i, i) == '[' then\n      s = s .. '['\n    elseif string.sub(string, i, i) ==\
    \ ']' then\n      if #s == 0 then\n        return false\n      else\n        s\
    \ = string.sub(s, 1, #s - 1)\n      end\n    end\n  end\n  if #s == 0 then\n \
    \   return true\n  else\n    return false\n  end\nend", "    --[[\n    Problem:\n\
    \        * input string only contains square brackets, \"[\" and \"]\"\n     \
    \   * a subsequence is a sequence of consecutive characters\n        * a bracket\
    \ is nested if it is enclosed in another bracket, e.g. \"[[]]\"\n        * if\
    \ at least one bracket is nested, return true\n        * otherwise, return false\n\
    \    Method:\n        * if the string is empty, it has no bracket sequences, so\
    \ return false\n        * otherwise, check if the last bracket is a matching bracket\
    \ for the first bracket\n            * if so, remove the first and last bracket\
    \ from the string and recurse\n            * if not, skip the first bracket and\
    \ recurse\n        * if the string is empty, return true\n        * otherwise,\
    \ return false\n    --]]\n    if string == '' then return false end\n    local\
    \ bracket = string:sub(1, 1)\n    if bracket == '[' then\n        if string:sub(-1)\
    \ == ']' then\n            return is_nested(string:sub(2, -2))\n        else\n\
    \            return is_nested(string:sub(2))\n        end\n    else\n        return\
    \ false\n    end\nend", "    -- Implement Me\nend", "    local stack = Stack()\n\
    \    for index = 1, #string do\n        local char = string:sub(index, index)\n\
    \        if char == '[' then\n            stack:push(char)\n        elseif char\
    \ == ']' then\n            if stack:empty() then\n                return false\n\
    \            else\n                stack:pop()\n            end\n        end\n\
    \    end\n    return not stack:empty()\nend", "    local stack = Stack:new()\n\
    \    for i = 1, #string do\n        local s = string:sub(i, i)\n        if s ==\
    \ '[' then\n            stack:push(s)\n        elseif s == ']' then\n        \
    \    local element = stack:pop()\n            if element == nil then\n       \
    \         return false\n            end\n        end\n    end\n    if stack:len()\
    \ > 0 then\n        return false\n    end\n    return true\nend", "    local open_stack\
    \ = Stack:new()\n    local close_stack = Stack:new()\n    for char in string:gmatch('.')\
    \ do\n        if char == '[' then\n            open_stack:push(char)\n       \
    \ elseif char == ']' then\n            close_stack:push(char)\n        end\n \
    \   end\n    if close_stack:top() == nil or close_stack:top() == '[' then\n  \
    \      return false\n    end\n    while not open_stack:is_empty() and not close_stack:is_empty()\
    \ do\n        open_stack:pop()\n        close_stack:pop()\n    end\n    if open_stack:is_empty()\
    \ and close_stack:is_empty() then\n        return true\n    else\n        return\
    \ false\n    end\nend", "\tlocal stack = Stack()\n\tfor i = 1, #string do\n\t\t\
    if stack:is_empty() then\n\t\t\tstack:push(string[i])\n\t\telseif stack:peek()\
    \ == '[' and string[i] == ']' then\n\t\t\tstack:pop()\n\t\telse\n\t\t\tstack:push(string[i])\n\
    \t\tend\n\tend\n\treturn stack:is_empty()\nend", "  local stack = Stack()\n  for\
    \ i=1, #string do\n    local c = string:sub(i,i)\n    if c == '[' then\n     \
    \ stack:push(c)\n    elseif c == ']' then\n      local elem = stack:pop()\n  \
    \    if elem == nil then\n        return false\n      end\n    end\n  end\n  if\
    \ stack:pop() == nil then\n    return false\n  end\n  return true\nend", "  local\
    \ stack = Stack()\n  for i = 1, string.len(string) do\n    if string[i] == '['\
    \ then\n      stack:push('[')\n    elseif stack:is_empty() then\n      return\
    \ false\n    else\n      stack:pop()\n    end\n  end\n  return not stack:is_empty()\n\
    end", "    -- your code here\n    return nil\nend", "    local depth = 0\n   \
    \ for _, c in string:gmatch'.' do\n        if c == '[' then\n            depth\
    \ = depth + 1\n        elseif c == ']' then\n            depth = depth - 1\n \
    \       end\n        if depth == 0 then\n            return true\n        end\n\
    \    end\n    return false\nend", "  -- create a counter starting at zero and\
    \ a boolean to be returned\n  local counter = 0\n  local nested = false\n  --\
    \ loop through the string character by character\n  for c in string:gmatch(\"\
    .\") do\n    -- increment the counter if the character is an opening bracket\n\
    \    if c == '[' then\n      counter = counter + 1\n    -- decrement the counter\
    \ if the character is a closing bracket\n    elseif c == ']' then\n      counter\
    \ = counter - 1\n    end\n    -- if we ever reach a negative counter, then there\
    \ is a subsequence of brackets where\n    -- at least one bracket in the subsequence\
    \ is nested.\n    if counter < 0 then\n      nested = true\n    end\n  end\n \
    \ return nested\nend", "    local stack = Stack()\n    for i = 1, string.len(string)\
    \ do\n        local char = string:sub(i, i)\n        if char == '[' then\n   \
    \         stack:push(char)\n        elseif stack:is_empty() then\n           \
    \ return false\n        else\n            stack:pop()\n        end\n    end\n\
    \    return stack:is_empty()\nend", "\tlocal valid = false\n\tlocal count = 0\n\
    \tfor i = 1, string.len(string) do\n\t\tif string.sub(string, i, i) == '[' then\n\
    \t\t\tcount = count + 1\n\t\telseif string.sub(string, i, i) == ']' then\n\t\t\
    \tcount = count - 1\n\t\tend\n\t\tif count < 0 then\n\t\t\treturn false\n\t\t\
    end\n\t\tif count == 0 then\n\t\t\tvalid = true\n\t\tend\n\tend\n\treturn valid\n\
    end", "    -- Your code here\nend", "    local stack = Stack:new()\n    for i\
    \ = 1, string.len(string) do\n        local char = string.sub(string, i, i)\n\
    \        if char == '[' then\n            stack:push(char)\n        elseif char\
    \ == ']' then\n            local last_char = stack:pop()\n            if last_char\
    \ == nil then\n                return false\n            end\n        end\n  \
    \  end\n    if stack:size() > 0 then\n        return false\n    end\n    return\
    \ true\nend", "  -- YOUR CODE HERE\nend", "\t-- TODO: Implement this\nend", " \
    \   local new_string = string.gsub(string, '[]', '')\n    local valid_string =\
    \ string.gsub(new_string, '][', '')\n    return (valid_string == '[')\nend", " \
    \ local left_brackets = 0\n  local right_brackets = 0\n  for i = 1, #string do\n\
    \    if string:sub(i, i) == '[' then\n      left_brackets = left_brackets + 1\n\
    \    else\n      right_brackets = right_brackets + 1\n    end\n    if right_brackets\
    \ > left_brackets then\n      return false\n    end\n  end\n  return left_brackets\
    \ > 0 and left_brackets > right_brackets\nend", "\tif string == \"\" then return\
    \ false end\n\tlocal stack = Stack()\n\tfor i = 1, #string do\n\t\tlocal char\
    \ = string:sub(i, i)\n\t\tif char == \"[\" then\n\t\t\tstack:push(char)\n\t\t\
    elseif char == \"]\" then\n\t\t\tif stack:is_empty() then return false end\n\t\
    \t\tstack:pop()\n\t\tend\n\tend\n\treturn true\nend", "    local function is_nested_helper(i,\
    \ j)\n        if i > j then\n            return false\n        elseif i == j then\n\
    \            return false\n        elseif string.sub(string, i, i) == \"[\" and\
    \ string.sub(string, j, j) == \"]\" then\n            return is_nested_helper(i\
    \ + 1, j - 1)\n        elseif string.sub(string, i, i) == \"[\" then\n       \
    \     return is_nested_helper(i + 1, j)\n        elseif string.sub(string, j,\
    \ j) == \"]\" then\n            return is_nested_helper(i, j - 1)\n        else\n\
    \            return is_nested_helper(i + 1, j - 1)\n        end\n    end\n   \
    \ return is_nested_helper(1, string.len(string))\nend", "    error \"TODO\"\n\
    end", "\t--\"WITHOUT USING A STACK\"\n\tlocal open,close,num_close=0,0,0\n\tfor\
    \ char in string:gmatch(\".\") do\n\t\tif char==\"[\" then\n\t\t\topen=open+1\n\
    \t\telseif char==\"]\" then\n\t\t\tif open<1 then\n\t\t\t\treturn false\n\t\t\t\
    end\n\t\t\topen=open-1\n\t\t\tnum_close=num_close+1\n\t\tend\n\tend\n\tif open>0\
    \ then\n\t\treturn false\n\tend\n\treturn num_close>0\nend", "    -- ...\nend",
  "  local stack = Stack()\n  for i = 1, #string do\n    local value = string:sub(i,\
    \ i)\n    if value == '[' then\n      stack:push(value)\n    elseif value == ']'\
    \ then\n      if stack:isempty() then\n        return false\n      else\n    \
    \    stack:pop()\n      end\n    end\n  end\n  return not stack:isempty()\nend",
  "    local len = string.len(string)\n    local i = 1\n    local count = 0\n    local\
    \ found = false\n    while i <= len do\n        if string.sub(string, i, i) ==\
    \ '[' then\n            count = count + 1\n        elseif string.sub(string, i,\
    \ i) == ']' then\n            count = count - 1\n        end\n        if count\
    \ < 0 then\n            return false\n        end\n        if count > 0 then\n\
    \            found = true\n        end\n        i = i + 1\n    end\n    return\
    \ count == 0 and found\nend", "    local nest = true\n    local nest_num = 0\n\
    \    for i = 1, #string do\n        if string.sub(string, i, i) == '[' then\n\
    \            nest_num = nest_num + 1\n        elseif string.sub(string, i, i)\
    \ == ']' then\n            nest_num = nest_num - 1\n        end\n        if nest_num\
    \ == 0 then\n            nest = false\n        end\n    end\n    return nest\n\
    end", "    local length = string.len(string)\n    if length < 2 then\n       \
    \ return false\n    end\n    local stack = {}\n    for i = 1, length do\n    \
    \    local char = string.sub(string, i, i)\n        if char == '[' then\n    \
    \        table.insert(stack, 1, ']')\n        elseif char == ']' then\n      \
    \      if #stack == 0 then\n                return false\n            end\n  \
    \          if stack[1] == ']' then\n                table.remove(stack, 1)\n \
    \           else\n                return false\n            end\n        end\n\
    \    end\n    if #stack == 0 then\n        return true\n    else\n        return\
    \ false\n    end\nend", "\tlocal function validate_brackets(input)\n\t\tlocal\
    \ result = true\n\t\tlocal b, e = string.find(input, '[[]]')\n\t\twhile b do\n\
    \t\t\tinput = string.sub(input, e+1)\n\t\t\tb, e = string.find(input, '[[]]')\n\
    \t\tend\n\t\tif input ~= '' then\n\t\t\tresult = false\n\t\tend\n\t\treturn result\n\
    \tend\n\tlocal result = false\n\tlocal length = string.len(string)\n\tlocal i\
    \ = 1\n\twhile i <= length do\n\t\tlocal test = string.sub(string, i)\n\t\tresult\
    \ = validate_brackets(test)\n\t\tif result then\n\t\t\tbreak\n\t\tend\n\t\ti =\
    \ i + 1\n\tend\n\treturn result\nend", "\tlocal stack = {}\n\tlocal stack_top\
    \ = 0\n\tlocal i = 1\n\twhile i <= #string do\n\t\tlocal ch = string:sub(i, i)\n\
    \t\tif ch == '[' then\n\t\t\tstack_top = stack_top + 1\n\t\t\tstack[stack_top]\
    \ = ch\n\t\telseif ch == ']' then\n\t\t\tif stack_top == 0 then\n\t\t\t\treturn\
    \ false\n\t\t\telse\n\t\t\t\tstack_top = stack_top - 1\n\t\t\tend\n\t\tend\n\t\
    \ti = i + 1\n\tend\n\tif stack_top == 0 then\n\t\treturn true\n\telse\n\t\treturn\
    \ false\n\tend\nend", end, "    local stack = 0\n    for i=1,#string do\n    \
    \    if string[i] == '[' then\n            stack = stack + 1\n        else\n \
    \           stack = stack - 1\n        end\n        if stack < 0 then\n      \
    \      return false\n        end\n    end\n    return true\nend", "  local str\
    \ = string\n  local op = {\n    ['['] = 1,\n    [']'] = -1\n  }\n  local stack\
    \ = {}\n  for _, value in ipairs(str) do\n    if op[value] > 0 then\n      table.insert(stack,\
    \ value)\n    else\n      if #stack > 0 then\n        if op[stack[#stack]] + op[value]\
    \ == 0 then\n          table.remove(stack)\n        else\n          return false\n\
    \        end\n      else\n        return false\n      end\n    end\n  end\n  return\
    \ #stack == 0\nend", "\tlocal function is_valid(stack, bracket)\n\t\tif table.maxn(stack)\
    \ == 0 then\n\t\t\treturn false\n\t\tend\n\t\tlocal last = stack[table.maxn(stack)]\n\
    \t\treturn (last == '[[' and bracket == ']]') or (last == '[[[' and bracket ==\
    \ ']]]')\n\tend\n\tlocal stack = {}\n\tfor i=1,string.len(string) do\n\t\tlocal\
    \ bracket = string.sub(string, i, i+1)\n\t\tif bracket == '[]' or bracket == '[[['\
    \ or bracket == ']]]' then\n\t\t\ttable.insert(stack, bracket)\n\t\telseif bracket\
    \ == ']]' then\n\t\t\tif not is_valid(stack, bracket) then\n\t\t\t\treturn false\n\
    \t\t\tend\n\t\t\ttable.remove(stack)\n\t\tend\n\tend\n\treturn table.maxn(stack)\
    \ == 0\nend", "    assert(type(string) == 'string', 'input must be a string')\n\
    \    assert(string:match('^%[+%]+$'), 'input must contain only square brackets')\n\
    \    local r = {}\n    for i = 1, #string do\n        local c = string:sub(i,\
    \ i)\n        if c == '[' then\n            r[#r + 1] = c\n        else\n    \
    \        if r[#r] == '[' then\n                r[#r] = nil\n            else\n\
    \                return false\n            end\n        end\n    end\n    return\
    \ #r == 0\nend", "    local t = {}\n    local status = false\n    for idx = 1,\
    \ #string do\n        local s = string:sub(idx, idx)\n        if s == '[' then\n\
    \            table.insert(t, s)\n        elseif s == ']' then\n            if\
    \ #t == 0 then\n                return false\n            else\n             \
    \   table.remove(t)\n            end\n        end\n    end\n    if #t == 0 then\n\
    \        status = true\n    end\n    return status\nend", "    -- Iterate over\
    \ the string\n    local index = 1\n    while index <= #string do\n        -- Look\
    \ ahead and see if there is an opening bracket\n        if string[index] == '['\
    \ then\n            -- If there is an opening bracket, see if there is a closing\
    \ bracket\n            local close_bracket_index = string:find(']', index)\n \
    \           if close_bracket_index ~= nil then\n                -- If there is\
    \ a closing bracket, see if the closing bracket is nested\n                --\
    \ inside the opening bracket.\n                local nesting_count = 0\n     \
    \           for i = index, close_bracket_index - 1 do\n                    if\
    \ string[i] == '[' then\n                        nesting_count = nesting_count\
    \ + 1\n                    elseif string[i] == ']' then\n                    \
    \    nesting_count = nesting_count - 1\n                    end\n            \
    \    end\n                if nesting_count ~= 0 then\n                    return\
    \ true\n                end\n            end\n        end\n        index = index\
    \ + 1\n    end\n    return false\nend", "  local stored = {}\n  for i = 1, #string\
    \ do\n    local current = string:sub(i, i)\n    if (current == '[') then\n   \
    \   table.insert(stored, current)\n    elseif (#stored > 0) then\n      table.remove(stored)\n\
    \    else\n      return false\n    end\n  end\n  return #stored == 0\nend", " \
    \ local depth = 0\n  for i = 1, #string do\n    if string:sub(i, i) == '[' then\n\
    \      depth = depth + 1\n    else\n      depth = depth - 1\n    end\n    if depth\
    \ < 0 then\n      return false\n    end\n  end\n  return depth ~= 0\nend", " \
    \ local bracket_stack = Stack()\n  for i = 1, #string do\n    if string[i] ==\
    \ '[' then\n      bracket_stack:push('[')\n    elseif string[i] == ']' then\n\
    \      if bracket_stack:is_empty() then\n        return false\n      else\n  \
    \      bracket_stack:pop()\n      end\n    end\n  end\n  return not bracket_stack:is_empty()\n\
    end", "    local i = 1\n    local start_index = 0\n    local end_index = 0\n \
    \   for i = 1, #string do\n        if string.sub(string, i, i) == '[' then\n \
    \           start_index = i\n        elseif string.sub(string, i, i) == ']' then\n\
    \            end_index = i\n            if start_index < end_index then\n    \
    \            return true\n            end\n        end\n    end\n    return false\n\
    end", "  local valid = true\n  local stack = {}\n  for char in string:gmatch('.')\
    \ do\n    if char == '[' then\n      stack[#stack + 1] = char\n    elseif char\
    \ == ']' then\n      if #stack == 0 then\n        valid = false\n        break\n\
    \      else\n        stack[#stack] = nil\n      end\n    end\n  end\n  if valid\
    \ and #stack > 0 then\n    valid = false\n  end\n  return valid\nend", "    local\
    \ level = 0\n    for c in string:gmatch('.') do\n        if c == '[' then\n  \
    \          level = level + 1\n        elseif c == ']' then\n            level\
    \ = level - 1\n        end\n        if level < 0 then\n            return false\n\
    \        end\n    end\n    return level > 0\nend", "  if string == '' then\n \
    \   return false\n  end\n  local new_string = string:gsub('%[%]', '')\n  if new_string\
    \ == '' then\n    return true\n  elseif new_string == string then\n    return\
    \ false\n  else\n    return is_nested(new_string)\n  end\nend", "  local nesting_level\
    \ = 0\n  for i = 1, #string do\n    if string:sub(i, i) == '[' then\n      nesting_level\
    \ = nesting_level + 1\n    elseif string:sub(i, i) == ']' then\n      nesting_level\
    \ = nesting_level - 1\n    end\n    if nesting_level == 0 then\n      return true\n\
    \    end\n  end\n  return false\nend", "  -- your code here\nend", "    local\
    \ brackets = {}\n    local top = 0\n    for i = 1, #string do\n        local char\
    \ = string:sub(i, i)\n        if char == '[' then\n            top = top + 1\n\
    \            brackets[top] = char\n        elseif char == ']' then\n         \
    \   if top > 0 and brackets[top] == '[' then\n                top = top - 1\n\
    \            else\n                top = top + 1\n            end\n        end\n\
    \    end\n    return top == 0\nend", "\tlocal stack = {}\n\tfor i = 1, #string\
    \ do\n\t\tif string[i] == '[' then\n\t\t\ttable.insert(stack, ']')\n\t\telseif\
    \ string[i] == ']' then\n\t\t\tif #stack == 0 then\n\t\t\t\treturn false\n\t\t\
    \telse\n\t\t\t\ttable.remove(stack)\n\t\t\tend\n\t\tend\n\tend\n\treturn #stack\
    \ ~= 0\nend", "\tlocal check = false\n\tlocal counter = 0\n\tfor i = 1, #string\
    \ do\n\t\tif string:sub(i, i) == '[' then\n\t\t\tcounter = counter + 1\n\t\telseif\
    \ string:sub(i, i) == ']' then\n\t\t\tcounter = counter - 1\n\t\tend\n\t\tif counter\
    \ < 0 then\n\t\t\tcheck = true\n\t\tend\n\tend\n\tif counter ~= 0 then\n\t\tcheck\
    \ = true\n\tend\n\treturn not check\nend", "  local len = string.len(string)\n\
    \  local result = false\n  local cnt = 0\n  for i = 1, len do\n    local c = string.sub(string,\
    \ i, i)\n    if c == '[' then\n      cnt = cnt + 1\n    elseif c == ']' then\n\
    \      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      break\n    end\n   \
    \ if cnt > 0 then\n      result = true\n    end\n  end\n  return result\nend",
  "    local match = 0\n    local fail = false\n    for i=1,#string do\n        if\
    \ string[i] == '[' then\n            match = match + 1\n        elseif string[i]\
    \ == ']' then\n            match = match - 1\n        end\n        if match <\
    \ 0 then\n            fail = true\n            break\n        end\n    end\n \
    \   return match == 0 and not fail\nend", "  local match = 0\n  for i = 1, string.len(string)\
    \ do\n    if string.sub(string, i, i) == '[' then\n      match = match + 1\n \
    \   elseif string.sub(string, i, i) == ']' then\n      match = match - 1\n   \
    \ end\n    if match < 0 then\n      return false\n    end\n  end\n  return match\
    \ == 0\nend", "    local i = 1\n    while i <= #string do\n        if string[i]\
    \ == '[' and string[i+1] == ']' then\n            return true\n        end\n \
    \       i = i + 1\n    end\n    return false\nend", "    local max_depth = 0\n\
    \    local depth = 0\n    for i = 1, string.len(string) do\n        local char\
    \ = string.sub(string, i, i)\n        if char == '[' then\n            depth =\
    \ depth + 1\n            if depth > max_depth then\n                max_depth\
    \ = depth\n            end\n        elseif char == ']' then\n            depth\
    \ = depth - 1\n        end\n    end\n    return max_depth > 1\nend", "  -- <your\
    \ code goes here>\nend", "    local stack = Stack:new()\n    for i = 1, #string\
    \ do\n        local c = string:sub(i, i)\n        if c == '[' then\n         \
    \   stack:push(c)\n        elseif c == ']' then\n            if stack:size() >\
    \ 0 then\n                stack:pop()\n            else\n                return\
    \ false\n            end\n        end\n    end\n    return stack:size() > 0\n\
    end", "    -- YOUR CODE GOES HERE\nend", "  local count = 0\n  for c in string:gmatch(\"\
    %a\") do\n    if c == '[' then\n      count = count + 1\n    elseif c == ']' then\n\
    \      count = count - 1\n    end\n    if count < 0 then\n      return false\n\
    \    end\n  end\n  return count > 0\nend", "\t-- REMOVE: local stack = Stack()\n\
    \tlocal stack = Stack()\n\t-- REMOVE: local length = #string\n\tfor i = 1, #string\
    \ do\n\t\tlocal c = string:sub(i, i)\n\t\tif c == '[' then\n\t\t\tstack:push(c)\n\
    \t\telseif c == ']' then\n\t\t\tif stack:is_empty() then\n\t\t\t\treturn false\n\
    \t\t\telse\n\t\t\t\tstack:pop()\n\t\t\tend\n\t\tend\n\tend\n\treturn stack:is_empty()\n\
    end", "  local is_nested = false\n  local stack = Stack()\n  for i = 1, #string\
    \ do\n    local symbol = string:sub(i, i)\n    if symbol == '[' then\n      stack:push(symbol)\n\
    \    elseif symbol == ']' then\n      if stack:is_empty() then\n        return\
    \ false\n      else\n        stack:pop()\n      end\n    end\n  end\n  if stack:is_empty()\
    \ then\n    return false\n  else\n    local is_nested = false\n    while not stack:is_empty()\
    \ do\n      stack:pop()\n      if stack:is_empty() then\n        is_nested = true\n\
    \      end\n    end\n    return is_nested\n  end\nend", "    local opened = 0\n\
    \    local closed = 0\n    for _, char in ipairs(string) do\n        if char ==\
    \ '[' then\n            opened = opened + 1\n        elseif char == ']' then\n\
    \            closed = closed + 1\n        end\n    end\n    return closed <= opened\n\
    end", "\tlocal stack = Stack:new()\n\tlocal is_nested = false\n\tlocal open_brackets\
    \ = {['['] = true}\n\tlocal close_brackets = {[']'] = true}\n\tfor i=1, #string\
    \ do\n\t\tlocal char = string:sub(i,i)\n\t\tif close_brackets[char] then\n\t\t\
    \tlocal bracket = stack:pop()\n\t\t\tif bracket then\n\t\t\t\tif bracket == '['\
    \ then\n\t\t\t\t\tis_nested = true\n\t\t\t\tend\n\t\t\tend\n\t\telseif open_brackets[char]\
    \ then\n\t\t\tstack:push(char)\n\t\tend\n\tend\n\treturn stack:size() == 0 and\
    \ is_nested\nend", "    return not not string:match('[[%]][[]')\nend", "  if string\
    \ == '' then return false end\n  local stack = {}\n  local is_valid = true\n \
    \ for i=1, #string do\n    if string:sub(i,i) == '[' then\n      stack[#stack+1]\
    \ = '['\n    else\n      if #stack == 0 then\n        is_valid = false\n     \
    \   break\n      else\n        stack[#stack] = nil\n      end\n    end\n  end\n\
    \  return is_valid and #stack > 0\nend", "    -- Your code here\nend", "  local\
    \ c = 0\n  for i=1, #string do\n    local char = string:sub(i,i)\n    if char\
    \ == '[' then\n      c = c + 1\n    elseif char == ']' then\n      c = c - 1\n\
    \    end\n    if c < 0 then return false end\n  end\n  return c > 0\nend", " \
    \ return false\nend", "\tlocal stack = {}\n\tfor c in string:gmatch('.') do\n\t\
    \tif c == '[' then\n\t\t\tstack[#stack + 1] = '['\n\t\telseif c == ']' then\n\t\
    \t\tstack[#stack] = nil\n\t\tend\n\tend\n\treturn #stack == 0\nend", "  local\
    \ match = {\n    ['['] = ']',\n    ['{'] = '}',\n    ['('] = ')'\n  }\n  local\
    \ stack = {}\n  for _, c in ipairs(string) do\n    if match[c] then\n      table.insert(stack,\
    \ match[c])\n    elseif c == ']' or c == '}' or c == ')' then\n      if stack[#stack]\
    \ == c then\n        table.remove(stack)\n      else\n        return false\n \
    \     end\n    end\n  end\n  return #stack == 0\nend", "  local level = 0\n  for\
    \ i=1, #string do\n    local char = string:sub(i,i)\n    if level == 0 and char\
    \ == ']' then\n      return false\n    elseif char == '[' then\n      level =\
    \ level + 1\n    elseif char == ']' then\n      level = level - 1\n    end\n \
    \ end\n  return level == 0\nend", "    local function is_empty(stack)\n      \
    \  if #stack == 0 then return true else return false end\n    end\n    local function\
    \ is_match(open, close)\n        if open == '[' and close == ']' then return true\
    \ else return false end\n    end\n    local function peek(stack)\n        return\
    \ stack[#stack]\n    end\n    local stack = {}\n    for c in string:gmatch(\"\
    .\") do\n        if c == '[' then\n            table.insert(stack, c)\n      \
    \  elseif c == ']' then\n            if is_empty(stack) then return false\n  \
    \          elseif not is_match(peek(stack), c) then return false\n           \
    \ else table.remove(stack) end\n        end\n    end\n    return true\nend", " \
    \   local count = 0\n    for i = 1, #string do\n        if string:sub(i, i) ==\
    \ '[' then\n            count = count + 1\n        elseif string:sub(i, i) ==\
    \ ']' then\n            count = count - 1\n        end\n        if count < 0 then\n\
    \            return false\n        end\n    end\n    return count > 0\nend", " \
    \   local count = 0\n    for i = 1, #string do\n        if string:sub(i, i) ==\
    \ '[' then\n            count = count + 1\n        elseif string:sub(i, i) ==\
    \ ']' then\n            count = count - 1\n        end\n        if count < 0 then\n\
    \            return false\n        end\n    end\n    return count == 0\nend",
  "    -- TODO\nend", "    -- Build a stack from left to right.\n    -- Each time\
    \ we find a '[', push to the stack.\n    -- Each time we find a ']', if the top\
    \ of the stack is '[', pop from the stack.\n    -- If the top of the stack is\
    \ ']', push to the stack.\n    -- If the stack is empty, we cannot nest.\n   \
    \ -- If the stack is not empty, the stack is not balanced.\n    local stack =\
    \ {}\n    for _, c in ipairs(string:split('')) do\n        if c == '[' then\n\
    \            stack[#stack + 1] = c\n        else\n            if #stack == 0 then\n\
    \                return false\n            end\n            local top = stack[#stack]\n\
    \            if top == '[' then\n                stack[#stack] = nil\n       \
    \     else\n                stack[#stack + 1] = c\n            end\n        end\n\
    \    end\n    return #stack == 0\nend", "  local left = 0\n  local right = 0\n\
    \  for i = 1, string.len(string) do\n    if string.sub(string, i, i) == '[' then\n\
    \      left = left + 1\n    else\n      right = right + 1\n    end\n    if right\
    \ > left then\n      return false\n    end\n  end\n  return right == left\nend",
  "  if #string == 0 then\n    return false\n  end\n  local last = ''\n  for i = 1,\
    \ #string do\n    local c = string:sub(i, i)\n    if c == '[' then\n      last\
    \ = last .. c\n    elseif c == ']' then\n      if last == '' then\n        return\
    \ false\n      end\n      last = last:sub(1, #last - 1)\n    end\n  end\n  return\
    \ #last > 0\nend", "\tlocal nested = false\n\tlocal stack = Stack:new()\n\tfor\
    \ i = 1, string.len(string) do\n\t\tlocal bracket = string.sub(string, i, i)\n\
    \t\tif bracket == '[' then\n\t\t\tstack:push(bracket)\n\t\telseif bracket == ']'\
    \ then\n\t\t\tif stack:isempty() then\n\t\t\t\tstack:push(bracket)\n\t\t\telse\n\
    \t\t\t\tstack:pop()\n\t\t\tend\n\t\tend\n\tend\n\tif stack:isempty() then\n\t\t\
    nested = true\n\tend\n\treturn nested\nend", "    local characters = {\n     \
    \   ['['] = 0,\n        [']'] = 0\n    }\n    for i = 1, #string do\n        if\
    \ string[i] == '[' then\n            characters['['] = characters['['] + 1\n \
    \       elseif string[i] == ']' then\n            characters[']'] = characters[']']\
    \ + 1\n        end\n    end\n    if characters['['] > characters[']'] then\n \
    \       return true\n    else\n        return false\n    end\nend", "    local\
    \ str = string\n    local is_str_ok = true\n    local repeat_time = 0\n    while\
    \ is_str_ok do\n        if str == '' then\n            break\n        end\n  \
    \      local str_len = string.len(str)\n        local pos1 = str:find('[')\n \
    \       local pos2 = str:find(']')\n        if pos1 and pos2 then\n          \
    \  if pos1 < pos2 then\n                str = str:sub(pos2 + 1, str_len)\n   \
    \         else\n                is_str_ok = false\n            end\n        elseif\
    \ pos1 and not pos2 then\n            is_str_ok = false\n        elseif not pos1\
    \ and pos2 then\n            is_str_ok = false\n        else\n            is_str_ok\
    \ = false\n        end\n        repeat_time = repeat_time + 1\n        if repeat_time\
    \ > 100 then\n            break\n        end\n    end\n    return is_str_ok\n\
    end", "    -- Your code here\nend", "    local stack = {}\n    for i = 1, #string\
    \ do\n        local char = string:sub(i, i)\n        if char == '[' then\n   \
    \         table.insert(stack, char)\n        elseif char == ']' then\n       \
    \     local top = table.remove(stack)\n            if top == nil then\n      \
    \          return false\n            end\n        end\n    end\n    return #stack\
    \ == 0\nend", "  assert(type(string) == 'string')\n  -- TODO: implement the function\n\
    end", "  -- your code goes here\nend", "    local stack = Stack:new()\n    local\
    \ top_char", "  local stack = {}\n  local index = 1\n  local s_length = string.len(string)\n\
    \  while index <= s_length do\n    local bracket = string.sub(string, index, index)\n\
    \    if bracket == '[' then\n      table.insert(stack, bracket)\n    elseif bracket\
    \ == ']' then\n      local item = table.remove(stack)\n      if item == nil then\n\
    \        return false\n      end\n    end\n    index = index + 1\n  end\n  return\
    \ table.getn(stack) == 0\nend", "  local chars = {};\n  local current_char;\n\
    \  local i;\n  local size = string.len(string);\n  local stack_size = 0;\n  local\
    \ is_nested = false;\n  for i = 1, size do\n    current_char = string.sub(string,\
    \ i, i);\n    chars[#chars + 1] = current_char;\n  end\n  for i = 1, #chars do\n\
    \    current_char = chars[i];\n    if current_char == '[' then\n      stack_size\
    \ = stack_size + 1;\n    elseif current_char == ']' then\n      stack_size = stack_size\
    \ - 1;\n    end\n    if stack_size < 0 then\n      is_nested = true;\n      break;\n\
    \    end\n  end\n  return is_nested;\nend", "    local open, close = 0, 0\n  \
    \  local nested = false\n    for _, char in pairs(string) do\n        if char\
    \ == '[' then\n            open = open + 1\n        elseif char == ']' then\n\
    \            close = close + 1\n        end\n        if open > 0 and close > 0\
    \ then\n            nested = true\n            break\n        end\n    end\n \
    \   return nested\nend", "  local level = 0\n  for i = 1, #string do\n    if string:sub(i,\
    \ i) == '[' then\n      level = level + 1\n    else\n      level = level - 1\n\
    \    end\n    if level < 0 then\n      return false\n    end\n  end\n  return\
    \ level > 0\nend", "  local stack = Stack:new()\n  local a = 1\n  local b = 1\n\
    \  for i = 1, string.len(string) do\n    local c = string.sub(string, i, i)\n\
    \    if c == '[' then\n      a = a + 1\n      stack:push(c)\n    elseif c == ']'\
    \ then\n      b = b + 1\n      if stack:is_empty() then\n        return false\n\
    \      else\n        stack:pop()\n      end\n    end\n  end\n  if a == b and not\
    \ stack:is_empty() then\n    return true\n  else\n    return false\n  end\nend",
  "  local stack = {}\n  for i=1,string.len(string) do\n    if string.sub(string,i,i)\
    \ == '[' then\n      table.insert(stack,1,1)\n    elseif stack[1] then\n     \
    \ table.remove(stack,1)\n    else\n      return false\n    end\n  end\n  return\
    \ #stack == 0\nend", "\t-- put the string into a list\n\tlocal list = {}\n\tlocal\
    \ valid_open_count = 0\n\tfor i=1,string.len(string) do\n\t\tlist[i] = string.sub(string,i,i)\n\
    \tend\n\t-- if there are an odd number of brackets, then no\n\tif #list % 2 ==\
    \ 1 then\n\t\treturn false\n\tend\n\tlocal open_square_count = 0\n\tlocal open_square_idx\
    \ = {}\n\tlocal closed_square_count = 0\n\tlocal closed_square_idx = {}\n\tfor\
    \ k,v in pairs(list) do\n\t\tif v == '[' then\n\t\t\topen_square_count = open_square_count\
    \ + 1\n\t\t\topen_square_idx[open_square_count] = k\n\t\telseif v == ']' then\n\
    \t\t\tclosed_square_count = closed_square_count + 1\n\t\t\tclosed_square_idx[closed_square_count]\
    \ = k\n\t\t\t-- check if the open and closed brackets are in the right order\n\
    \t\t\tif closed_square_idx[closed_square_count] < open_square_idx[open_square_count]\
    \ then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\t-- check if the open and closed\
    \ brackets are nested\n\t\t\tif closed_square_idx[closed_square_count] - open_square_idx[open_square_count]\
    \ > 1 then\n\t\t\t\tvalid_open_count = valid_open_count + 1\n\t\t\tend\n\t\t\t\
    open_square_count = open_square_count - 1\n\t\tend\n\tend\n\tif valid_open_count\
    \ > 0 then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "\tlocal left,\
    \ right = 0, 0\n\tfor i = 1, #string do\n\t\tif string[i] == '[' then\n\t\t\t\
    left = left + 1\n\t\telse\n\t\t\tright = right + 1\n\t\tend\n\t\tif right > left\
    \ then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn left > 0 and left == right\n\
    end", "\t--implementation\nend", "    local stack = {}\n    for _,c in ipairs(string)\
    \ do\n        if c == '[' then\n            table.insert(stack, c)\n        elseif\
    \ #stack > 0 then\n            table.remove(stack)\n        else\n           \
    \ return false\n        end\n    end\n    return #stack == 0\nend", "    local\
    \ last_char = ' '\n    local first_open = 0\n    local last_closed = 0\n    for\
    \ c in string:gmatch('.') do\n        if c == '[' then\n            if last_char\
    \ == '[' then\n                first_open = first_open + 1\n            end\n\
    \            last_char = '['\n        elseif c == ']' then\n            if last_char\
    \ == '[' then\n                first_open = first_open - 1\n            elseif\
    \ last_char == ']' then\n                last_closed = last_closed + 1\n     \
    \       end\n            last_char = ']'\n        end\n    end\n    return first_open\
    \ == 0 and last_closed == 0\nend", "  -- TODO: write this function\nend", "  \
    \  local stack = {}\n    for i = 1, string.len(string) do\n        local ch =\
    \ string.sub(string, i, i)\n        if ch == '[' then\n            table.insert(stack,\
    \ ']')\n        elseif ch == ']' then\n            local top = table.remove(stack)\n\
    \            if top ~= ch then\n                return false\n            end\n\
    \        end\n    end\n    return #stack == 0\nend", "  local l=0 -- l is the\
    \ number of left square brackets\n  local r=0 -- r is the number of right square\
    \ brackets\n  local f=false -- f is the flag for nested brackets\n  for i=1,string.len(string)\
    \ do\n    if string.sub(string,i,i)=='[' then\n      l=l+1\n    else\n      r=r+1\n\
    \    end\n    if l<r then\n      f=true\n    end\n  end\n  if r~=l then\n    return\
    \ false\n  elseif f==true then\n    return true\n  else\n    return false\n  end\n\
    end", "    if not string then\n        return false\n    end\n    local len =\
    \ #string\n    if len == 0 then\n        return false\n    end\n    local n =\
    \ 0\n    for i = 1, len do\n        local ch = string:sub(i, i)\n        if ch\
    \ == '[' then\n            n = n + 1\n        elseif ch == ']' then\n        \
    \    n = n - 1\n        end\n        if n < 0 then\n            return false\n\
    \        end\n    end\n    return n > 0\nend", "\tlocal matches = 0\n\tfor i=1,#string\
    \ do\n\t\tif string:sub(i,i) == '[' then\n\t\t\tmatches = matches + 1\n\t\telseif\
    \ string:sub(i,i) == ']' then\n\t\t\tmatches = matches - 1\n\t\tend\n\t\tif matches\
    \ < 0 then return false end\n\tend\n\treturn matches ~= 0\nend", "\tlocal function\
    \ _is_nested(string, i, j)\n\t\tif i > j then\n\t\t\treturn true\n\t\tend\n\t\t\
    if string:sub(i, i) == string:sub(j, j) then\n\t\t\tlocal k = i + 1\n\t\t\twhile\
    \ string:sub(k, k) ~= string:sub(j, j) do\n\t\t\t\tk = k + 1\n\t\t\tend\n\t\t\t\
    return _is_nested(string, i + 1, k - 1) and _is_nested(string, k + 1, j - 1)\n\
    \t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\treturn _is_nested(string, 1, #string)\n\
    end", "  local stack = require('stack')\n  local s = stack:new()\n  local char\
    \ = string:sub(1,1)\n  for i = 1, #string do\n    char = string:sub(i,i)\n   \
    \ if char == '[' then\n      s:push(char)\n    elseif char == ']' then\n     \
    \ if s:isempty() then\n        return false\n      else\n        s:pop()\n   \
    \   end\n    end\n  end\n  if s:isempty() then\n    return true\n  else\n    return\
    \ false\n  end\nend", "    local function aux(string, i, balance)\n        if\
    \ i > #string then\n            return balance == 0\n        elseif string[i]\
    \ == '[' then\n            return aux(string, i + 1, balance + 1)\n        elseif\
    \ string[i] == ']' then\n            return balance > 0 and aux(string, i + 1,\
    \ balance - 1)\n        else\n            return aux(string, i + 1, balance)\n\
    \        end\n    end\n    return aux(string, 1, 0)\nend", "  local stack = Stack:new()\n\
    \  for i = 1, string.len(string) do\n    if string.sub(string, i, i) == '[' then\n\
    \      stack:push('[')\n    elseif string.sub(string, i, i) == ']' then\n    \
    \  if stack:is_empty() then\n        return false\n      else\n        stack:pop()\n\
    \      end\n    end\n  end\n  return stack:is_empty()\nend", "    local stack\
    \ = {}\n    for char in string:gmatch('.') do\n        if char == '[' then\n \
    \           stack[#stack + 1] = char\n        elseif char == ']' then\n      \
    \      if #stack == 0 then\n                return false\n            else\n \
    \               stack[#stack] = nil\n            end\n        end\n    end\n \
    \   return #stack > 0\nend", "    local depth = 0\n    for i = 1, #string do\n\
    \        if string[i] == '[' then\n            depth = depth + 1\n        elseif\
    \ string[i] == ']' then\n            depth = depth - 1\n        end\n        if\
    \ depth < 0 then\n            return false\n        end\n    end\n    return depth\
    \ > 0\nend", end, "    local level = 0\n    for i = 1, #string do\n        if\
    \ string:sub(i, i) == '[' then\n            level = level + 1\n        elseif\
    \ string:sub(i, i) == ']' then\n            level = level - 1\n        end\n \
    \       if level < 0 then\n            return false\n        end\n    end\n  \
    \  return level > 0\nend", "    return true\nend", "  return 0\nend", "    local\
    \ depth = 0\n    for i = 1, #string do\n        local next = string:sub(i, i)\n\
    \        if next == '[' then\n            depth = depth + 1\n        elseif next\
    \ == ']' then\n            depth = depth - 1\n        end\n        if depth <\
    \ 0 then\n            return false\n        end\n    end\n    return depth > 0\n\
    end", "  local count = 0\n  for i = 1, #string do\n    if count < 0 then return\
    \ false end\n    if string[i] == '[' then count = count + 1\n    elseif string[i]\
    \ == ']' then count = count - 1 end\n  end\n  return count == 0\nend", "    --\
    \ Iterate over the characters in string.\n    for c in string:gmatch('.') do\n\
    \        -- If the character is the opening bracket ('['),\n        -- then push\
    \ it to the stack.\n        if c == '[' then\n            table.insert(stack,\
    \ c)\n        -- If the character is the closing bracket (']'),\n        -- then\
    \ pop the last element from the stack.\n        elseif c == ']' then\n       \
    \     table.remove(stack)\n        end\n    end\n    -- Check whether the stack\
    \ is empty.\n    -- If it is empty, then there is no nested brackets.\n    return\
    \ #stack == 0\nend", "  local is_nested = false\n  local stack = Stack:new()\n\
    \  for _, val in ipairs(string) do\n    if val == '[' then\n      stack:push(val)\n\
    \    elseif val == ']' then\n      if stack:pop() then\n        if stack:peek()\
    \ == '[' then\n          is_nested = true\n        end\n      end\n    end\n \
    \ end\n  return is_nested\nend", "    -- TODO\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
