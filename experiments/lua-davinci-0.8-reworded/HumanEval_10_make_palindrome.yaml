name: HumanEval_10_make_palindrome
language: lua
prompt: "-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm\
  \ idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n\
  -- - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n-- >>> make_palindrome('')\n-- ''\n-- >>> make_palindrome('cat')\n\
  -- 'catac'\n-- >>> make_palindrome('cata')\n-- 'catac'\nlocal function make_palindrome(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
  \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
  \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
  \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal string_len = #string\n\tlocal prefix = string:sub(1, math.floor(string_len\
    \ / 2))\n\tlocal suffix = string:sub(math.ceil(string_len / 2) + 1)\n\tlocal reversed_prefix\
    \ = prefix:reverse()\n\tlocal max_prefix_length = 1\n\tfor prefix_length = 2,\
    \ #prefix do\n\t\tlocal prefix_candidate = reversed_prefix:sub(1, prefix_length)\n\
    \t\tif string.sub(suffix, 1, prefix_length) == prefix_candidate then\n\t\t\tmax_prefix_length\
    \ = prefix_length\n\t\tend\n\tend\n\treturn string .. reversed_prefix:sub(max_prefix_length\
    \ + 1)\nend", "    local longest_postfix = longest_palindromic_postfix(string)\n\
    \    local reversed_remainder = string:sub(0, -longest_postfix - 1):reverse()\n\
    \    return string .. reversed_remainder\nend", "\tlocal s_l = #string\n\tlocal\
    \ palindrome_suffix = string:sub(1, find_longest_palindrome_suffix(string))\n\t\
    return string .. palindrome_suffix:reverse()\nend", "    local prefix_length =\
    \ 0\n    local string_length = #string\n    while prefix_length < string_length\
    \ do\n        local suffix_length = 0\n        while suffix_length <= prefix_length\
    \ do\n            if string[prefix_length - suffix_length + 1] ~= string[string_length\
    \ - suffix_length + 1] then\n                break\n            end\n        \
    \    suffix_length = suffix_length + 1\n        end\n        if suffix_length\
    \ > prefix_length then\n            break\n        end\n        prefix_length\
    \ = prefix_length + 1\n    end\n    local prefix = string:sub(1, prefix_length)\n\
    \    return string .. prefix:reverse()\nend", "  local s = string\n  if #s ==\
    \ 0 then\n    return s\n  end\n  local suffix_is_palindrome, j = is_palindrome(s)\n\
    \  if suffix_is_palindrome then\n    return s\n  end\n  -- if not then append\
    \ reverse of the rest of the string\n  local s_reverse = reverse(s)\n  local s_plus_s_reverse\
    \ = s .. s_reverse\n  if s_plus_s_reverse == s then\n    return s\n  end\n  return\
    \ s_plus_s_reverse\nend", "    local prefix = {}\n    for i = 1, string.len(string)\
    \ do\n        prefix[i] = string.sub(string, 1, i)\n    end\n    local p = string.len(string)\n\
    \    while p > 0 do\n        if is_palindrome(prefix[p]) then\n            break\n\
    \        end\n        p = p - 1\n    end\n    local prefix = string.sub(string,\
    \ 1, p)\n    local suffix = reverse(prefix)\n    return prefix .. suffix\nend",
  "    local original_len = #string\n    local offset = original_len\n    -- Because\
    \ we are checking palindromes from the beginning, longest found\n    -- palindrome\
    \ is suffixed to the end of the string. Because of this,\n    -- the maximum length\
    \ of a palindrome that we are interested in is the\n    -- half of the length\
    \ of the string.\n    local max_palindrome_length = math.floor(original_len /\
    \ 2)", "    local reverse = string.reverse(string)\n    local suffix = ''\n  \
    \  local left = 1\n    local right = math.min(#string, #reverse)\n    while left\
    \ <= right do\n        local prefix = string.sub(string, 1, left)\n        local\
    \ postfix = string.sub(reverse, 1, right)\n        if prefix == postfix then\n\
    \            suffix = prefix\n        end\n        left = left + 1\n        right\
    \ = right - 1\n    end\n    local prefix = string.sub(string, 1, #string - #suffix)\n\
    \    return string.format('%s%s%s', string, string.reverse(prefix), suffix)\n\
    end", "    local suffix = find_longest_palindrome_suffix(string)\n    local prefix\
    \ = string.sub(string, 1, #string - #suffix)\n    local reversed_prefix = string.reverse(prefix)\n\
    \    return string .. reversed_prefix\nend", "  local reverse_string = string.reverse(string)\n\
    \  local a = string .. \"$\" .. reverse_string\n  local z = z_function(a)\n  local\
    \ zz = z.z\n  local zzz = z.zz\n  local longest_prefix = {}\n  local m = #string\n\
    \  for i = m + 2, #a do\n    if zz[i] == m + 1 then\n      longest_prefix[#longest_prefix\
    \ + 1] = i\n    end\n  end\n  local shortest_index = #string + 1\n  for i = 1,\
    \ #longest_prefix do\n    if zzz[longest_prefix[i]] < shortest_index then\n  \
    \    shortest_index = zzz[longest_prefix[i]]\n    end\n  end\n  return string\
    \ .. string.sub(reverse_string, 1, #string - shortest_index + 1)\nend", "    local\
    \ postfix_length = longest_palindromic_suffix(string)\n    local string_length\
    \ = #string\n    local string_prefix = string:sub(1, string_length - postfix_length)\n\
    \    local string_postfix = string:sub(string_length - postfix_length + 1, string_length)\n\
    \    return string_postfix .. string_prefix:reverse()\nend", "    local prefix\
    \ = string:sub(1, #string - is_palindrome(string))\n    local suffix = string:sub(#string\
    \ - is_palindrome(string) + 1)\n    return suffix .. prefix:reverse()\nend", " \
    \ local n = #string\n  local k = longest_palindrome_end(string)\n  return string\
    \ .. string:sub(1, n - k):reverse()\nend", "    local l = longest_palindrome_substring(string)\n\
    \    return l.s == string and l.s or l.s .. string:sub(1, l.prefix_len):reverse()\n\
    end", "  -- Find the first position of a char that is not a palindrome.\n  local\
    \ pos\n  for i = string.len(string), 1, -1 do\n    if not is_palindrome(string.sub(string,\
    \ 1, i)) then\n      pos = i\n      break\n    end\n  end\n  return string ..\
    \ string.reverse(string.sub(string, 1, pos - 1))\nend", "    local lps = longest_palindromic_suffix(string)\n\
    \    local prefix = string:sub(1, #string - lps)\n    return string .. prefix:reverse()\n\
    end", "    local length = string:len()\n    for i = 0, length - 1 do\n       \
    \ if string:sub(length - i) == string:sub(1, i):reverse() then\n            return\
    \ string .. string:sub(1, length - i - 1):reverse()\n        end\n    end\n  \
    \  return string\nend", "    local palindrome_suffix = get_longest_palindrome_suffix(string)\n\
    \    local palindrome_prefix = string.reverse(string:sub(1, #string - #palindrome_suffix))\n\
    \    return string .. palindrome_prefix\nend", "    assert(string ~= nil)\n  \
    \  -- Find the longest palindromic suffix.\n    local longest_palindromic_suffix\
    \ = ''\n    for i = 1, string.len(string) do\n        local substring = string.sub(string,\
    \ i)\n        if is_palindrome(substring) then\n            longest_palindromic_suffix\
    \ = substring\n            break\n        end\n    end\n    -- Append to the suffix\
    \ the reverse of the prefix.\n    local prefix = string.sub(string, 1, string.len(string)\
    \ - string.len(longest_palindromic_suffix))\n    local reverse_prefix = reverse(prefix)\n\
    \    return string .. reverse_prefix\nend", "    local length = string:len()\n\
    \    local reverse = string:reverse()\n    local max_match_length = 0\n    local\
    \ max_match_prefix = 0\n    local table = {}\n    -- Fill the match table.\n \
    \   for i = 1, length do\n        local match_length = 0\n        for j = 1, i\
    \ do\n            local sub_string_a = string:sub(j, j + match_length)\n     \
    \       local sub_string_b = reverse:sub(length - i + 1, length - i + 1 + match_length)\n\
    \            if sub_string_a == sub_string_b then\n                match_length\
    \ = match_length + 1\n            else\n                break\n            end\n\
    \        end\n        table[i] = match_length\n        if match_length > max_match_length\
    \ then\n            max_match_length = match_length\n            max_match_prefix\
    \ = i\n        end\n    end\n    -- Extract the substring that needs to be appended\
    \ to the end of the supplied string.\n    local non_palindromic_suffix = string:sub(max_match_prefix\
    \ + 1, length)\n    local reverse_of_non_palindromic_suffix = non_palindromic_suffix:reverse()\n\
    \    return string .. reverse_of_non_palindromic_suffix\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
