name: HumanEval_43_pairs_sum_to_zero
language: lua
prompt: "-- pairs_sum_to_zero takes a table of integers as an input.\n-- it returns\
  \ true if there are two distinct elements in the table that\n-- sum to zero, and\
  \ false otherwise.\n-- >>> pairs_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> pairs_sum_to_zero({1,\
  \ 3, -2, 1})\n-- false\n-- >>> pairs_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>>\
  \ pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\n-- true\n-- >>> pairs_sum_to_zero({1})\n\
  -- false\nlocal function pairs_sum_to_zero(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pairs_sum_to_zero\n\
  \    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1,\
  \ 3, -2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({2,\
  \ 4, -5, 3, 5, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({-3,\
  \ 9, -1, 3, 2, 30}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}),\
  \ true)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)\n    lu.assertEquals(candidate({-3,\
  \ 9, -1, 4, 2, 31}), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    for i = 1, #l do\n        for j = i + 1, #l do\n            if\
    \ l[i] + l[j] == 0 then\n                return true\n            end\n      \
    \  end\n    end\n    return false\nend", "  local a = {}\n  for i, e in ipairs(l)\
    \ do\n    if a[e] then\n      return true\n    end\n    a[-e] = true\n  end\n\
    \  return false\nend", "  for k, v in pairs(l) do\n    for n, m in pairs(l) do\n\
    \      if n ~= k and v + m == 0 then\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "    local seen = {}\n    for _, i in ipairs(l)\
    \ do\n        if seen[-i] then\n            return true\n        end\n       \
    \ seen[i] = true\n    end\n    return false\nend", "    -- TODO: Implement this!\n\
    \    if (#l > 1) then\n        for i = 1, (#l - 1) do\n            for j = i +\
    \ 1, #l do\n                if (l[i] + l[j] == 0) then\n                    return\
    \ true\n                end\n            end\n        end\n    end\n    return\
    \ false\nend", "  local flag = false\n  for i, x in ipairs(l) do\n    for j, y\
    \ in ipairs(l) do\n      if i ~= j and x + y == 0 then\n        flag = true\n\
    \      end\n    end\n  end\n  return flag\nend", "  table.sort(l)\n  local N =\
    \ #l\n  local i = 1\n  local j = N\n  while i <= j do\n    local v = l[i] + l[j]\n\
    \    if v == 0 then\n      return true\n    elseif v < 0 then\n      i = i + 1\n\
    \    else\n      j = j - 1\n    end\n  end\n  return false\nend", '    local s
    = {}', "    for i = 1, #l do\n        for j = i + 1, #l do\n            if l[i]\
    \ + l[j] == 0 then\n                return true\n            end\n        end\n\
    \    end\n    return false\nend", "    -- YOUR CODE HERE\n    error(\"not implemented\"\
    )\nend", "    for i, v in ipairs(l) do\n        for j, k in ipairs(l) do\n   \
    \         if v ~= k and v + k == 0 then\n                return true\n       \
    \     end\n        end\n    end\n    return false\nend", "  return false\nend",
  "    if table.getn(l) == 1 then\n        return false\n    end\n    for i,_ in ipairs(l)\
    \ do\n        for j,_ in ipairs(l) do\n            if l[i] + l[j] == 0 and l[i]\
    \ ~= l[j] then\n                return true\n            end\n        end\n  \
    \  end\n    return false\nend", "    for i = 1, #l do\n        for j = i + 1,\
    \ #l do\n            if l[i] + l[j] == 0 then\n                return true\n \
    \           end\n        end\n    end\n    return false\nend", "  -- replace this\
    \ line with your implementation\n  return false\nend", "   local seen = {}\n \
    \  for _, v in ipairs(l) do\n      if seen[-v] then\n         return true\n  \
    \    end\n      seen[v] = true\n   end\n   return false\nend", '  local found
    = false', "    -- We are going to loop through the list and store\n    -- what\
    \ we have seen in a dictionary. We can then check\n    -- if we have seen the\
    \ negative of the current number\n    -- (or the current number if it is negative).\n\
    \    local dict = {}\n    for i,v in ipairs(l) do\n        -- check if we have\
    \ seen the negative of the current number\n        if dict[-v] then\n        \
    \    return true\n        end\n        -- store the current number\n        dict[v]\
    \ = true\n    end\n    return false\nend", "  for i = 1, #l - 1 do\n    for j\
    \ = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "    -- your code here\n    return false\n\
    end", "\t\nend", "    local function has_value(t, val)\n        for _, v in ipairs(t)\
    \ do\n            if v == val then\n                return true\n            end\n\
    \        end\n        return false\n    end", "  -- YOUR CODE HERE\n  local sum\
    \ = {}\n  for i = 1, #l do\n    for j = i+1, #l do\n      if l[i] + l[j] == 0\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "    -- ~~~~~YOUR CODE HERE~~~~~\n    local n = #l\n    if (n == 1) then\n     \
    \   return false\n    end\n    local o = {}\n    for i, v in ipairs(l) do\n  \
    \      o[v] = i\n    end\n    for i, v in ipairs(l) do\n        if (o[-v] ~= nil\
    \ and o[-v] ~= i) then\n            return true\n        end\n    end\n    return\
    \ false\nend", "  -- Add your implementation here.\n  for i,v in ipairs(l) do\n\
    \    for j,k in ipairs(l) do\n      if v + k == 0 and i ~= j then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  -- find sums of pairs\
    \ and store them in a set\n  local set = {}\n  for i = 1, #l do\n    for j = i\
    \ + 1, #l do\n      set[l[i] + l[j]] = true\n    end\n  end\n  -- check whether\
    \ zero is in the set\n  return set[0]\nend", "    -- YOUR CODE HERE\n    -- You\
    \ may not use any of the functions in the table manipulation\n    -- section above\
    \ (unless you write them yourself).\n    -- Instead, make use of the built-in\
    \ `table` library.\n    --\n    -- See http://www.lua.org/manual/5.3/manual.html#6.6\
    \ for the list\n    -- of functions that the `table` library provides.\n    --\n\
    \    -- See http://www.lua.org/manual/5.3/manual.html#2.5.4 for how\n    -- to\
    \ use the `table` library to access and alter tables.\n    --\n    -- You should\
    \ think about what common case you can assume about\n    -- the input and how\
    \ you can use `table` functions to avoid writing\n    -- a lot of code.\n    local\
    \ t = {}\n    for i = 1, #l do\n        if l[i] == 0 then\n            return\
    \ true\n        end\n        if not t[l[i]] then\n            t[l[i]] = true\n\
    \        else\n            return true\n        end\n    end\n    return false\n\
    end", "  local seen = {}\n  for i = 1, #l do\n    local x = l[i]\n    if seen[-x]\
    \ then\n      return true\n    end\n    seen[x] = true\n  end\n  return false\n\
    end", "\tlocal found = false\n\tfor i = 1, #l do\n\t\tfor j = i + 1, #l do\n\t\
    \t\tif l[i] + l[j] == 0 then\n\t\t\t\tfound = true\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn found\nend", "    local seen = {}\n    for _, val in ipairs(l) do\n \
    \       if seen[val] then\n            return true\n        end\n        seen[-val]\
    \ = true\n    end\n    return false\nend", "\tl = quicksort(l)\n\tlocal i = 1\n\
    \tlocal j = #l\n\twhile i < j do\n\t\tif l[i] + l[j] == 0 then\n\t\t\treturn true\n\
    \t\telseif l[i] + l[j] < 0 then\n\t\t\ti = i + 1\n\t\telse\n\t\t\tj = j - 1\n\t\
    \tend\n\tend\n\treturn false\nend", "   if #l < 2 then\n      return false\n \
    \  end\n   local visited = {}\n   for i, v in ipairs(l) do\n      if visited[-v]\
    \ then\n         return true\n      end\n      visited[v] = true\n   end\n   return\
    \ false\nend", "    table.sort(l)\n    for k, v in ipairs(l) do\n        if v\
    \ > 0 then\n            return false\n        end\n        for _, v2 in ipairs(l)\
    \ do\n            if v + v2 == 0 then\n                return true\n         \
    \   end\n        end\n    end\n    return false\nend", "    local zeros = {}\n\
    \    for i, num in ipairs(l) do\n        if zeros[-num] then\n            return\
    \ true\n        end\n        zeros[num] = true\n    end\n    return false\nend",
  "    -- if list is empty, return false\n    if #l == 0 then\n        return false\n\
    \    end\n    -- if list has 1 value, return false\n    if #l == 1 then\n    \
    \    return false\n    end\n    -- if list has more than 1 values, then return\
    \ false\n    if #l > 1 then\n        -- sorting\n        table.sort(l)\n     \
    \   -- make a new table\n        local m = {}\n        -- loop through the sorted\
    \ list\n        for i, _ in ipairs(l) do\n            -- do the following if value\
    \ is not zero\n            if l[i] ~= 0 then\n                -- look for the\
    \ negative of the value\n                if lookup(l, -l[i]) then\n          \
    \          --if found, return true\n                    return true\n        \
    \        end\n            end\n        end\n        -- if not found, return false\n\
    \        return false\n    end\nend", "  return l[1] == 0 and l[2] == 0\nend",
  "  -- return true if l contains -a for some a in l, or false otherwise\n  local\
    \ function contains_neg(l)\n    for i = 1, #l do\n      for j = 1, #l do\n   \
    \     if l[i] + l[j] == 0 and i ~= j then\n          return true\n        end\n\
    \      end\n    end\n    return false\n  end\n  return contains_neg(l)\nend",
  "    local t = {}\n    for i = 1, #l do\n        if t[-l[i]] then\n            return\
    \ true\n        end\n        t[l[i]] = true\n    end\n    return false\nend",
  "    return false\nend", "\tfor i, v in ipairs(l) do\n\t\tfor j, w in ipairs(l)\
    \ do\n\t\t\tif i ~= j and v + w == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn false\nend", "    local found = {}\n    for i, e in ipairs(l)\
    \ do\n        if found[-e] then\n            return true\n        end\n      \
    \  found[e] = true\n    end\n    return false\nend", "\tfor i = 1, #l do\n\t\t\
    for j = i + 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn false\nend", "    local mark = {}\n    for _,\
    \ elem in ipairs(l) do\n        if mark[-elem] then\n            return true\n\
    \        end\n        mark[elem] = true\n    end\n    return false\nend", "  local\
    \ result = false\n  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i]\
    \ + l[j] == 0 then\n        result = true\n      end\n    end\n  end\n  return\
    \ result\nend", "    -- your code here\n    return nil\nend", "  for i = 1, #l\
    \ - 1 do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  -- In case you are\
    \ interested, in the [submission period](https://pravit.github.io/class/itp125-fall-2018/submission-period.html)\n\
    \  -- I will be collecting your solutions to this problem.\n  -- I will run the\
    \ following command to test your solution:\n  -- lua -lluassert test.lua\n  --\
    \ This command should finish with the message:\n  -- OK  All tests passed!\n \
    \ -- It's possible that it will also return a message saying that something failed.\n\
    \  -- If you get such a message, then there is a problem with your solution.\n\
    \  -- For example, if your solution doesn't return true when it should, then you\
    \ will get a message saying something failed.\n  -- It's important that you fix\
    \ any failures before the submission period, or else you will not be able to submit\
    \ your solution.\n  return false\nend", "\tlocal visited = {}\n\tfor i,x in ipairs(l)\
    \ do\n\t\tif (visited[-x]) then\n\t\t\treturn true\n\t\tend\n\t\tvisited[x] =\
    \ true\n\tend\n\treturn false\nend", "  -- YOUR CODE HERE\n  --[[\n  check to\
    \ see if l has at least two numbers\n  start with first number, look at every\
    \ other number\n  if first number + any other number == 0, then return true\n\
    \  if no match found, move on to next number and repeat process\n  if no match\
    \ at all, return false\n  --]]\n  local size = #l\n  if size < 2 then\n    return\
    \ false\n  end\n  local copy = deepcopy(l)\n  while #copy > 0 do\n    local first\
    \ = table.remove(copy, 1)\n    for i = 1, #copy do\n      if first + copy[i] ==\
    \ 0 then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  for _, e1 in ipairs(l) do\n    for _, e2 in ipairs(l) do\n      if e1 ~= e2 and\
    \ e1 + e2 == 0 then\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "  -- TODO: implement\nend", "  -- your code here\n  for k,v in\
    \ pairs(l) do\n    for m,n in pairs(l) do\n      if k~=m and (v+n)==0 then\n \
    \       return true\n      end\n    end\n  end\n  return false\nend", "\tlocal\
    \ hasZero, hasPositive, hasNegative = false, false, false\n\tfor i, v in ipairs(l)\
    \ do\n\t\tif v == 0 then\n\t\t\thasZero = true\n\t\telseif v > 0 then\n\t\t\t\
    hasPositive = true\n\t\telse\n\t\t\thasNegative = true\n\t\tend\n\tend\n\treturn\
    \ (hasZero and (hasPositive or hasNegative)) or (hasPositive and hasNegative)\n\
    end", "\t-- TODO", "    for i,v in ipairs(l) do\n        for j = i + 1, #l do\n\
    \            if v + l[j] == 0 then\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "    -- TODO\n    local neg = {}\n\
    \    local pos = {}\n    for k, v in pairs(l) do\n        if v > 0 then\n    \
    \        pos[v] = k\n        else\n            neg[v] = k\n        end\n    end\n\
    \    for k, v in pairs(pos) do\n        if neg[-k] then\n            return true\n\
    \        end\n    end\n    return false\nend", "  for i = 1, #l do\n    for j\
    \ = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "\tlocal hasZero = false\n\tlocal zeroIdx\
    \ = -1\n\tlocal hasPositive = false\n\tlocal hasNegative = false\n\tlocal set\
    \ = {}\n\t\n\tfor i, v in ipairs(l) do\n\t\tif v == 0 then\n\t\t\thasZero = true\n\
    \t\t\tzeroIdx = i\n\t\telseif v > 0 then\n\t\t\thasPositive = true\n\t\telse\n\
    \t\t\thasNegative = true\n\t\tend\n\t\t\n\t\tset[v] = i\n\tend\n\t\n\tif hasZero\
    \ and (hasPositive or hasNegative) then\n\t\treturn true\n\tend\n\t\n\tfor i,\
    \ v in ipairs(l) do\n\t\tif i ~= zeroIdx and set[-v] ~= nil then\n\t\t\treturn\
    \ true\n\t\tend\n\tend\n\t\n\treturn false\nend", "  for i = 1, #l do\n    for\
    \ j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n    \
    \  end\n    end\n  end\n  return false\nend", "  -- initialize a table to keep\
    \ track of the numbers we've seen so far\n  local t = {}\n  -- loop through the\
    \ list\n  for i = 1, #l do\n    -- get the number we're looking at\n    local\
    \ n = l[i]\n    -- check if the table has an entry for -n, if so, return true\n\
    \    if t[-n] then\n      return true\n    end\n    -- put n in the table\n  \
    \  t[n] = true\n  end\n  -- return false\n  return false\nend", "  local v = false\n\
    \  local x\n  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i] + l[j]\
    \ == 0 then\n        v = true\n      end\n    end\n  end\n  return v\nend", " \
    \ -- your code here\n  -- hard part: make sure to check all possible pairs\n \
    \ -- hint: I recommend doing this part bottom-up\n  -- i.e. get all the pairs,\
    \ then check if there are any that sum to zero\n  -- in order to do the former,\
    \ you can use a set, the \"+\" operator, and list.unpack\n  -- you can check if\
    \ a value is in a set using \"in\"\n  -- hint 2: set() will not work with tables,\
    \ you can use {}, though.\n  -- hint 3: you can also use table.concat() and table.sort()\
    \ to make your code a lot simpler\n  -- hint 4: please do not use global variables\
    \ in this solution\n  -- hint 5: side note, this problem is known as the 3SUM\
    \ problem, and is known to be NP-Hard\n  -- you can google for more info about\
    \ this, if you're interested.\n  -- hint 6: the solution with table.concat() and\
    \ table.sort() can be done in around 5 lines of code.\n  -- hint 7: hint 6 is\
    \ a lie.\n  -- hint 8: hint 7 is also a lie.\nend", "  local map = {}\n  for i,\
    \ v in ipairs(l) do\n    if map[v] then\n      return true\n    end\n    map[v\
    \ * -1] = true\n  end\n  return false\nend", "\tlocal set = {}\n\tfor i = 1, #l\
    \ do\n\t\tlocal num = l[i]\n\t\tif set[-num] then\n\t\t\treturn true\n\t\tend\n\
    \t\tset[num] = true\n\tend\n\treturn false\nend", "  for _, x in ipairs(l) do\n\
    \    for _, y in ipairs(l) do\n      if x + y == 0 and x ~= y then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "    -- TODO (Part 2)\n\
    \    -- [Coding Style - Documentation] Please follow lua's style of docstring\n\
    \    -- which starts with \"--[=[ ... ]=]\", instead of \"-- >>> ....\".\n   \
    \ -- You can find the style guide at:\n    --     https://www.lua.org/gems/sample.pdf\n\
    \    --     Note that the style guide was written for Lua 5.1.\n    --     The\
    \ style hasn't changed significantly in later versions.\n    -- [Correctness]\
    \ If there are two items with equal value, the function\n    -- return false.\
    \ This is incorrect.\n    -- [Coding Style - lua-users] You can use lua-users.org\
    \ as a reference.\n    --     http://lua-users.org/wiki/\n    --     http://lua-users.org/wiki/TablesTutorial\n\
    \    --     http://lua-users.org/wiki/LuaStyleGuide\n    --     http://lua-users.org/wiki/CodingConventions\n\
    \    for i, n in ipairs(l) do\n        for j, m in ipairs(l) do\n            if\
    \ n == -m and i ~= j then\n                return true\n            end\n    \
    \    end\n    end\n    return false\nend", "\tlocal a, b = 0, 0\n\tlocal len =\
    \ #l\n\tfor i = 1, len do\n\t\ta = l[i]\n\t\tfor j = i + 1, len do\n\t\t\tb =\
    \ l[j]\n\t\t\tif a + b == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn false\nend", "  -- BEGIN\n  for i = 1, #l - 1 do\n    for j = i\
    \ + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n\
    \    end\n  end\n  return false\n  -- END\nend", "  -- if the table has more than\
    \ one element\n  if #l > 1 then\n    -- create a set of the table's elements\n\
    \    local set = {}\n    for _, n in ipairs(l) do\n      set[n] = true\n    end\n\
    \    -- check each element to see if it has a negative counterpart\n    for _,\
    \ n in ipairs(l) do\n      if set[-n] then\n        return true\n      end\n \
    \   end\n  end\n  return false\nend", "    local positive = {}\n    local negative\
    \ = {}\n    for _, v in ipairs(l) do\n        if v > 0 then\n            positive[v]\
    \ = true\n        elseif v < 0 then\n            negative[-v] = true\n       \
    \ else\n            return true\n        end\n    end\n    for _, v in ipairs(l)\
    \ do\n        if v > 0 and negative[v] then\n            return true\n       \
    \ end\n    end\n    return false\nend", "    -- sort the list\n    sort(l)\n \
    \   -- loop\n    local left, right = 1, #l\n    while left < right do\n      \
    \  local sum = l[left] + l[right]\n        if sum == 0 then\n            return\
    \ true\n        elseif sum < 0 then\n            left = left + 1\n        else\n\
    \            right = right - 1\n        end\n    end\n    return false\nend",
  "  local t = {}\n  for i = 1, #l do\n    t[l[i]] = true\n  end\n  for i = 1, #l\
    \ do\n    if t[-l[i]] then\n      return true\n    end\n  end\n  return false\n\
    end", "  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "   local h = {}\n   for _, v in ipairs(l) do\n      if h[-v] then\n         return\
    \ true\n      end\n      h[v] = true\n   end\n   return false\nend", "    -- TODO:\
    \ Implement this function.\n    for i = 1, #l do\n        for j = i + 1, #l do\n\
    \            if l[i] + l[j] == 0 then\n                return true\n         \
    \   end\n        end\n    end\n    return false\nend", "  -- YOUR CODE HERE\n\
    end", "    return true\nend", "\treturn true\nend", "\tfor i, v in ipairs(l) do\n\
    \t\tfor j, w in ipairs(l) do\n\t\t\tif i ~= j and v + w == 0 then\n\t\t\t\treturn\
    \ true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "   local input = {}\n\
    \   for i, k in ipairs(l) do\n      input[i] = k\n   end\n   local function sum(a,\
    \ b)\n      if a < b then\n         return false\n      elseif a == b then\n \
    \        return true\n      else\n         return sum(a - b, b)\n      end\n \
    \  end\n   for i, v in ipairs(input) do\n      if sum(0 - v, input[i]) then\n\
    \         return true\n      end\n   end\n   return false\nend", "    for i =\
    \ 1, #l - 1 do\n        for j = i + 1, #l do\n            if l[i] + l[j] == 0\
    \ then\n                return true\n            end\n        end\n    end\n \
    \   return false\nend", "\t-- ------------------------------------------------------------\n\
    \t-- TODO: Implement this function\n\t-- ------------------------------------------------------------\n\
    end", "  local m = {}\n  for _, i in ipairs(l) do\n    if i == 0 then\n      if\
    \ m[0] then\n        return true\n      else\n        m[0] = true\n      end\n\
    \    elseif m[-i] then\n      return true\n    else\n      m[i] = true\n    end\n\
    \  end\n  return false\nend", "    local seen = {}\n    for _, x in ipairs(l)\
    \ do\n        if seen[-x] then\n            return true\n        end\n       \
    \ seen[x] = true\n    end\n    return false\nend", "  for i, v in ipairs(l) do\n\
    \    for j, w in ipairs(l) do\n      if (i ~= j) and (v + w == 0) then\n     \
    \   return true\n      end\n    end\n  end\n  return false\nend", "    local set\
    \ = {};\n    for _, v in ipairs(l) do\n        if set[v] then\n            return\
    \ true;\n        end\n        set[-v] = true;\n    end\n    return false;\nend",
  "  local map = {}\n  for _, v in ipairs(l) do\n    if map[v] then\n      return\
    \ true\n    end\n    map[-v] = true\n  end\n  return false\nend", "  for i = 1,\
    \ #l do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "   -- your implementation\
    \ goes here.\n   -- you may use the fact that the list is sorted in your implementation.\n\
    \   for i=1,#l do\n      for j=i+1,#l do\n         if l[i]+l[j]==0 then\n    \
    \        return true\n         end\n      end\n   end\n   return false\nend",
  "  for _,x in ipairs(l) do\n    for _,y in ipairs(l) do\n      if x + y == 0 and\
    \ x ~= y then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "    return false -- replace me with a proper implementation\nend", "  \
    \ -- Initialize a table\n   local t = {}\n   -- Loop through all the numbers and\
    \ add them to the table\n   for i = 1, #l do\n      if not t[l[i]] then\n    \
    \     t[l[i]] = 1\n      else\n         t[l[i]] = t[l[i]] + 1\n      end\n   end\n\
    \   -- Loop through all the numbers again\n   for i = 1, #l do\n      -- Check\
    \ if the number is zero, or if the table has a -l[i]\n      if l[i] == 0 and t[l[i]]\
    \ > 1 or t[-l[i]] then\n         return true\n      end\n   end\n   return false\n\
    end", "    local hash = {}\n    for _, v in ipairs(l) do\n        if hash[-v]\
    \ then\n            return true\n        end\n        hash[v] = true\n    end\n\
    \    return false\nend", "    local has_zero = false\n    local non_neg = {}\n\
    \    local neg = {}\n    local zero = 0\n    for i, v in ipairs(l) do\n      \
    \  if v == 0 then\n            has_zero = true\n        elseif v > 0 then\n  \
    \          non_neg[v] = i\n        else\n            neg[-v] = i\n        end\n\
    \    end\n    for v, i in pairs(non_neg) do\n        if neg[v] ~= nil then\n \
    \           return true\n        end\n    end\n    return has_zero\nend", "\t\
    local n = 0\n\tfor i = 1, #l do\n\t\tfor j = i + 1, #l do\n\t\t\tif l[i] + l[j]\
    \ == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\n\
    end", "  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  local seen = {}\n  for _,v in ipairs(l) do\n    if seen[-v] then\n      return\
    \ true\n    end\n    seen[v] = true\n  end\n  return false\nend", "    return\
    \ false\nend", "   -- TODO: implement this function\nend", "    for i, v in ipairs(l)\
    \ do\n        for j, w in ipairs(l) do\n            if v + w == 0 and i ~= j then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "\tfor _,v in ipairs(l) do\n\t\tif v == 0 then\n\t\t\tfor _,w in\
    \ ipairs(l) do\n\t\t\t\tif w == 0 and v ~= w then\n\t\t\t\t\treturn true\n\t\t\
    \t\tend\n\t\t\tend\n\t\tend\n\tend\n\tfor _,v in ipairs(l) do\n\t\tfor _,w in\
    \ ipairs(l) do\n\t\t\tif v ~= w and v + w == 0 then\n\t\t\t\treturn true\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn false\nend", "    for i = 1, #l do\n        for\
    \ j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n                return\
    \ true\n            end\n        end\n    end\n    return false\nend", "    return\
    \ not not get_pairs_sum_to_zero(l)\nend", "    for i, x in ipairs(l) do\n    \
    \    for j, y in ipairs(l) do\n            if (x ~= y) and (x + y == 0) then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "    local n = #l\n    for i=1,n-1 do\n        for j=i+1,n do\n\
    \            if l[i] + l[j] == 0 then\n                return true\n         \
    \   end\n        end\n    end\n    return false\nend", "    local count = {}\n\
    \    for _, v in ipairs(l) do\n        count[v] = (count[v] or 0) + 1\n    end\n\
    \    for _, v in ipairs(l) do\n        if (count[-v] or 0) > 0 then\n        \
    \    if not (v == 0 and count[v] > 1) then\n                return true\n    \
    \        end\n        end\n    end\n    return false\nend", "  return nil\nend",
  "    for i = 1, #l do\n        for j = i + 1, #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "  -- your code here\nend", "   local seen = {}\n   for\
    \ i = 1, #l do\n      if seen[-l[i]] ~= nil then\n         return true\n     \
    \ end\n      seen[l[i]] = true\n   end\n   return false\nend", "    --[[\n   \
    \ Implementation:\n    First, get all the sums between the numbers and check if\
    \ any are 0\n    Then, loop through the array to see if there are two numbers\
    \ that sum to zero\n    Time Complexity: O(n^2)\n    Space Complexity: O(n)\n\
    \    ]]\n    -- Check if numbers in the list sum to zero\n    for i = 1, #l -\
    \ 1 do\n        for j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n \
    \               return true\n            end\n        end\n    end\n    return\
    \ false\nend", "    local results = {}\n    for i = 1, #l do\n        for j =\
    \ i + 1, #l do\n            if l[i] + l[j] == 0 then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "   local hash_table\
    \ = {}\n   for i, val in ipairs(l) do\n      hash_table[val] = i\n   end\n   for\
    \ i, val in ipairs(l) do\n      if (hash_table[-val] ~= nil) and (hash_table[-val]\
    \ ~= i) then\n         return true\n      end\n   end\n   return false\nend",
  "  -- YOUR CODE HERE\n  return false\nend", "  for i, e in ipairs(l) do\n    for\
    \ j, f in ipairs(l) do\n      if i ~= j and e + f == 0 then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "\tfor i = 1, #l - 1 do\n\t\t\
    for j = i + 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn false\nend", "    local set = {}\n    for i =\
    \ 1, #l do\n        local v = l[i]\n        if set[-v] then\n            return\
    \ true\n        end\n        set[v] = true\n    end\n    return false\nend", " \
    \   -- the set of integers\n    local ints = {};\n    -- iterate over the table\n\
    \    for i, v in ipairs(l) do\n        -- if the integer is already in the set\n\
    \        if ints[v] ~= nil then\n            -- return true\n            return\
    \ true;\n        end\n        -- if the integer is not already in the set\n  \
    \      -- but -v is in the set\n        if ints[-v] ~= nil then\n            --\
    \ return true\n            return true;\n        end\n        -- if neither the\
    \ integer nor -v is in the set\n        -- insert v\n        ints[v] = v;\n  \
    \  end\n    -- the set of integers is empty\n    -- return false\n    return false;\n\
    end", "    return false\nend", "\tlocal \n\tfor k, v in pairs(l) do\n\t\tif v\
    \ == 0 then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "  local\
    \ h = {}\n  for i, v in ipairs(l) do\n    if h[v] then\n      return true\n  \
    \  end\n    h[-v] = true\n  end\n  return false\nend", "  -- YOUR CODE HERE\n\
    \  local len = #l\n  for i = 1, len - 1 do\n    for j = i + 1, len do\n      if\
    \ l[i] + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "\tlocal has_negative = {}\n\tfor _, n in ipairs(l) do\n\t\tif\
    \ n < 0 then\n\t\t\thas_negative[-n] = true\n\t\tend\n\tend\n\tfor _, n in ipairs(l)\
    \ do\n\t\tif has_negative[n] then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn\
    \ false\nend", "  -- if the size of the list is less than two, there cannot be\
    \ a pair that sums to zero.\n  if #l < 2 then\n    return false\n  end\n  -- create\
    \ a set that holds the remaining numbers.\n  local remaining = Set()\n  -- iterate\
    \ through each number in the list.\n  for i = 1, #l do\n    -- if the list at\
    \ the current index is zero, return true.\n    if l[i] == 0 then\n      return\
    \ true\n    end\n    -- otherwise, add the number to the set.\n    remaining:add(l[i])\n\
    \  end\n  -- iterate through each number in the list.\n  for i = 1, #l do\n  \
    \  -- if the other number in the pair that sums to zero is in the set,\n    --\
    \ return true.\n    if remaining:contains(-l[i]) then\n      return true\n   \
    \ end\n  end\n  -- return false otherwise.\n  return false\nend", "\tlocal t =\
    \ {}\n\tfor i,v in ipairs(l) do\n\t\tif t[v] then\n\t\t\treturn true\n\t\tend\n\
    \t\tt[-v] = true\n\tend\n\treturn false\nend", "\tif #l == 1 then\n\t\treturn\
    \ false\n\tend\n\tfor i = 1, #l - 1 do\n\t\tfor j = i + 1, #l do\n\t\t\tif l[i]\
    \ + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\n\
    end", "  for i, v in ipairs(l) do\n    for j, w in ipairs(l) do\n      if i ~=\
    \ j and v + w == 0 then\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "\t-- Implement a solution here\nend", "\treturn false\nend", " \
    \   local t = {}\n    for _, v in ipairs(l) do\n        if t[-v] then\n      \
    \      return true\n        end\n        t[v] = true\n    end\n    return false\n\
    end", "    local keys = {}\n    for i, _ in pairs(l) do\n        if keys[-i] then\n\
    \            return true\n        end\n        keys[i] = true\n    end\n    return\
    \ false\nend", "  -- TODO: implement this function\nend", "  -- check that input\
    \ is valid\n  if type(l) ~= \"table\" then\n    return false\n  end\n  local negative\
    \ = {}\n  local positive = {}\n  -- populate two lists, one with all positive\
    \ numbers, the other with all negative\n  for _, v in ipairs(l) do\n    if v <\
    \ 0 then\n      table.insert(negative, v)\n    elseif v > 0 then\n      table.insert(positive,\
    \ v)\n    end\n  end\n  -- check that the lists are not empty\n  if #negative\
    \ < 1 or #positive < 1 then\n    return false\n  end\n  -- brute force the search\n\
    \  for _, v in ipairs(negative) do\n    for _, v1 in ipairs(positive) do\n   \
    \   if v + v1 == 0 then\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i] +\
    \ l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "    -- TODO: Your code here!\nend", "  local visited = {}\n  for _,val\
    \ in ipairs(l) do\n    if visited[-val] then\n      return true\n    end\n   \
    \ visited[val] = true\n  end\n  return false\nend", "  for i = 1, #l - 1 do\n\
    \    for j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  for i = 1, #l - 1 do\n  \
    \  for j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "    local numbers = {}\n  \
    \  for _, n in ipairs(l) do\n        if numbers[-n] then\n            return true\n\
    \        end\n        numbers[n] = true\n    end\n    return false\nend", "  \
    \  for i = 1, #l do\n        for j = i + 1, #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "    --YOUR CODE HERE\nend", "\tlocal flag = false\n\t\
    for i = 1, #l do\n\t\tfor j = i+1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\
    \t\tflag = true\n\t\t\tend\n\t\tend\n\tend\n\treturn flag\nend", "    -- your\
    \ code here\n    return false\nend", "\t-- your solution goes here\nend", "  \
    \  for i = 1, #l do\n        for j = i + 1, #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "    local zeros = {}\n    for k,v in pairs(l) do\n \
    \       if zeros[v] ~= nil then\n            return true\n        end\n      \
    \  zeros[-v] = 1\n    end\n    return false\nend", "\tfor i = 1, #l - 1 do\n\t\
    \tfor j = i + 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\
    \t\tend\n\t\tend\n\tend\n\treturn false\nend", "    -- FILL IN CODE HERE\n\tlocal\
    \ count = 0\n\tlocal list = {}\n\tfor _, v in ipairs(l) do\n\t\tfor k, _ in ipairs(l)\
    \ do\n\t\t\tif v + l[k] == 0 then\n\t\t\t\tcount = count + 1\n\t\t\t\ttable.insert(list,\
    \ k)\n\t\t\tend\n\t\tend\n\tend\n\tfor i = 1, #list do\n\t\tif i == 1 then\n\t\
    \t\tif list[i] == list[i+1] then\n\t\t\t\treturn false\n\t\t\tend\n\t\telseif\
    \ i == #list then\n\t\t\tif list[i] == list[i-1] then\n\t\t\t\treturn false\n\t\
    \t\tend\n\t\telse\n\t\t\tif list[i] == list[i+1] or list[i] == list[i-1] then\n\
    \t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\tif count > 0 then\n\t\treturn\
    \ true\n\telse\n\t\treturn false\n\tend\nend", "    local numbers = {}\n    for\
    \ i = 1, #l do\n        local num = l[i]\n        if numbers[num] == nil then\n\
    \            numbers[num] = 1\n        else\n            numbers[num] = numbers[num]\
    \ + 1\n        end\n    end\n    for i = 1, #l do\n        local num = l[i]\n\
    \        if num == 0 and numbers[num] > 1 then\n            return true\n    \
    \    elseif num ~= 0 and numbers[-num] ~= nil then\n            return true\n\
    \        end\n    end\n    return false\nend", "    for _, x in ipairs(l) do\n\
    \        for _, y in ipairs(l) do\n            if x ~= y and x + y == 0 then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "    for i = 1, #l do\n        for j = i + 1, #l do\n         \
    \   if l[i] + l[j] == 0 then\n                return true\n            end\n \
    \       end\n    end\n    return false\nend", "    --make a table that stores\
    \ all numbers from the list. we then will count numbers of them. \n    local num_of_num\
    \ = {}\n    for i = 1, #l do\n        local num = l[i]\n        if num_of_num[num]\
    \ == nil then\n            num_of_num[num] = 1\n        else\n            num_of_num[num]\
    \ = num_of_num[num] + 1\n        end\n    end\n    -- if there is a number with\
    \ same number but negative (which means the sum of them is 0), then we return\
    \ true.\n    for i = 1, #l do\n        local num = l[i]\n        if num == 0 and\
    \ num_of_num[num] > 1 then\n            return true\n        elseif num_of_num[num\
    \ * -1] ~= nil then\n            return true\n        end\n    end\n    return\
    \ false\nend", "    -- check input size\n    if #l < 2 then\n        return false\n\
    \    end", "  local map = {}\n  for i, n in ipairs(l) do\n    if map[-n] then\n\
    \      return true\n    end\n    map[n] = true\n  end\n  return false\nend", " \
    \   -- your code here\n    local set = {}\n    for _,n in ipairs(l) do\n     \
    \   set[n] = true\n    end\n    for _,n in ipairs(l) do\n        if set[-n] then\n\
    \            return true\n        end\n    end\n    return false\nend", "    local\
    \ t = {}\n    for _, v in ipairs(l) do\n        t[v] = true\n    end\n    for\
    \ _, v in ipairs(l) do\n        if v ~= 0 and t[-v] then\n            return true\n\
    \        end\n    end\n    return false\nend", "    return true\nend", "    local\
    \ function find_pair(l, sum)\n        local i = 1\n        local j = #l\n    \
    \    while i < j do\n            if l[i] + l[j] == sum then\n                return\
    \ true\n            elseif l[i] + l[j] < sum then\n                i = i + 1\n\
    \            else\n                j = j - 1\n            end\n        end\n \
    \       return false\n    end", "  -- YOUR CODE HERE\n  local n = table.getn(l)\n\
    \  if n <= 1 then\n    return false\n  end\n  local l1 = {}\n  for i = 1, n do\n\
    \    l1[i] = 0 - l[i]\n  end\n  for i = 1, n do\n    for j = 1, n do\n      if\
    \ l[i] == l1[j] and i ~= j then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  for i = 1, #l do\n    for j = i + 1, #l do\n      if\
    \ l[i] + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "    for i, x in ipairs(l) do\n        for j, y in ipairs(l) do\n\
    \            if (i ~= j) and (x + y == 0) then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "\tlocal found\
    \ = false\n\tfor k, _ in pairs(l) do\n\t\tif found then break end\n\t\tfor j,\
    \ _ in pairs(l) do\n\t\t\tif j ~= k and j > k then\n\t\t\t\tif l[k] + l[j] ==\
    \ 0 then\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn found\nend", "  return false\nend", "    return false\nend",
  "    -- Code here\nend", "    -- put your code here\n    -- you can use print to\
    \ debug\nend", "  -- lua's built in sort requires a function to be passed as an\n\
    \  -- argument that knows how to compare two elements.\n  -- See: http://lua-users.org/wiki/SortedIteration\n\
    \  table.sort(l, function(a, b) return a < b end)\n  for i = 1, #l do\n    local\
    \ n = l[i]\n    for j = i + 1, #l do\n      local m = l[j]\n      if n + m ==\
    \ 0 then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  -- your code here\nend", "    local dict = {}\n    for i,v in ipairs(l) do\n\
    \        if dict[v] then\n            return true\n        end\n        dict[-v]\
    \ = true\n    end\n    return false\nend", "    for k, v in pairs(l) do\n    \
    \    for k2, v2 in pairs(l) do\n            if k ~= k2 and v + v2 == 0 then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "   local function help(l, seen)\n      if l[1] == nil then\n \
    \        return false\n      elseif seen[(0 - l[1])] then\n         return true\n\
    \      else\n         seen[l[1]] = true\n         return help(tail(l), seen)\n\
    \      end\n   end\n   return help(l, {})\nend", "    local seen = {}\n    for\
    \ i = 1, #l do\n        local x = l[i]\n        if seen[-x] then\n           \
    \ return true\n        end\n        seen[x] = true\n    end\n    return false\n\
    end", "  local m = {}\n  for i, v in ipairs(l) do\n    local diff = -v\n    if\
    \ m[diff] then\n      return true\n    end\n    m[v] = true\n  end\n  return false\n\
    end", "  return true\nend", "\tfor i = 1, #l do\n\t\tfor j = i + 1, #l do\n\t\t\
    \tif l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    return false\nend", "  return false\nend", "\tlocal sum = {};\n\tfor key, value\
    \ in pairs(l) do\n\t\tfor key2, value2 in pairs(l) do\n\t\t\tsum[value + value2]\
    \ = true;\n\t\tend\n\tend\n\tfor key, value in pairs(sum) do\n\t\tif (key == 0)\
    \ then\n\t\t\treturn true;\n\t\tend\n\tend\n\treturn false;\nend", "  return false\n\
    end", "    for i, v in ipairs(l) do\n        for _, x in ipairs(l) do\n      \
    \      if i ~= _ and v + x == 0 then\n                return true\n          \
    \  end\n        end\n    end\n    return false\nend", "    local used = {}\n \
    \   for _, x in ipairs(l) do\n        if x == 0 then\n            return true\n\
    \        end\n        if used[-x] then\n            return true\n        end\n\
    \        used[x] = true\n    end\n    return false\nend", "    return false\n\
    end", "    -- For each pair of elements in the list,\n    -- check if their sum\
    \ is zero.\n    for i = 1, #l - 1 do\n        for j = i + 1, #l do\n         \
    \   if l[i] + l[j] == 0 then\n                return true\n            end\n \
    \       end\n    end\n    return false\nend", "  -- compute number of elements\
    \ in the table\n  local n = 0\n  for _ in pairs(l) do\n    n = n + 1\n  end\n\
    \  -- sort the table\n  table.sort(l)\n  -- loop over the table\n  local i = 1\n\
    \  local j = n\n  while i < j do\n    if l[i] + l[j] == 0 then\n      return true\n\
    \    elseif l[i] + l[j] < 0 then\n      i = i + 1\n    else\n      j = j - 1\n\
    \    end\n  end\n  return false\nend", "  local n = 0\n  local m = 0\n  for i,\
    \ v in ipairs(l) do\n    n = v\n    for j, w in ipairs(l) do\n      m = w\n  \
    \    if n + m == 0 then\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "  l = unique(l)\n  l = sorted(l)\n  local left = 1\n  local right\
    \ = #l\n  while left < right do\n    local sum = l[left] + l[right]\n    if sum\
    \ == 0 then\n      return true\n    elseif sum < 0 then\n      left = left + 1\n\
    \    else\n      right = right - 1\n    end\n  end\n  return false\nend", "  \
    \ local seen = {}\n   for _,n in ipairs(l) do\n      seen[n] = true\n   end\n\
    \   for _,n in ipairs(l) do\n      if seen[-n] then\n         return true\n  \
    \    end\n   end\n   return false\nend", "    -- STUDENT CODE BEGINS\n    -- loop\
    \ through each value\n    for _,v in ipairs(l) do\n        --loop through each\
    \ value\n        for _,b in ipairs(l) do\n            --check if the value of\
    \ the first loop is equal to the second loop and if their sum is equal to zero\n\
    \            if v == b and v + b == 0 then\n                return true\n    \
    \        end\n        end\n    end\n    return false\n    -- STUDENT CODE ENDS\n\
    end", "  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  -- YOUR CODE GOES HERE.\n  -- 1: check if list is empty.\n  if table.getn(l)\
    \ == 0 then return false end\n  -- 2: build a hash\n  local hashtable = {}\n \
    \ for key, val in pairs(l) do\n    if hashtable[val] == nil then\n      hashtable[val]\
    \ = 1\n    else\n      hashtable[val] = hashtable[val] + 1\n    end\n  end\n \
    \ -- 3: check the hash for existence of zero and non-zero pairs\n  for key, val\
    \ in pairs(hashtable) do\n    if val >= 2 then\n      return true\n    end\n \
    \   if hashtable[-key] ~= nil then\n      return true\n    end\n  end\n  return\
    \ false\nend", "\treturn false\nend", "    return true\nend", "  for i = 1, #l\
    \ do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "\tlocal hash = {}\n\t\
    for _,v in ipairs(l) do\n\t\tif hash[v] then\n\t\t\treturn true\n\t\telse\n\t\t\
    \thash[-v] = true\n\t\tend\n\tend\n\treturn false\nend", "    -- first, we sort\
    \ the table to make searching easier\n    local sorted = sort(l)\n    -- i acts\
    \ as a pointer to the first element of each pair\n    -- j acts as a pointer to\
    \ the second element of each pair\n    -- we start with i at the beginning of\
    \ the table and j at the end\n    -- as we move i up and j down, we check if they\
    \ sum to zero\n    -- if they do, we return true, otherwise we keep moving them\n\
    \    -- until we've checked all possible pairs.\n    local i = 1\n    local j\
    \ = #sorted\n    while i < j do\n        if sorted[i] + sorted[j] == 0 then\n\
    \            return true\n        elseif sorted[i] + sorted[j] < 0 then\n    \
    \        i = i + 1\n        elseif sorted[i] + sorted[j] > 0 then\n          \
    \  j = j - 1\n        end\n    end\n    return false\nend", "    for _,v in ipairs(l)\
    \ do\n        for _,v2 in ipairs(l) do\n            if v ~= v2 and v + v2 == 0\
    \ then\n                return true\n            end\n        end\n    end\n \
    \   return false\nend", "  -- TODO: your code here\nend", "    local found = {}\n\
    \    for _, v in ipairs(l) do\n        if found[-v] then\n            return true\n\
    \        end\n        found[v] = true\n    end\n    return false\nend", "    for\
    \ k, v in pairs(l) do\n        if l[-v] then\n            return true\n      \
    \  end\n    end\n    return false\nend", "    local remain = {}\n    for _, v\
    \ in ipairs(l) do\n        if remain[-v] then\n            return true\n     \
    \   end\n        remain[v] = true\n    end\n    return false\nend", "  for i =\
    \ 1, #l do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n       \
    \ return true\n      end\n    end\n  end\n  return false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
