name: HumanEval_5_intersperse
language: lua
prompt: "-- Insert a number 'delimeter' between every two consecutive elements of\
  \ input table `numbers'\n-- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1,\
  \ 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersperse\n\
  \    lu.assertEquals(candidate({}, 7), {})\n    lu.assertEquals(candidate({5, 6,\
  \ 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})\n    lu.assertEquals(candidate({2, 2, 2}, 2),\
  \ {2, 2, 2, 2, 2})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if not is_table(numbers) then\n        return numbers\n    end\n\
    \    local result = {}\n    local count = #numbers\n    if count < 2 then\n  \
    \      return numbers\n    end\n    for i = 1, count do\n        if i > 1 then\n\
    \            result[#result + 1] = delimeter\n        end\n        result[#result\
    \ + 1] = numbers[i]\n    end\n    return result\nend", "    local result = {}\n\
    \    local size = #numbers\n    if size == 0 then\n        return result\n   \
    \ end\n    result[1] = numbers[1]\n    for i = 2, size do\n        table.insert(result,\
    \ delimeter)\n        table.insert(result, numbers[i])\n    end\n    return result\n\
    end", "    if #numbers == 0 then\n        return {}\n    end\n    if #numbers\
    \ == 1 then\n        return numbers\n    end\n    local l = {}\n    for i = 1,\
    \ #numbers - 1 do\n        l[2 * i - 1] = numbers[i]\n        l[2 * i] = delimeter\n\
    \    end\n    l[#l] = numbers[#numbers]\n    return l\nend", "\tlocal result =\
    \ {}\n\tfor i = 1, #numbers do\n\t\tresult[#result + 1] = numbers[i]\n\t\tif i\
    \ < #numbers then\n\t\t\tresult[#result + 1] = delimeter\n\t\tend\n\tend\n\treturn\
    \ result\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n     \
    \   result[#result + 1] = numbers[i]\n        result[#result + 1] = delimeter\n\
    \    end\n    result[#result + 1] = numbers[#numbers]\n    return result\nend",
  "    local result = {}\n    local n = #numbers\n    for i = 1, n - 1 do\n      \
    \  local number = numbers[i]\n        result[#result + 1] = number\n        result[#result\
    \ + 1] = delimeter\n    end\n    if n > 0 then\n        result[#result + 1] =\
    \ numbers[n]\n    end\n    return result\nend", "    local new_table = {}\n  \
    \  for i, number in ipairs(numbers) do\n        table.insert(new_table, number)\n\
    \        if i < #numbers then\n            table.insert(new_table, delimeter)\n\
    \        end\n    end\n    return new_table\nend", "  local result = {}\n  for\
    \ i, number in ipairs(numbers) do\n    result[#result + 1] = number\n    if i\
    \ < #numbers then\n      result[#result + 1] = delimeter\n    end\n  end\n  return\
    \ result\nend", "  local out = {}\n  local n = len(numbers)\n  if n > 0 then\n\
    \    out[1] = numbers[1]\n    for i = 2, n do\n      out[2 * i - 1] = delimeter\n\
    \      out[2 * i] = numbers[i]\n    end\n  end\n  return out\nend", "    local\
    \ out = {}\n    for i, num in ipairs(numbers) do\n        out[#out + 1] = num\n\
    \        if i ~= #numbers then\n            out[#out + 1] = delimeter\n      \
    \  end\n    end\n    return out\nend", "\tlocal result = {}\n\tlocal n = #numbers\n\
    \tfor i = 1, n - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result\
    \ + 1] = delimeter\n\tend\n\tresult[#result + 1] = numbers[n]\n\treturn result\n\
    end", "    return zip(numbers, interleave({}, numbers, delimeter))\nend", "  \
    \  assert_arg_tables({numbers})\n    assert_arg_number(delimeter)", "    local\
    \ result = {}\n    local length = #numbers\n    if length > 0 then\n        result[1]\
    \ = numbers[1]\n        for i = 2, length do\n            result[#result + 1]\
    \ = delimeter\n            result[#result + 1] = numbers[i]\n        end\n   \
    \ end\n    return result\nend", "    if #numbers == 0 then\n        return {}\n\
    \    end\n    local output = {}\n    for i = 1, #numbers - 1 do\n        output[#output\
    \ + 1] = numbers[i]\n        output[#output + 1] = delimeter\n    end\n    output[#output\
    \ + 1] = numbers[#numbers]\n    return output\nend", "  if #numbers <= 1 then\n\
    \    return numbers\n  end\n  local result = {}\n  for i, number in ipairs(numbers)\
    \ do\n    if i > 1 then\n      table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ number)\n  end\n  return result\nend", "\tlocal res = {}\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\tres[#res + 1] = numbers[i]\n\t\tres[#res + 1] = delimeter\n\tend\n\
    \tres[#res + 1] = numbers[#numbers]\n\treturn res\nend", "    local result = {}\n\
    \    for i, number in ipairs(numbers) do\n        if i ~= 1 then\n           \
    \ table.insert(result, delimeter)\n        end\n        table.insert(result, number)\n\
    \    end\n    return result\nend", "  if #numbers <= 1 then\n    return numbers\n\
    \  end\n  local interleaved = {}\n  for i = 1, #numbers - 1 do\n    local v =\
    \ numbers[i]\n    table.insert(interleaved, v)\n    table.insert(interleaved,\
    \ delimeter)\n  end\n  table.insert(interleaved, numbers[#numbers])\n  return\
    \ interleaved\nend", "\tassertPositiveInteger(delimeter)\n\treturn collect(function()\n\
    \t\tlocal first\n\t\tfor _, n in ipairs(numbers) do\n\t\t\tif first ~= nil then\n\
    \t\t\t\tyield(delimeter)\n\t\t\tend\n\t\t\tyield(n)\n\t\t\tfirst = n\n\t\tend\n\
    \tend)\nend", "    assert(is_a_list(numbers), \"intersperse: input must be a table\"\
    )\n    assert(#numbers >= 0, \"intersperse: input must be a list of numbers\"\
    )\n    assert(type(delimeter) == \"number\", \"intersperse: delimeter must be\
    \ a number\")", "    local ret = {}\n    local len = table.getn(numbers)\n   \
    \ if len == 0 then\n        return ret\n    end\n    ret[1] = numbers[1]\n   \
    \ for i = 2, len do\n        ret[(i - 1) * 2] = delimeter\n        ret[(i - 1)\
    \ * 2 + 1] = numbers[i]\n    end\n    return ret\nend", "\tassert(type(numbers)\
    \ == \"table\", \"numbers must be a table\")\n\tassert(delimeter ~= nil, \"delimeter\
    \ must not be nil\")\n\tlocal t = {}\n\tfor i, v in ipairs(numbers) do\n\t\ttable.insert(t,\
    \ v)\n\t\tif i < #numbers then\n\t\t\ttable.insert(t, delimeter)\n\t\tend\n\t\
    end\n\treturn t\nend", "  local new_numbers = {}\n  for i = 1, #numbers do\n \
    \   new_numbers[i * 2 - 1] = numbers[i]\n    new_numbers[i * 2] = delimeter\n\
    \  end\n  table.remove(new_numbers)\n  return new_numbers\nend", "    assertType(delimeter,\
    \ \"number\", \"delimeter\")\n    if not numbers or #numbers == 0 then\n     \
    \   return {}\n    end\n    local result = {numbers[1]}\n    for i = 2, #numbers\
    \ do\n        table.insert(result, delimeter)\n        table.insert(result, numbers[i])\n\
    \    end\n    return result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers\
    \ do\n\t\tresult[#result + 1] = numbers[i]\n\t\tif i < #numbers then\n\t\t\tresult[#result\
    \ + 1] = delimeter\n\t\tend\n\tend\n\treturn result\nend", "    if #numbers <=\
    \ 1 then\n        return numbers\n    end\n    local interspersed = {numbers[1]}\n\
    \    for i = 2, #numbers do\n        table.insert(interspersed, delimeter)\n \
    \       table.insert(interspersed, numbers[i])\n    end\n    return interspersed\n\
    end", "  assert_table(numbers)\n  assert_number(delimeter)\n  local res = {}\n\
    \  local i = 1\n  while i <= #numbers do\n    res[#res + 1] = numbers[i]\n   \
    \ i = i + 1\n    if i <= #numbers then\n      res[#res + 1] = delimeter\n    end\n\
    \  end\n  return res\nend", "    local count = #numbers\n    if count == 0 then\n\
    \        return {}\n    end\n    local indices = range(1, count * 2 - 1)\n   \
    \ local result = {}\n    for _, index in ipairs(indices) do\n        if index\
    \ % 2 == 1 then\n            result[index] = numbers[(index + 1) / 2]\n      \
    \  else\n            result[index] = delimeter\n        end\n    end\n    return\
    \ result\nend", "\tlocal result = {}\n\tlocal last = #numbers\n\tfor i = 1, last\
    \ do\n\t\tresult[#result + 1] = numbers[i]\n\t\tif i < last then\n\t\t\tresult[#result\
    \ + 1] = delimeter\n\t\tend\n\tend\n\treturn result\nend", "    local result =\
    \ {}\n    for i = 1, #numbers - 1 do\n        tinsert(result, numbers[i])\n  \
    \      tinsert(result, delimeter)\n    end\n    tinsert(result, numbers[#numbers])\n\
    \    return result\nend", "  if #numbers < 2 then\n    return numbers\n  end\n\
    \  local res = {numbers[1]}\n  for i = 2, #numbers do\n    table.insert(res, delimeter)\n\
    \    table.insert(res, numbers[i])\n  end\n  return res\nend", "    local res\
    \ = {}\n    local len = #numbers\n    for i = 1, len do\n        local num = numbers[i]\n\
    \        res[#res + 1] = num\n        if i < len then\n            res[#res +\
    \ 1] = delimeter\n        end\n    end\n    return res\nend", "  local result\
    \ = {}\n  local i = 1\n  while i <= #numbers do\n    result[#result + 1] = numbers[i]\n\
    \    if i < #numbers then\n      result[#result + 1] = delimeter\n    end\n  \
    \  i = i + 1\n  end\n  return result\nend", "    if #numbers == 0 then\n     \
    \   return {}\n    end\n    if #numbers == 1 then\n        return numbers\n  \
    \  end\n    local result = {}\n    for i, number in ipairs(numbers) do\n     \
    \   table.insert(result, number)\n        if i < #numbers then\n            table.insert(result,\
    \ delimeter)\n        end\n    end\n    return result\nend", "    local result\
    \ = {}\n    for i = 1, #numbers do\n        result[#result + 1] = numbers[i]\n\
    \        if i < #numbers then\n            result[#result + 1] = delimeter\n \
    \       end\n    end\n    return result\nend", "    assert_arg_count(intersperse,\
    \ numbers, 1)\n    local result = {}\n    for i,n in ipairs(numbers) do\n    \
    \    table.insert(result, n)\n        if i < #numbers then\n            table.insert(result,\
    \ delimeter)\n        end\n    end\n    return result\nend", "    local result\
    \ = {}\n    for index, number in ipairs(numbers) do\n        if index > 1 then\n\
    \            table.insert(result, delimeter)\n        end\n        table.insert(result,\
    \ number)\n    end\n    return result\nend", "  local result = {}\n  for i = 1,\
    \ #numbers - 1 do\n    result[#result + 1] = numbers[i]\n    result[#result +\
    \ 1] = delimeter\n  end\n  result[#result + 1] = numbers[#numbers]\n  return result\n\
    end", "  local result = {}\n  for i = 1, #numbers do\n    result[i * 2 - 1] =\
    \ numbers[i]\n    result[i * 2] = delimeter\n  end\n  result[#result] = nil\n\
    \  return result\nend", "  local result = {}\n  for i = 1, #numbers do\n    result[i\
    \ * 2 - 1] = numbers[i]\n    result[i * 2] = delimeter\n  end\n  result[#result]\
    \ = nil\n  return result\nend", "  assertType(numbers, 'table', 'number list')\n\
    \  assertType(delimeter, 'number', 'delimeter')\n  if #numbers == 0 then return\
    \ {} end\n  local res = {numbers[1]}\n  for i = 2, #numbers do\n    table.insert(res,\
    \ delimeter)\n    table.insert(res, numbers[i])\n  end\n  return res\nend", " \
    \   local res = {}\n    for i = 1, #numbers - 1 do\n        res[#res + 1] = numbers[i]\n\
    \        res[#res + 1] = delimeter\n    end\n    res[#res + 1] = numbers[#numbers]\n\
    \    return res\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n\
    \        result[#result + 1] = numbers[i]\n        result[#result + 1] = delimeter\n\
    \    end\n    result[#result + 1] = numbers[#numbers]\n    return result\nend",
  "    local res = {}\n    local len = #numbers\n    if len == 0 then\n        return\
    \ res\n    end\n    res[1] = numbers[1]\n    for i = 2, len do\n        res[i\
    \ * 2 - 1] = delimeter\n        res[i * 2] = numbers[i]\n    end\n    return res\n\
    end", "    local ret = {}\n    for i,v in ipairs(numbers) do\n        ret[#ret+1]\
    \ = v\n        if i ~= #numbers then\n            ret[#ret+1] = delimeter\n  \
    \      end\n    end\n    return ret\nend", "    if #numbers <= 1 then\n      \
    \  return numbers\n    end\n    local result = {}\n    for i, v in ipairs(numbers)\
    \ do\n        table.insert(result, v)\n        if i < #numbers then\n        \
    \    table.insert(result, delimeter)\n        end\n    end\n    return result\n\
    end", "  if #numbers == 0 then\n    return {}\n  end\n  local result = {numbers[1]}\n\
    \  for i = 2, #numbers do\n    result[#result + 1] = delimeter\n    result[#result\
    \ + 1] = numbers[i]\n  end\n  return result\nend", "    return _.reduce(numbers,\
    \ function(t, v)\n        _.push(t, v)\n        _.push(t, delimeter)\n       \
    \ return t\n    end, {})\nend", "    if #numbers <= 1 then\n        return numbers\n\
    \    end", "    local sequence = {}\n    for i = 1, #numbers - 1 do\n        table.insert(sequence,\
    \ numbers[i])\n        table.insert(sequence, delimeter)\n    end\n    table.insert(sequence,\
    \ numbers[#numbers])\n    return sequence\nend", "  local result = {}\n  for i\
    \ = 1, #numbers - 1 do\n    result[#result + 1] = numbers[i]\n    result[#result\
    \ + 1] = delimeter\n  end\n  result[#result + 1] = numbers[#numbers]\n  return\
    \ result\nend", "  local acc = {}\n  for i, n in ipairs(numbers) do\n    if i\
    \ > 1 then acc[#acc + 1] = delimeter end\n    acc[#acc + 1] = n\n  end\n  return\
    \ acc\nend", "    if #numbers == 0 then\n        return {}\n    end\n    if #numbers\
    \ == 1 then\n        return numbers\n    end\n    local result = {}\n    local\
    \ index = 1\n    while index <= #numbers do\n        result[#result + 1] = numbers[index]\n\
    \        if index + 1 <= #numbers then\n            result[#result + 1] = delimeter\n\
    \        end\n        index = index + 1\n    end\n    return result\nend", " \
    \ if #numbers == 0 then\n    return {}\n  end\n  local ret = {}\n  for i = 1,\
    \ #numbers - 1 do\n    table.insert(ret, numbers[i])\n    table.insert(ret, delimeter)\n\
    \  end\n  table.insert(ret, numbers[#numbers])\n  return ret\nend", "  local r\
    \ = {}\n  for i = 1, #numbers - 1 do\n    r[#r + 1] = numbers[i]\n    r[#r + 1]\
    \ = delimeter\n  end\n  r[#r + 1] = numbers[#numbers]\n  return r\nend", "\tlocal\
    \ result = {}\n\tfor i = 1, #numbers - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\
    \t\tresult[#result + 1] = delimeter\n\tend\n\tresult[#result + 1] = numbers[#numbers]\n\
    \treturn result\nend", "    if (not isArray(numbers)) then\n        error(\"Expected\
    \ an array, got \" .. type(numbers))\n    end\n    local result = {}\n    local\
    \ index = 0\n    for i = 1, #numbers - 1 do\n        index = index + 1\n     \
    \   result[index] = numbers[i]\n        index = index + 1\n        result[index]\
    \ = delimeter\n    end\n    if (#numbers >= 1) then\n        index = index + 1\n\
    \        result[index] = numbers[#numbers]\n    end\n    return result\nend",
  "  local res = {}\n  for i, v in ipairs(numbers) do\n    if i == 1 then\n      table.insert(res,\
    \ v)\n    else\n      table.insert(res, delimeter)\n      table.insert(res, v)\n\
    \    end\n  end\n  return res\nend", "  local result = {}\n  for i, n in ipairs(numbers)\
    \ do\n    result[#result + 1] = n\n    if i < #numbers then\n      result[#result\
    \ + 1] = delimeter\n    end\n  end\n  return result\nend", "    local result =\
    \ {}\n    for i, number in ipairs(numbers) do\n        if i > 1 then\n       \
    \     table.insert(result, delimeter)\n        end\n        table.insert(result,\
    \ number)\n    end\n    return result\nend", "    if #numbers == 0 then\n    \
    \    return {}\n    end\n    local result = {numbers[1]}\n    for index = 2, #numbers\
    \ do\n        result[#result + 1] = delimeter\n        result[#result + 1] = numbers[index]\n\
    \    end\n    return result\nend", "  if numbers == nil or #numbers == 0 then\n\
    \    return {}\n  end\n  local interspersed = {}\n  for i = 1, #numbers do\n \
    \   interspersed[i] = numbers[i]\n    if i < #numbers then\n      interspersed[i\
    \ + 1] = delimeter\n    end\n  end\n  return interspersed\nend", "    assert(type(numbers)\
    \ == \"table\", \"expected a table\")\n    assert(type(delimeter) == \"number\"\
    , \"expected a number\")\n    if #numbers == 0 then\n        return {}\n    end\n\
    \    local t = {}\n    for i = 1, #numbers - 1 do\n        t[i * 2 - 1] = numbers[i]\n\
    \        t[i * 2] = delimeter\n    end\n    t[#t] = numbers[#numbers]\n    return\
    \ t\nend", "  if #numbers < 2 then\n    return numbers\n  end\n  local result\
    \ = {}\n  for i = 1, #numbers - 1 do\n    table.insert(result, numbers[i])\n \
    \   table.insert(result, delimeter)\n  end\n  table.insert(result, numbers[#numbers])\n\
    \  return result\nend", "    local result = {}\n    for i, v in ipairs(numbers)\
    \ do\n        table.insert(result, v)\n        if i < #numbers then\n        \
    \    table.insert(result, delimeter)\n        end\n    end\n    return result\n\
    end", "  local interspersed = {}\n  for i = 1, #numbers do\n    interspersed[#interspersed\
    \ + 1] = numbers[i]\n    if i ~= #numbers then\n      interspersed[#interspersed\
    \ + 1] = delimeter\n    end\n  end\n  return interspersed\nend", "    return\n\
    \        empty(numbers) and {} or\n        foldr(\n            function(a, acc)\n\
    \                return\n                    empty(acc) and\n                \
    \    {a} or\n                    {a, delimeter, unpack(acc)}\n            end,\n\
    \            {},\n            numbers\n        )\nend", "    local out = {}\n\
    \    for i = 1, #numbers - 1 do\n        out[#out + 1] = numbers[i]\n        out[#out\
    \ + 1] = delimeter\n    end\n    out[#out + 1] = numbers[#numbers]\n    return\
    \ out\nend", "    local result = {}\n    local length = #numbers\n    for i =\
    \ 1, length do\n        result[i * 2 - 1] = numbers[i]\n        if i ~= length\
    \ then\n            result[i * 2] = delimeter\n        end\n    end\n    return\
    \ result\nend", "  local result = {}\n  for i, number in ipairs(numbers) do\n\
    \    table.insert(result, number)\n    if i < #numbers then\n      table.insert(result,\
    \ delimeter)\n    end\n  end\n  return result\nend", "    local output = {}\n\
    \    for index, number in ipairs(numbers) do\n        output[#output + 1] = number\n\
    \        if index ~= #numbers then\n            output[#output + 1] = delimeter\n\
    \        end\n    end\n    return output\nend", "    assert(type(numbers) == \"\
    table\")\n    assert(type(delimeter) == \"number\")\n    local result = {}\n \
    \   for i = 1, #numbers - 1 do\n        table.insert(result, numbers[i])\n   \
    \     table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\nend", "\tlocal result = {}\n\tfor i, v in ipairs(numbers)\
    \ do\n\t\ttable.insert(result, v)\n\t\tif i < #numbers then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\tend\n\treturn result\nend", "  local result = {}\n  for\
    \ i = 1, #numbers do\n    result[#result + 1] = numbers[i]\n    if i < #numbers\
    \ then\n      result[#result + 1] = delimeter\n    end\n  end\n  return result\n\
    end", "    assertx.is_table(numbers)\n    assertx.is_number(delimeter)", "   \
    \ local t = {}\n    for i = 1, #numbers do\n        t[#t + 1] = numbers[i]\n \
    \       if i < #numbers then\n            t[#t + 1] = delimeter\n        end\n\
    \    end\n    return t\nend", "  if #numbers == 0 then\n    return {}\n  end\n\
    \  local head = numbers[1]\n  local tail = slice(numbers, 2)\n  local result =\
    \ {head}\n  for _, v in ipairs(tail) do\n    table.insert(result, delimeter)\n\
    \    table.insert(result, v)\n  end\n  return result\nend", "    local out = {}\n\
    \    for i = 1, #numbers - 1 do\n        out[#out + 1] = numbers[i]\n        out[#out\
    \ + 1] = delimeter\n    end\n    out[#out + 1] = numbers[#numbers]\n    return\
    \ out\nend", "\tassert(type(numbers) == \"table\", \"bad argument #1 to 'intersperse'\
    \ (expected table)\")\n\tassert(type(delimeter) == \"number\", \"bad argument\
    \ #2 to 'intersperse' (expected number)\")\n\t\n\tlocal result = {}\n\t\n\tfor\
    \ i = 1, #numbers - 1 do\n\t\ttable.insert(result, numbers[i])\n\t\ttable.insert(result,\
    \ delimeter)\n\tend\n\t\n\ttable.insert(result, numbers[#numbers])\n\t\n\treturn\
    \ result\nend", "\tlocal result = {}\n\tlocal len = #numbers\n\tfor i = 1, len\
    \ do\n\t\tresult[2 * i - 1] = numbers[i]\n\t\tresult[2 * i] = delimeter\n\tend\n\
    \tresult[#result] = nil\n\treturn result\nend", "\tlocal result = {}\n\tfor _,\
    \ number in ipairs(numbers) do\n\t\tresult[#result + 1] = number\n\t\tresult[#result\
    \ + 1] = delimeter\n\tend\n\ttable.remove(result) -- remove the last delimeter\n\
    \treturn result\nend", "    local res = {}\n    for i, v in ipairs(numbers) do\n\
    \        table.insert(res, v)\n        if i < #numbers then\n            table.insert(res,\
    \ delimeter)\n        end\n    end\n    return res\nend", "\tlocal result = {}\n\
    \tfor i, number in ipairs(numbers) do\n\t\ttable.insert(result, number)\n\t\t\
    if i ~= #numbers then\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\tend\n\
    \treturn result\nend", "\tassert(isTuple(numbers), \"invalid numbers: must be\
    \ a tuple\")\n\tassert(isNumber(delimeter), \"invalid delimeter: must be a number\"\
    )\n\tif next(numbers) == nil then\n\t\treturn {}\n\tend\n\tlocal result = { numbers[1]\
    \ }\n\tfor i = 2, #numbers do\n\t\tresult[#result + 1] = delimeter\n\t\tresult[#result\
    \ + 1] = numbers[i]\n\tend\n\treturn result\nend", "\tlocal result = {}\n\tfor\
    \ i = 1, #numbers - 1 do\n\t\ttable.insert(result, numbers[i])\n\t\ttable.insert(result,\
    \ delimeter)\n\tend\n\ttable.insert(result, numbers[#numbers])\n\treturn result\n\
    end", "  local result = {}\n  for i = 1, #numbers - 1 do\n    result[#result +\
    \ 1] = numbers[i]\n    result[#result + 1] = delimeter\n  end\n  result[#result\
    \ + 1] = numbers[#numbers]\n  return result\nend", "  if #numbers == 0 then\n\
    \    return {}\n  end\n  local result = {numbers[1]}\n  for i = 2, #numbers do\n\
    \    append(result, delimeter)\n    append(result, numbers[i])\n  end\n  return\
    \ result\nend", "  if #numbers == 0 then\n    return {}\n  end\n  local t = {numbers[1]}\n\
    \  for i = 2, #numbers do\n    table.insert(t, delimeter)\n    table.insert(t,\
    \ numbers[i])\n  end\n  return t\nend", "    local newNumbers = {}\n    for i\
    \ = 1, #numbers - 1 do\n        newNumbers[#newNumbers + 1] = numbers[i]\n   \
    \     newNumbers[#newNumbers + 1] = delimeter\n    end\n    newNumbers[#newNumbers\
    \ + 1] = numbers[#numbers]\n    return newNumbers\nend", "    if not numbers[1]\
    \ then\n        return {}\n    end\n    local interspersed = {numbers[1]}\n  \
    \  for i = 2, #numbers do\n        t_insert(interspersed, delimeter)\n       \
    \ t_insert(interspersed, numbers[i])\n    end\n    return interspersed\nend",
  "  if #numbers < 2 then\n    return numbers\n  end\n  local new_numbers = {}\n \
    \ for i = 1, #numbers - 1 do\n    table.insert(new_numbers, numbers[i])\n    table.insert(new_numbers,\
    \ delimeter)\n  end\n  table.insert(new_numbers, numbers[#numbers])\n  return\
    \ new_numbers\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n\
    \        result[i * 2 - 1] = numbers[i]\n        result[i * 2] = delimeter\n \
    \   end\n    result[#result] = numbers[#numbers]\n    return result\nend", " \
    \   local result = {}\n    local length = #numbers\n    for i, n in ipairs(numbers)\
    \ do\n        table.insert(result, n)\n        if i < length then\n          \
    \  table.insert(result, delimeter)\n        end\n    end\n    return result\n\
    end", "    --local result = {}\n    --local first = true\n    --for _, number\
    \ in ipairs(numbers) do\n    --    if first then\n    --        first = false\n\
    \    --    else\n    --        result[#result + 1] = delimeter\n    --    end\n\
    \    --    result[#result + 1] = number\n    --end\n    --return result\n    local\
    \ result = {}\n    for index, number in ipairs(numbers) do\n        if index >\
    \ 1 then\n            result[#result + 1] = delimeter\n        end\n        result[#result\
    \ + 1] = number\n    end\n    return result\nend", "    assert(type(numbers) ==\
    \ \"table\", \"Expected a table, got \" .. type(numbers))\n    assert(type(delimeter)\
    \ == \"number\", \"Expected a number, got \" .. type(delimeter))", "  local res\
    \ = {}\n  for i = 1, #numbers do\n    res[#res + 1] = numbers[i]\n    if i < #numbers\
    \ then\n      res[#res + 1] = delimeter\n    end\n  end\n  return res\nend", " \
    \   local result = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result,\
    \ numbers[i])\n        table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ numbers[#numbers])\n    return result\nend", "    local result = {}\n    for\
    \ i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result\
    \ + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n   \
    \ return result\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n\
    \        result[#result + 1] = numbers[i]\n        result[#result + 1] = delimeter\n\
    \    end\n    result[#result + 1] = numbers[#numbers]\n    return result\nend",
  "\tlocal t = {}\n\tfor i = 1, #numbers - 1 do\n\t\tt[#t + 1] = numbers[i]\n\t\t\
    t[#t + 1] = delimeter\n\tend\n\tt[#t + 1] = numbers[#numbers]\n\treturn t\nend",
  "    local new_table = {}\n    for i, v in ipairs(numbers) do\n        if i ~= 1\
    \ then\n            table.insert(new_table, delimeter)\n        end\n        table.insert(new_table,\
    \ v)\n    end\n    return new_table\nend", "    if #numbers < 2 then\n       \
    \ return numbers\n    end\n    local result = {}\n    for i = 1, #numbers do\n\
    \        if i == 1 then\n            result[i] = numbers[i]\n        else\n  \
    \          table.insert(result, result[i])\n            result[i] = delimeter\n\
    \            table.insert(result, result[i])\n            result[i] = numbers[i]\n\
    \        end\n    end\n    return result\nend", "  local newTable = {}\n  for\
    \ index, value in ipairs(numbers) do\n    newTable[#newTable + 1] = value\n  \
    \  if (index < #numbers) then\n      newTable[#newTable + 1] = delimeter\n   \
    \ end\n  end\n  return newTable\nend", "    local result = {}\n    for i = 1,\
    \ #numbers - 1 do\n        table.insert(result, numbers[i])\n        table.insert(result,\
    \ delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n    return\
    \ result\nend", "    if #numbers <= 1 then\n        return numbers\n    end\n\
    \    local result = {}\n    for i = 1, #numbers - 1 do\n        result[#result\
    \ + 1] = numbers[i]\n        result[#result + 1] = delimeter\n    end\n    result[#result\
    \ + 1] = numbers[#numbers]\n    return result\nend", "    local result = {}\n\
    \    for i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n  \
    \      result[#result + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n\
    \    return result\nend", "    local output = {}\n    for i, number in ipairs(numbers)\
    \ do\n        table.insert(output, number)\n        if i ~= #numbers then\n  \
    \          table.insert(output, delimeter)\n        end\n    end\n    return output\n\
    end", "    if not numbers or #numbers == 0 then\n        return {}\n    end",
  "    assert(is_table(numbers), \"Intersperse: invalid input 'numbers'\")\n    assert(type(delimeter)\
    \ == \"number\", \"Intersperse: invalid input 'delimeter'\")\n    local result\
    \ = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result, numbers[i])\n\
    \        table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\nend", "  local output = {}\n  local lastIndex = #numbers\n\
    \  for i = 1, lastIndex do\n    output[#output + 1] = numbers[i]\n    if i ~=\
    \ lastIndex then\n      output[#output + 1] = delimeter\n    end\n  end\n  return\
    \ output\nend", "\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\t\tresult[#result\
    \ + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\tend\n\tresult[#result\
    \ + 1] = numbers[#numbers]\n\treturn result\nend", "  if #numbers == 0 then\n\
    \    return {}\n  end\n  local t = {numbers[1]}\n  for i = 2, #numbers do\n  \
    \  table.insert(t, delimeter)\n    table.insert(t, numbers[i])\n  end\n  return\
    \ t\nend", "  local result = {}\n  for i = 1, #numbers - 1 do\n    table.insert(result,\
    \ numbers[i])\n    table.insert(result, delimeter)\n  end\n  table.insert(result,\
    \ numbers[#numbers])\n  return result\nend", "  local result = {}\n  local i =\
    \ 1\n  while i <= #numbers do\n    table.insert(result, numbers[i])\n    if i\
    \ < #numbers then\n      table.insert(result, delimeter)\n    end\n    i = i +\
    \ 1\n  end\n  return result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\
    \tend\n\tresult[#result + 1] = numbers[#numbers]\n\treturn result\nend", "  return\
    \ numbers:zip(numbers:slice(2))\n    :map(function(pair)\n      return table.concat({pair[1],\
    \ delimeter, pair[2]}, '')\n    end)\n    :concat({numbers[#numbers]})\nend",
  "    local result = {}\n    for index, number in ipairs(numbers) do\n        if\
    \ index > 1 then\n            table.insert(result, delimeter)\n        end\n \
    \       table.insert(result, number)\n    end\n    return result\nend", "    if\
    \ #numbers <= 1 then\n        return numbers\n    end\n    local ret = {}\n  \
    \  for i = 1, #numbers - 1 do\n        ret[#ret + 1] = numbers[i]\n        ret[#ret\
    \ + 1] = delimeter\n    end\n    ret[#ret + 1] = numbers[#numbers]\n    return\
    \ ret\nend", "    local result = {}\n    for i, number in ipairs(numbers) do\n\
    \        if i > 1 then\n            result[#result + 1] = delimeter\n        end\n\
    \        result[#result + 1] = number\n    end\n    return result\nend", "\tassert(type(numbers)\
    \ == \"table\", \"bad argument #1 to 'intersperse' (table expected, got \" ..\
    \ type(numbers) .. \")\")\n\tassert(type(delimeter) == \"number\", \"bad argument\
    \ #2 to 'intersperse' (number expected, got \" .. type(delimeter) .. \")\")\n\t\
    \n\tlocal result = {}\n\t\n\tfor i = 1, #numbers - 1 do\n\t\tresult[2 * i - 1]\
    \ = numbers[i]\n\t\tresult[2 * i] = delimeter\n\tend\n\t\n\tresult[#result + 1]\
    \ = numbers[#numbers]\n\t\n\treturn result\nend", "\tif #numbers == 0 then\n\t\
    \treturn {}\n\tend\n\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\t\tresult[#result\
    \ + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\tend\n\tresult[#result\
    \ + 1] = numbers[#numbers]\n\treturn result\nend", "\tassertarg(numbers, \"table\"\
    )\n\tassertarg(delimeter, \"number\")\n\t\n\tif #numbers < 2 then\n\t\treturn\
    \ numbers\n\tend\n\t\n\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\t\t\
    result[#result + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\tend\n\
    \tresult[#result + 1] = numbers[#numbers]\n\treturn result\nend", "  local new_numbers\
    \ = {}\n  for _, n in ipairs(numbers) do\n    new_numbers[#new_numbers + 1] =\
    \ n\n    new_numbers[#new_numbers + 1] = delimeter\n  end\n  new_numbers[#new_numbers]\
    \ = nil\n  return new_numbers\nend", "\tlocal result = {}\n\tfor i = 1, #numbers\
    \ do\n\t\tif i > 1 then\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\t\t\
    table.insert(result, numbers[i])\n\tend\n\treturn result\nend", "    local res\
    \ = {}\n    for i = 1, #numbers - 1 do\n        table.insert(res, numbers[i])\n\
    \        table.insert(res, delimeter)\n    end\n    table.insert(res, numbers[#numbers])\n\
    \    return res\nend", "  local result = {}\n  local length = #numbers\n  for\
    \ i = 1, length - 1 do\n    local element = numbers[i]\n    table.insert(result,\
    \ element)\n    table.insert(result, delimeter)\n  end\n  table.insert(result,\
    \ numbers[length])\n  return result\nend", "    local out = {}\n    for i = 1,\
    \ #numbers do\n        table.insert(out, numbers[i])\n        if i < #numbers\
    \ then\n            table.insert(out, delimeter)\n        end\n    end\n    return\
    \ out\nend", "    local out = {}\n    for i = 1, #numbers do\n        out[#out\
    \ + 1] = numbers[i]\n        if i ~= #numbers then\n            out[#out + 1]\
    \ = delimeter\n        end\n    end\n    return out\nend", "\tlocal result = {}\n\
    \tfor i, n in ipairs(numbers) do\n\t\tif i > 1 then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\t\ttable.insert(result, n)\n\tend\n\treturn result\nend",
  "\tassert(istable(numbers), \"numbers must be a table\")\n\tassert(delimeter ~=\
    \ nil, \"delimeter must not be nil\")\n\tlocal newt = {}\n\tlocal len = #numbers\n\
    \tif len > 0 then\n\t\tfor i, v in ipairs(numbers) do\n\t\t\tnewt[#newt + 1] =\
    \ v\n\t\t\tif i < len then\n\t\t\t\tnewt[#newt + 1] = delimeter\n\t\t\tend\n\t\
    \tend\n\tend\n\treturn newt\nend", "\treturn 0 == #numbers and {} or #numbers\
    \ < 2 and numbers or { numbers[1], delimeter, unpack(intersperse(sub(numbers,\
    \ 2), delimeter)) }\nend", "\tlocal t = {}\n\tfor i = 1, #numbers - 1 do\n\t\t\
    t[i * 2 - 1] = numbers[i]\n\t\tt[i * 2] = delimeter\n\tend\n\tt[#t] = numbers[#numbers]\n\
    \treturn t\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n   \
    \     result[#result + 1] = numbers[i]\n        result[#result + 1] = delimeter\n\
    \    end\n    result[#result + 1] = numbers[#numbers]\n    return result\nend",
  "    local result = {}\n    for i = 1, #numbers do\n        if i > 1 then\n    \
    \        result[#result + 1] = delimeter\n        end\n        result[#result\
    \ + 1] = numbers[i]\n    end\n    return result\nend", "    local result = {}\n\
    \    for i = 1, #numbers - 1 do\n        table.insert(result, numbers[i])\n  \
    \      table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\nend", "\tlocal result = {}\n\tfor i,v in ipairs(numbers) do\n\
    \t\ttable.insert(result, v)\n\t\tif i ~= #numbers then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\tend\n\treturn result\nend", "  local result = {}\n  local\
    \ idx = 1\n  for i = 1, #numbers do\n    result[idx] = numbers[i]\n    if i ~=\
    \ #numbers then\n      idx = idx + 1\n      result[idx] = delimeter\n    end\n\
    \    idx = idx + 1\n  end\n  return result\nend", "    assert(type(numbers) ==\
    \ \"table\", \"must be table\")\n    assert(type(delimeter) == \"number\", \"\
    must be number\")\n    local out = {}\n    for i = 1, #numbers - 1 do\n      \
    \  out[#out + 1] = numbers[i]\n        out[#out + 1] = delimeter\n    end\n  \
    \  out[#out + 1] = numbers[#numbers]\n    return out\nend", "  local t = {}\n\
    \  local n = #numbers\n  for i = 1, n do\n    t[#t + 1] = numbers[i]\n    if i\
    \ < n then\n      t[#t + 1] = delimeter\n    end\n  end\n  return t\nend", " \
    \   if #numbers < 2 then\n        return numbers\n    end\n    local ret = {}\n\
    \    for i = 1, #numbers - 1 do\n        table.insert(ret, numbers[i])\n     \
    \   table.insert(ret, delimeter)\n    end\n    table.insert(ret, numbers[#numbers])\n\
    \    return ret\nend", "\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\tresult[2\
    \ * i - 1] = numbers[i]\n\t\tresult[2 * i] = delimeter\n\tend\n\tresult[#result]\
    \ = nil\n\treturn result\nend", "  if #numbers == 0 then\n    return {}\n  end\n\
    \  local result = {numbers[1]}\n  for i = 2, #numbers do\n    result[#result +\
    \ 1] = delimeter\n    result[#result + 1] = numbers[i]\n  end\n  return result\n\
    end", "  if not numbers[1] then return {} end\n  local result = {numbers[1]}\n\
    \  for i = 2, #numbers do\n    table.insert(result, delimeter)\n    table.insert(result,\
    \ numbers[i])\n  end\n  return result\nend", "    if not numbers[1] then\n   \
    \     return {}\n    end\n    local result = {numbers[1]}\n    for i = 2, #numbers\
    \ do\n        result[#result + 1] = delimeter\n        result[#result + 1] = numbers[i]\n\
    \    end\n    return result\nend", "\tlocal ret = {}\n\tfor i, v in ipairs(numbers)\
    \ do\n\t\tret[#ret + 1] = v\n\t\tif i < #numbers then\n\t\t\tret[#ret + 1] = delimeter\n\
    \t\tend\n\tend\n\treturn ret\nend", "  local numbers = pack(numbers)\n  if #numbers\
    \ < 2 then\n    return numbers\n  end\n  local t = {}\n  for i, v in ipairs(numbers)\
    \ do\n    t[#t + 1] = v\n    if i < #numbers then\n      t[#t + 1] = delimeter\n\
    \    end\n  end\n  return t\nend", "  if #numbers == 0 then\n    return {}\n \
    \ end\n  local result = {numbers[1]}\n  for i = 2, #numbers do\n    table.insert(result,\
    \ delimeter)\n    table.insert(result, numbers[i])\n  end\n  return result\nend",
  "    local result = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result,\
    \ numbers[i])\n        table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ numbers[#numbers])\n    return result\nend", "    local result = {}\n    for\
    \ i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result\
    \ + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n   \
    \ return result\nend", "  assert_type(numbers, \"table\", 1)\n  assert_type(delimeter,\
    \ \"number\", 2)\n  local result = {}\n  for i = 1, #numbers - 1 do\n    result[#result\
    \ + 1] = numbers[i]\n    result[#result + 1] = delimeter\n  end\n  result[#result\
    \ + 1] = numbers[#numbers]\n  return result\nend", "    if getn(numbers) == 0\
    \ then\n        return {}\n    end\n    local head = numbers[1]\n    local tail\
    \ = slice(numbers, 2)\n    return concat({head}, map(function(x) return {delimeter,\
    \ x} end, tail))\nend", "\tlocal output = {}\n\tlocal idx = 1\n\tfor i, v in ipairs(numbers)\
    \ do\n\t\toutput[idx] = v\n\t\tidx = idx + 1\n\t\tif i < #numbers then\n\t\t\t\
    output[idx] = delimeter\n\t\t\tidx = idx + 1\n\t\tend\n\tend\n\treturn output\n\
    end", "    if #numbers < 2 then\n        return numbers\n    end\n    local result\
    \ = {}\n    local i = 1\n    while i <= #numbers do\n        result[#result +\
    \ 1] = numbers[i]\n        if i ~= #numbers then\n            result[#result +\
    \ 1] = delimeter\n        end\n        i = i + 1\n    end\n    return result\n\
    end", "    local t = {}\n    for i = 1, #numbers do\n        t[#t + 1] = numbers[i]\n\
    \        if i < #numbers then\n            t[#t + 1] = delimeter\n        end\n\
    \    end\n    return t\nend", "  local out = {}\n  local size = #numbers\n  if\
    \ size > 0 then\n    out[1] = numbers[1]\n    for i = 2, size do\n      out[i\
    \ * 2 - 1] = delimeter\n      out[i * 2] = numbers[i]\n    end\n  end\n  return\
    \ out\nend", "  local new_table = {}\n  local i = 1\n  while i <= #numbers do\n\
    \    new_table[#new_table + 1] = numbers[i]\n    if i < #numbers then\n      new_table[#new_table\
    \ + 1] = delimeter\n    end\n    i = i + 1\n  end\n  return new_table\nend", " \
    \ local result = {}\n  for i = 1, #numbers - 1 do\n    result[#result + 1] = numbers[i]\n\
    \    result[#result + 1] = delimeter\n  end\n  result[#result + 1] = numbers[#numbers]\n\
    \  return result\nend", "  local numbers1 = {}\n  for i = 1, #numbers do\n   \
    \ numbers1[#numbers1 + 1] = numbers[i]\n    if i < #numbers then\n      numbers1[#numbers1\
    \ + 1] = delimeter\n    end\n  end\n  return numbers1\nend", "    local result\
    \ = {}\n    for i = 1, #numbers do\n        table.insert(result, numbers[i])\n\
    \        if i < #numbers then\n            table.insert(result, delimeter)\n \
    \       end\n    end\n    return result\nend", "\tlocal result = {}\n\tfor i =\
    \ 1, #numbers - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result\
    \ + 1] = delimeter\n\tend\n\tresult[#result + 1] = numbers[#numbers]\n\treturn\
    \ result\nend", "\tif #numbers == 0 then\n\t\treturn {}\n\tend\n\tlocal result\
    \ = {numbers[1]}\n\tfor i = 2, #numbers do\n\t\ttable.insert(result, delimeter)\n\
    \t\ttable.insert(result, numbers[i])\n\tend\n\treturn result\nend", "    local\
    \ result = {}\n    local n = #numbers\n    for i = 1, n - 1 do\n        result[#result\
    \ + 1] = numbers[i]\n        result[#result + 1] = delimeter\n    end\n    if\
    \ n ~= 0 then\n        result[#result + 1] = numbers[n]\n    end\n    return result\n\
    end", "\tassert_table(numbers)\n\tassert_number(delimeter)\n\tlocal result = {}\n\
    \tlocal last_index = #numbers - 1\n\tfor i = 1, last_index do\n\t\tresult[#result\
    \ + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\tend\n\tresult[#result\
    \ + 1] = numbers[last_index + 1]\n\treturn result\nend", "    local sep\n    local\
    \ function separator(x)\n        return sep and {sep, x} or {x}\n    end\n   \
    \ local result = {}\n    for i = 1, #numbers do\n        sep = delimeter\n   \
    \     local v = numbers[i]\n        for _, element in ipairs(separator(v)) do\n\
    \            result[#result + 1] = element\n        end\n    end\n    return result\n\
    end", "  local count = #numbers\n  if count < 2 then\n    return numbers\n  end\n\
    \  local result = {}\n  for i, number in ipairs(numbers) do\n    result[i * 2\
    \ - 1] = number\n    result[i * 2] = delimeter\n  end\n  result[#result] = nil\n\
    \  return result\nend", "    assert_table(numbers)\n    assert_number(delimeter)\n\
    \    local result = {}\n    for index, number in ipairs(numbers) do\n        if\
    \ index > 1 then\n            result[#result + 1] = delimeter\n        end\n \
    \       result[#result + 1] = number\n    end\n    return result\nend", "    local\
    \ result = {}\n    for _, v in ipairs(numbers) do\n        table.insert(result,\
    \ v)\n        table.insert(result, delimeter)\n    end\n    table.remove(result)\n\
    \    return result\nend", "  checkArg(1, numbers, \"table\")\n  checkArg(2, delimeter,\
    \ \"number\")", "  local result = {}\n  local last_index = #numbers\n  for i =\
    \ 1, last_index do\n    table.insert(result, numbers[i])\n    if i < last_index\
    \ then\n      table.insert(result, delimeter)\n    end\n  end\n  return result\n\
    end", "  local out = {}\n  for i, v in ipairs(numbers) do\n    out[#out + 1] =\
    \ v\n    if i < #numbers then\n      out[#out + 1] = delimeter\n    end\n  end\n\
    \  return out\nend", "    if (#numbers == 0) then\n        return numbers\n  \
    \  end\n    local result = {numbers[1]}\n    for i = 2, #numbers do\n        result[#result\
    \ + 1] = delimeter\n        result[#result + 1] = numbers[i]\n    end\n    return\
    \ result\nend", "    if not isArray(numbers) then\n        error(\"The 1st parameter\
    \ must be an array.\", 2)\n    end\n    if not isNumber(delimeter) then\n    \
    \    error(\"The 2nd parameter must be a number.\", 2)\n    end\n    local list\
    \ = {}\n    for i = 1, #numbers - 1 do\n        list[#list + 1] = numbers[i]\n\
    \        list[#list + 1] = delimeter\n    end\n    list[#list + 1] = numbers[#numbers]\n\
    \    return list\nend", "\tlocal i, j = 1, 1\n\tlocal l = #numbers", "    local\
    \ result = {}\n    for i, n in ipairs(numbers) do\n        result[#result + 1]\
    \ = n\n        if i < #numbers then\n            result[#result + 1] = delimeter\n\
    \        end\n    end\n    return result\nend", "\tlocal result = {}\n\tfor i\
    \ = 1, #numbers do\n\t\ttable.insert(result, numbers[i])\n\t\tif i < #numbers\
    \ then\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\tend\n\treturn result\n\
    end", "    local result = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result,\
    \ numbers[i])\n        table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ numbers[#numbers])\n    return result\nend", "    local result = {}\n    local\
    \ position = 1\n    local numbersLength = #numbers\n    while position <= numbersLength\
    \ do\n        result[#result + 1] = numbers[position]\n        if position < numbersLength\
    \ then\n            result[#result + 1] = delimeter\n        end\n        position\
    \ = position + 1\n    end\n    return result\nend", "  if #numbers <= 1 then\n\
    \    return numbers\n  end\n  local output = {numbers[1]}\n  for i = 2, #numbers\
    \ do\n    table.insert(output, delimeter)\n    table.insert(output, numbers[i])\n\
    \  end\n  return output\nend", "    local result = {}\n    local numbersLength\
    \ = #numbers\n    if numbersLength == 0 then\n        return result\n    end\n\
    \    local lastIndex = numbersLength - 1\n    result[1] = numbers[1]\n    for\
    \ i = 1, lastIndex do\n        result[2 * i] = delimeter\n        result[2 * i\
    \ + 1] = numbers[i + 1]\n    end\n    return result\nend", "  local result = {}\n\
    \  for i = 1, #numbers do\n    table.insert(result, numbers[i])\n    if i < #numbers\
    \ then\n      table.insert(result, delimeter)\n    end\n  end\n  return result\n\
    end", "    if #numbers == 0 then\n        return {}\n    end\n    local result\
    \ = {numbers[1]}\n    for i = 2, #numbers do\n        table.insert(result, delimeter)\n\
    \        table.insert(result, numbers[i])\n    end\n    return result\nend", " \
    \ local result = {}\n  local n = #numbers\n  if n > 0 then\n    table.insert(result,\
    \ numbers[1])\n    for i = 2, n do\n      table.insert(result, delimeter)\n  \
    \    table.insert(result, numbers[i])\n    end\n  end\n  return result\nend",
  "\tif #numbers == 0 then\n\t\treturn {}\n\tend\n\tlocal result = {}\n\tfor i = 1,\
    \ #numbers - 1 do\n\t\ttable.insert(result, numbers[i])\n\t\ttable.insert(result,\
    \ delimeter)\n\tend\n\ttable.insert(result, numbers[#numbers])\n\treturn result\n\
    end", "  local result = {}\n  local prev = nil\n  for i, num in ipairs(numbers)\
    \ do\n    if i > 1 then\n      result[#result + 1] = delimeter\n    end\n    result[#result\
    \ + 1] = num\n  end\n  return result\nend", "    if #numbers < 2 then\n      \
    \  return numbers\n    end\n    local new_numbers = {}\n    for i = 1, #numbers\
    \ - 1 do\n        new_numbers[#new_numbers + 1] = numbers[i]\n        new_numbers[#new_numbers\
    \ + 1] = delimeter\n    end\n    new_numbers[#new_numbers + 1] = numbers[#numbers]\n\
    \    return new_numbers\nend", "    local result = {}\n    for i = 1, #numbers\
    \ - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result + 1]\
    \ = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n    return\
    \ result\nend", "    if not numbers or #numbers == 0 then\n        return {}\n\
    \    end", "    if #numbers < 2 then\n        return numbers\n    end\n    local\
    \ result = {}\n    for i = 1, #numbers - 1 do\n        local v = numbers[i]\n\
    \        table.insert(result, v)\n        table.insert(result, delimeter)\n  \
    \  end\n    table.insert(result, numbers[#numbers])\n    return result\nend",
  "    assert_arg_length(numbers, 1)\n    assert_arg_length(delimeter, 2)\n    assert_arg_type(numbers,\
    \ 1, 'table')\n    assert_arg_type(delimeter, 2, 'number')", "  if #numbers ==\
    \ 0 then\n    return {}\n  end\n  local ret = {numbers[1]}\n  for i = 2, #numbers\
    \ do\n    ret[#ret + 1] = delimeter\n    ret[#ret + 1] = numbers[i]\n  end\n \
    \ return ret\nend", "  local result = {}\n  for i = 1, #numbers - 1 do\n    result[i*2\
    \ - 1] = numbers[i]\n    result[i*2] = delimeter\n  end\n  result[#result + 1]\
    \ = numbers[#numbers]\n  return result\nend", "\tif (#numbers == 0) then\n\t\t\
    return numbers\n\tend\n\tlocal new_t = {numbers[1]}\n\tfor i = 2, #numbers do\n\
    \t\ttable.insert(new_t, delimeter)\n\t\ttable.insert(new_t, numbers[i])\n\tend\n\
    \treturn new_t\nend", "\tlocal n = #numbers\n\tif n < 2 then\n\t\treturn numbers\n\
    \tend\n\tlocal result = {}\n\tfor i = 1, n - 1 do\n\t\tresult[2 * i - 1] = numbers[i]\n\
    \t\tresult[2 * i] = delimeter\n\tend\n\tresult[2 * n - 1] = numbers[n]\n\treturn\
    \ result\nend", "  local result = {}\n  for i = 1, #numbers do\n    table.insert(result,\
    \ numbers[i])\n    if i < #numbers then\n      table.insert(result, delimeter)\n\
    \    end\n  end\n  return result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\
    \tend\n\tresult[#result + 1] = numbers[#numbers]\n\treturn result\nend", "   \
    \ if #numbers < 2 then\n        return numbers\n    end\n    local ret = { numbers[1]\
    \ }\n    for i = 2, #numbers do\n        ret[#ret + 1] = delimeter\n        ret[#ret\
    \ + 1] = numbers[i]\n    end\n    return ret\nend", "  assert_arg_types('table',\
    \ {'number', 'nil'}, numbers, delimeter)\n  local result = {}\n  for i, value\
    \ in ipairs(numbers) do\n    result[#result + 1] = value\n    if i < #numbers\
    \ then\n      result[#result + 1] = delimeter\n    end\n  end\n  return result\n\
    end", "    local n = #numbers\n    if n == 0 then\n        return {}\n    elseif\
    \ n == 1 then\n        return numbers\n    else\n        local interspersed =\
    \ {numbers[1]}\n        for i = 2, n do\n            interspersed[#interspersed\
    \ + 1] = delimeter\n            interspersed[#interspersed + 1] = numbers[i]\n\
    \        end\n        return interspersed\n    end\nend", "    local result =\
    \ {}\n    for i = 1, #numbers do\n        table.insert(result, numbers[i])\n \
    \       if i < #numbers then\n            table.insert(result, delimeter)\n  \
    \      end\n    end\n    return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
