name: HumanEval_5_intersperse
language: lua
prompt: "-- Insert a number 'delimeter' between every two consecutive elements of\
  \ input table `numbers'\n-- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1,\
  \ 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersperse\n\
  \    lu.assertEquals(candidate({}, 7), {})\n    lu.assertEquals(candidate({5, 6,\
  \ 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})\n    lu.assertEquals(candidate({2, 2, 2}, 2),\
  \ {2, 2, 2, 2, 2})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if not is_table(numbers) then\n        return numbers\n    end\n\
    \    local result = {}\n    local count = #numbers\n    if count < 2 then\n  \
    \      return numbers\n    end\n    for i = 1, count do\n        if i > 1 then\n\
    \            result[#result + 1] = delimeter\n        end\n        result[#result\
    \ + 1] = numbers[i]\n    end\n    return result\nend", "    local result = {}\n\
    \    local size = #numbers\n    if size == 0 then\n        return result\n   \
    \ end\n    result[1] = numbers[1]\n    for i = 2, size do\n        table.insert(result,\
    \ delimeter)\n        table.insert(result, numbers[i])\n    end\n    return result\n\
    end", "    if #numbers == 0 then\n        return {}\n    end\n    if #numbers\
    \ == 1 then\n        return numbers\n    end\n    local l = {}\n    for i = 1,\
    \ #numbers - 1 do\n        l[2 * i - 1] = numbers[i]\n        l[2 * i] = delimeter\n\
    \    end\n    l[#l] = numbers[#numbers]\n    return l\nend", "\tlocal result =\
    \ {}\n\tfor i = 1, #numbers do\n\t\tresult[#result + 1] = numbers[i]\n\t\tif i\
    \ < #numbers then\n\t\t\tresult[#result + 1] = delimeter\n\t\tend\n\tend\n\treturn\
    \ result\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n     \
    \   result[#result + 1] = numbers[i]\n        result[#result + 1] = delimeter\n\
    \    end\n    result[#result + 1] = numbers[#numbers]\n    return result\nend",
  "    local result = {}\n    local n = #numbers\n    for i = 1, n - 1 do\n      \
    \  local number = numbers[i]\n        result[#result + 1] = number\n        result[#result\
    \ + 1] = delimeter\n    end\n    if n > 0 then\n        result[#result + 1] =\
    \ numbers[n]\n    end\n    return result\nend", "    local new_table = {}\n  \
    \  for i, number in ipairs(numbers) do\n        table.insert(new_table, number)\n\
    \        if i < #numbers then\n            table.insert(new_table, delimeter)\n\
    \        end\n    end\n    return new_table\nend", "  local result = {}\n  for\
    \ i, number in ipairs(numbers) do\n    result[#result + 1] = number\n    if i\
    \ < #numbers then\n      result[#result + 1] = delimeter\n    end\n  end\n  return\
    \ result\nend", "  local out = {}\n  local n = len(numbers)\n  if n > 0 then\n\
    \    out[1] = numbers[1]\n    for i = 2, n do\n      out[2 * i - 1] = delimeter\n\
    \      out[2 * i] = numbers[i]\n    end\n  end\n  return out\nend", "    local\
    \ out = {}\n    for i, num in ipairs(numbers) do\n        out[#out + 1] = num\n\
    \        if i ~= #numbers then\n            out[#out + 1] = delimeter\n      \
    \  end\n    end\n    return out\nend", "\tlocal result = {}\n\tlocal n = #numbers\n\
    \tfor i = 1, n - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result\
    \ + 1] = delimeter\n\tend\n\tresult[#result + 1] = numbers[n]\n\treturn result\n\
    end", "    return zip(numbers, interleave({}, numbers, delimeter))\nend", "  \
    \  assert_arg_tables({numbers})\n    assert_arg_number(delimeter)", "    local\
    \ result = {}\n    local length = #numbers\n    if length > 0 then\n        result[1]\
    \ = numbers[1]\n        for i = 2, length do\n            result[#result + 1]\
    \ = delimeter\n            result[#result + 1] = numbers[i]\n        end\n   \
    \ end\n    return result\nend", "    if #numbers == 0 then\n        return {}\n\
    \    end\n    local output = {}\n    for i = 1, #numbers - 1 do\n        output[#output\
    \ + 1] = numbers[i]\n        output[#output + 1] = delimeter\n    end\n    output[#output\
    \ + 1] = numbers[#numbers]\n    return output\nend", "  if #numbers <= 1 then\n\
    \    return numbers\n  end\n  local result = {}\n  for i, number in ipairs(numbers)\
    \ do\n    if i > 1 then\n      table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ number)\n  end\n  return result\nend", "\tlocal res = {}\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\tres[#res + 1] = numbers[i]\n\t\tres[#res + 1] = delimeter\n\tend\n\
    \tres[#res + 1] = numbers[#numbers]\n\treturn res\nend", "    local result = {}\n\
    \    for i, number in ipairs(numbers) do\n        if i ~= 1 then\n           \
    \ table.insert(result, delimeter)\n        end\n        table.insert(result, number)\n\
    \    end\n    return result\nend", "  if #numbers <= 1 then\n    return numbers\n\
    \  end\n  local interleaved = {}\n  for i = 1, #numbers - 1 do\n    local v =\
    \ numbers[i]\n    table.insert(interleaved, v)\n    table.insert(interleaved,\
    \ delimeter)\n  end\n  table.insert(interleaved, numbers[#numbers])\n  return\
    \ interleaved\nend", "\tassertPositiveInteger(delimeter)\n\treturn collect(function()\n\
    \t\tlocal first\n\t\tfor _, n in ipairs(numbers) do\n\t\t\tif first ~= nil then\n\
    \t\t\t\tyield(delimeter)\n\t\t\tend\n\t\t\tyield(n)\n\t\t\tfirst = n\n\t\tend\n\
    \tend)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
