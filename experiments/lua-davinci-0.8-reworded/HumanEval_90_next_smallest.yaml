name: HumanEval_90_next_smallest
language: lua
prompt: "-- You are given a table of integers.\n-- Write a function next_smallest()\
  \ that returns the 2nd smallest element of the table.\n-- Return None if there is\
  \ no such element.\n-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5,\
  \ 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1,\
  \ 1})\n-- None\nlocal function next_smallest(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5,\
  \ 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local min = math.huge\n    local sec = math.huge\n    for _,x in\
    \ ipairs(lst) do\n        if x < min then\n            sec = min\n           \
    \ min = x\n        elseif x < sec then\n            sec = x\n        end\n   \
    \ end\n    if sec == math.huge then\n        return nil\n    else\n        return\
    \ sec\n    end\nend", "\ttable.sort(lst)\n\tfor i = 1, #lst - 1 do\n\t\tif lst[i]\
    \ ~= lst[i + 1] then\n\t\t\treturn lst[i + 1]\n\t\tend\n\tend\nend", "  return\
    \ lst[{#lst}]\nend", "\tif not lst or #lst < 2 then\n\t\treturn nil\n\tend\n\t\
    local smallest = math.huge\n\tlocal next_smallest = math.huge\n\tfor _, n in ipairs(lst)\
    \ do\n\t\tif n < smallest then\n\t\t\tnext_smallest = smallest\n\t\t\tsmallest\
    \ = n\n\t\telseif n < next_smallest then\n\t\t\tnext_smallest = n\n\t\tend\n\t\
    end\n\tif next_smallest == math.huge then\n\t\treturn nil\n\tend\n\treturn next_smallest\n\
    end", "    local min, min2\n    for i, v in ipairs(lst) do\n        if min ==\
    \ nil or v < min then\n            min2 = min\n            min = v\n        elseif\
    \ min2 == nil or v < min2 then\n            min2 = v\n        end\n    end\n \
    \   return min2\nend", "    table.sort(lst)\n    local min1 = lst[1]\n    local\
    \ min2 = nil\n    for _, value in ipairs(lst) do\n        if value > min1 then\n\
    \            min2 = value\n            break\n        end\n    end\n    return\
    \ min2\nend", "  if #lst <= 1 then\n    return nil\n  end\n  local smallest =\
    \ math.min(table.unpack(lst))\n  local candidate = smallest\n  for _,x in ipairs(lst)\
    \ do\n    if x ~= smallest and x < candidate then\n      candidate = x\n    end\n\
    \  end\n  if candidate == smallest then\n    return nil\n  else\n    return candidate\n\
    \  end\nend", "  local min, min2 = math.huge, math.huge\n  for _, x in ipairs(lst)\
    \ do\n    if x < min then\n      min2 = min\n      min = x\n    elseif x < min2\
    \ then\n      min2 = x\n    end\n  end\n  return min2 < math.huge and min2 or\
    \ nil\nend", "  local sorted_lst = sort(lst)\n  local min = first(sorted_lst)\n\
    \  for i, v in ipairs(sorted_lst) do\n    if v > min then\n      return v\n  \
    \  end\n  end\n  return nil\nend", "\tlocal min = math.huge\n\tlocal min2 = math.huge\n\
    \tfor _, v in ipairs(lst) do\n\t\tif v < min then\n\t\t\tmin2 = min\n\t\t\tmin\
    \ = v\n\t\telseif v > min and v < min2 then\n\t\t\tmin2 = v\n\t\tend\n\tend\n\t\
    if min2 == math.huge then\n\t\treturn nil\n\tend\n\treturn min2\nend", "    local\
    \ min1, min2 = math.maxinteger, math.maxinteger\n    for _, v in ipairs(lst) do\n\
    \        if v < min1 then\n            min2 = min1\n            min1 = v\n   \
    \     elseif v < min2 then\n            min2 = v\n        end\n    end\n    return\
    \ min2 == math.maxinteger and nil or min2\nend", "    -- TODO\nend", "    local\
    \ min, min2 = math.huge, math.huge\n    for _, v in ipairs(lst) do\n        if\
    \ v <= min then\n            min2 = min\n            min = v\n        elseif v\
    \ < min2 then\n            min2 = v\n        end\n    end\n    return min == min2\
    \ and nil or min2\nend", "  return nil\nend", "    if #lst == 0 then\n       \
    \ return nil\n    end\n    if #lst == 1 then\n        return nil\n    end\n  \
    \  if #lst == 2 then\n        if lst[1] ~= lst[2] then\n            return math.min(lst[1],\
    \ lst[2])\n        else\n            return nil\n        end\n    end\n    local\
    \ min, second_min = math.huge, math.huge\n    for _, v in ipairs(lst) do\n   \
    \     if v < min then\n            second_min = min\n            min = v\n   \
    \     elseif v < second_min then\n            second_min = v\n        end\n  \
    \  end\n    if second_min == math.huge then\n        return nil\n    else\n  \
    \      return second_min\n    end\nend", "  -- your code here\nend", "    -- first\
    \ check list length\n    if #lst < 2 then\n        return nil\n    end\n    --\
    \ next make a copy of the list and sort it\n    local copy = copy_lst(lst)\n \
    \   table.sort(copy)\n    -- then find first non-matching element (should be 2nd\
    \ smallest)\n    for i = 1, #copy - 1 do\n        if copy[i] ~= copy[i + 1] then\n\
    \            return copy[i + 1]\n        end\n    end\n    -- if you made it here,\
    \ there was no second smallest element\n    return nil\nend", "    local ans =\
    \ nil\n    for _, v in ipairs(lst) do\n        if not ans or ans > v then\n  \
    \          ans = v\n        end\n    end\n    local min\n    for _, v in ipairs(lst)\
    \ do\n        if v ~= ans and (not min or min > v) then\n            min = v\n\
    \        end\n    end\n    return min\nend", "  local min, min2 = lst[1], lst[2]\n\
    \  for i = 1, #lst do\n    if lst[i] <= min then\n      min2 = min\n      min\
    \ = lst[i]\n    elseif lst[i] < min2 then\n      min2 = lst[i]\n    end\n  end\n\
    \  return min == min2 and nil or min2\nend", "    local smallest = math.huge\n\
    \    local second_smallest = math.huge\n    for _, val in ipairs(lst) do\n   \
    \     if val < smallest then\n            second_smallest = smallest\n       \
    \     smallest = val\n        elseif val < second_smallest then\n            second_smallest\
    \ = val\n        end\n    end\n    if second_smallest == math.huge then\n    \
    \    return nil\n    else\n        return second_smallest\n    end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
