name: HumanEval_90_next_smallest
language: lua
prompt: "-- You are given a table of integers.\n-- Write a function next_smallest()\
  \ that returns the 2nd smallest element of the table.\n-- Return None if there is\
  \ no such element.\n-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5,\
  \ 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1,\
  \ 1})\n-- None\nlocal function next_smallest(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5,\
  \ 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local min = math.huge\n    local sec = math.huge\n    for _,x in\
    \ ipairs(lst) do\n        if x < min then\n            sec = min\n           \
    \ min = x\n        elseif x < sec then\n            sec = x\n        end\n   \
    \ end\n    if sec == math.huge then\n        return nil\n    else\n        return\
    \ sec\n    end\nend", "\ttable.sort(lst)\n\tfor i = 1, #lst - 1 do\n\t\tif lst[i]\
    \ ~= lst[i + 1] then\n\t\t\treturn lst[i + 1]\n\t\tend\n\tend\nend", "  return\
    \ lst[{#lst}]\nend", "\tif not lst or #lst < 2 then\n\t\treturn nil\n\tend\n\t\
    local smallest = math.huge\n\tlocal next_smallest = math.huge\n\tfor _, n in ipairs(lst)\
    \ do\n\t\tif n < smallest then\n\t\t\tnext_smallest = smallest\n\t\t\tsmallest\
    \ = n\n\t\telseif n < next_smallest then\n\t\t\tnext_smallest = n\n\t\tend\n\t\
    end\n\tif next_smallest == math.huge then\n\t\treturn nil\n\tend\n\treturn next_smallest\n\
    end", "    local min, min2\n    for i, v in ipairs(lst) do\n        if min ==\
    \ nil or v < min then\n            min2 = min\n            min = v\n        elseif\
    \ min2 == nil or v < min2 then\n            min2 = v\n        end\n    end\n \
    \   return min2\nend", "    table.sort(lst)\n    local min1 = lst[1]\n    local\
    \ min2 = nil\n    for _, value in ipairs(lst) do\n        if value > min1 then\n\
    \            min2 = value\n            break\n        end\n    end\n    return\
    \ min2\nend", "  if #lst <= 1 then\n    return nil\n  end\n  local smallest =\
    \ math.min(table.unpack(lst))\n  local candidate = smallest\n  for _,x in ipairs(lst)\
    \ do\n    if x ~= smallest and x < candidate then\n      candidate = x\n    end\n\
    \  end\n  if candidate == smallest then\n    return nil\n  else\n    return candidate\n\
    \  end\nend", "  local min, min2 = math.huge, math.huge\n  for _, x in ipairs(lst)\
    \ do\n    if x < min then\n      min2 = min\n      min = x\n    elseif x < min2\
    \ then\n      min2 = x\n    end\n  end\n  return min2 < math.huge and min2 or\
    \ nil\nend", "  local sorted_lst = sort(lst)\n  local min = first(sorted_lst)\n\
    \  for i, v in ipairs(sorted_lst) do\n    if v > min then\n      return v\n  \
    \  end\n  end\n  return nil\nend", "\tlocal min = math.huge\n\tlocal min2 = math.huge\n\
    \tfor _, v in ipairs(lst) do\n\t\tif v < min then\n\t\t\tmin2 = min\n\t\t\tmin\
    \ = v\n\t\telseif v > min and v < min2 then\n\t\t\tmin2 = v\n\t\tend\n\tend\n\t\
    if min2 == math.huge then\n\t\treturn nil\n\tend\n\treturn min2\nend", "    local\
    \ min1, min2 = math.maxinteger, math.maxinteger\n    for _, v in ipairs(lst) do\n\
    \        if v < min1 then\n            min2 = min1\n            min1 = v\n   \
    \     elseif v < min2 then\n            min2 = v\n        end\n    end\n    return\
    \ min2 == math.maxinteger and nil or min2\nend", "    -- TODO\nend", "    local\
    \ min, min2 = math.huge, math.huge\n    for _, v in ipairs(lst) do\n        if\
    \ v <= min then\n            min2 = min\n            min = v\n        elseif v\
    \ < min2 then\n            min2 = v\n        end\n    end\n    return min == min2\
    \ and nil or min2\nend", "  return nil\nend", "    if #lst == 0 then\n       \
    \ return nil\n    end\n    if #lst == 1 then\n        return nil\n    end\n  \
    \  if #lst == 2 then\n        if lst[1] ~= lst[2] then\n            return math.min(lst[1],\
    \ lst[2])\n        else\n            return nil\n        end\n    end\n    local\
    \ min, second_min = math.huge, math.huge\n    for _, v in ipairs(lst) do\n   \
    \     if v < min then\n            second_min = min\n            min = v\n   \
    \     elseif v < second_min then\n            second_min = v\n        end\n  \
    \  end\n    if second_min == math.huge then\n        return nil\n    else\n  \
    \      return second_min\n    end\nend", "  -- your code here\nend", "    -- first\
    \ check list length\n    if #lst < 2 then\n        return nil\n    end\n    --\
    \ next make a copy of the list and sort it\n    local copy = copy_lst(lst)\n \
    \   table.sort(copy)\n    -- then find first non-matching element (should be 2nd\
    \ smallest)\n    for i = 1, #copy - 1 do\n        if copy[i] ~= copy[i + 1] then\n\
    \            return copy[i + 1]\n        end\n    end\n    -- if you made it here,\
    \ there was no second smallest element\n    return nil\nend", "    local ans =\
    \ nil\n    for _, v in ipairs(lst) do\n        if not ans or ans > v then\n  \
    \          ans = v\n        end\n    end\n    local min\n    for _, v in ipairs(lst)\
    \ do\n        if v ~= ans and (not min or min > v) then\n            min = v\n\
    \        end\n    end\n    return min\nend", "  local min, min2 = lst[1], lst[2]\n\
    \  for i = 1, #lst do\n    if lst[i] <= min then\n      min2 = min\n      min\
    \ = lst[i]\n    elseif lst[i] < min2 then\n      min2 = lst[i]\n    end\n  end\n\
    \  return min == min2 and nil or min2\nend", "    local smallest = math.huge\n\
    \    local second_smallest = math.huge\n    for _, val in ipairs(lst) do\n   \
    \     if val < smallest then\n            second_smallest = smallest\n       \
    \     smallest = val\n        elseif val < second_smallest then\n            second_smallest\
    \ = val\n        end\n    end\n    if second_smallest == math.huge then\n    \
    \    return nil\n    else\n        return second_smallest\n    end\nend", "  \
    \  if #lst == 0 then\n        return nil\n    end\n    local current_min = math.min(unpack(lst))\n\
    \    local min_index = table.indexof(lst, current_min)\n    table.remove(lst,\
    \ min_index)\n    return math.min(unpack(lst))\nend", "  local min = math.min(unpack(lst))\n\
    \  for _, v in ipairs(lst) do\n    if v ~= min then\n      return v\n    end\n\
    \  end\n  return nil\nend", "  -- \u5B9A\u4E49\u4E00\u4E2Anil, \u4F5C\u4E3A\u9ED8\
    \u8BA4\u503C\n  local p, q = math.maxinteger, nil\n  for _, v in ipairs(lst) do\n\
    \    if v < p then\n      q, p = p, v\n    elseif v < q then\n      q = v\n  \
    \  end\n  end\n  return q\nend", "  table.sort(lst)\n  if #lst == 0 then\n   \
    \ return nil\n  end\n  if #lst == 1 then\n    return nil\n  end\n  if lst[1] ==\
    \ lst[2] then\n    return nil\n  end\n  return lst[2]\nend", "    local smallest\
    \ = math.huge\n    local second = math.huge\n    for _, i in ipairs(lst) do\n\
    \        if i < smallest then\n            second = smallest\n            smallest\
    \ = i\n        elseif i < second then\n            second = i\n        end\n \
    \   end\n    if second == math.huge then\n        return nil\n    else\n     \
    \   return second\n    end\nend", "\t-- Your code here\n\treturn nil\nend", " \
    \   local min, next_min\n    for _, elem in ipairs(lst) do\n        if not min\
    \ or elem < min then\n            next_min = min\n            min = elem\n   \
    \     elseif not next_min or elem < next_min then\n            next_min = elem\n\
    \        end\n    end\n    return next_min\nend", "  if (lst == nil) then return\
    \ nil end\n  local smallest = lst[1]\n  local next_smallest = nil\n  for i, v\
    \ in ipairs(lst) do\n    if (v < smallest) then\n      next_smallest = smallest\n\
    \      smallest = v\n    elseif (v < next_smallest) then\n      next_smallest\
    \ = v\n    end\n  end\n  return next_smallest\nend", "    if #lst < 2 then\n \
    \       return nil\n    end\n    local min = math.min(unpack(lst))\n    local\
    \ snd_min = math.huge\n    for _, n in ipairs(lst) do\n        if n > min and\
    \ n < snd_min then\n            snd_min = n\n        end\n    end\n    if snd_min\
    \ == math.huge then\n        return nil\n    end\n    return snd_min\nend", " \
    \   if #lst < 2 then\n        return nil\n    end\n    -- Create a list with values\
    \ 1-len(lst)\n    local sorted_list = {}\n    for i = 1, #lst do\n        sorted_list[i]\
    \ = i\n    end\n    -- Sort the indices of the list with bubble sort\n    local\
    \ swap = true\n    while swap do\n        swap = false\n        for i = 1, #lst\
    \ - 1 do\n            if lst[sorted_list[i]] > lst[sorted_list[i + 1]] then\n\
    \                sorted_list[i], sorted_list[i + 1] = sorted_list[i + 1], sorted_list[i]\n\
    \                swap = true\n            end\n        end\n    end\n    return\
    \ lst[sorted_list[2]]\nend", "    local min, min2 = math.huge, math.huge\n   \
    \ for _, v in ipairs(lst) do\n        if v < min then\n            min2 = min\n\
    \            min = v\n        elseif v < min2 then\n            min2 = v\n   \
    \     end\n    end\n    return min2 ~= math.huge and min2 or nil\nend", "    local\
    \ smallest = math.huge\n    local second = math.huge\n    for _, v in ipairs(lst)\
    \ do\n        if v < smallest then\n            second = smallest\n          \
    \  smallest = v\n        elseif v < second then\n            second = v\n    \
    \    end\n    end\n    if second == math.huge then\n        return nil\n    else\n\
    \        return second\n    end\nend", "    local next_smallest = math.huge\n\
    \    local smallest = math.huge\n    for i = 1, #lst do\n        if lst[i] < smallest\
    \ then\n            next_smallest = smallest\n            smallest = lst[i]\n\
    \        elseif lst[i] < next_smallest then\n            next_smallest = lst[i]\n\
    \        end\n    end\n    if next_smallest == math.huge then\n        return\
    \ nil\n    else\n        return next_smallest\n    end\nend", "  local smallest\
    \ = math.huge\n  local ret = math.huge\n  for _, v in ipairs(lst) do\n    if v\
    \ < smallest then\n      ret = smallest\n      smallest = v\n    elseif v < ret\
    \ then\n      ret = v\n    end\n  end\n  return ret == math.huge and nil or ret\n\
    end", "    local minimum = math.min(unpack(lst))\n    local seccnd = math.max(unpack(lst))\n\
    \    for i = 1, #lst do\n        if lst[i] == minimum then\n            goto continue\n\
    \        end\n        if lst[i] < seccnd then\n            seccnd = lst[i]\n \
    \       end\n        ::continue::\n    end\n    if seccnd == math.max(unpack(lst))\
    \ then\n        return nil\n    end\n    return seccnd\nend", "    if (next(lst)\
    \ == nil) then\n        return nil\n    end\n    local lst_sorted = {}\n    for\
    \ k, v in pairs(lst) do\n        lst_sorted[k] = v\n    end\n    local swap =\
    \ function(lst, i, j)\n        lst[i], lst[j] = lst[j], lst[i]\n    end\n    for\
    \ i = 1, #lst_sorted do\n        for j = i + 1, #lst_sorted do\n            if\
    \ (lst_sorted[i] > lst_sorted[j]) then\n                swap(lst_sorted, i, j)\n\
    \            end\n        end\n    end\n    if (#lst_sorted < 2) then\n      \
    \  return nil\n    end\n    return lst_sorted[2]\nend", "    if #lst == 0 then\n\
    \        return nil\n    end\n    local min, min2 = lst[1], nil\n    for i = 2,\
    \ #lst do\n        if lst[i] < min then\n            min2 = min\n            min\
    \ = lst[i]\n        elseif lst[i] < min2 or min2 == nil then\n            min2\
    \ = lst[i]\n        end\n    end\n    return min2\nend", "    local min1, min2\n\
    \    for i,v in ipairs(lst) do\n        if not min1 or v < min1 then\n       \
    \     min2 = min1\n            min1 = v\n        elseif not min2 or v < min2 then\n\
    \            min2 = v\n        end\n    end\n    return min2\nend", "    local\
    \ min1, min2\n    for _, i in ipairs(lst) do\n        if not min1 or i < min1\
    \ then\n            min2 = min1\n            min1 = i\n        elseif not min2\
    \ or i < min2 then\n            min2 = i\n        end\n    end\n    return min2\n\
    end", "    -- your code here\nend", "    -- your code here\nend", "    local first,\
    \ second = math.huge, math.huge\n    for _, e in ipairs(lst) do\n        if e\
    \ < first then\n            second = first\n            first = e\n        elseif\
    \ e < second then\n            second = e\n        end\n    end\n    return second\
    \ == math.huge and nil or second\nend", "  local size = 0\n  for _ in pairs(lst)\
    \ do size = size + 1 end\n  if size < 2 then return nil end\n  local v1, v2\n\
    \  for _, v in pairs(lst) do\n    if not v1 or v < v1 then\n      v2 = v1\n  \
    \    v1 = v\n    elseif not v2 or v < v2 then\n      v2 = v\n    end\n  end\n\
    \  return v2\nend", "\treturn nil\nend", "    local smallest = lst[1]\n    local\
    \ smallest_i = 1\n    local second_smallest\n    local second_smallest_i\n   \
    \ for i = 2, #lst do\n        if lst[i] < smallest then\n            second_smallest\
    \ = smallest\n            second_smallest_i = smallest_i\n            smallest\
    \ = lst[i]\n            smallest_i = i\n        elseif lst[i] > smallest and\n\
    \               (second_smallest == nil or lst[i] < second_smallest) then\n  \
    \          second_smallest = lst[i]\n            second_smallest_i = i\n     \
    \   end\n    end\n    if smallest_i == second_smallest_i then\n        return\
    \ nil\n    else\n        return second_smallest\n    end\nend", "  if #lst < 2\
    \ then\n    return nil\n  end\n  table.sort(lst)\n  local min = lst[1]\n  local\
    \ min2 = nil\n  for _, val in ipairs(lst) do\n    if val > min then\n      if\
    \ min2 == nil or val < min2 then\n        min2 = val\n      end\n    end\n  end\n\
    \  return min2\nend", "  local tbl = {}\n  local unique = {}\n  local found =\
    \ false\n  if not lst or #lst < 2 then\n    return nil\n  end\n  for i, v in ipairs(lst)\
    \ do\n    if not unique[v] then\n      table.insert(tbl, v)\n      unique[v] =\
    \ true\n    end\n  end\n  if #tbl < 2 then\n    return nil\n  end\n  table.sort(tbl)\n\
    \  for i = 2, #tbl do\n    if tbl[i] > tbl[1] then\n      return tbl[i]\n    end\n\
    \  end\n  return nil\nend", "    table.sort(lst)\n    local found = false\n  \
    \  local last = nil\n    for _, v in ipairs(lst) do\n        if v ~= last then\n\
    \            if found then\n                return v\n            end\n      \
    \      found = true\n            last = v\n        end\n    end\n    return nil\n\
    end", "\tlocal min1, min2 = math.huge, math.huge\n\tfor _, x in ipairs(lst) do\n\
    \t\tif x < min1 then\n\t\t\tmin2 = min1\n\t\t\tmin1 = x\n\t\telseif x < min2 then\n\
    \t\t\tmin2 = x\n\t\tend\n\tend\n\treturn min2 ~= math.huge and min2 or nil\nend",
  "    local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    local n = #lst\n    local count = {}\n    for i = 1, n do\n        count[lst[i]]\
    \ = (count[lst[i]] or 0) + 1\n    end\n    if count[min] == n then\n        return\
    \ nil\n    end\n    for i = min + 1, max do\n        if count[i] then\n      \
    \      return i\n        end\n    end\nend", "    return lst[2]\nend", "    local\
    \ min = math.min(unpack(lst))\n    local found, ret\n    for _, v in ipairs(lst)\
    \ do\n        if v ~= min then\n            if not found or v < ret then\n   \
    \             found = true\n                ret = v\n            end\n       \
    \ end\n    end\n    return ret\nend", "    local _, res = next({nil, unpack(lst)}):sort()\n\
    \    return res\nend", "    local smallest, second_smallest = math.huge, math.huge\n\
    \    for _, v in ipairs(lst) do\n        if v < smallest then\n            second_smallest\
    \ = smallest\n            smallest = v\n        elseif v < second_smallest then\n\
    \            second_smallest = v\n        end\n    end\n    return smallest ==\
    \ second_smallest and nil or second_smallest\nend", "  local sorted = {}\n  for\
    \ _, v in ipairs(lst) do\n    table.insert(sorted, v)\n  end\n  table.sort(sorted)\n\
    \  for i, v in ipairs(sorted) do\n    if v ~= sorted[1] then\n      return v\n\
    \    end\n  end\n  return nil\nend", "    local smallest = math.huge\n    local\
    \ next_smallest = math.huge\n    for _, v in ipairs(lst) do\n        if v < smallest\
    \ then\n            next_smallest = smallest\n            smallest = v\n     \
    \   elseif v < next_smallest then\n            next_smallest = v\n        end\n\
    \    end\n    if next_smallest == math.huge then\n        return nil\n    else\n\
    \        return next_smallest\n    end\nend", "    local min_index, min_value\
    \ = next(lst, nil)\n    local min2_index, min2_value\n    for index, value in\
    \ next, lst, min_index do\n        if value < min_value then\n            min2_index,\
    \ min2_value = min_index, min_value\n            min_index, min_value = index,\
    \ value\n        elseif not min2_index or value < min2_value then\n          \
    \  min2_index, min2_value = index, value\n        end\n    end\n    return min2_value\n\
    end", "    if not lst then return nil end\n    local min, min2 = math.huge, math.huge\n\
    \    for i = 1, #lst do\n        if lst[i] < min then\n            min2 = min\n\
    \            min = lst[i]\n        elseif lst[i] < min2 then\n            min2\
    \ = lst[i]\n        end\n    end\n    return min2 == math.huge and nil or min2\n\
    end", "    local min_ = lst[1]\n    local min2_ = nil\n    for _, v in ipairs(lst)\
    \ do\n        if v < min_ then\n            min2_ = min_\n            min_ = v\n\
    \        elseif min2_ == nil or v < min2_ then\n            min2_ = v\n      \
    \  end\n    end\n    return min2_\nend", "  if #lst < 2 then\n    return nil\n\
    \  end\n  local smallest = math.huge\n  local second_smallest = math.huge\n  for\
    \ _, val in ipairs(lst) do\n    if val < smallest then\n      second_smallest\
    \ = smallest\n      smallest = val\n    elseif val < second_smallest then\n  \
    \    second_smallest = val\n    end\n  end\n  if second_smallest == math.huge\
    \ then\n    return nil\n  end\n  return second_smallest\nend", "    local first\
    \ = math.huge\n    local second = math.huge\n    for _, n in ipairs(lst) do\n\
    \        if n < first then\n            second = first\n            first = n\n\
    \        elseif n < second then\n            second = n\n        end\n    end\n\
    \    return second ~= math.huge and second or nil\nend", "    local cur_min =\
    \ math.min(table.unpack(lst))\n    local cur_max = math.max(table.unpack(lst))\n\
    \    local result = cur_max\n    for _, v in ipairs(lst) do\n        if cur_min\
    \ < v and v < result then\n            result = v\n        end\n    end\n    if\
    \ result == cur_max then\n        return nil\n    end\n    return result\nend",
  "    -- find the smallest number and its index\n    local smallest = lst[1]\n  \
    \  local smallest_index = 1\n    for i,v in ipairs(lst) do\n        if v < smallest\
    \ then\n            smallest = v\n            smallest_index = i\n        end\n\
    \    end\n    -- find the second smallest number\n    local second_smallest =\
    \ lst[1]\n    for i,v in ipairs(lst) do\n        if i ~= smallest_index and v\
    \ < second_smallest then\n            second_smallest = v\n        end\n    end\n\
    \    -- return the second smallest number\n    return second_smallest\nend", " \
    \   if #lst == 0 then\n        return\n    end\n    local min, second_min = math.huge,\
    \ math.huge\n    for _, v in ipairs(lst) do\n        if v < min then\n       \
    \     second_min = min\n            min = v\n        elseif v < second_min then\n\
    \            second_min = v\n        end\n    end\n    return second_min ~= math.huge\
    \ and second_min or nil\nend", "    return (lst and table.sort(lst)[2]) or nil\n\
    end", "    if #lst < 2 then\n        return nil\n    end\n    local min1, min2\
    \ = math.huge, math.huge\n    for _, x in ipairs(lst) do\n        if x < min1\
    \ then\n            min2 = min1\n            min1 = x\n        elseif x < min2\
    \ then\n            min2 = x\n        end\n    end\n    return min2\nend", " \
    \   if #lst < 2 then\n        return nil\n    end\n    local min = math.min(unpack(lst))\n\
    \    table.remove(lst, index_of(lst, min))\n    return math.min(unpack(lst))\n\
    end", "    local max, min = -math.huge, math.huge\n    local second = math.huge\n\
    \    local flag = false\n    for _, v in ipairs(lst) do\n        if v > max then\n\
    \            max = v\n        end\n        if v < min then\n            min =\
    \ v\n        end\n    end\n    for _, v in ipairs(lst) do\n        if v > min\
    \ and v < second then\n            second = v\n            flag = true\n     \
    \   end\n    end\n    if flag then\n        return second\n    else\n        return\
    \ nil\n    end\nend", "    local min1, min2 = math.huge, math.huge\n    for _,\
    \ v in ipairs(lst) do\n        if v < min1 then\n            min2 = min1\n   \
    \         min1 = v\n        elseif v < min2 then\n            min2 = v\n     \
    \   end\n    end\n    return min2 ~= math.huge and min2 or nil\nend", "\ttable.sort(lst)\n\
    \tif #lst <= 1 then\n\t\treturn nil\n\tend\n\tfor i = 2, #lst do\n\t\tif lst[i]\
    \ ~= lst[1] then\n\t\t\treturn lst[i]\n\t\tend\n\tend\n\treturn nil\nend", " \
    \ local sorted = {}\n  local n = 0\n  for _, v in ipairs(lst) do\n    if n ==\
    \ 0 then\n      sorted[1] = v\n      n = n + 1\n    elseif v < sorted[1] then\n\
    \      sorted[2] = sorted[1]\n      sorted[1] = v\n    elseif n == 1 then\n  \
    \    sorted[2] = v\n      n = n + 1\n    elseif v < sorted[2] then\n      sorted[2]\
    \ = v\n    end\n  end\n  if n < 2 then\n    return nil\n  else\n    return sorted[2]\n\
    \  end\nend", "    if #lst < 2 then\n        return nil\n    end\n    local smallest,\
    \ next_smallest_value\n    for _, v in ipairs(lst) do\n        if smallest ==\
    \ nil or v < smallest then\n            next_smallest_value = smallest\n     \
    \       smallest = v\n        elseif next_smallest_value == nil or v < next_smallest_value\
    \ then\n            next_smallest_value = v\n        end\n    end\n    return\
    \ next_smallest_value\nend", "    local smallest = math.huge\n    local secondsmallest\
    \ = math.huge\n    for _, elem in ipairs(lst) do\n        if elem < smallest then\n\
    \            secondsmallest = smallest\n            smallest = elem\n        elseif\
    \ elem < secondsmallest then\n            secondsmallest = elem\n        end\n\
    \    end\n    if secondsmallest == math.huge then\n        return nil\n    else\n\
    \        return secondsmallest\n    end\nend", "    local min = math.huge\n  \
    \  local min2 = math.huge\n    for _, val in ipairs(lst) do\n        if val <\
    \ min then\n            min2 = min\n            min = val\n        elseif val\
    \ > min and val < min2 then\n            min2 = val\n        end\n    end\n  \
    \  if min2 == math.huge then\n        return nil\n    else\n        return min2\n\
    \    end\nend", "    -- sort the list first\n    local sort = {}\n    for i =\
    \ 1, #lst do\n        if i == 1 then\n            sort[i] = lst[i]\n        else\n\
    \            for j = 1, i do\n                if lst[i] < sort[j] then\n     \
    \               for k = i - 1, j, -1 do\n                        sort[k + 1] =\
    \ sort[k]\n                    end\n                    sort[j] = lst[i]\n   \
    \                 break\n                end\n                if j == i then\n\
    \                    sort[j] = lst[i]\n                end\n            end\n\
    \        end\n    end\n    -- check if there is a second smallest\n    local smallest\
    \ = sort[1]\n    local second_smallest = nil\n    for i = 2, #sort do\n      \
    \  if sort[i] > smallest then\n            second_smallest = sort[i]\n       \
    \     break\n        end\n    end\n    return second_smallest\nend", "    local\
    \ function find_smallest(lst, smallest, second_smallest)\n        if #lst == 0\
    \ then\n            return second_smallest\n        end\n        if lst[1] < smallest\
    \ then\n            second_smallest = smallest\n            smallest = lst[1]\n\
    \        elseif lst[1] < second_smallest then\n            second_smallest = lst[1]\n\
    \        end\n        return find_smallest(tail(lst), smallest, second_smallest)\n\
    \    end\n    if #lst < 2 then\n        return nil\n    end\n    return find_smallest(tail(lst),\
    \ lst[1], lst[1])\nend", "    local set, min1, min2 = {}, math.huge, math.huge\n\
    \    for _, v in ipairs(lst) do\n        if set[v] == nil then\n            set[v]\
    \ = 1\n            if v < min1 then\n                min2 = min1\n           \
    \     min1 = v\n            elseif v < min2 then\n                min2 = v\n \
    \           end\n        end\n    end\n    return min2 ~= math.huge and min2 or\
    \ nil\nend", "  local max = math.maxinteger\n  local min = math.mininteger\n \
    \ for _, v in ipairs(lst) do\n    if v > min and v < max then\n      max = v\n\
    \    end\n  end\n  return max ~= math.maxinteger and max or nil\nend", "    local\
    \ set = {}\n    for _, v in ipairs(lst) do\n        set[v] = true\n    end\n \
    \   table.sort(lst)\n    for _, v in ipairs(lst) do\n        if set[v + 1] then\n\
    \            return v\n        end\n    end\n    return nil\nend", "    table.sort(lst)\n\
    \    return lst[2] or nil\nend", "  -- TODO: Implement your solution here\nend",
  "    local mi, mi2 = math.min(table.unpack(lst))\n    if mi == mi2 then\n      \
    \  return nil\n    end\n    return mi2\nend", "  local min = math.min(unpack(lst))\n\
    \  local min_index = table.indexof(lst, min)\n  table.remove(lst, min_index)\n\
    \  if lst then\n    return math.min(unpack(lst))\n  else\n    return nil\n  end\n\
    end", "    return nil\nend", "  -- TODO\nend", "  local t = {}\n  for i = 1, #lst\
    \ do\n    if lst[i] > 0 then\n      t[#t + 1] = lst[i]\n    end\n  end\n  if #t\
    \ < 2 then\n    return nil\n  end\n  table.sort(t)\n  return t[2]\nend", "   \
    \ local tbl = {}\n    local smallest = math.huge\n    local count = 0\n    for\
    \ k, v in pairs(lst) do\n        if (v < smallest) then\n            smallest\
    \ = v\n        end\n        if not (tbl[v]) then\n            tbl[v] = 0\n   \
    \     end\n        tbl[v] = tbl[v] + 1\n    end\n    for k, v in pairs(tbl) do\n\
    \        if (k ~= smallest) then\n            count = count + 1\n            if\
    \ (count == 2) then\n                return k\n            end\n        end\n\
    \    end\n    return nil\nend", "    local sorted = {}\n    local set = {}\n \
    \   for _, v in ipairs(lst) do\n        set[v] = true\n    end\n    for k in pairs(set)\
    \ do\n        table.insert(sorted, k)\n    end\n    table.sort(sorted)\n    if\
    \ #sorted >= 2 then\n        return sorted[2]\n    else\n        return nil\n\
    \    end\nend", "    table.sort(lst)\n    if lst[1] == lst[2] then\n        return\
    \ nil\n    end\n    return lst[2]\nend", "    if not lst then return nil end\n\
    \    if #lst < 2 then return nil end\n    local min, max = nil, nil\n    for _,\
    \ val in ipairs(lst) do\n        if not min or val < min then\n            max\
    \ = min\n            min = val\n        elseif not max or val < max then\n   \
    \         max = val\n        end\n    end\n    return max\nend", "\ttable.sort(lst)\n\
    \tif #lst <= 1 then\n\t\treturn nil\n\tend\n\tlocal i = 1\n\twhile i <= #lst do\n\
    \t\tif lst[i] ~= lst[i+1] then\n\t\t\treturn lst[i+1]\n\t\tend\n\t\ti = i + 1\n\
    \tend\n\treturn nil\nend", "    local min = math.min(unpack(lst))\n    local max\
    \ = math.max(unpack(lst))\n    local unique = {}\n    for _, item in ipairs(lst)\
    \ do\n        unique[item] = (unique[item] or 0) + 1\n    end\n    if unique[min]\
    \ > 1 then\n        return nil\n    end\n    for i = min + 1, max do\n       \
    \ if unique[i] then\n            return i\n        end\n    end\n    return nil\n\
    end\nprint(next_smallest({1, 2, 3, 4, 5}))\nprint(next_smallest({5, 1, 4, 3, 2}))\n\
    print(next_smallest({}))\nprint(next_smallest({1, 1}))", "    local min, min2\
    \ = math.maxinteger, math.maxinteger\n    for _, num in ipairs(lst) do\n     \
    \   if num < min then\n            min2 = min\n            min = num\n       \
    \ elseif num < min2 then\n            min2 = num\n        end\n    end\n    return\
    \ min2 ~= math.maxinteger and min2 or nil\nend", "  -- your code here\nend", " \
    \   if (#lst < 2) then\n        return nil\n    end\n    table.sort(lst)\n   \
    \ return lst[2]\nend", "  local min, min2, is_exists = math.huge, math.huge, false\n\
    \  for _, value in ipairs(lst) do\n    if value < min then\n      min2 = min\n\
    \      min = value\n      is_exists = true\n    elseif value < min2 then\n   \
    \   min2 = value\n    end\n  end\n  return is_exists and min2 or nil\nend", " \
    \   local n = #lst\n    if n < 2 then\n        return nil\n    end\n    -- Use\
    \ bubble sort to find the 2nd smallest element.\n    local cur = lst[1]\n    local\
    \ next\n    for i = 2, n do\n        next = lst[i]\n        if next < cur then\n\
    \            lst[i] = cur\n            lst[i - 1] = next\n            cur = next\n\
    \        end\n    end\n    return lst[2]\nend", "  if #lst < 2 then\n    return\
    \ nil\n  end\n  local min = math.min(unpack(lst))\n  local min2 = min\n  for _,\
    \ elem in ipairs(lst) do\n    if elem ~= min and elem < min2 then\n      min2\
    \ = elem\n    end\n  end\n  if min2 == min then\n    return nil\n  end\n  return\
    \ min2\nend", "  if #lst <= 1 then\n    return nil\n  end\n  local min1, min2\
    \ = lst[1], lst[2]\n  if min1 > min2 then\n    min1, min2 = min2, min1\n  end\n\
    \  for i = 3, #lst do\n    local el = lst[i]\n    if el < min1 then\n      min2\
    \ = min1\n      min1 = el\n    elseif el < min2 then\n      min2 = el\n    end\n\
    \  end\n  return min2\nend", "\t--your code here\n\tlocal smallest = lst[1]\n\t\
    local small = lst[1]\n\tfor i = 1, #lst do\n\t\tif lst[i] < smallest then\n\t\t\
    \tsmallest = lst[i]\n\t\tend\n\tend\n\tfor i = 1, #lst do\n\t\tif lst[i] > smallest\
    \ and lst[i] < small then\n\t\t\tsmall = lst[i]\n\t\tend\n\tend\n\tif small ==\
    \ lst[1] then\n\t\treturn nil\n\telse\n\t\treturn small\n\tend\nend", "  local\
    \ min_val, min_idx, min2_val, min2_idx = math.huge, nil, math.huge, nil\n  for\
    \ idx, val in ipairs(lst) do\n    if val < min_val then\n      min2_val, min2_idx\
    \ = min_val, min_idx\n      min_val, min_idx = val, idx\n    elseif val < min2_val\
    \ then\n      min2_val, min2_idx = val, idx\n    end\n  end\n  return min2_idx\
    \ and min2_val\nend", "  local min, second = lst[1], nil\n  for i = 2, #lst do\n\
    \    if lst[i] < min then\n      second = min\n      min = lst[i]\n    elseif\
    \ not second or lst[i] < second then\n      second = lst[i]\n    end\n  end\n\
    \  return second\nend", "\t-- [ YOUR CODE HERE ]\n\t-- use table.sort(lst) to\
    \ sort lst\n\ttable.sort(lst)\n\t-- use # to get the length of lst\n\tlocal len\
    \ = #lst\n\t-- use for-in to loop lst\n\tfor i, v in ipairs(lst) do\n\t\t-- use\
    \ i+1 to get the index of next\n\t\t-- if the next one is not nil, return it\n\
    \t\tif lst[i+1] ~= nil then\n\t\t\treturn lst[i+1]\n\t\tend\n\tend\n\t-- return\
    \ nil if not found\n\treturn nil\nend", "    -- your code here\nend", "    table.sort(lst)\n\
    \    return lst[2]\nend", "  local n = #lst\n  if n <= 1 then return nil end\n\
    \  local smallest = lst[1]\n  local next_smallest = nil\n  for i = 2, n do\n \
    \   local x = lst[i]\n    if x < smallest then\n      next_smallest = smallest\n\
    \      smallest = x\n    elseif next_smallest == nil or x < next_smallest then\n\
    \      next_smallest = x\n    end\n  end\n  return next_smallest\nend", "    if\
    \ #lst < 2 then\n        return nil\n    end\n    local smallest = math.min(unpack(lst))\n\
    \    local second_smallest = math.max(unpack(lst))\n    for _, i in ipairs(lst)\
    \ do\n        if i ~= smallest and i < second_smallest then\n            second_smallest\
    \ = i\n        end\n    end\n    if second_smallest == math.max(unpack(lst)) then\n\
    \        return nil\n    end\n    return second_smallest\nend", "    -- your code\
    \ here\n    local min, max = math.min(table.unpack(lst)), math.max(table.unpack(lst))\n\
    \    local function get_value(t)\n        if t == nil then\n            return\n\
    \        end\n        local val = table.remove(t, 1)\n        return val, table.concat(t,\
    \ ',')\n    end\n    local function next_smallest_helper(cur_min, cur_max, lst)\n\
    \        if #lst == 0 then\n            return nil\n        end\n        if cur_min\
    \ < cur_max then\n            return cur_min\n        end\n        local val,\
    \ lst = get_value(lst)\n        return next_smallest_helper(val, cur_min, lst\
    \ and lst:split(',') or {})\n    end\n    return next_smallest_helper(max, min,\
    \ lst)\nend", "    if #lst < 2 then\n        return nil\n    end\n    local min\
    \ = lst[1]\n    local second = nil\n    for i = 2, #lst do\n        if lst[i]\
    \ < min then\n            second = min\n            min = lst[i]\n        elseif\
    \ lst[i] < second or second == nil then\n            second = lst[i]\n       \
    \ end\n    end\n    return second\nend", "    table.sort(lst)\n    return lst[2]\n\
    end\nprint(next_smallest({1, 2, 3, 4, 5}))\nprint(next_smallest({5, 1, 4, 3, 2}))\n\
    print(next_smallest({}))\nprint(next_smallest({1, 1}))", "\tif #lst < 2 then\n\
    \t\treturn nil\n\tend\n\tlocal smallest = math.huge\n\tlocal second = math.huge\n\
    \tfor i = 1, #lst do\n\t\tif lst[i] < smallest then\n\t\t\tsecond = smallest\n\
    \t\t\tsmallest = lst[i]\n\t\telseif lst[i] < second then\n\t\t\tsecond = lst[i]\n\
    \t\tend\n\tend\n\tif second == math.huge then\n\t\treturn nil\n\tend\n\treturn\
    \ second\nend", "    -- TODO\nend", "    local smallest, smallest2 = math.huge,\
    \ math.huge\n    for _, v in ipairs(lst) do\n        if v <= smallest then\n \
    \           smallest2 = smallest\n            smallest = v\n        elseif v <\
    \ smallest2 then\n            smallest2 = v\n        end\n    end\n    return\
    \ smallest == smallest2 and nil or smallest2\nend", "    local min1, min2 = math.maxinteger,\
    \ math.maxinteger\n    for _, v in ipairs(lst) do\n        if v < min1 then\n\
    \            min2 = min1\n            min1 = v\n        elseif v < min2 then\n\
    \            min2 = v\n        end\n    end\n    return min2 < math.maxinteger\
    \ and min2 or nil\nend\n_exports.next_smallest = next_smallest", "  local min1,\
    \ min2 = math.huge, math.huge\n  for _, v in ipairs(lst) do\n    if v < min1 then\n\
    \      min2 = min1\n      min1 = v\n    elseif v < min2 then\n      min2 = v\n\
    \    end\n  end\n  return min2 == math.huge and nil or min2\nend", "  if not lst\
    \ or #lst < 2 then return nil end\n  local next\n  local first = math.huge\n \
    \ for i,v in ipairs(lst) do\n    if v < first then\n      first = v\n      next\
    \ = math.huge\n    elseif v < next then\n      next = v\n    end\n  end\n  return\
    \ next\nend", "  -- your code here\n  -- return the 2nd smallest element of the\
    \ table\n  -- return \"None\" if there is no such element\n  -- or return nil\n\
    end", "    local res, res2 = math.huge, math.huge\n    for _, v in ipairs(lst)\
    \ do\n        if v < res then\n            res2 = res\n            res = v\n \
    \       elseif v < res2 then\n            res2 = v\n        end\n    end\n   \
    \ return res == math.huge and nil or res2\nend", "    local curr_smallest = lst[1]\n\
    \    local next_smallest = nil\n    for i = 2, #lst do\n        if lst[i] < curr_smallest\
    \ then\n            next_smallest = curr_smallest\n            curr_smallest =\
    \ lst[i]\n        elseif next_smallest == nil or lst[i] < next_smallest then\n\
    \            next_smallest = lst[i]\n        end\n    end\n    return next_smallest\n\
    end", "    local min = lst[1]\n    local nmin = nil\n    for i,v in ipairs(lst)\
    \ do\n        if v < min then\n            nmin = min\n            min = v\n \
    \       elseif v < nmin then\n            nmin = v\n        end\n    end\n   \
    \ return nmin\nend", "  if #lst == 0 then\n    return nil\n  end\n  local smallest\
    \ = lst[1]\n  local second_smallest = nil\n  for _, v in ipairs(lst) do\n    if\
    \ v < smallest then\n      second_smallest = smallest\n      smallest = v\n  \
    \  elseif second_smallest == nil then\n      second_smallest = v\n    elseif v\
    \ < second_smallest then\n      second_smallest = v\n    end\n  end\n  return\
    \ second_smallest\nend", "    local min = lst[1]\n    local ret = 0\n    for k,\
    \ v in pairs(lst) do\n        if min > v then\n            ret = min\n       \
    \     min = v\n        elseif ret > v then\n            ret = v\n        end\n\
    \    end\n    return ret\nend", "  local function get_first_key(t)\n    local\
    \ k, v = next(t)\n    return k\n  end\n  local function get_first_value(t)\n \
    \   local k, v = next(t)\n    return v\n  end\n  local function get_second_key(t)\n\
    \    local k, v = next(t)\n    k, v = next(t, k)\n    return k\n  end\n  local\
    \ function get_second_value(t)\n    local k, v = next(t)\n    k, v = next(t, k)\n\
    \    return v\n  end\n  local function set_second_key(t, k, v)\n    local k1,\
    \ v1 = next(t)\n    k1, v1 = next(t, k1)\n    t[k1] = v\n  end\n  local s = {}\n\
    \  for _, v in ipairs(lst) do\n    if not s[v] then\n      s[v] = 0\n    end\n\
    \    s[v] = s[v] + 1\n  end\n  local keys = {}\n  for k, v in pairs(s) do\n  \
    \  table.insert(keys, k)\n  end\n  if #keys < 2 then\n    return nil\n  end\n\
    \  table.sort(keys)\n  local c, f, s = s, get_first_key(s), get_second_key(s)\n\
    \  local v = c[f]\n  if c[s] == 1 then\n    c[s] = nil\n    set_second_key(c,\
    \ f, nil)\n  else\n    c[s] = c[s] - 1\n  end\n  if v == 1 then\n    c[f] = nil\n\
    \  else\n    c[f] = v - 1\n  end\n  local keys = {}\n  for k, v in pairs(c) do\n\
    \    table.insert(keys, k)\n  end\n  table.sort(keys)\n  return get_second_value(c)\n\
    end", "    if #lst < 2 then\n        return nil\n    end\n    local smallest =\
    \ math.huge\n    local second_smallest = math.huge\n    for _,v in ipairs(lst)\
    \ do\n        if v < smallest then\n            second_smallest = smallest\n \
    \           smallest = v\n        elseif v < second_smallest then\n          \
    \  second_smallest = v\n        end\n    end\n    if second_smallest == math.huge\
    \ then\n        return nil\n    end\n    return second_smallest\nend", "\tlocal\
    \ sorted_lst = lst:clone()\n\tsorted_lst:sort()\n\tlocal cur_min = sorted_lst[1]\n\
    \tlocal found_next = false\n\tfor _, e in ipairs(sorted_lst) do\n\t\tif not found_next\
    \ and e ~= cur_min then\n\t\t\treturn e\n\t\tend\n\t\tif e == cur_min then\n\t\
    \t\tfound_next = true\n\t\tend\n\tend\n\treturn nil\nend", "    table.sort(lst)\n\
    \    if lst[1] == lst[2] then\n        return nil\n    end\n    return lst[2]\n\
    end", "  table.sort(lst)\n  local min, min2 = math.min(table.unpack(lst))\n  if\
    \ min == min2 then\n    return nil\n  else\n    return min2\n  end\nend", "  \
    \  -- your code here\n    local min = math.min(unpack(lst))\n    table.remove(lst,\
    \ table.indexOf(lst, min))\n    return math.min(unpack(lst))\nend", "    if #lst\
    \ == 0 then\n        return nil\n    end\n    local min1, min2 = lst[1], nil\n\
    \    for i = 2, #lst do\n        if lst[i] < min1 then\n            min2 = min1\n\
    \            min1 = lst[i]\n        elseif lst[i] < min2 or min2 == nil then\n\
    \            min2 = lst[i]\n        end\n    end\n    return min2\nend", "   \
    \ table.sort(lst)\n    return lst[2]\nend", "  if not lst then return nil end\n\
    \  local min_index, min_value, min2_index, min2_value = 1, lst[1], 1, math.huge\n\
    \  for i, v in ipairs(lst) do\n    if v < min_value then\n      min2_index, min2_value\
    \ = min_index, min_value\n      min_index, min_value = i, v\n    elseif v < min2_value\
    \ then\n      min2_index, min2_value = i, v\n    end\n  end\n  if min2_value ==\
    \ math.huge then return nil end\n  return min2_value\nend", "    local smallest,\
    \ second_smallest\n    for _, n in ipairs(lst) do\n        if smallest then\n\
    \            if n < smallest then\n                second_smallest = smallest\n\
    \                smallest = n\n            elseif n > smallest and (not second_smallest\
    \ or n < second_smallest) then\n                second_smallest = n\n        \
    \    end\n        else\n            smallest = n\n        end\n    end\n    return\
    \ second_smallest\nend", "    table.sort(lst)\n    if #lst == 0 then\n       \
    \ return nil\n    end\n    if #lst == 1 then\n        return nil\n    end\n  \
    \  local min = lst[1]\n    local min_index = 1\n    for i = 2, #lst do\n     \
    \   if lst[i] < min then\n            min = lst[i]\n            min_index = i\n\
    \        end\n    end\n    return lst[min_index + 1]\nend", "  local sorted =\
    \ {}\n  for _, item in ipairs(lst) do\n    table.insert(sorted, item)\n  end\n\
    \  table.sort(sorted)\n  for i, item in ipairs(sorted) do\n    if i > 1 and sorted[i\
    \ - 1] < item then\n      return item\n    end\n  end\n  return nil\nend", " \
    \ local smallest, s_val, second, s_val2 = 1, lst[1], 2, lst[2]\n  for i, v in\
    \ ipairs(lst) do\n    if v < s_val then\n      smallest, s_val = i, v\n    end\n\
    \  end\n  for i, v in ipairs(lst) do\n    if v > s_val and (v < s_val2 or s_val2\
    \ == s_val) then\n      second, s_val2 = i, v\n    end\n  end\n  if s_val == s_val2\
    \ then\n    return nil\n  else\n    return s_val2\n  end\nend", "    local smallest\
    \ = math.min(unpack(lst))\n    local smallest_count = 0\n    for _, v in ipairs(lst)\
    \ do\n        if v == smallest then\n            smallest_count = smallest_count\
    \ + 1\n        end\n    end\n    if smallest_count == #lst then\n        return\
    \ nil\n    end\n    return math.min(unpack(filter(lst, function(x) return x ~=\
    \ smallest end)))\nend", "    local min\n    local min2", "    local smallest\
    \ = nil\n    local next_smallest = nil\n    for _, v in ipairs(lst) do\n     \
    \   if not smallest or v < smallest then\n            next_smallest = smallest\n\
    \            smallest = v\n        elseif not next_smallest or v < next_smallest\
    \ then\n            next_smallest = v\n        end\n    end\n    return next_smallest\n\
    end", "  local s = None\n  local i = 1\n  while s == None and i <= #lst do\n \
    \   if lst[i] < min(lst) then\n      s = lst[i]\n    end\n    i = i + 1\n  end\n\
    \  return s\nend", "    -- #lst > 1\n    local min = lst[1]\n    local smin =\
    \ nil\n    for i = 2, #lst do\n        if lst[i] < min then\n            smin\
    \ = min\n            min = lst[i]\n        elseif not smin or lst[i] < smin then\n\
    \            smin = lst[i]\n        end\n    end\n    return smin\nend", "  local\
    \ mini, minj\n  for i,v in ipairs(lst) do\n    if not mini or v < mini then\n\
    \      mini, minj = v, i\n    end\n  end\n  local lst = lst[minj]\n  table.remove(lst,\
    \ minj)\n  return next_smallest(lst) or mini\nend", "    table.sort(lst)\n   \
    \ local res = {}\n    for i, v in ipairs(lst) do\n        if v > lst[1] then\n\
    \            table.insert(res, v)\n        end\n    end\n    if #res == 0 then\n\
    \        return nil\n    else\n        return res[1]\n    end\nend", "  -- your\
    \ code here\nend", "    local next_smallest = nil\n    local smallest = math.maxinteger\n\
    \    for _, i in ipairs(lst) do\n        if i < smallest then\n            next_smallest\
    \ = smallest\n            smallest = i\n        elseif i < next_smallest or next_smallest\
    \ == nil then\n            next_smallest = i\n        end\n    end\n    return\
    \ next_smallest\nend", "    -- Your code here\nend", "    if #lst < 2 then\n \
    \       return nil\n    end\n    local smallest, second_smallest = lst[1], lst[2]\n\
    \    if smallest > second_smallest then\n        smallest, second_smallest = second_smallest,\
    \ smallest\n    end\n    for i = 3, #lst do\n        if lst[i] < smallest then\n\
    \            second_smallest = smallest\n            smallest = lst[i]\n     \
    \   elseif lst[i] < second_smallest then\n            second_smallest = lst[i]\n\
    \        end\n    end\n    return second_smallest\nend", "  local smallest, second_smallest\
    \ = nil, nil\n  for _, v in ipairs(lst) do\n    if smallest == nil or v < smallest\
    \ then\n      second_smallest = smallest\n      smallest = v\n    elseif second_smallest\
    \ == nil or v < second_smallest then\n      second_smallest = v\n    end\n  end\n\
    \  return second_smallest\nend", "\t-- TODO\nend", "    if #lst < 2 then\n   \
    \     return nil\n    end\n    local max_val = math.max(unpack(lst))\n    local\
    \ max_idx = max_idx_of(lst, max_val)\n    if max_idx ~= 1 then\n        lst[max_idx]\
    \ = lst[1]\n        lst[1] = max_val\n    end\n    local min_val = math.min(unpack(lst,\
    \ 2))\n    return min_val\nend", "    -- TODO: implement next_smallest()\nend",
  "    local function _next_smallest(lst, sorted_lst)\n        if #lst < 2 then\n\
    \            return nil\n        end\n        local smallest = lst[1]\n      \
    \  local smallest_i = 1\n        for i = 2, #lst do\n            if lst[i] < smallest\
    \ then\n                smallest = lst[i]\n                smallest_i = i\n  \
    \          end\n        end\n        table.insert(sorted_lst, smallest)\n    \
    \    if #lst > 2 then\n            return _next_smallest(lst, sorted_lst)\n  \
    \      else\n            table.insert(sorted_lst, lst[smallest_i == 1 and 2 or\
    \ 1])\n            return sorted_lst[2]\n        end\n    end\n    return _next_smallest(lst,\
    \ {})\nend", "    local first_num = math.huge\n    local second_num = math.huge\n\
    \    for i = 1, #lst do\n        if lst[i] < first_num then\n            second_num\
    \ = first_num\n            first_num = lst[i]\n        elseif lst[i] > first_num\
    \ and lst[i] < second_num then\n            second_num = lst[i]\n        end\n\
    \    end\n    if second_num == math.huge then\n        return\n    end\n    return\
    \ second_num\nend", "    local cnt = lst[1]\n    local lst2 = {}\n    for i =\
    \ 1, #lst do\n        if lst[i] < cnt then\n            cnt = lst[i]\n       \
    \ end\n    end\n    local f = false\n    for i = 1, #lst do\n        if lst[i]\
    \ > cnt then\n            lst2[#lst2 + 1] = lst[i]\n            f = true\n   \
    \     end\n    end\n    if not f then\n        return\n    end\n    cnt = lst2[1]\n\
    \    for i = 1, #lst2 do\n        if lst2[i] < cnt then\n            cnt = lst2[i]\n\
    \        end\n    end\n    return cnt\nend", "  if #lst < 2 then\n    return nil\n\
    \  end\n  local min1, min2\n  if lst[1] < lst[2] then\n    min1, min2 = lst[1],\
    \ lst[2]\n  else\n    min1, min2 = lst[2], lst[1]\n  end\n  for i = 3, #lst do\n\
    \    if lst[i] < min1 then\n      min2 = min1\n      min1 = lst[i]\n    elseif\
    \ lst[i] < min2 then\n      min2 = lst[i]\n    end\n  end\n  return min2\nend",
  "    if not lst or #lst == 0 then\n        return nil\n    end\n    local min1,\
    \ min2 = lst[1], nil\n    for i = 2, #lst do\n        if lst[i] < min1 then\n\
    \            min2 = min1\n            min1 = lst[i]\n        elseif lst[i] < min2\
    \ or min2 == nil then\n            min2 = lst[i]\n        end\n    end\n    return\
    \ min2\nend", "    if #lst < 2 then\n        return nil\n    end\n    local next\
    \ = math.huge\n    local smallest = math.huge\n    for _, v in ipairs(lst) do\n\
    \        if v < smallest then\n            next = smallest\n            smallest\
    \ = v\n        elseif v < next then\n            next = v\n        end\n    end\n\
    \    if next == math.huge then\n        return nil\n    end\n    return next\n\
    end", "  -- your code here\nend", "    -- TODO\nend", "    if type(lst) ~= 'table'\
    \ then\n        return nil\n    end\n    if #lst < 2 then\n        return nil\n\
    \    end\n    local min1, min2 = math.huge, math.huge\n    for i = 1, #lst do\n\
    \        if lst[i] < min1 then\n            min2 = min1\n            min1 = lst[i]\n\
    \        elseif lst[i] < min2 then\n            min2 = lst[i]\n        end\n \
    \   end\n    if min2 == math.huge then\n        return nil\n    end\n    return\
    \ min2\nend", "    if #lst < 2 then\n        return nil\n    end\n    local min,\
    \ min_idx = math.huge, nil\n    local nmin, nmin_idx = math.huge, nil\n    for\
    \ i,v in ipairs(lst) do\n        if v < min then\n            nmin, nmin_idx =\
    \ min, min_idx\n            min, min_idx = v, i\n        elseif v < nmin then\n\
    \            nmin, nmin_idx = v, i\n        end\n    end\n    return nmin\nend",
  end, "    local sorted = table.sort(lst)\n    return sorted[2]\nend", "    local\
    \ found = false\n    local min, smin\n    for _, v in ipairs(lst) do\n       \
    \ if not found then\n            min = v\n            found = true\n        elseif\
    \ min > v then\n            smin = min\n            min = v\n        elseif smin\
    \ == nil or smin > v then\n            smin = v\n        end\n    end\n    return\
    \ smin\nend", "  local a = {}\n  local b = {}\n  local c = nil\n  for i, v in\
    \ ipairs(lst) do\n    a[i] = v\n    b[v] = i\n  end\n  table.sort(a)\n  for _,\
    \ v in ipairs(a) do\n    if not c then\n      c = v\n    elseif c == v then\n\
    \      c = nil\n    else\n      return v\n    end\n  end\n  return nil\nend",
  "    -- Your code here\nend", "  -- body\nend", "  local min, smin = math.huge,\
    \ math.huge\n  for _, v in ipairs(lst) do\n    if v < min then\n      smin = min\n\
    \      min = v\n    elseif v < smin then\n      smin = v\n    end\n  end\n  return\
    \ smin ~= math.huge and smin or nil\nend", "  local numbers = {}\n  for _, v in\
    \ ipairs(lst) do\n    table.insert(numbers, v)\n  end\n  table.sort(numbers)\n\
    \  if #numbers < 2 then\n    return nil\n  end\n  return numbers[2]\nend", " \
    \   table.sort(lst)\n    if #lst > 1 then\n        return lst[2]\n    end\n  \
    \  return nil\nend\nprint(next_smallest({1, 2, 3, 4, 5}))\nprint(next_smallest({5,\
    \ 1, 4, 3, 2}))\nprint(next_smallest({}))\nprint(next_smallest({1, 1}))", "  local\
    \ res = nil\n  local len = #lst\n  for i = 1, len - 1 do\n    local cur = lst[i]\n\
    \    for j = i + 1, len do\n      local val = lst[j]\n      if cur > val then\n\
    \        res = res and (res < val and res or val) or val\n      end\n    end\n\
    \  end\n  return res\nend", "    if #lst == 0 then\n        return nil\n    end\n\
    \    local min1, min2\n    for i, v in ipairs(lst) do\n        if not min1 or\
    \ v < min1 then\n            min2 = min1\n            min1 = v\n        elseif\
    \ not min2 or v < min2 then\n            min2 = v\n        end\n    end\n    return\
    \ min2\nend", "  if #lst < 2 then\n    return nil\n  end\n  local min = lst[1]\n\
    \  local sec = lst[2]\n  for i = 3, #lst do\n    if lst[i] < min then\n      sec\
    \ = min\n      min = lst[i]\n    elseif lst[i] < sec then\n      sec = lst[i]\n\
    \    end\n  end\n  return sec\nend", "    table.sort(lst)\n    if #lst < 2 then\n\
    \        return nil\n    end\n    return lst[2]\nend", "    if type(lst) ~= 'table'\
    \ then\n        return nil\n    end\n    local len = #lst\n    if len == 0 then\n\
    \        return nil\n    end\n    local min = math.min(unpack(lst))\n    local\
    \ i = 1\n    local j = 1\n    local new = {}\n    for k, v in pairs(lst) do\n\
    \        if v ~= min then\n            new[i] = v\n            i = i + 1\n   \
    \     end\n    end\n    local second = math.min(unpack(new))\n    while j <= len\
    \ do\n        if lst[j] == second then\n            return lst[j]\n        end\n\
    \        j = j + 1\n    end\n    return nil\nend", "    if #lst <= 1 then\n  \
    \      return nil\n    end\n    local smallest = math.min(unpack(lst))\n    local\
    \ second_smallest = nil\n    for _, n in ipairs(lst) do\n        if n > smallest\
    \ then\n            if second_smallest == nil or n < second_smallest then\n  \
    \              second_smallest = n\n            end\n        end\n    end\n  \
    \  return second_smallest\nend", "  -- your code here\n  local result = nil\n\
    \  local first = lst[1]\n  local second = lst[2]\n  if #lst == 0 then\n    return\
    \ nil\n  end\n  if #lst == 1 then\n    return nil\n  end\n  for i = 1, #lst, 1\
    \ do\n    if first >= lst[i] then\n      first = lst[i]\n    end\n  end\n  for\
    \ i = 1, #lst, 1 do\n    if lst[i] > first and (lst[i] < second or second == nil)\
    \ then\n      second = lst[i]\n    end\n  end\n  if second == nil then\n    return\
    \ nil\n  end\n  return second\nend", "    local min1, min2\n    for i, v in ipairs(lst)\
    \ do\n        if not min1 or v < min1 then\n            min2 = min1\n        \
    \    min1 = v\n        elseif not min2 or v < min2 then\n            min2 = v\n\
    \        end\n    end\n    return min2\nend", "\t-- your code here\nend", "\t\
    --\nend", "  if #lst == 0 then\n    return nil\n  end\n  if #lst == 1 then\n \
    \   return nil\n  end\n  if #lst == 2 then\n    if lst[1] == lst[2] then\n   \
    \   return nil\n    end\n  end\n  local sorted_lst = insertion_sort(lst)\n  for\
    \ i = 1, #sorted_lst do\n    if sorted_lst[i] ~= sorted_lst[1] then\n      return\
    \ sorted_lst[i]\n    end\n  end\nend", "    if #lst == 0 then\n        return\
    \ nil\n    end\n    if #lst == 1 then\n        return nil\n    end\n    if #lst\
    \ == 2 then\n        if lst[1] == lst[2] then\n            return nil\n      \
    \  end\n    end\n    table.sort(lst)\n    local i = 1\n    while i < #lst do\n\
    \        if lst[i] == lst[i + 1] then\n            i = i + 1\n        else\n \
    \           return lst[i + 1]\n        end\n    end\n    return nil\nend", " \
    \   local min, min2\n    for _, v in ipairs(lst) do\n        if min == nil or\
    \ v < min then\n            min2 = min\n            min = v\n        elseif min2\
    \ == nil or v < min2 then\n            min2 = v\n        end\n    end\n    return\
    \ min2\nend", "  local min, min2\n  for i = 1, #lst do\n    if not min or lst[i]\
    \ < min then\n      min2 = min\n      min = lst[i]\n    elseif not min2 or lst[i]\
    \ < min2 then\n      min2 = lst[i]\n    end\n  end\n  return min2\nend", "  local\
    \ min, min2\n  for _,v in ipairs(lst) do\n    if min2 == nil or v < min2 then\n\
    \      if min == nil or v < min then\n        min2 = min\n        min = v\n  \
    \    else\n        min2 = v\n      end\n    end\n  end\n  return min2\nend", " \
    \   local min, min2 = math.maxinteger, math.maxinteger\n    for _, v in ipairs(lst)\
    \ do\n        if v < min then\n            min2 = min\n            min = v\n \
    \       elseif v > min and v < min2 then\n            min2 = v\n        end\n\
    \    end\n    return min2 == math.maxinteger and nil or min2\nend", "  local seen\
    \ = {}\n  local minimum = math.huge\n  local second_minimum = math.huge\n  for\
    \ _,n in ipairs(lst) do\n    if n > minimum then\n      second_minimum = math.min(second_minimum,\
    \ n)\n    elseif n < minimum then\n      minimum, second_minimum = n, minimum\n\
    \    end\n  end\n  return second_minimum == math.huge and nil or second_minimum\n\
    end", "    -- Note: need to return 2nd smallest, don't return the smallest\n \
    \   local smallest = nil\n    local second_smallest = nil\n    for _, item in\
    \ ipairs(lst) do\n        if not smallest then\n            smallest = item\n\
    \        elseif item < smallest then\n            second_smallest = smallest\n\
    \            smallest = item\n        elseif not second_smallest or item < second_smallest\
    \ then\n            second_smallest = item\n        end\n    end\n    return second_smallest\n\
    end\nassert(next_smallest({1, 2, 3, 4, 5}) == 2)\nassert(next_smallest({5, 1,\
    \ 4, 3, 2}) == 2)\nassert(next_smallest({}) == nil)\nassert(next_smallest({1,\
    \ 1}) == nil)", "    local l = {}\n    for _,v in ipairs(lst) do\n        table.insert(l,\
    \ v)\n    end\n    table.sort(l)\n    if #l == 0 then\n        return nil\n  \
    \  elseif #l == 1 then\n        return nil\n    elseif #l == 2 then\n        if\
    \ l[1] == l[2] then\n            return nil\n        else\n            return\
    \ l[2]\n        end\n    else\n        local smallest = l[1]\n        for i =\
    \ 2, #l do\n            if l[i] > smallest then\n                return l[i]\n\
    \            end\n        end\n        return nil\n    end\nend", "\tlocal a =\
    \ table.remove(lst, 1)\n\tlocal b = table.remove(lst, 1)\n\tlocal m = math.min(a,\
    \ b)\n\tlocal n = math.max(a, b)\n\tfor _, v in ipairs(lst) do\n\t\tif v < m then\n\
    \t\t\tn = m\n\t\t\tm = v\n\t\telseif v < n then\n\t\t\tn = v\n\t\tend\n\tend\n\
    \treturn n\nend", "  local min, min2\n  for _, val in ipairs(lst) do\n    if not\
    \ min or val < min then\n      min2 = min\n      min = val\n    elseif not min2\
    \ or val < min2 then\n      min2 = val\n    end\n  end\n  return min2\nend", " \
    \   local min = min(lst)\n    local temp = {}\n    for i, v in ipairs(lst) do\n\
    \        if v ~= min then\n            table.insert(temp, v)\n        end\n  \
    \  end\n    return #temp > 0 and min(temp) or nil\nend", "    table.sort(lst)\n\
    \    for i = 2, #lst do\n        if lst[i] ~= lst[1] then\n            return\
    \ lst[i]\n        end\n    end\n    return nil\nend", "    -- your code here\n\
    \    -- lst_copy = lst:copy()\n    lst = {1, 2, 3, 4, 5}\n    lst_copy = {}\n\
    \    for i, x in ipairs(lst) do\n        lst_copy[i] = x\n    end\n    table.sort(lst_copy)\n\
    \    print('lst:', lst)\n    print('lst_copy:', lst_copy)\n    if #lst == 0 then\n\
    \        return nil\n    end\n    if #lst == 1 then\n        return nil\n    end\n\
    \    if #lst == 2 then\n        if lst[1] == lst[2] then\n            return nil\n\
    \        end\n    end\n    for i, x in ipairs(lst_copy) do\n        if i == 2\
    \ then\n            return x\n        end\n    end\nend", "  if #lst < 2 then\n\
    \    return nil\n  end\n  local tbl = {}\n  for _,v in ipairs(lst) do\n    tbl[v]\
    \ = true\n  end\n  local min = min_int(lst)\n  local i = min + 1\n  while true\
    \ do\n    if not tbl[i] then\n      return i\n    end\n    i = i + 1\n  end\n\
    end", "    table.sort(lst)\n    local last_val = lst[1]\n    for i = 2, #lst do\n\
    \        if lst[i] ~= last_val then\n            return lst[i]\n        end\n\
    \    end\n    return nil\nend", "    local smallest = math.huge\n    local second\
    \ = math.huge\n    for _, val in ipairs(lst) do\n        if val < smallest then\n\
    \            second = smallest\n            smallest = val\n        elseif val\
    \ < second then\n            second = val\n        end\n    end\n    if second\
    \ == math.huge then\n        return nil\n    end\n    return second\nend", " \
    \   if #lst < 2 then\n        return nil\n    end\n    local min_val = math.min(unpack(lst))\n\
    \    local min_pos = 0\n    for k, v in ipairs(lst) do\n        if v == min_val\
    \ then\n            min_pos = k\n            break\n        end\n    end\n   \
    \ table.remove(lst, min_pos)\n    return math.min(unpack(lst))\nend", "    local\
    \ count = 0\n    local min = math.huge\n    local min_2 = math.huge\n    for _,\
    \ v in ipairs(lst) do\n        if v < min then\n            min_2 = min\n    \
    \        min = v\n        elseif v < min_2 then\n            min_2 = v\n     \
    \   end\n        count = count + 1\n    end\n    if count < 2 then\n        return\
    \ nil\n    end\n    return min_2\nend", "    if #lst < 2 then\n        return\
    \ nil\n    end\n    local min, min2 = lst[1], lst[2]\n    for i = 2, #lst do\n\
    \        if lst[i] < min then\n            min2 = min\n            min = lst[i]\n\
    \        elseif lst[i] < min2 then\n            min2 = lst[i]\n        end\n \
    \   end\n    return min2\nend", "    local min, min2 = math.huge, math.huge\n\
    \    for i, v in ipairs(lst) do\n        if v < min then\n            min2 = min\n\
    \            min = v\n        elseif v > min and v < min2 then\n            min2\
    \ = v\n        end\n    end\n    return min2 == math.huge and nil or min2\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
