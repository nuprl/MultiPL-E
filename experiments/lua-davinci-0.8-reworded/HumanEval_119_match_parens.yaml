name: HumanEval_119_match_parens
language: lua
prompt: "-- You are given a table of two strings, both strings consist of open\n--\
  \ parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it\
  \ is possible to concatenate the two strings in\n-- some order, that the resulting\
  \ string will be good.\n-- A string S is considered to be good if and only if all\
  \ parentheses in S\n-- are balanced. For example: the string '(())()' is good, while\
  \ the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good\
  \ string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
  \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
  \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
  \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n  \
  \  lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
  \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n  \
  \  lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
  \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n   \
  \ lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
  \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #lst ~= 2 then\n    return 'Error'\n  end\n  local str1, str2\
    \ = lst[1], lst[2]\n  local count1, count2 = 0, 0\n  for i = 1, #str1 do\n   \
    \ if str1:sub(i, i) == '(' then\n      count1 = count1 + 1\n    else\n      count1\
    \ = count1 - 1\n    end\n  end\n  for i = 1, #str2 do\n    if str2:sub(i, i) ==\
    \ '(' then\n      count2 = count2 + 1\n    else\n      count2 = count2 - 1\n \
    \   end\n  end\n  if count1 < 0 or count2 < 0 then\n    return 'No'\n  end\n \
    \ local pos = count1 - count2\n  if pos == 0 then\n    return 'Yes'\n  elseif\
    \ pos < 0 then\n    return 'No'\n  else\n    return 'Yes'\n  end\nend", "    if\
    \ #lst[1] == 0 then\n        return 'Yes'\n    end\n    local parens = {}\n  \
    \  for _, str in ipairs(lst) do\n        for p in str:gmatch'()' do\n        \
    \    if str:sub(p, p) == '(' then\n                table.insert(parens, '(())')\n\
    \            else\n                if #parens == 0 then\n                    return\
    \ 'No'\n                end\n                table.remove(parens)\n          \
    \  end\n        end\n    end\n    return #parens == 0 and 'Yes' or 'No'\nend",
  "    -- your code goes here\n    -- \u601D\u8DEF\uFF1A\n    --    \u5224\u65AD\u5B57\
    \u7B26\u4E32\u4E2D'('\u4E0E')'\u7684\u4E2A\u6570\u662F\u5426\u76F8\u7B49\n   \
    \ --    \u5982\u679C\u76F8\u7B49\uFF0C\u5219\u8FD4\u56DEYes\n    --    \u5982\u679C\
    \u4E0D\u76F8\u7B49\uFF0C\u5219\u8FD4\u56DENo\n    --\n    -- \u5B9E\u73B0\uFF1A\
    \n    --    \u5229\u7528string.match()\u51FD\u6570\n    --    \u5229\u7528string.format()\u5C06\
    \u7ED3\u679C\u8F6C\u6362\u4E3AYes\u6216No\u5B57\u7B26\u4E32\n    local open_parens\
    \ = 0\n    local close_parens = 0\n    for i, v in ipairs(lst) do\n        _,\
    \ open_parens = string.gsub(v, '%(', '')\n        _, close_parens = string.gsub(v,\
    \ '%)', '')\n    end\n    if open_parens == close_parens then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend", "  local v1, v2 = lst[1],\
    \ lst[2]\n  local s = 0\n  for i=1, #v1 do\n    if v1:sub(i, i) == '(' then\n\
    \      s = s + 1\n    else\n      s = s - 1\n    end\n    if s < 0 then\n    \
    \  return 'No'\n    end\n  end\n  for i=1, #v2 do\n    if v2:sub(i, i) == '('\
    \ then\n      s = s + 1\n    else\n      s = s - 1\n    end\n    if s < 0 then\n\
    \      return 'No'\n    end\n  end\n  return s == 0 and 'Yes' or 'No'\nend", " \
    \ local s1, s2 = table.unpack(lst)\n  local s = s1 .. s2\n  local cnt = 0\n  for\
    \ i = 1, #s do\n    if s:sub(i, i) == '(' then\n      cnt = cnt + 1\n    else\n\
    \      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n    end\n\
    \  end\n  return cnt == 0 and 'Yes' or 'No'\nend", "  local parens = { ['('] =\
    \ 0, [')'] = 0 }\n  for _, x in ipairs(lst) do\n    for y in x:gmatch('.') do\n\
    \      parens[y] = parens[y] + 1\n    end\n  end\n  if parens['('] < parens[')']\
    \ then\n    return 'No'\n  end\n  if parens['('] > parens[')'] then\n    return\
    \ 'Yes'\n  end\n  return 'Yes'\nend", "  local function check_parens(s)\n    local\
    \ count = 0\n    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n        count\
    \ = count + 1\n      else\n        count = count - 1\n      end\n      if count\
    \ < 0 then\n        return false\n      end\n    end\n    return count == 0\n\
    \  end\n  return check_parens(lst[1] .. lst[2]) and 'Yes' or 'No'\nend", "  local\
    \ l1, l2 = lst[1], lst[2]\n  local m1, m2 = (#l1 + 1) / 2, (#l2 + 1) / 2\n  if\
    \ m1 > m2 then\n    local t = l1\n    l1 = l2\n    l2 = t\n    m1, m2 = m2, m1\n\
    \  end\n  local s1, s2 = l1:rep(m2), l2:rep(m1)\n  return s1:find(s2) and 'Yes'\
    \ or 'No'\nend", "    local open = {}\n    local close = {}\n    for i = 1, #lst\
    \ do\n        if lst[i]:match('^%(') then\n            open[#open + 1] = i\n \
    \       else\n            close[#close + 1] = i\n        end\n    end\n    if\
    \ #open > #close then\n        return 'No'\n    end\n    if #open < #close then\n\
    \        return 'Yes'\n    end\n    return 'No'\nend", "    local s = table.concat(lst)\n\
    \    local left, right = 0, 0\n    for i = 1, #s do\n        local c = s:sub(i,\
    \ i)\n        if c == '(' then\n            left = left + 1\n        else\n  \
    \          right = right + 1\n        end\n        if right > left then\n    \
    \        return 'No'\n        end\n    end\n    return left == right and 'Yes'\
    \ or 'No'\nend", "  local no = 'No'\n  local yes = 'Yes'\n  -- Count parentheses\
    \ in each string.\n  local a, b = lst[1], lst[2]\n  local count_a, count_b = 0,\
    \ 0\n  for i = 1, #a do\n    if a:sub(i, i) == '(' then\n      count_a = count_a\
    \ + 1\n    else\n      count_a = count_a - 1\n    end\n  end\n  for i = 1, #b\
    \ do\n    if b:sub(i, i) == '(' then\n      count_b = count_b + 1\n    else\n\
    \      count_b = count_b - 1\n    end\n  end\n  if count_a == 0 and count_b ==\
    \ 0 then\n    return yes\n  end\n  if count_a == 0 and count_b > 0 then\n    if\
    \ count_b % 2 == 0 then\n      return yes\n    else\n      return no\n    end\n\
    \  end\n  if count_a > 0 and count_b == 0 then\n    if count_a % 2 == 0 then\n\
    \      return yes\n    else\n      return no\n    end\n  end\n  if count_a > 0\
    \ and count_b > 0 then\n    return no\n  end\nend", "  local left = {}\n  local\
    \ right = {}\n  for i = 1, #lst do\n    local str = lst[i]\n    local l = 0\n\
    \    local r = 0\n    for j = 1, #str do\n      if str:sub(j, j) == '(' then\n\
    \        l = l + 1\n      else\n        r = r + 1\n      end\n    end\n    left[i]\
    \ = l\n    right[i] = r\n  end\n  local num_left = 0\n  local num_right = 0\n\
    \  for i = 1, #left do\n    if left[i] < right[i] then\n      num_right = num_right\
    \ + right[i] - left[i]\n    else\n      num_left = num_left + left[i] - right[i]\n\
    \    end\n  end\n  return num_left == num_right and 'Yes' or 'No'\nend", "   \
    \ local s = table.concat(lst)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n        if c == '(' then\n            count = count + 1\n        else\n\
    \            count = count - 1\n        end\n        if count < 0 then\n     \
    \       return 'No'\n        end\n    end\n    return count == 0 and 'Yes' or\
    \ 'No'\nend", "  local s = lst[1] .. lst[2]\n  local cnt = 0\n  for i = 1, #s\
    \ do\n    if s:sub(i, i) == '(' then\n      cnt = cnt + 1\n    else\n      cnt\
    \ = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n    end\n  end\n\
    \  return cnt == 0 and 'Yes' or 'No'\nend", "  -- Write your code here\n  return\
    \ ''\nend", "  local a, b = lst[1], lst[2]\n  local eq_n = 0\n  local op_n = 0\n\
    \  local cp_n = 0\n  local a_eq, a_op, a_cp = 0, 0, 0\n  local b_eq, b_op, b_cp\
    \ = 0, 0, 0\n  for i = 1, #a do\n    if a:sub(i, i) == '(' then\n      a_op =\
    \ a_op + 1\n    else\n      a_cp = a_cp + 1\n    end\n  end\n  for i = 1, #b do\n\
    \    if b:sub(i, i) == '(' then\n      b_op = b_op + 1\n    else\n      b_cp =\
    \ b_cp + 1\n    end\n  end\n  if a_op == a_cp and b_op == b_cp then\n    return\
    \ 'Yes'\n  end\n  for i = 1, #a do\n    if a:sub(i, i) == '(' then\n      eq_n\
    \ = eq_n + 1\n    else\n      eq_n = eq_n - 1\n    end\n    if eq_n < 0 then\n\
    \      op_n = op_n + 1\n    end\n  end\n  eq_n = 0\n  for i = 1, #b do\n    if\
    \ b:sub(i, i) == '(' then\n      eq_n = eq_n + 1\n    else\n      eq_n = eq_n\
    \ - 1\n    end\n    if eq_n > 0 then\n      cp_n = cp_n + 1\n    end\n  end\n\
    \  if op_n == cp_n then\n    return 'Yes'\n  end\n  return 'No'\nend", "    local\
    \ open, close = 0, 0\n    for i, v in ipairs(lst) do\n        for _, p in ipairs(v)\
    \ do\n            if p == '(' then\n                open = open + 1\n        \
    \    else\n                close = close + 1\n            end\n        end\n \
    \   end\n    return open > close and 'Yes' or 'No'\nend", "    -- The answer is\
    \ \"Yes\" if the balance of the first string is the opposite\n    -- of the balance\
    \ of the second string.\n    local b1 = balance(lst[1])\n    local b2 = balance(lst[2])\n\
    \    if b1 == -b2 then\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend", "  local hash = { ['('] = 1, [')'] = -1 }\n  local sum = function(acc,\
    \ v) return acc + hash[v] end\n  local v1, v2 = lst[1], lst[2]\n  return ((foldl(sum,\
    \ 0, v1) >= 0) and (foldl(sum, 0, v2) <= 0)) and\n         'Yes' or 'No'\nend",
  "    local function is_good(s)\n        local bal = 0\n        for _, p in ipairs(s)\
    \ do\n            if p == '(' then\n                bal = bal + 1\n          \
    \  else\n                bal = bal - 1\n            end\n            if bal <\
    \ 0 then\n                return false\n            end\n        end\n       \
    \ return bal == 0\n    end\n    for _, s in ipairs{lst[1] .. lst[2], lst[2] ..\
    \ lst[1]} do\n        if is_good(s) then\n            return 'Yes'\n        end\n\
    \    end\n    return 'No'\nend", "  -- Check the number of parenthesis\n  local\
    \ total_parens = 0\n  for _, parens in ipairs(lst) do\n    for _ in parens:gmatch('[()]')\
    \ do\n      total_parens = total_parens + 1\n    end\n  end\n  if total_parens\
    \ % 2 ~= 0 then\n    return 'No'\n  end", "  local count = 0\n  for _, v in ipairs(lst)\
    \ do\n    for i = 1, #v do\n      if v:sub(i, i) == '(' then\n        count =\
    \ count + 1\n      else\n        count = count - 1\n      end\n      if count\
    \ < 0 then\n        return 'No'\n      end\n    end\n  end\n  return count ==\
    \ 0 and 'Yes' or 'No'\nend", "  local open, close = 0, 0\n  for i = 1, #lst[1]\
    \ do\n    if lst[1]:sub(i, i) == '(' then\n      open = open + 1\n    else\n \
    \     close = close + 1\n    end\n  end\n  for i = 1, #lst[2] do\n    if lst[2]:sub(i,\
    \ i) == '(' then\n      open = open + 1\n    else\n      close = close + 1\n \
    \   end\n  end\n  if open == close then\n    return 'Yes'\n  else\n    return\
    \ 'No'\n  end\nend", "  local left = 0\n  local right = 0\n  for i = 1, #lst[1]\
    \ do\n    local char = lst[1]:sub(i, i)\n    if char == '(' then\n      left =\
    \ left + 1\n    else\n      right = right + 1\n    end\n  end\n  for i = 1, #lst[2]\
    \ do\n    local char = lst[2]:sub(i, i)\n    if char == '(' then\n      left =\
    \ left + 1\n    else\n      right = right + 1\n    end\n  end\n  if left == right\
    \ then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend", "  local parens\
    \ = {\n    ['('] = ')',\n    [')'] = '('\n  }\n  local function check_balans(str)\n\
    \    local s = {}\n    for i=1, #str do\n      local c = str:sub(i, i)\n     \
    \ if c == '(' then\n        table.insert(s, c)\n      else\n        if #s == 0\
    \ then\n          return false\n        end\n        local p = table.remove(s)\n\
    \        if parens[p] ~= c then\n          return false\n        end\n      end\n\
    \    end\n    return #s == 0\n  end\n  local str1, str2 = lst[1], lst[2]\n  local\
    \ len1, len2 = #str1, #str2\n  local len = len1 + len2\n  local l = 0\n  local\
    \ r = 0\n  local mask = 1\n  local answer = 'No'\n  while mask < (1 << len) do\n\
    \    local t = {}\n    local p = 1\n    for i=1, len do\n      if (mask & (1 <<\
    \ i)) ~= 0 then\n        t[p] = str1:sub(i, i)\n        p = p + 1\n      end\n\
    \    end\n    for i=1, len do\n      if (mask & (1 << i)) == 0 then\n        t[p]\
    \ = str2:sub(i, i)\n        p = p + 1\n      end\n    end\n    local str = table.concat(t)\n\
    \    if check_balans(str) then\n      answer = 'Yes'\n      break\n    end\n \
    \   mask = mask + 1\n  end\n  return answer\nend", "  local s1, s2 = lst[1], lst[2]\n\
    \  local n1, n2 = (s1:gsub('%(', '')), (s2:gsub('%(', ''))\n  if #s1 == n1 and\
    \ #s2 == n2 then return 'No' end\n  if (n1 == #s1 and n2 == #s2) or (n1 == #s1\
    \ and #s2 - n2 == n1) or\n     (n2 == #s2 and #s1 - n1 == n2) then return 'Yes'\
    \ end\n  if #s1 - n1 > #s2 - n2 then\n    for i = 1, #s2 - n2 do\n      s1 = s1\
    \ .. ')'\n    end\n  else\n    for i = 1, #s1 - n1 do\n      s2 = s2 .. ')'\n\
    \    end\n  end\n  return (check_parens(s1 .. s2) and 'Yes' or 'No')\nend", " \
    \   -- Write your code here\n    local str = ''\n    for _, v in ipairs(lst) do\n\
    \        str = str .. v\n    end\n    local n = string.len(str)\n    local cnt\
    \ = 0\n    for i = 1, n do\n        if str:sub(i, i) == '(' then\n           \
    \ cnt = cnt + 1\n        else\n            cnt = cnt - 1\n        end\n      \
    \  if cnt < 0 then\n            return 'No'\n        end\n    end\n    if cnt\
    \ == 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend",
  "  local o1, o2 = lst[1]:count('('), lst[2]:count('(')\n  local c1, c2 = lst[1]:count(')'),\
    \ lst[2]:count(')')\n  if (o1 + o2) == (c1 + c2) then\n    return 'Yes'\n  else\n\
    \    return 'No'\n  end\nend", "    local opens = 0\n    local closes = 0\n  \
    \  for _, s in ipairs(lst) do\n        for i = 1, #s do\n            if s:sub(i,\
    \ i) == '(' then\n                opens = opens + 1\n            else\n      \
    \          closes = closes + 1\n            end\n        end\n    end\n    return\
    \ opens == closes and 'Yes' or 'No'\nend", "    local s = lst[1] .. lst[2]\n \
    \   local parens = {}\n    for i = 1, #s do\n        table.insert(parens, s:sub(i,\
    \ i))\n    end\n    while parens[1] == ')' do\n        table.remove(parens, 1)\n\
    \    end\n    while parens[#parens] == '(' do\n        table.remove(parens, #parens)\n\
    \    end\n    if #parens % 2 == 0 then\n        for i = 1, #parens - 1, 2 do\n\
    \            if parens[i] == ')' or parens[i + 1] == '(' then\n              \
    \  return 'No'\n            end\n        end\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend", "  local function isbalanced(str)\n    local\
    \ bal = 0\n    for i = 1, str:len() do\n      if str:sub(i, i) == '(' then\n \
    \       bal = bal + 1\n      else\n        bal = bal - 1\n      end\n      if\
    \ bal < 0 then\n        return false\n      end\n    end\n    return bal == 0\n\
    \  end\n  return isbalanced(lst[1] .. lst[2]) and 'Yes' or 'No'\nend", "    local\
    \ cnt = 0\n    for _, v in ipairs(lst) do\n        for i = 1, #v do\n        \
    \    if v:sub(i, i) == '(' then\n                cnt = cnt + 1\n            else\n\
    \                cnt = cnt - 1\n            end\n            if cnt < 0 then\n\
    \                return 'No'\n            end\n        end\n    end\n    return\
    \ cnt == 0 and 'Yes' or 'No'\nend", "  local function is_good(s)\n    local bal\
    \ = 0\n    for c in s:gmatch(\".\") do\n      if c == \"(\" then\n        bal\
    \ = bal + 1\n      else\n        bal = bal - 1\n      end\n      if bal < 0 then\n\
    \        return false\n      end\n    end\n    return bal == 0\n  end\n  return\
    \ is_good(lst[1] .. lst[2]) and \"Yes\" or \"No\"\nend", "  local open_p, close_p\
    \ = 0, 0\n  for _, s in ipairs(lst) do\n    for i = 1, #s do\n      if s:sub(i,\
    \ i) == '(' then\n        open_p = open_p + 1\n      else\n        close_p = close_p\
    \ + 1\n      end\n    end\n  end\n  return open_p == close_p and 'Yes' or 'No'\n\
    end", "    local open = 0\n    local closed = 0\n    for i = 1, #lst[1] do\n \
    \       if lst[1]:sub(i, i) == '(' then\n            open = open + 1\n       \
    \ else\n            closed = closed + 1\n        end\n    end\n    for i = 1,\
    \ #lst[2] do\n        if lst[2]:sub(i, i) == '(' then\n            open = open\
    \ + 1\n        else\n            closed = closed + 1\n        end\n    end\n \
    \   if open == closed then\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend", "    local l, r = lst[1], lst[2]\n    local t = {\n        closed\
    \ = 0,\n        opened = 0,\n        opened_r = 0,\n        closed_r = 0,\n  \
    \  }\n    for i = 1, #l do\n        if l:sub(i, i) == '(' then\n            t.opened\
    \ = t.opened + 1\n        else\n            t.closed = t.closed + 1\n        end\n\
    \    end\n    for i = 1, #r do\n        if r:sub(i, i) == '(' then\n         \
    \   t.opened_r = t.opened_r + 1\n        else\n            t.closed_r = t.closed_r\
    \ + 1\n        end\n    end\n    if t.opened > t.closed then\n        if t.opened\
    \ > t.opened_r then\n            return 'No'\n        end\n    elseif t.closed\
    \ > t.opened then\n        if t.closed > t.closed_r then\n            return 'No'\n\
    \        end\n    end\n    return 'Yes'\nend\nreturn match_parens", "  local unbalanced\
    \ = 0\n  for _, s in ipairs(lst) do\n    for _, p in ipairs(s:gmatch(\"[()]\"\
    )) do\n      if p == '(' then\n        unbalanced = unbalanced + 1\n      else\n\
    \        unbalanced = unbalanced - 1\n      end\n      if unbalanced < 0 then\n\
    \        return 'No'\n      end\n    end\n  end\n  return unbalanced == 0 and\
    \ 'Yes' or 'No'\nend", "  local stack = {}\n  local first = lst[1]\n  local second\
    \ = lst[2]\n  local i = 1\n  local j = 1\n  while i <= #first do\n    local a\
    \ = first:sub(i, i)\n    if a == '(' then\n      table.insert(stack, a)\n    else\n\
    \      if #stack == 0 then\n        return 'No'\n      end\n      local top =\
    \ table.remove(stack)\n      if top ~= '(' then\n        return 'No'\n      end\n\
    \    end\n    i = i + 1\n  end\n  while j <= #second do\n    local b = second:sub(j,\
    \ j)\n    if b == '(' then\n      table.insert(stack, b)\n    else\n      if #stack\
    \ == 0 then\n        return 'No'\n      end\n      local top = table.remove(stack)\n\
    \      if top ~= '(' then\n        return 'No'\n      end\n    end\n    j = j\
    \ + 1\n  end\n  if #stack > 0 then\n    return 'No'\n  end\n  return 'Yes'\nend",
  "  if not lst then return end\n  if #lst ~= 2 then return end\n  local fst, snd\
    \ = lst[1], lst[2]\n  local o, c = 0, 0\n  for i=1,#fst do\n    if fst:sub(i,i)\
    \ == '(' then o = o + 1 else c = c + 1 end\n  end\n  for i=1,#snd do\n    if snd:sub(i,i)\
    \ == '(' then o = o + 1 else c = c + 1 end\n  end\n  if c > o then return 'No'\
    \ end\n  return 'Yes'\nend", "    local n_op = 0\n    local n_cl = 0\n    for\
    \ _, par in ipairs(lst) do\n        for _, p in par:gmatch(\"()\") do\n      \
    \      if p == '(' then\n                n_op = n_op + 1\n            else\n \
    \               n_cl = n_cl + 1\n            end\n        end\n    end\n    return\
    \ n_op == n_cl and 'Yes' or 'No'\nend", "\tlocal s = table.concat(lst)\n\tlocal\
    \ t, count = {}, 0\n\tfor p in s:gmatch('%b()') do\n\t\tt[#t + 1] = p\n\t\tcount\
    \ = count + p:sub(1, 1) == '(' and 1 or -1\n\tend\n\tif count ~= 0 then return\
    \ 'No' end\n\tfor i = 1, #t - 1 do\n\t\tfor j = 1, #t - 1 do\n\t\t\tif #t[j] <\
    \ #t[j + 1] then\n\t\t\t\tt[j], t[j + 1] = t[j + 1], t[j]\n\t\t\tend\n\t\tend\n\
    \tend\n\tlocal s = ''\n\tfor _, p in ipairs(t) do\n\t\ts = s .. p\n\tend\n\treturn\
    \ s:sub(1, 1) == '(' and 'Yes' or 'No'\nend", "  local left, right = 0, 0\n  for\
    \ _, paren in ipairs(lst) do\n    for _, char in ipairs(paren) do\n      if char\
    \ == '(' then\n        left = left + 1\n      else\n        right = right + 1\n\
    \      end\n    end\n  end\n  return (left == right) and 'Yes' or 'No'\nend",
  "    local s1, s2 = lst[1], lst[2]\n    local n1, n2 = #s1, #s2\n    local function\
    \ stack_empty(stack)\n        return #stack == 0\n    end\n    local function\
    \ stack_top(stack)\n        return stack[#stack]\n    end\n    local function\
    \ stack_pop(stack)\n        return table.remove(stack)\n    end\n    local function\
    \ stack_push(stack, paren)\n        table.insert(stack, paren)\n    end\n    local\
    \ function check_parens(str)\n        local stack = {}\n        for i = 1, #str\
    \ do\n            local c = str:sub(i, i)\n            if c == '(' then\n    \
    \            stack_push(stack, c)\n            else\n                if stack_empty(stack)\
    \ then\n                    return false\n                else\n             \
    \       stack_pop(stack)\n                end\n            end\n        end\n\
    \        return stack_empty(stack)\n    end\n    local function check_match(str1,\
    \ str2)\n        local stack = {}\n        for i = 1, #str1 do\n            local\
    \ c = str1:sub(i, i)\n            if c == '(' then\n                stack_push(stack,\
    \ c)\n            else\n                if stack_empty(stack) then\n         \
    \           return false\n                else\n                    stack_pop(stack)\n\
    \                end\n            end\n        end\n        local open_parens\
    \ = {}\n        while not stack_empty(stack) do\n            local paren = stack_pop(stack)\n\
    \            table.insert(open_parens, paren)\n        end\n        for i = 1,\
    \ #str2 do\n            local c = str2:sub(i, i)\n            if c == '(' then\n\
    \                stack_push(stack, c)\n            else\n                if stack_empty(stack)\
    \ then\n                    return false\n                else\n             \
    \       stack_pop(stack)\n                end\n            end\n        end\n\
    \        while not stack_empty(stack) do\n            local paren = stack_pop(stack)\n\
    \            if paren ~= table.remove(open_parens) then\n                return\
    \ false\n            end\n        end\n", "    -- your code goes here\n    local\
    \ nleft, nright = 0, 0\n    for i = 1, #lst[1] do\n        local p = lst[1]:sub(i,\
    \ i)\n        if p == '(' then\n            nleft = nleft + 1\n        else\n\
    \            nright = nright + 1\n        end\n    end\n    for i = 1, #lst[2]\
    \ do\n        local p = lst[2]:sub(i, i)\n        if p == '(' then\n         \
    \   nleft = nleft + 1\n        else\n            nright = nright + 1\n       \
    \ end\n    end\n    if nleft == nright then\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend", "  local open, close = 0, 0\n  for i = 1,\
    \ #lst[1] do\n    if lst[1]:sub(i, i) == '(' then\n      open = open + 1\n   \
    \ else\n      close = close + 1\n    end\n  end\n  for i = 1, #lst[2] do\n   \
    \ if lst[2]:sub(i, i) == '(' then\n      open = open + 1\n    else\n      close\
    \ = close + 1\n    end\n  end\n  if open == close then\n    return 'Yes'\n  else\n\
    \    return 'No'\n  end\nend", "  local function good(s)\n    local cnt = 0\n\
    \    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n        cnt = cnt + 1\n\
    \      else\n        cnt = cnt - 1\n      end\n      if cnt < 0 then\n       \
    \ return false\n      end\n    end\n    return cnt == 0\n  end\n  local x, y =\
    \ lst[1], lst[2]\n  return good(x .. y) or good(y .. x) and 'Yes' or 'No'\nend",
  "    local parens = {['('] = ')', [')'] = '('}\n    local stack = {}\n    local\
    \ i = 1\n    local j = 1\n    local a = lst[1]\n    local b = lst[2]\n    local\
    \ la = #a\n    local lb = #b\n    local t = ''\n    local c", "    local dif =\
    \ 0\n    for i = 1, 2 do\n        for j = 1, #lst[i] do\n            if lst[i]:sub(j,\
    \ j) == '(' then\n                dif = dif + 1\n            else\n          \
    \      dif = dif - 1\n            end\n            if dif < 0 then\n         \
    \       return 'No'\n            end\n        end\n    end\n    return 'Yes'\n\
    end", "    local s1, s2 = lst[1], lst[2]\n    local n1, n2 = s1:match('^%(+()'),\
    \ s2:match('^%(+()')\n    local has_first_open, has_second_open = false, false\n\
    \    if n1 and n2 then\n        has_first_open, has_second_open = true, true\n\
    \    elseif n1 then\n        has_first_open = true\n    elseif n2 then\n     \
    \   has_second_open = true\n    end\n    -- it is impossible to make a good string\
    \ otherwise\n    if not has_first_open and not has_second_open then\n        return\
    \ 'No'\n    end\n    return is_good(s1 .. s2) and 'Yes' or 'No'\nend", "  if lst[1]\
    \ == ')' then return 'No' end\n  local cnt1, cnt2 = 0, 0\n  for i = 1, #lst[1]\
    \ do\n    if lst[1]:sub(i, i) == '(' then cnt1 = cnt1 + 1\n    else cnt1 = cnt1\
    \ - 1 end\n  end\n  for i = 1, #lst[2] do\n    if lst[2]:sub(i, i) == '(' then\
    \ cnt2 = cnt2 + 1\n    else cnt2 = cnt2 - 1 end\n  end\n  if cnt1 + cnt2 == 0\
    \ then return 'Yes'\n  else return 'No' end\nend", "    local function is_good(str)\n\
    \        local opened = 0\n        for c in str:gmatch('.') do\n            if\
    \ c == '(' then\n                opened = opened + 1\n            else\n     \
    \           opened = opened - 1\n            end\n            if opened < 0 then\n\
    \                return false\n            end\n        end\n        return opened\
    \ == 0\n    end\n    local function dfs(lst, path)\n        if is_good(path) then\n\
    \            return 'Yes'\n        end\n        for i, s in ipairs(lst) do\n \
    \           if #s > 0 then\n                table.remove(lst, i)\n           \
    \     local ret = dfs(lst, path .. s)\n                if ret == 'Yes' then\n\
    \                    return ret\n                end\n                table.insert(lst,\
    \ i, s)\n            end\n        end\n        return 'No'\n    end\n    return\
    \ dfs(lst, '')\nend", "  local parens = {\n    ['('] = 0,\n    [')'] = 0\n  }\n\
    \  for _, v in ipairs(lst) do\n    for _, c in ipairs(v:split('')) do\n      parens[c]\
    \ = parens[c] + 1\n    end\n  end\n  if parens['('] == parens[')'] then\n    return\
    \ 'Yes'\n  else\n    return 'No'\n  end\nend", "    local left, right = 0, 0\n\
    \    for c in lst[1]:gmatch('.') do\n        if c == '(' then\n            left\
    \ = left + 1\n        else\n            left = left - 1\n        end\n    end\n\
    \    for c in lst[2]:gmatch('.') do\n        if c == '(' then\n            right\
    \ = right + 1\n        else\n            right = right - 1\n        end\n    end\n\
    \    if left < 0 or right < 0 then\n        return 'No'\n    end\n    if left\
    \ == 0 and right == 0 then\n        return 'Yes'\n    end\n    if left + right\
    \ == 0 then\n        return 'Yes'\n    end\n    return 'No'\nend", "    local\
    \ parens = {\n        ['('] = function(paren) return paren == ')' end,\n     \
    \   [')'] = function(paren) return paren == '(' end\n    }\n    local function\
    \ is_good(s)\n        local c = 0\n        for i = 1, #s do\n            local\
    \ c = s:sub(i, i)\n            if parens[c] then\n                c = c + (parens[c](c)\
    \ and -1 or 1)\n            end\n            if c < 0 then\n                return\
    \ false\n            end\n        end\n        return c == 0\n    end\n    return\
    \ is_good(lst[1] .. lst[2]) and 'Yes' or 'No'\nend", "  -- your code here\n  local\
    \ open = 0\n  local close = 0\n  for _,v in ipairs(lst) do\n    for i = 1, #v\
    \ do\n      if v:sub(i,i) == '(' then\n        open = open + 1\n      else\n \
    \       close = close + 1\n      end\n    end\n  end\n  if open == close then\n\
    \    return 'Yes'\n  else\n    return 'No'\n  end\nend", "    local l = lst[1]\n\
    \    local r = lst[2]\n    local lcnt = 0\n    local rcnt = 0\n    for i = 1,\
    \ #l do\n        if l:sub(i, i) == '(' then\n            lcnt = lcnt + 1\n   \
    \     else\n            lcnt = lcnt - 1\n        end\n    end\n    for i = 1,\
    \ #r do\n        if r:sub(i, i) == '(' then\n            rcnt = rcnt + 1\n   \
    \     else\n            rcnt = rcnt - 1\n        end\n    end\n    if lcnt + rcnt\
    \ == 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend",
  "  local left, right = lst[1], lst[2]\n  local nleft, nright = count(left, '('),\
    \ count(right, ')')\n  if nleft == nright then\n    return 'Yes'\n  else\n   \
    \ return 'No'\n  end\nend", "  -- 'count' will count the number of open parentheses\
    \ minus the number of close\n  -- parentheses. If the number is negative, then\
    \ there are already more closed\n  -- parentheses than opened ones. If the number\
    \ is positive, then there are\n  -- more opened parentheses than closed ones.\
    \ So, if 'count' is negative,\n  -- there will be a closed parentheses left unmatched,\
    \ which is not good.\n  -- If count is 0, then all parentheses are balanced, which\
    \ is good. If count\n  -- is positive, we will keep searching the second string\
    \ to see if we can\n  -- match those opened parentheses.\n  local function helper(s1,\
    \ s2, count)\n    for i = 1, #s1 do\n      if s1:sub(i, i) == '(' then\n     \
    \   count = count + 1\n      else\n        count = count - 1\n      end\n    \
    \  if count < 0 then\n        return false\n      end\n    end\n    if count ==\
    \ 0 then\n      return true\n    end\n    for i = 1, #s2 do\n      if s2:sub(i,\
    \ i) == '(' then\n        count = count + 1\n      else\n        count = count\
    \ - 1\n      end\n      if count == 0 then\n        return true\n      end\n \
    \   end\n    return false\n  end\n  return helper(lst[1], lst[2], 0) and 'Yes'\
    \ or 'No'\nend", "  local left  = 0\n  local right = 0\n  for i = 1, #lst[1] do\n\
    \    if lst[1]:sub(i, i) == '(' then\n      left = left + 1\n    else\n      right\
    \ = right + 1\n    end\n  end\n  for i = 1, #lst[2] do\n    if lst[2]:sub(i, i)\
    \ == '(' then\n      left = left + 1\n    else\n      right = right + 1\n    end\n\
    \  end\n  if left == right then\n    return 'Yes'\n  else\n    return 'No'\n \
    \ end\nend", "  local open, closed = 0, 0\n  for _, s in ipairs(lst) do\n    for\
    \ c in s:gmatch('[()]') do\n      if c == '(' then\n        open = open + 1\n\
    \      else\n        closed = closed + 1\n      end\n    end\n  end\n  return\
    \ (open == closed) and 'Yes' or 'No'\nend", "  local cnt1, cnt2 = 0, 0\n  for\
    \ ch in lst[1]:gmatch(\"%(\") do cnt1 = cnt1 + 1 end\n  for ch in lst[1]:gmatch(\"\
    %)\") do cnt1 = cnt1 - 1 end\n  for ch in lst[2]:gmatch(\"%(\") do cnt2 = cnt2\
    \ + 1 end\n  for ch in lst[2]:gmatch(\"%)\") do cnt2 = cnt2 - 1 end\n  if cnt1\
    \ == 0 and cnt2 == 0 then return \"Yes\" end\n  if cnt1 == 0 and cnt2 > 0 then\
    \ return \"No\" end\n  if cnt1 > 0 and cnt2 == 0 then return \"No\" end\n  if\
    \ cnt1 < 0 and cnt2 < 0 then return \"No\" end\n  if cnt1 > 0 and cnt2 > 0 then\
    \ return \"Yes\" end\n  if cnt1 < 0 and cnt2 > 0 then return \"Yes\" end\n  if\
    \ cnt1 > 0 and cnt2 < 0 then return \"Yes\" end\nend", "    local s1, s2 = lst[1],\
    \ lst[2]\n    -- If a string contains only of open parentheses, then it is impossible\n\
    \    -- to make a good string.\n    if not string.find(s1, '%)') then\n      \
    \  return 'No'\n    end\n    -- If a string contains only of close parentheses,\
    \ then it is impossible\n    -- to make a good string.\n    if not string.find(s2,\
    \ '%(') then\n        return 'No'\n    end\n    -- Because we have to have a close\
    \ parentheses every time when we have\n    -- open parentheses, we can do a quick\
    \ check to see if the strings\n    -- can possibly be matched.\n    local o1,\
    \ c1 = #string.gsub(s1, '%(', ''), #string.gsub(s1, '%)', '')\n    local o2, c2\
    \ = #string.gsub(s2, '%(', ''), #string.gsub(s2, '%)', '')\n    if o1 + o2 <=\
    \ c1 + c2 then\n        return 'No'\n    end\n    -- Now we try every possible\
    \ concatenation of the two strings,\n    -- and check if the resulting string\
    \ is good.\n    for _, s in ipairs{s1..s2, s2..s1} do\n        local stack = {}\n\
    \        local top = 0\n        for c in s:gmatch('.') do\n            if c ==\
    \ '(' then\n                top = top + 1\n                stack[top] = c\n  \
    \          else\n                if top > 0 then\n                    top = top\
    \ - 1\n                else\n                    break\n                end\n\
    \            end\n        end\n        if top == 0 then\n            return 'Yes'\n\
    \        end\n    end\n    return 'No'\nend", "    local a, b = lst[1], lst[2]\n\
    \    if count_parens(a) == count_parens(b) then\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend", "  local first, second = lst[1], lst[2]\n\
    \  if string.find(first, '%(') == nil and string.find(second, '%(') == nil then\n\
    \    return 'No'\n  end\n  local function make_parens(str)\n    local cnt = 0\n\
    \    for i = 1, #str do\n      local c = str:sub(i, i)\n      if c == '(' then\n\
    \        cnt = cnt + 1\n      else\n        cnt = cnt - 1\n      end\n      if\
    \ cnt < 0 then\n        return false\n      end\n    end\n    return cnt == 0\n\
    \  end\n  return make_parens(first..second) and 'Yes' or 'No'\nend", "    local\
    \ s = 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i, i) == '(' then\n\
    \            s = s + 1\n        else\n            s = s - 1\n        end\n   \
    \     if s < 0 then\n            return 'No'\n        end\n    end\n    for i\
    \ = 1, #lst[2] do\n        if lst[2]:sub(i, i) == '(' then\n            s = s\
    \ + 1\n        else\n            s = s - 1\n        end\n        if s < 0 then\n\
    \            return 'No'\n        end\n    end\n    return s == 0 and 'Yes' or\
    \ 'No'\nend", "  local open = 0\n  local close = 0\n  for _, str in ipairs(lst)\
    \ do\n    for c in str:gmatch('.') do\n      if c == '(' then\n        open =\
    \ open + 1\n      else\n        close = close + 1\n      end\n    end\n  end\n\
    \  if open == close then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend",
  "  local open, close = 0, 0\n  for ch in table.concat(lst):gmatch('.') do\n    if\
    \ ch == '(' then\n      open = open + 1\n    else\n      if open > 0 then\n  \
    \      open = open - 1\n      else\n        close = close + 1\n      end\n   \
    \ end\n  end\n  return open == 0 and close == 0 and 'Yes' or 'No'\nend", "  local\
    \ s = lst[1] .. lst[2]\n  local count = 0\n  for i=1,#s do\n    local c = s:sub(i,i)\n\
    \    if c == '(' then\n      count = count + 1\n    else\n      count = count\
    \ - 1\n    end\n    if count < 0 then\n      return 'No'\n    end\n  end\n  return\
    \ count == 0 and 'Yes' or 'No'\nend", "  local s1, s2 = lst[1], lst[2]\n  local\
    \ A = {s1:match((s1:gsub('[()]', '()')))}\n  local B = {s2:match((s2:gsub('[()]',\
    \ '()')))}\n  local len1, len2 = #A, #B\n  local i, j = 1, 1\n  local res = {}\n\
    \  while i <= len1 or j <= len2 do\n    if i <= len1 and A[i] == '(' then\n  \
    \    res[#res + 1] = '('\n      i = i + 1\n    elseif j <= len2 and B[j] == '('\
    \ then\n      res[#res + 1] = '('\n      j = j + 1\n    elseif i <= len1 and A[i]\
    \ == ')' then\n      res[#res + 1] = ')'\n      i = i + 1\n    elseif j <= len2\
    \ and B[j] == ')' then\n      res[#res + 1] = ')'\n      j = j + 1\n    end\n\
    \  end\n  local s = table.concat(res)\n  local a, b = 0, 0\n  for c in s:gmatch('.')\
    \ do\n    if c == '(' then\n      a = a + 1\n    else\n      b = b + 1\n    end\n\
    \    if b > a then\n      return 'No'\n    end\n  end\n  return 'Yes'\nend", " \
    \   local open = 0\n    local close = 0\n    for _, paren in ipairs(lst) do\n\
    \        for i = 1, #paren do\n            if paren:sub(i, i) == '(' then\n  \
    \              open = open + 1\n            else\n                close = close\
    \ + 1\n            end\n        end\n    end\n    return open == close and 'Yes'\
    \ or 'No'\nend", "  -- your code here\n  local len1 = #lst[1]\n  local len2 =\
    \ #lst[2]\n  local cnt1 = 0\n  local cnt2 = 0\n  for i = 1, len1 do\n    local\
    \ ch = lst[1]:sub(i, i)\n    if ch == '(' then\n      cnt1 = cnt1 + 1\n    else\n\
    \      cnt1 = cnt1 - 1\n    end\n  end\n  for i = 1, len2 do\n    local ch = lst[2]:sub(i,\
    \ i)\n    if ch == '(' then\n      cnt2 = cnt2 + 1\n    else\n      cnt2 = cnt2\
    \ - 1\n    end\n  end\n  if cnt1 > 0 and cnt2 < 0 then\n    return 'No'\n  elseif\
    \ cnt1 < 0 and cnt2 > 0 then\n    return 'No'\n  else\n    return 'Yes'\n  end\n\
    end", "    local lhs = lst[1]\n    local rhs = lst[2]\n    local lhs_l = 0\n \
    \   local rhs_l = 0\n    for i = 1, #lhs do\n        if lhs:sub(i, i) == '(' then\n\
    \            lhs_l = lhs_l + 1\n        else\n            lhs_l = lhs_l - 1\n\
    \        end\n    end\n    for i = 1, #rhs do\n        if rhs:sub(i, i) == '('\
    \ then\n            rhs_l = rhs_l + 1\n        else\n            rhs_l = rhs_l\
    \ - 1\n        end\n    end\n    if lhs_l > 0 and rhs_l > 0 then\n        return\
    \ 'No'\n    elseif lhs_l < 0 and rhs_l < 0 then\n        return 'No'\n    else\n\
    \        return 'Yes'\n    end\nend", "  local balance = 0\n  for _, s in ipairs(lst)\
    \ do\n    for _, c in ipairs(s:chars()) do\n      if c == '(' then\n        balance\
    \ = balance + 1\n      else\n        balance = balance - 1\n      end\n      if\
    \ balance < 0 then\n        return 'No'\n      end\n    end\n  end\n  return balance\
    \ == 0 and 'Yes' or 'No'\nend", "  local function is_good(str)\n    local cnt\
    \ = 0\n    for i = 1, #str do\n      if str:sub(i, i) == '(' then\n        cnt\
    \ = cnt + 1\n      else\n        cnt = cnt - 1\n      end\n      if cnt < 0 then\n\
    \        return false\n      end\n    end\n    return cnt == 0\n  end\n  local\
    \ perm_gen = require('fp.permutation')\n  local str1, str2 = lst[1], lst[2]\n\
    \  local res = perm_gen(str1, str2)\n  for perm in res do\n    if is_good(perm)\
    \ then\n      return 'Yes'\n    end\n  end\n  return 'No'\nend", "    -- your\
    \ code goes here\n    lst[1], lst[2] = lst[1] .. lst[2], nil\n    local num =\
    \ 0\n    local flag = true\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i,\
    \ i) == '(' then\n            num = num + 1\n        else\n            num = num\
    \ - 1\n        end\n        if num < 0 then\n            flag = false\n      \
    \      break\n        end\n    end\n    if flag and num == 0 then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend", "  local left = lst[1]:gsub('%)',\
    \ '')\n  local right = lst[2]:gsub('%(', '')\n  if #left ~= #right then\n    return\
    \ 'No'\n  end\n  return 'Yes'\nend", "    local function is_good(str)\n      \
    \  local balance = 0\n        for i = 1, #str do\n            if str:sub(i, i)\
    \ == '(' then\n                balance = balance + 1\n            else\n     \
    \           balance = balance - 1\n            end\n            if balance < 0\
    \ then\n                return false\n            end\n        end\n        return\
    \ balance == 0\n    end\n    return (is_good(lst[1]) and is_good(lst[2])) and\n\
    \        (is_good(lst[1] .. lst[2]) or is_good(lst[2] .. lst[1])) and\n      \
    \  'Yes' or 'No'\nend", "  local function resolve(s)\n    local res = 0\n    for\
    \ i = 1, #s do\n      if s:sub(i, i) == '(' then\n        res = res + 1\n    \
    \  else\n        res = res - 1\n      end\n      if res < 0 then\n        return\
    \ false\n      end\n    end\n    return res == 0\n  end\n  return resolve(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend", "  local open, close = 0, 0\n  for _, ch\
    \ in ipairs(lst) do\n    for c in ch:gmatch(\".\") do\n      if c == '(' then\n\
    \        open = open + 1\n      else\n        close = close + 1\n      end\n \
    \   end\n  end\n  return open >= close and 'Yes' or 'No'\nend", "    -- keep track\
    \ of how many open '(' there are\n    local left = 0\n    -- keep track of how\
    \ many closed ')' there are\n    local right = 0\n    -- check the two strings\
    \ in the list\n    for _, str in ipairs(lst) do\n        -- keep track of open\
    \ and closed parantheses for each string\n        for ch in str:gmatch(\".\")\
    \ do\n            if ch == '(' then\n                left = left + 1\n       \
    \     else\n                right = right + 1\n            end\n        end\n\
    \    end\n    -- if there are more closed than open, return 'No'\n    if right\
    \ > left then\n        return 'No'\n    end\n    -- return 'Yes' if there's a\
    \ way to make a good string\n    return 'Yes'\nend", "  local function valid_comb(str1,\
    \ str2)\n    local balance = 0\n    for i = 1, #str1 do\n      if str1:sub(i,\
    \ i) == '(' then\n        balance = balance + 1\n      else\n        balance =\
    \ balance - 1\n      end\n      if balance < 0 then\n        return false\n  \
    \    end\n    end\n    for i = 1, #str2 do\n      if str2:sub(i, i) == '(' then\n\
    \        balance = balance + 1\n      else\n        balance = balance - 1\n  \
    \    end\n      if balance < 0 then\n        return false\n      end\n    end\n\
    \    return balance == 0\n  end\n  return valid_comb(lst[1], lst[2]) or valid_comb(lst[2],\
    \ lst[1]) and 'Yes' or 'No'\nend", "    -- Count of opening and closing parentheses\
    \ in each string\n    local n, m = 0, 0\n    for _, s in ipairs(lst) do\n    \
    \    local op, cl = 0, 0\n        for _ in s:gmatch('%(') do op = op + 1 end\n\
    \        for _ in s:gmatch('%)') do cl = cl + 1 end\n        n = n + op\n    \
    \    m = m + cl\n    end\n    -- Check if the whole string is balanced\n    if\
    \ n == m then return 'Yes' end\n    -- Check if there is a way to balance the\
    \ whole string\n    return (n - m) % 2 == 0 and 'Yes' or 'No'\nend", "\tlocal\
    \ len = 0\n\tfor _, v in ipairs(lst) do\n\t\tlen = len + #v\n\tend\n\tlocal s\
    \ = table.concat(lst)\n\tlocal up, down = 0, 0\n\tfor i = 1, len do\n\t\tif s:sub(i,\
    \ i) == '(' then\n\t\t\tup = up + 1\n\t\telse\n\t\t\tdown = down + 1\n\t\tend\n\
    \t\tif down > up then\n\t\t\treturn 'No'\n\t\tend\n\tend\n\treturn up == down\
    \ and 'Yes' or 'No'\nend", "  local closed_to_open = {\n    [')'] = '(',\n  }\n\
    \  local function balanced(str)\n    local stack = {}\n    for i = 1, #str do\n\
    \      local c = str:sub(i, i)\n      if c == '(' then\n        table.insert(stack,\
    \ c)\n      else\n        local top = table.remove(stack)\n        if top ~= closed_to_open[c]\
    \ then\n          return false\n        end\n      end\n    end\n    return #stack\
    \ == 0\n  end\n  local function concat(a, b)\n    return a .. b\n  end\n  local\
    \ function is_good(str)\n    return balanced(str)\n  end\n  local str = lst[1]\
    \ .. lst[2]\n  for i = 1, #str do\n    for j = i + 1, #str do\n      local left\
    \ = str:sub(1, i)\n      local right = str:sub(i + 1, j)\n      local rest = str:sub(j\
    \ + 1)\n      local b1 = concat(left, right)\n      local b2 = concat(b1, rest)\n\
    \      if is_good(b2) then\n        return 'Yes'\n      end\n    end\n  end\n\
    \  return 'No'\nend", "    local unbalanced_num, stack = 0, { }\n    for _, s\
    \ in ipairs(lst) do\n        for c in s:gmatch('.') do\n            if c == '('\
    \ then\n                table.insert(stack, c)\n            else\n           \
    \     if #stack == 0 then\n                    unbalanced_num = unbalanced_num\
    \ + 1\n                else\n                    table.remove(stack)\n       \
    \         end\n            end\n        end\n    end\n    return #stack == unbalanced_num\
    \ and 'Yes' or 'No'\nend", "  local function pop_paren(str)\n    local sym = str:sub(1,\
    \ 1)\n    local rem = str:sub(2)\n    if sym == '(' then\n      return '('\n \
    \   elseif sym == ')' then\n      return rem\n    end\n  end\n  local function\
    \ reduce_parens(str)\n    if str == '' then\n      return str\n    else\n    \
    \  local rem, sym = pop_paren(str)\n      if sym == '(' then\n        local op_sym,\
    \ clo_rem = reduce_parens(rem)\n        if op_sym == '(' then\n          return\
    \ '', clo_rem\n        else\n          return op_sym, clo_rem\n        end\n \
    \     else\n        return sym, rem\n      end\n    end\n  end\n  local tot_str\
    \ = lst[1] .. lst[2]\n  local rem_str = reduce_parens(tot_str)\n  if rem_str ==\
    \ '' then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend", "  local c\
    \ = 0\n  for i = 1, #lst[1] do\n    if lst[1]:sub(i, i) == '(' then\n      c =\
    \ c + 1\n    else\n      c = c - 1\n    end\n  end\n  for i = 1, #lst[2] do\n\
    \    if lst[2]:sub(i, i) == '(' then\n      c = c + 1\n    else\n      c = c -\
    \ 1\n    end\n  end\n  return (c == 0) and 'Yes' or 'No'\nend", "  local lst =\
    \ table.concat(lst)\n  -- This is an edge case where if the last parenthesis is\
    \ a closing one,\n  -- then there's no way to make the resulting string good.\n\
    \  if lst:sub(-1) == ')' then\n    return 'No'\n  end\n  -- Creates a list of\
    \ opening parentheses only.\n  local stack = lst:gsub('%)', '')\n  -- Iterates\
    \ over the list. If a closing parenthesis is encountered,\n  -- checks if it's\
    \ balanced by a previous opening parenthesis.\n  for i=1, #lst do\n    if lst:sub(i,\
    \ i) == ')' then\n      if #stack == 0 then\n        return 'No'\n      end\n\
    \      stack = stack:sub(1, -2)\n    end\n  end\n  return 'Yes'\nend", "    local\
    \ function check_balanced(str)\n        local level = 0\n        for i = 1, #str\
    \ do\n            if str:sub(i, i) == '(' then\n                level = level\
    \ + 1\n            else\n                level = level - 1\n            end\n\
    \            if level < 0 then\n                return false\n            end\n\
    \        end\n        return level == 0\n    end\n    return check_balanced(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend", "    local depth = 0\n    for _, s in ipairs(lst)\
    \ do\n        for p in s:gmatch('.') do\n            if p == '(' then\n      \
    \          depth = depth + 1\n            else\n                depth = depth\
    \ - 1\n            end\n            if depth < 0 then\n                return\
    \ 'No'\n            end\n        end\n    end\n    return 'Yes'\nend", "    local\
    \ s = table.concat(lst)\n    local c = 0\n    for i = 1, #s do\n        if s:sub(i,\
    \ i) == '(' then\n            c = c + 1\n        else\n            c = c - 1\n\
    \        end\n        if c < 0 then\n            return 'No'\n        end\n  \
    \  end\n    return c == 0 and 'Yes' or 'No'\nend", "    local left, right = 0,\
    \ 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i, i) == '(' then\n    \
    \        left = left + 1\n        else\n            left = left - 1\n        end\n\
    \    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i, i) == '(' then\n\
    \            right = right + 1\n        else\n            right = right - 1\n\
    \        end\n    end\n    return (left > 0 and right < 0 and right + left ==\
    \ 0) or\n           (left < 0 and right > 0 and right + left == 0) and 'Yes' or\
    \ 'No'\nend", "  local stack, r, s = {}, {}, lst[1] .. lst[2]\n  for i = 1, #s\
    \ do\n    if s:sub(i, i) == '(' then\n      table.insert(stack, '(')\n    else\n\
    \      if #stack > 0 then\n        table.remove(stack)\n      else\n        table.insert(r,\
    \ ')')\n      end\n    end\n  end\n  return (#r == 0 and #stack == 0) and 'Yes'\
    \ or 'No'\nend", "  local function is_good(s)\n    local cnt = 0\n    for c in\
    \ s:gmatch('.') do\n      if c == '(' then\n        cnt = cnt + 1\n      else\n\
    \        cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n\
    \      end\n    end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  if is_good(s1 .. s2) or is_good(s2 .. s1) then\n    return 'Yes'\n  else\n\
    \    return 'No'\n  end\nend", "    local close_p = false\n    local open_p =\
    \ false\n    for _,v in ipairs(lst) do\n        if v:match('%)') then\n      \
    \      close_p = true\n        end\n        if v:match('%(') then\n          \
    \  open_p = true\n        end\n    end\n    return close_p and open_p and 'Yes'\
    \ or 'No'\nend", "  local left = 0\n  local right = 0\n  for i = 1, #lst[1] do\n\
    \    if lst[1]:sub(i, i) == '(' then\n      left = left + 1\n    else\n      right\
    \ = right + 1\n    end\n  end\n  for i = 1, #lst[2] do\n    if lst[2]:sub(i, i)\
    \ == '(' then\n      left = left + 1\n    else\n      right = right + 1\n    end\n\
    \  end\n  if left == right then\n    return 'Yes'\n  else\n    return 'No'\n \
    \ end\nend", "    local target = ''\n    for _, s in ipairs(lst) do\n        if\
    \ not isgood(s) then\n            return 'No'\n        end\n        target = target\
    \ .. s\n    end\n    return isgood(target) and 'Yes' or 'No'\nend", "    local\
    \ left, right = 0, 0\n    for _, v in ipairs(lst) do\n        for c in v:gmatch('%(%-%)')\
    \ do\n            left = left + 1\n        end\n        for c in v:gmatch('%)%-%(')\
    \ do\n            right = right + 1\n        end\n    end\n    return (left >\
    \ right and 'Yes') or 'No'\nend", "  local known = {}\n  local open = lst[1]:gsub('%)',\
    \ '')\n  local close = lst[2]:gsub('%(', '')\n  local balance = #open - #close\n\
    \  if balance < 0 then\n    return 'No'\n  end\n  known[balance] = true\n  while\
    \ #open > 0 and #close > 0 do\n    local x = open:sub(1, 1)\n    local y = close:sub(1,\
    \ 1)\n    if x == '(' and y == ')' then\n      open = open:sub(2)\n      close\
    \ = close:sub(2)\n    elseif x == '(' then\n      close = close:sub(2)\n     \
    \ balance = balance + 1\n      if known[balance] then\n        return 'No'\n \
    \     end\n      known[balance] = true\n    else\n      open = open:sub(2)\n \
    \     balance = balance - 1\n      if known[balance] then\n        return 'No'\n\
    \      end\n      known[balance] = true\n    end\n  end\n  if balance > 0 then\n\
    \    return 'No'\n  end\n  return 'Yes'\nend", "    local function nleft(s)\n\
    \        local n = 0\n        for c in s:gmatch('%(') do\n            n = n +\
    \ 1\n        end\n        return n\n    end\n    local function nright(s)\n  \
    \      local n = 0\n        for c in s:gmatch('%)') do\n            n = n + 1\n\
    \        end\n        return n\n    end\n    local s0, s1 = lst[1], lst[2]\n \
    \   if nleft(s0) + nleft(s1) == nright(s0) + nright(s1) then\n        return 'Yes'\n\
    \    else\n        return 'No'\n    end\nend", "    local ans = 'Yes'\n    local\
    \ function traverse(s)\n        local exp, idx = 0, 1\n        while s:sub(idx,\
    \ idx) do\n            if s:sub(idx, idx) == '(' then\n                exp = exp\
    \ + 1\n            else\n                exp = exp - 1\n            end\n    \
    \        if exp < 0 then\n                ans = 'No'\n                break\n\
    \            end\n            idx = idx + 1\n        end\n        if exp ~= 0\
    \ then\n            ans = 'No'\n        end\n    end\n    traverse(lst[1])\n \
    \   traverse(lst[2])\n    return ans\nend", "  local function _parens(s)\n   \
    \ local res = ''\n    for c in s:gmatch('.') do\n      if c == '(' then\n    \
    \    res = res .. ')'\n      else\n        res = '(' .. res\n      end\n    end\n\
    \    return res\n  end\n  local lhs, rhs = _parens(lst[1]), _parens(lst[2])\n\
    \  return tostring(lhs == rhs)\nend", "    local open = 0\n    local close = 0\n\
    \    for i = 1, #lst[1] do\n        if lst[1]:sub(i, i) == '(' then\n        \
    \    open = open + 1\n        else\n            close = close + 1\n        end\n\
    \    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i, i) == '(' then\n\
    \            open = open + 1\n        else\n            close = close + 1\n  \
    \      end\n    end\n    if open == close then\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend", "  local l, r = lst[1], lst[2]\n  local c\
    \ = 0\n  for i = 1, #l do\n    if l:sub(i, i) == '(' then\n      c = c + 1\n \
    \   else\n      c = c - 1\n    end\n  end\n  if c < 0 then\n    return 'No'\n\
    \  end\n  c = 0\n  for i = 1, #r do\n    if r:sub(i, i) == ')' then\n      c =\
    \ c + 1\n    else\n      c = c - 1\n    end\n  end\n  if c < 0 then\n    return\
    \ 'No'\n  end\n  return 'Yes'\nend", "    local open_parens, close_parens = 0,\
    \ 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i, i) == '(' then\n    \
    \        open_parens = open_parens + 1\n        else\n            close_parens\
    \ = close_parens + 1\n        end\n    end\n    for i = 1, #lst[2] do\n      \
    \  if lst[2]:sub(i, i) == '(' then\n            open_parens = open_parens + 1\n\
    \        else\n            close_parens = close_parens + 1\n        end\n    end\n\
    \    return open_parens == close_parens and 'Yes' or 'No'\nend", "  local c1,\
    \ c2 = lst[1], lst[2]\n  for i=1,#c1 do\n    if count_parens(c1:sub(1, i)) ==\
    \ count_parens(c2) then\n      return 'Yes'\n    end\n  end\n  return 'No'\nend",
  "    local count1, count2 = 0, 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i,\
    \ i) == '(' then\n            count1 = count1 + 1\n        else\n            count1\
    \ = count1 - 1\n        end\n    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i,\
    \ i) == '(' then\n            count2 = count2 + 1\n        else\n            count2\
    \ = count2 - 1\n        end\n    end\n    if count1 + count2 == 0 then\n     \
    \   return 'Yes'\n    else\n        return 'No'\n    end\nend", "\tlocal left,\
    \ right = 0, 0\n\tfor i = 1, #lst[1] do\n\t\tif lst[1]:sub(i, i) == '(' then\n\
    \t\t\tleft = left + 1\n\t\telse\n\t\t\tright = right + 1\n\t\tend\n\tend\n\tfor\
    \ i = 1, #lst[2] do\n\t\tif lst[2]:sub(i, i) == '(' then\n\t\t\tleft = left +\
    \ 1\n\t\telse\n\t\t\tright = right + 1\n\t\tend\n\tend\n\tif left == right then\n\
    \t\treturn 'Yes'\n\telse\n\t\treturn 'No'\n\tend\nend", "    if #lst == 0 then\n\
    \        return 'Yes'\n    end\n    local left = 0\n    local right = 0\n    for\
    \ _, s in ipairs(lst) do\n        for i = 1, #s do\n            if s:sub(i, i)\
    \ == '(' then\n                left = left + 1\n            else\n           \
    \     right = right + 1\n            end\n        end\n    end\n    if left ==\
    \ right then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend",
  "  local diff = 0\n  for _, str in ipairs(lst) do\n    for c in str:gmatch('.')\
    \ do\n      if c == '(' then\n        diff = diff + 1\n      else\n        diff\
    \ = diff - 1\n      end\n      if diff < 0 then\n        return 'No'\n      end\n\
    \    end\n  end\n  return diff == 0 and 'Yes' or 'No'\nend", "    local function\
    \ aux_match_parens(s1, s2)\n        if s1 == '' then\n            return good_string(s2)\n\
    \        elseif s2 == '' then\n            return good_string(s1)\n        else\n\
    \            return good_string(s1 .. s2) or\n                   aux_match_parens(s1\
    \ .. s2[1], s2:sub(2)) or\n                   aux_match_parens(s1, s2:sub(2))\n\
    \        end\n    end\n    local s1, s2 = table.unpack(lst)\n    return aux_match_parens(s1,\
    \ s2) and 'Yes' or 'No'\nend", "    local a = lst[1]\n    local b = lst[2]\n \
    \   local s = a .. b\n    local cnt = 0\n    for ch in s:gmatch('.') do\n    \
    \    if ch == '(' then\n            cnt = cnt + 1\n        else\n            cnt\
    \ = cnt - 1\n        end\n        if cnt < 0 then\n            return 'No'\n \
    \       end\n    end\n    return cnt == 0 and 'Yes' or 'No'\nend", "    local\
    \ cnt = 0\n    for i = 1, #lst[1] do\n        cnt = cnt + (lst[1]:sub(i, i) ==\
    \ '(' and 1 or -1)\n        if cnt < 0 then\n            return 'No'\n       \
    \ end\n    end\n    for i = 1, #lst[2] do\n        cnt = cnt + (lst[2]:sub(i,\
    \ i) == '(' and 1 or -1)\n        if cnt < 0 then\n            return 'No'\n \
    \       end\n    end\n    return 'Yes'\nend", "    local stack = {}\n    local\
    \ function push(c)\n        stack[#stack + 1] = c\n    end\n    local function\
    \ pop()\n        stack[#stack] = nil\n    end\n    local function top()\n    \
    \    return stack[#stack]\n    end\n    local function is_empty()\n        return\
    \ #stack == 0\n    end\n    local function is_good(s)\n        for i = 1, #s do\n\
    \            local c = s:sub(i, i)\n            if c == '(' then\n           \
    \     push(c)\n            else\n                if is_empty() then\n        \
    \            return false\n                end\n                pop()\n      \
    \      end\n        end\n        return is_empty()\n    end\n    return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend", "    -- Time complexity: O(1)\n    -- Space\
    \ complexity: O(1)\n    -- Because both strings are guaranteed to be of length\
    \ <= 11.\n    local lookup = {['()'] = 'Good', [')('] = 'Bad'}\n    return (lookup[lst[1]\
    \ .. lst[2]] or 'Yes')\nend", "  local prefix, suffix = lst[1], lst[2]\n  local\
    \ good = true\n  local prefix_balance, suffix_balance = 0, 0\n  for i = 1, #prefix\
    \ do\n    local char = prefix:sub(i, i)\n    if char == '(' then\n      prefix_balance\
    \ = prefix_balance + 1\n    else\n      prefix_balance = prefix_balance - 1\n\
    \    end\n    if prefix_balance < 0 then\n      good = false\n      break\n  \
    \  end\n  end\n  if good then\n    for i = 1, #suffix do\n      local char = suffix:sub(i,\
    \ i)\n      if char == '(' then\n        suffix_balance = suffix_balance + 1\n\
    \      else\n        suffix_balance = suffix_balance - 1\n      end\n      if\
    \ suffix_balance < 0 then\n        good = false\n        break\n      end\n  \
    \  end\n  end\n  if good then\n    return 'Yes'\n  else\n    return 'No'\n  end\n\
    end", "    local count = 0\n    for _, v in ipairs(lst) do\n        for _, p in\
    \ ipairs(v:split('')) do\n            if p == '(' then\n                count\
    \ = count + 1\n            else\n                count = count - 1\n         \
    \   end\n            if count < 0 then\n                return 'No'\n        \
    \    end\n        end\n    end\n    return count == 0 and 'Yes' or 'No'\nend",
  "    local str1, str2 = lst[1], lst[2]\n    local cnt1, cnt2 = 0, 0\n    for i =\
    \ 1, #str1 do\n        cnt1 = cnt1 + (str1:sub(i, i) == '(' and 1 or -1)\n   \
    \ end\n    for i = 1, #str2 do\n        cnt2 = cnt2 + (str2:sub(i, i) == '(' and\
    \ 1 or -1)\n    end\n    return (cnt1 + cnt2) == 0 and 'Yes' or 'No'\nend", " \
    \ local a, b = lst[1], lst[2]\n  local c = 0\n  for i = 1, #a do\n    if a:sub(i,\
    \ i) == '(' then\n      c = c + 1\n    else\n      c = c - 1\n    end\n    if\
    \ c < 0 then\n      return 'No'\n    end\n  end\n  c = 0\n  for i = 1, #b do\n\
    \    if b:sub(i, i) == '(' then\n      c = c + 1\n    else\n      c = c - 1\n\
    \    end\n    if c < 0 then\n      return 'No'\n    end\n  end\n  if c == 0 then\n\
    \    return 'Yes'\n  else\n    return 'No'\n  end\nend", "  local open, close\
    \ = 0, 0\n  for _, v in ipairs(lst) do\n    for c in v:gmatch('%(') do open =\
    \ open + 1 end\n    for c in v:gmatch('%)') do close = close + 1 end\n  end\n\
    \  return open == close and 'Yes' or 'No'\nend", "    local (for generator), (for\
    \ state), (for control) = ipairs(lst)\n    do\n        do break end\n        if\
    \ val == '(' then\n            pos = pos + 1\n        else\n            if pos\
    \ == 0 then\n                return 'No'\n            end\n            pos = pos\
    \ - 1\n        end\n    end\n    return (pos == 0 and 'Yes') or 'No'\nend", " \
    \ local a, b = lst[1], lst[2]\n  local function is_good(s)\n    local cnt = 0\n\
    \    for i = 1, #s do\n      local c = s:sub(i, i)\n      if c == '(' then\n \
    \       cnt = cnt + 1\n      else\n        cnt = cnt - 1\n      end\n      if\
    \ cnt < 0 then\n        return false\n      end\n    end\n    return cnt == 0\n\
    \  end\n  return is_good(a .. b) or is_good(b .. a) and 'Yes' or 'No'\nend", " \
    \ local num_open, num_close = 0, 0\n  for _, v in ipairs(lst) do\n    for _, x\
    \ in ipairs(v:gmatch('%(')) do\n      num_open = num_open + 1\n    end\n    for\
    \ _, x in ipairs(v:gmatch('%)')) do\n      num_close = num_close + 1\n    end\n\
    \  end\n  return num_open == num_close and 'Yes' or 'No'\nend", "    local s =\
    \ table.concat(lst)\n    local len = #s\n    local i = 1\n    local opened = 0\n\
    \    while i <= len do\n        if s:sub(i, i) == '(' then\n            opened\
    \ = opened + 1\n        else\n            opened = opened - 1\n        end\n \
    \       if opened < 0 then\n            return 'No'\n        end\n        i =\
    \ i + 1\n    end\n    return opened == 0 and 'Yes' or 'No'\nend", "  local function\
    \ helper(lst, n)\n    if n == 0 then return 'Yes' end\n    local s1, s2 = lst[1],\
    \ lst[2]\n    if s1:match('^%(') and s2:match('^%)') then\n      local t1, t2\
    \ = s1:sub(2), s2:sub(2)\n      return helper{t1, t2}, helper{t1, s2}, helper{s1,\
    \ t2}\n    elseif s1:match('^%)') and s2:match('^%(') then\n      local t1, t2\
    \ = s1:sub(2), s2:sub(2)\n      return helper{t1, t2}, helper{t1, s2}, helper{s1,\
    \ t2}\n    elseif s1:match('^%)') then\n      return helper{s1:sub(2), s2}\n \
    \   elseif s2:match('^%)') then\n      return helper{s1, s2:sub(2)}\n    elseif\
    \ s1:match('^%(') then\n      return helper{s1:sub(2), s2}\n    elseif s2:match('^%(')\
    \ then\n      return helper{s1, s2:sub(2)}\n    end\n  end\n  return helper(lst,\
    \ 2)\nend", "    local s, t = lst[1], lst[2]\n    local open, close = 0, 0\n \
    \   for i = 1, #s do\n        if s:sub(i, i) == '(' then\n            open = open\
    \ + 1\n        else\n            close = close + 1\n        end\n    end\n   \
    \ for i = 1, #t do\n        if t:sub(i, i) == '(' then\n            open = open\
    \ + 1\n        else\n            close = close + 1\n        end\n    end\n   \
    \ if open == close then\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend", "  local a, b = table.unpack(lst)\n  local a_open, a_close = 0,\
    \ 0\n  local b_open, b_close = 0, 0\n  for i = 1, #a do\n    if a:sub(i, i) ==\
    \ '(' then\n      a_open = a_open + 1\n    else\n      a_close = a_close + 1\n\
    \    end\n  end\n  for i = 1, #b do\n    if b:sub(i, i) == '(' then\n      b_open\
    \ = b_open + 1\n    else\n      b_close = b_close + 1\n    end\n  end\n  if a_open\
    \ == b_close and a_close == b_open then\n    return 'Yes'\n  else\n    return\
    \ 'No'\n  end\nend", "  local function balanced(s)\n    local level = 0\n    for\
    \ c in s:gmatch\".\" do\n      if c == \"(\" then\n        level = level + 1\n\
    \      else\n        level = level - 1\n      end\n      if level < 0 then\n \
    \       return false\n      end\n    end\n    return level == 0\n  end\n  return\
    \ balanced(lst[1] .. lst[2]) and \"Yes\" or \"No\"\nend", "  local open_parentheses,\
    \ close_parentheses = 0, 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        open_parentheses = open_parentheses + 1\n\
    \      else\n        close_parentheses = close_parentheses + 1\n      end\n  \
    \  end\n  end\n  return (open_parentheses > close_parentheses and 'Yes') or 'No'\n\
    end", "    local function remove_parens(str)\n        local function is_open(c)\n\
    \            return c == '('\n        end\n        local function is_close(c)\n\
    \            return c == ')'\n        end\n        local i = 1\n        while\
    \ i <= #str do\n            if is_open(str:sub(i, i)) then\n                local\
    \ j = i + 1\n                while j <= #str do\n                    if is_close(str:sub(j,\
    \ j)) then\n                        str = str:sub(1, i - 1) .. str:sub(j + 1)\n\
    \                        break\n                    end\n                    j\
    \ = j + 1\n                end\n            end\n            i = i + 1\n     \
    \   end\n        return str\n    end\n    local function check_parens(str)\n \
    \       local stack = {}\n        for i = 1, #str do\n            local s = str:sub(i,\
    \ i)\n            if s == '(' then\n                table.insert(stack, s)\n \
    \           elseif s == ')' then\n                if #stack == 0 then\n      \
    \              return false\n                else\n                    table.remove(stack)\n\
    \                end\n            end\n        end\n        return #stack == 0\n\
    \    end\n    local s1, s2 = table.unpack(lst)\n    return check_parens(remove_parens(s1\
    \ .. s2)) and 'Yes' or 'No'\nend", "  local function isgood(s)\n    local count\
    \ = 0\n    for c in s:gmatch('.') do\n      if c == '(' then\n        count =\
    \ count + 1\n      else\n        count = count - 1\n      end\n      if count\
    \ < 0 then\n        return false\n      end\n    end\n    return count == 0\n\
    \  end\n  return isgood(lst[1] .. lst[2]) and 'Yes' or 'No'\nend", "    local\
    \ opens = 0\n    local closes = 0\n    for _, par in ipairs(lst) do\n        for\
    \ _, char in ipairs(par) do\n            if char == '(' then\n               \
    \ opens = opens + 1\n            else\n                closes = closes + 1\n \
    \           end\n        end\n    end\n    return (opens == closes) and 'Yes'\
    \ or 'No'\nend", "  local s1, s2 = table.unpack(lst)\n  return (#s1 - s1:gsub('%(',\
    \ ''):len()) == (#s2 - s2:gsub('%)', ''):len()) and 'Yes' or 'No'\nend", "  local\
    \ count_lst = {0, 0}\n  for i = 1, 2 do\n    for _, v in ipairs(lst[i]) do\n \
    \     if v == '(' then\n        count_lst[i] = count_lst[i] + 1\n      else\n\
    \        count_lst[i] = count_lst[i] - 1\n      end\n    end\n  end\n  if count_lst[1]\
    \ == 0 and count_lst[2] == 0 then\n    return 'Yes'\n  elseif count_lst[1] ==\
    \ 0 and count_lst[2] ~= 0 then\n    return 'No'\n  elseif count_lst[1] ~= 0 and\
    \ count_lst[2] == 0 then\n    return 'No'\n  elseif count_lst[1] == count_lst[2]\
    \ then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend", "    local neg\
    \ = 0\n    for _, ch in ipairs(lst) do\n        for i = 1, #ch do\n          \
    \  neg = neg + ch:sub(i, i) == ')' and -1 or 1\n            if neg < 0 then return\
    \ 'No' end\n        end\n    end\n    return neg == 0 and 'Yes' or 'No'\nend",
  "  local cnt = 0\n  for i = 1, #lst[1] do\n    if lst[1]:sub(i, i) == '(' then\n\
    \      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n  end\n  for i =\
    \ 1, #lst[2] do\n    if lst[2]:sub(i, i) == '(' then\n      cnt = cnt + 1\n  \
    \  else\n      cnt = cnt - 1\n    end\n  end\n  return cnt == 0 and 'Yes' or 'No'\n\
    end", "    local open = 0\n    local close = 0\n    for _, v in ipairs(lst) do\n\
    \        for _, c in utf8.gensub(v, '()') do\n            if c == '(' then\n \
    \               open = open + 1\n            else\n                close = close\
    \ + 1\n            end\n        end\n    end\n    return ((open == close) and\
    \ 'Yes') or 'No'\nend", "    local str1, str2 = lst[1], lst[2]\n    local good\
    \ = 'No'\n    if str1 == '' then\n        good = 'Yes'\n    elseif str2 == ''\
    \ then\n        good = 'Yes'\n    elseif str1:sub(1, 1) == '(' and str2:sub(#str2,\
    \ #str2) == ')' then\n        good = 'Yes'\n    elseif str1:sub(1, 1) == ')' and\
    \ str2:sub(#str2, #str2) == '(' then\n        good = 'Yes'\n    end\n    return\
    \ good\nend", "  return (lst[1]:match('^%s*()()') or lst[1]:match('^%s*()$'))\
    \ and\n         (lst[2]:match('^%s*()()') or lst[2]:match('^%s*()$')) and\n  \
    \       'Yes' or 'No'\nend", "  -- for lst, index lst[1] and index lst[2], count\
    \ the number of opening\n  -- parentheses '(' and compare it to the number of\
    \ closing parentheses ')'\n  -- in each string, if the number of opening parentheses\
    \ is greater in lst[1]\n  -- then it is possible to form a good string by concatenating\
    \ lst[1] to lst[2]\n  -- and vice versa, if the number of closing parentheses\
    \ is greater in lst[1]\n  -- then it is possible to form a good string by concatenating\
    \ lst[2] to lst[1]\n  -- if neither is the case, it is not possible to form a\
    \ good string\n  -- by concatenating the two strings in some order\n  local str1\
    \ = lst[1]\n  local str2 = lst[2]\n  local count_open_str1 = 0\n  local count_open_str2\
    \ = 0\n  local count_close_str1 = 0\n  local count_close_str2 = 0\n  for i = 1,\
    \ #str1 do\n    if str1:sub(i, i) == '(' then\n      count_open_str1 = count_open_str1\
    \ + 1\n    else\n      count_close_str1 = count_close_str1 + 1\n    end\n  end\n\
    \  for i = 1, #str2 do\n    if str2:sub(i, i) == '(' then\n      count_open_str2\
    \ = count_open_str2 + 1\n    else\n      count_close_str2 = count_close_str2 +\
    \ 1\n    end\n  end\n  if count_open_str1 > count_close_str1 then\n    return\
    \ 'Yes'\n  elseif count_open_str2 > count_close_str2 then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend", "  local _ = lst[1]\n  local s = lst[2]\n\
    \  local function helper(s, cnt)\n    if not s then return cnt == 0 end\n    local\
    \ x = s:sub(1, 1)\n    local rest = s:sub(2)\n    if x == '(' then\n      return\
    \ helper(rest, cnt + 1)\n    elseif x == ')' then\n      return cnt > 0 and helper(rest,\
    \ cnt - 1)\n    end\n  end\n  return helper(s, 0) and 'Yes' or 'No'\nend", " \
    \ local lst2 = {}\n  for _, s in ipairs(lst) do\n    for i = 1, #s do\n      lst2[#lst2\
    \ + 1] = s:sub(i, i)\n    end\n  end\n  local s = table.concat(lst2)\n  local\
    \ t = {}\n  for i = 1, #s do\n    local c = s:sub(i, i)\n    if c == '(' then\n\
    \      t[#t + 1] = c\n    elseif #t > 0 then\n      t[#t] = nil\n    else\n  \
    \    return 'No'\n    end\n  end\n  return #t == 0 and 'Yes' or 'No'\nend", " \
    \ -- your code here\n  return 'Yes'\nend", "  local function calc(str)\n    local\
    \ count = 0\n    for i = 1, #str do\n      if str:sub(i, i) == '(' then\n    \
    \    count = count + 1\n      else\n        count = count - 1\n      end\n   \
    \   if count < 0 then\n        return false\n      end\n    end\n    return count\
    \ == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  if calc(s1) then\n    return\
    \ 'Yes'\n  elseif calc(s2) then\n    return 'Yes'\n  elseif calc(s1 .. s2) then\n\
    \    return 'Yes'\n  elseif calc(s2 .. s1) then\n    return 'Yes'\n  else\n  \
    \  return 'No'\n  end\nend", "  local first, second = lst[1], lst[2]\n  local\
    \ left, right = 0, 0\n  for _, sym in ipairs(first) do\n    if sym == '(' then\n\
    \      left = left + 1\n    else\n      right = right + 1\n    end\n  end\n  for\
    \ _, sym in ipairs(second) do\n    if sym == '(' then\n      left = left + 1\n\
    \    else\n      right = right + 1\n    end\n  end\n  return left == right and\
    \ 'Yes' or 'No'\nend", "    local open, close = 0, 0\n    for _, bracket in ipairs(lst)\
    \ do\n        if bracket == '(' then\n            open = open + 1\n        else\n\
    \            if open > 0 then\n                open = open - 1\n            else\n\
    \                close = close + 1\n            end\n        end\n    end\n  \
    \  if close == 0 then\n        return 'Yes'\n    else\n        return 'No'\n \
    \   end\nend", "  -- your code here\n  if is_balanced(lst[1]) and is_balanced(lst[2])\
    \ then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend", "  local close,\
    \ open = 0, 0\n  for _, s in ipairs(lst) do\n    if s == ')' then\n      close\
    \ = close + 1\n    else\n      open = open + 1\n    end\n  end\n  return (open\
    \ > close) and 'Yes' or 'No'\nend", "  local function loop(lst, acc, n)\n    local\
    \ s, t = lst[1], lst[2]\n    if #s == 0 then return acc + n\n    elseif s:sub(1,\
    \ 1) == '(' then return loop({s:sub(2), t}, acc, n + 1)\n    else return loop({s:sub(2),\
    \ t}, acc, n - 1) end\n  end\n  return loop(lst, 0, 0) >= 0 and 'Yes' or 'No'\n\
    end", "    local function is_good(str)\n        local count = 0\n        for _,\
    \ char in ipairs(str) do\n            if char == '(' then\n                count\
    \ = count + 1\n            else\n                count = count - 1\n         \
    \   end\n            if count < 0 then\n                return false\n       \
    \     end\n        end\n        return count == 0\n    end\n    return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend", "  local function is_good(s)\n    local\
    \ c = 0\n    for i = 1, #s do\n      local p = s:sub(i, i)\n      if p == '('\
    \ then\n        c = c + 1\n      else\n        c = c - 1\n      end\n      if\
    \ c < 0 then\n        return false\n      end\n    end\n    return c == 0\n  end\n\
    \  return (is_good(lst[1]) and is_good(lst[2])) and 'Yes' or 'No'\nend", "  return\
    \ (lst[1]:match('^%(+$') and lst[2]:match('^%)+$') and 'Yes') or 'No'\nend", " \
    \   -- your code here\n    return nil\nend", "  local function is_good(str)\n\
    \    local open, close = 0, 0\n    for i = 1, #str do\n      if str:sub(i, i)\
    \ == '(' then\n        open = open + 1\n      else\n        close = close + 1\n\
    \      end\n      if close > open then\n        return false\n      end\n    end\n\
    \    return open == close\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend", "    local k, s = {}, ''\n    for _, v in ipairs(lst) do\n  \
    \      for j = 1, #v do\n            if v:sub(j, j) == '(' then\n            \
    \    s = s .. '('\n            else\n                if s:sub(-1, -1) == '(' then\n\
    \                    s = s:sub(1, -2)\n                else\n                \
    \    table.insert(k, false)\n                end\n            end\n        end\n\
    \    end\n    if s ~= '' then\n        table.insert(k, false)\n    end\n    return\
    \ (#k == 0 and 'Yes' or 'No')\nend", "    local lst1, lst2 = lst[1], lst[2]\n\
    \    local count = 0\n    for _, char in ipairs(lst1) do\n        if char == '('\
    \ then\n            count = count + 1\n        else\n            count = count\
    \ - 1\n        end\n    end\n    for _, char in ipairs(lst2) do\n        if char\
    \ == '(' then\n            count = count + 1\n        else\n            count\
    \ = count - 1\n        end\n    end\n    if count == 0 then\n        return 'Yes'\n\
    \    else\n        return 'No'\n    end\nend", "    if #lst ~= 2 then\n      \
    \  return 'Wrong Parameters'\n    end\n    for i = 1, 2 do\n        if not is_parens(lst[i])\
    \ then\n            return 'Wrong Parameters'\n        end\n    end\n    local\
    \ one, two = lst[1], lst[2]\n    local cnt_one, cnt_two = 0, 0\n    for i = 1,\
    \ #one do\n        if one:sub(i, i) == '(' then\n            cnt_one = cnt_one\
    \ + 1\n        else\n            cnt_one = cnt_one - 1\n        end\n    end\n\
    \    for i = 1, #two do\n        if two:sub(i, i) == '(' then\n            cnt_two\
    \ = cnt_two + 1\n        else\n            cnt_two = cnt_two - 1\n        end\n\
    \    end\n    if cnt_one == 0 and cnt_two == 0 then\n        return 'Yes'\n  \
    \  elseif cnt_one == 0 and cnt_two > 0 then\n        for i = 1, #two do\n    \
    \        if two:sub(i, i) == '(' then\n                cnt_two = cnt_two + 1\n\
    \            else\n                cnt_two = cnt_two - 1\n            end\n  \
    \          if cnt_two == 0 then\n                return 'Yes'\n            end\n\
    \        end\n    elseif cnt_one > 0 and cnt_two == 0 then\n        for i = 1,\
    \ #one do\n            if one:sub(i, i) == '(' then\n                cnt_one =\
    \ cnt_one + 1\n            else\n                cnt_one = cnt_one - 1\n     \
    \       end\n            if cnt_one == 0 then\n                return 'Yes'\n\
    \            end\n        end\n    elseif cnt_one > 0 and cnt_two > 0 then\n \
    \       for i = 1, #one do\n            if one:sub(i, i) == '(' then\n       \
    \         cnt_one = cnt_one + 1\n            else\n                cnt_one = cnt_one\
    \ - 1\n            end\n            if cnt_one ==", "    local la, lb = lst[1],\
    \ lst[2]\n    local n1, n2 = 0, 0\n    for i = 1, #la do\n        if la:sub(i,\
    \ i) == '(' then\n            n1 = n1 + 1\n        else\n            n1 = n1 -\
    \ 1\n        end\n    end\n    for i = 1, #lb do\n        if lb:sub(i, i) == '('\
    \ then\n            n2 = n2 + 1\n        else\n            n2 = n2 - 1\n     \
    \   end\n    end\n    if n1 < 0 or n2 < 0 then\n        return 'No'\n    end\n\
    \    return 'Yes'\nend", "  local left, right = 0, 0\n  for _, c in ipairs(lst[1])\
    \ do\n    if c == '(' then\n      left = left + 1\n    else\n      right = right\
    \ + 1\n    end\n  end\n  if right > left then\n    return 'No'\n  end\n  left\
    \ = left - right\n  right = 0\n  for _, c in ipairs(lst[2]) do\n    if c == '('\
    \ then\n      left = left + 1\n    else\n      right = right + 1\n    end\n  end\n\
    \  if left == right then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend",
  "  -- on input we have a table of two strings\n  local s, t = lst[1], lst[2]\n \
    \ -- we check each of the 4 permutations\n  local st, ts = s .. t, t .. s\n  if\
    \ good(st) then return 'Yes' end\n  if good(ts) then return 'Yes' end\n  return\
    \ 'No'\nend", "    local s = table.concat(lst)\n    if (s:gsub('%(', ''):gsub('%)',\
    \ '') == '') then\n        local st, pat = '', ''\n        for i = 1, #s do\n\
    \            if (s:sub(i, i) == '(') then\n                st = st .. '('\n  \
    \          else\n                if (#st == 0) then\n                    pat =\
    \ pat .. ')'\n                else\n                    st = st:sub(1, #st - 1)\n\
    \                end\n            end\n        end\n        return pat .. st\n\
    \    else\n        return 'No'\n    end\nend", "    local t = {0, 0}\n    for\
    \ i, v in ipairs(lst) do\n        for j = 1, #v do\n            if v:sub(j, j)\
    \ == '(' then\n                t[i] = t[i] + 1\n            else\n           \
    \     t[i] = t[i] - 1\n            end\n            if t[i] < 0 then\n       \
    \         return 'No'\n            end\n        end\n    end\n    if t[1] == t[2]\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend", " \
    \ local parens = {['('] = ')', [')'] = '('}\n  for i = 1, #lst do\n    lst[i]\
    \ = lst[i]:gsub('.', parens)\n  end\n  return (lst[1] .. lst[2]):gsub('()', '')\
    \ == '' and 'Yes' or 'No'\nend", "  local l1, l2 = lst[1], lst[2]\n  local n1,\
    \ n2 = (l1:gsub('%(', '')), (l2:gsub('%(', ''))\n  local r1, r2 = l1:len() - n1,\
    \ l2:len() - n2\n  if l1:sub(1, 1) == ')' or l2:sub(1, 1) == ')' then\n    return\
    \ 'No'\n  elseif l1:sub(-1, -1) == '(' or l2:sub(-1, -1) == '(' then\n    return\
    \ 'No'\n  elseif r1 == n1 and r2 == n2 then\n    return 'Yes'\n  elseif r1 ==\
    \ n1 then\n    if l2:sub(1, 1) == '(' then\n      if l2:sub(-1, -1) == ')' then\n\
    \        return 'Yes'\n      else\n        return 'No'\n      end\n    else\n\
    \      if l2:sub(-1, -1) == ')' then\n        return 'Yes'\n      else\n     \
    \   return 'No'\n      end\n    end\n  elseif r2 == n2 then\n    if l1:sub(1,\
    \ 1) == '(' then\n      if l1:sub(-1, -1) == ')' then\n        return 'Yes'\n\
    \      else\n        return 'No'\n      end\n    else\n      if l1:sub(-1, -1)\
    \ == ')' then\n        return 'Yes'\n      else\n        return 'No'\n      end\n\
    \    end\n  else\n    return 'Yes'\n  end\nend", "  local l = lst[1]\n  local\
    \ r = lst[2]\n  local t\n  if l:match('%(') then\n    t = l\n    l = r\n    r\
    \ = t\n  end\n  local l = l:match('^*%(%(*%)')\n  local r = r:match('^*%)%)*$')\n\
    \  if l and r then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend", " \
    \ local function balanced(str)\n    local count = 0\n    for char in str:gmatch('[()]')\
    \ do\n      if char == '(' then\n        count = count + 1\n      else\n     \
    \   count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local left, right = lst[1],\
    \ lst[2]\n  return (balanced(left) and balanced(right))\n         or (balanced(left\
    \ .. right))\n         and 'Yes' or 'No'\nend", "  local bad = lst[1]:find '[^()]'\
    \ or lst[2]:find '[^()]'\n  if bad then\n    return 'No'\n  end\n  local s = lst[1]\
    \ .. lst[2]\n  local good = true\n  local i = 1\n  local count = 0\n  while i\
    \ <= #s do\n    if s:sub(i, i) == '(' then\n      count = count + 1\n    else\n\
    \      count = count - 1\n    end\n    if count < 0 then\n      good = false\n\
    \      break\n    end\n    i = i + 1\n  end\n  if good and count == 0 then\n \
    \   return 'Yes'\n  else\n    return 'No'\n  end\nend", "  local valid, cnt =\
    \ true, 0\n  for i = 1, #lst do\n    for c in lst[i]:gmatch '.' do\n      if c\
    \ == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt - 1\n    \
    \    if cnt < 0 then\n          valid = false\n          break\n        end\n\
    \      end\n    end\n  end\n  return valid and cnt == 0 and 'Yes' or 'No'\nend",
  "  local total_open = 0\n  local total_close = 0\n  for _, s in ipairs(lst) do\n\
    \    local num_open = 0\n    local num_close = 0\n    for c in s:gmatch('.') do\n\
    \      if c == '(' then\n        num_open = num_open + 1\n      else\n       \
    \ num_close = num_close + 1\n      end\n    end\n    total_open = total_open +\
    \ num_open\n    total_close = total_close + num_close\n  end\n  if total_open\
    \ == total_close then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend",
  "  local s, t = lst[1], lst[2]\n  local count_t = s:gsub('%(', ''):len()\n  local\
    \ count_s = t:gsub('%)', ''):len()\n  if count_s > count_t then\n    return 'No'\n\
    \  end\n  for i = 1, count_s do\n    s = s:gsub('%)', '', 1)\n  end\n  for i =\
    \ 1, count_t do\n    t = t:gsub('%(', '', 1)\n  end\n  local len_s = s:len()\n\
    \  local len_t = t:len()\n  if len_s == 0 and len_t == 0 then\n    return 'Yes'\n\
    \  end\n  if len_s == 0 then\n    t = t:gsub('%)', '')\n    if t:len() == 0 then\n\
    \      return 'Yes'\n    end\n  end\n  if len_t == 0 then\n    s = s:gsub('%(',\
    \ '')\n    if s:len() == 0 then\n      return 'Yes'\n    end\n  end\n  return\
    \ 'No'\nend", "    local function check(str)\n        for i = 1, #str do\n   \
    \         if str:sub(i, i) == ')' then\n                if str:sub(i - 1, i -\
    \ 1) ~= '(' then\n                    return false\n                end\n    \
    \        end\n        end\n        return true\n    end\n    if check(lst[1])\
    \ and check(lst[2]) then\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend", "    local str = table.concat(lst)\n    local ok, res = pcall(p.loadstring(str))\n\
    \    return (ok and res) and 'Yes' or 'No'\nend", "    local cnt = 0\n    for\
    \ _, v in ipairs(lst) do\n        cnt = cnt + v:gsub('[()]', {['('] = 1, [')']\
    \ = -1})\n    end\n    return (cnt == 0) and 'Yes' or 'No'\nend", "  local pos1,\
    \ pos2 = string.find(lst[1], '%(%(+)')\n  local open1, open2 = 0, 0\n  local close1,\
    \ close2 = 0, 0\n  local str1, str2 = '', ''\n  local sym\n  local good = true\n\
    \  if pos1 and pos2 then\n    open1 = pos2 - pos1 + 1\n    str1 = string.sub(lst[1],\
    \ pos2 + 1)\n  else\n    pos1, pos2 = string.find(lst[1], '%)(+)')\n    if pos1\
    \ and pos2 then\n      close1 = pos2 - pos1 + 1\n      str1 = string.sub(lst[1],\
    \ pos2 + 1)\n    else\n      pos1, pos2 = string.find(lst[1], '%)%(+)')\n    \
    \  if pos1 and pos2 then\n        open1 = pos2 - pos1 + 1\n        str1 = string.sub(lst[1],\
    \ pos2 + 1)\n      else\n        pos1, pos2 = string.find(lst[1], '%(%)')\n  \
    \      if pos1 and pos2 then\n          str1 = string.sub(lst[1], pos2 + 1)\n\
    \        else\n          pos1, pos2 = string.find(lst[1], '%)%)')\n          if\
    \ pos1 and pos2 then\n            str1 = string.sub(lst[1], pos2 + 1)\n      \
    \    else\n            str1 = lst[1]\n          end\n        end\n      end\n\
    \    end\n  end\n  pos1, pos2 = string.find(lst[2], '%(%(+)')\n  if pos1 and pos2\
    \ then\n    open2 = pos2 - pos1 + 1\n    str2 = string.sub(lst[2], pos2 + 1)\n\
    \  else\n    pos1, pos2 = string.find(lst[2], '%)(+)')\n    if pos1 and pos2 then\n\
    \      close2 = pos2 - pos1 + 1\n      str2 = string.sub(lst[2], pos2 + 1)\n \
    \   else\n      pos1,", "  local cnt = 0\n  for i = 1, #lst[1] do\n    cnt = cnt\
    \ + (lst[1]:sub(i, i) == '(' and 1 or -1)\n    if cnt < 0 then return 'No' end\n\
    \  end\n  cnt = 0\n  for i = 1, #lst[2] do\n    cnt = cnt + (lst[2]:sub(i, i)\
    \ == '(' and 1 or -1)\n    if cnt < 0 then return 'No' end\n  end\n  return cnt\
    \ == 0 and 'Yes' or 'No'\nend", "  local left = select(1, unpack(lst))\n  local\
    \ right = select(2, unpack(lst))\n  return is_good(left .. right) and 'Yes' or\
    \ 'No'\nend", "  local s = table.concat(lst)\n  if s:find('^%(+%)+$') then\n \
    \   return 'Yes'\n  else\n    return 'No'\n  end\nend", "  local res = 'Yes'\n\
    \  local str = table.concat(lst)\n  local depth = 0\n  for ch in str:gmatch '.'\
    \ do\n    if ch == '(' then\n      depth = depth + 1\n    else\n      depth =\
    \ depth - 1\n    end\n    if depth < 0 then\n      res = 'No'\n      break\n \
    \   end\n  end\n  return res\nend", "  local o = 0\n  local c = 0\n  for _, v\
    \ in ipairs(lst) do\n    for _, p in ipairs(v:gmatch('.')) do\n      if p == '('\
    \ then\n        o = o + 1\n      else\n        c = c + 1\n      end\n    end\n\
    \  end\n  return o == c and 'Yes' or 'No'\nend", "  local parens = lst[1] .. lst[2]\n\
    \  local stack = {}\n  for i = 1, #parens do\n    local c = parens:sub(i, i)\n\
    \    if c == '(' then\n      stack[#stack + 1] = '('\n    else\n      if stack[#stack]\
    \ == '(' then\n        stack[#stack] = nil\n      else\n        return 'No'\n\
    \      end\n    end\n  end\n  return #stack == 0 and 'Yes' or 'No'\nend", "  \
    \  local open_cnt, close_cnt = 0, 0\n    for c in lst[1]:gmatch(\".\") do\n  \
    \      if c == \"(\" then\n            open_cnt = open_cnt + 1\n        else\n\
    \            close_cnt = close_cnt + 1\n        end\n    end\n    for c in lst[2]:gmatch(\"\
    .\") do\n        if c == \"(\" then\n            open_cnt = open_cnt + 1\n   \
    \     else\n            close_cnt = close_cnt + 1\n        end\n    end\n    if\
    \ close_cnt > open_cnt then\n        return \"No\"\n    end\n    local s = {}\n\
    \    for c in lst[1]:gmatch(\".\") do\n        table.insert(s, c)\n    end\n \
    \   for c in lst[2]:gmatch(\".\") do\n        table.insert(s, c)\n    end\n  \
    \  local open_cnt, close_cnt = 0, 0\n    for _, c in ipairs(s) do\n        if\
    \ c == \"(\" then\n            open_cnt = open_cnt + 1\n        else\n       \
    \     close_cnt = close_cnt + 1\n        end\n        if close_cnt > open_cnt\
    \ then\n            return \"No\"\n        end\n    end\n    return \"Yes\"\n\
    end", "  local count = 0\n  for _, char in ipairs(lst[1]) do\n    if char == '('\
    \ then\n      count = count + 1\n    else\n      count = count - 1\n    end\n\
    \  end\n  for _, char in ipairs(lst[2]) do\n    if char == '(' then\n      count\
    \ = count + 1\n    else\n      count = count - 1\n    end\n  end\n  return count\
    \ == 0 and 'Yes' or 'No'\nend", "    -- TODO: write your code here\n    return\
    \ ''\nend", "  local n = #lst[1] + #lst[2]\n  local left, right = 0, 0\n  for\
    \ i = 1, n do\n    if lst[1]:sub(i, i) == '(' then\n      left = left + 1\n  \
    \  else\n      right = right + 1\n    end\n  end\n  if left ~= right then\n  \
    \  return 'No'\n  end\n  left, right = 0, 0\n  for i = 1, n do\n    if lst[2]:sub(i,\
    \ i) == '(' then\n      left = left + 1\n    else\n      right = right + 1\n \
    \   end\n  end\n  if left ~= right then\n    return 'No'\n  end\n  return 'Yes'\n\
    end", "    -- First we check if the number of open and close parentheses are equal.\n\
    \    -- If the number of open parentheses is greater than the number of close\n\
    \    -- parentheses then the strings can't be matched to create a good string.\n\
    \    -- This is because the number of close parentheses must be greater than\n\
    \    -- or equal to the number of open parentheses otherwise we'll end up with\n\
    \    -- unmatched parentheses.\n    local num_open = 0\n    local num_close =\
    \ 0\n    for _, v in ipairs(lst) do\n        for _, c in ipairs(v) do\n      \
    \      if c == '(' then\n                num_open = num_open + 1\n           \
    \ else\n                num_close = num_close + 1\n            end\n        end\n\
    \    end\n    if num_open > num_close then\n        return 'No'\n    end", " \
    \ local res = {}\n  for _, v in ipairs(lst) do\n    if v == '(' then\n      table.insert(res,\
    \ '(')\n    elseif v == ')' then\n      if #res == 0 then\n        return 'No'\n\
    \      end\n      table.remove(res)\n    end\n  end\n  return #res == 0 and 'Yes'\
    \ or 'No'\nend", "    local o = 0\n    local c = 0\n    for i = 1, #lst[1] do\n\
    \        if lst[1]:sub(i, i) == '(' then\n            o = o + 1\n        else\n\
    \            c = c + 1\n        end\n    end\n    for i = 1, #lst[2] do\n    \
    \    if lst[2]:sub(i, i) == '(' then\n            o = o + 1\n        else\n  \
    \          c = c + 1\n        end\n    end\n    if o == c then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend", "    local left = lst[1]:gsub('[^()]',\
    \ '')\n    local right = lst[2]:gsub('[^()]', '')\n    local r1 = left:reverse():gsub('[^()]',\
    \ '')\n    local r2 = right:reverse():gsub('[^()]', '')\n    if left:len() ==\
    \ r2:len() and right:len() == r1:len() then\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend", "  local k, v = lst[1], lst[2]\n  local open,\
    \ close = 0, 0\n  for i = 1, #k do\n    if k:sub(i, i) == '(' then\n      open\
    \ = open + 1\n    else\n      close = close + 1\n    end\n  end\n  for i = 1,\
    \ #v do\n    if v:sub(i, i) == '(' then\n      open = open + 1\n    else\n   \
    \   close = close + 1\n    end\n  end\n  return open == close and 'Yes' or 'No'\n\
    end", "  local open = 0\n  local close = 0\n  for _, v in ipairs(lst) do\n   \
    \ for i = 1, #v do\n      if v:sub(i, i) == '(' then\n        open = open + 1\n\
    \      else\n        close = close + 1\n      end\n    end\n  end\n  return open\
    \ == close and 'Yes' or 'No'\nend", "    local parens = {['('] = ')', [')'] =\
    \ '('}\n    local stack = {}\n    local function is_good(str)\n        for c in\
    \ str:gmatch('.') do\n            if #stack == 0 or stack[#stack] ~= parens[c]\
    \ then\n                table.insert(stack, c)\n            else\n           \
    \     table.remove(stack)\n            end\n        end\n        return #stack\
    \ == 0\n    end\n    local function loop(lst)\n        if #lst == 0 then\n   \
    \         return is_good(table.concat(lst))\n        end\n        local a, b =\
    \ table.remove(lst, 1), table.remove(lst, 1)\n        return loop({a .. b, table.unpack(lst)})\
    \ or\n            loop({b .. a, table.unpack(lst)})\n    end\n    return loop(lst)\
    \ and 'Yes' or 'No'\nend", "  local sum = 0\n  for _, s in ipairs(lst) do\n  \
    \  for c in s:gmatch('%(') do sum = sum + 1 end\n    for c in s:gmatch('%)') do\
    \ sum = sum - 1 end\n    if sum < 0 then return 'No' end\n  end\n  return sum\
    \ == 0 and 'Yes' or 'No'\nend", "    local tl = {}\n    local nl = 0\n    for\
    \ _, s in ipairs(lst) do\n        for i = 1, #s do\n            nl = nl + 1\n\
    \            tl[nl] = s:sub(i, i)\n        end\n    end\n    local n_open = 0\n\
    \    for _, p in ipairs(tl) do\n        if p == '(' then\n            n_open =\
    \ n_open + 1\n        else\n            n_open = n_open - 1\n            if n_open\
    \ < 0 then\n                return 'No'\n            end\n        end\n    end\n\
    \    return n_open == 0 and 'Yes' or 'No'\nend", "    local a, b = table.unpack(lst)\n\
    \    return (b:match('^%(*)$') and a:match('^()%*)$') and 'Yes') or 'No'\nend",
  "  local res = {}\n  local ok\n  local i = 0\n  while lst[i+1] do\n    local a,\
    \ b = lst[i+1], lst[i+2]\n    local l = string.len(a)\n    local m = string.len(b)\n\
    \    local j = 0\n    ok = false\n    for _ = 1, l do\n      for _ = 1, m do\n\
    \        j = j + 1\n        local a1 = string.sub(a, j, j)\n        local b1 =\
    \ string.sub(b, j, j)\n        local p = 0\n        for x in string.gmatch(a1\
    \ .. b1, \"%(\") do\n          p = p + 1\n        end\n        for x in string.gmatch(a1\
    \ .. b1, \"%)\") do\n          p = p - 1\n        end\n        if p == 0 then\n\
    \          ok = true\n          break\n        end\n      end\n      if ok then\
    \ break end\n    end\n    if ok then\n      break\n    end\n    i = i + 2\n  end\n\
    \  return ok and \"Yes\" or \"No\"\nend", "  local n1, n2 = 0, 0\n  for _, s in\
    \ ipairs(lst) do\n    for c in s:gmatch'.' do\n      if c == '(' then\n      \
    \  n1 = n1 + 1\n      else\n        n2 = n2 + 1\n      end\n    end\n  end\n \
    \ return n1 == n2 and 'Yes' or 'No'\nend", "    local function is_good(s)\n  \
    \      local count = 0\n        for c in s:gmatch(\".\") do\n            if c\
    \ == '(' then\n                count = count + 1\n            else\n         \
    \       count = count - 1\n            end\n            if count < 0 then\n  \
    \              return false\n            end\n        end\n        return count\
    \ == 0\n    end\n    if is_good(lst[1]) then\n        return \"Yes\"\n    end\n\
    \    if is_good(lst[2]) then\n        return \"Yes\"\n    end\n    local l1, l2\
    \ = lst[1], lst[2]\n    for i = 1, #l1 do\n        for j = 1, #l2 do\n       \
    \     if l1:sub(i, i) == '(' and l2:sub(j, j) == ')' then\n                if\
    \ is_good(l1:sub(1, i - 1) .. l2:sub(j + 1)) then\n                    return\
    \ \"Yes\"\n                end\n            end\n            if l1:sub(i, i) ==\
    \ ')' and l2:sub(j, j) == '(' then\n                if is_good(l1:sub(i + 1) ..\
    \ l2:sub(1, j - 1)) then\n                    return \"Yes\"\n               \
    \ end\n            end\n        end\n    end\n    return \"No\"\nend", "  local\
    \ left, right = table.unpack(lst)\n  local lc, rc = 0, 0\n  for c in left:gmatch('%(')\
    \ do lc = lc + 1 end\n  for c in right:gmatch('%)') do rc = rc + 1 end\n  if lc\
    \ == rc then return 'Yes' end\n  return 'No'\nend", "  if #lst[1] + #lst[2] %\
    \ 2 == 1 then\n    return 'No'\n  end\n  local count1, count2 = 0, 0\n  for i\
    \ = 1, #lst[1] do\n    if lst[1]:sub(i, i) == '(' then\n      count1 = count1\
    \ + 1\n    else\n      count1 = count1 - 1\n    end\n  end\n  for i = 1, #lst[2]\
    \ do\n    if lst[2]:sub(i, i) == '(' then\n      count2 = count2 + 1\n    else\n\
    \      count2 = count2 - 1\n    end\n  end\n  if math.abs(count1 - count2) % 2\
    \ == 1 then\n    return 'No'\n  end\n  if count1 < 0 then\n    return 'No'\n \
    \ end\n  return 'Yes'\nend", "  local l1, l2 = lst[1], lst[2]\n  local len1, len2\
    \ = #l1, #l2\n  local is_good = true\n  if len1 == 0 and len2 == 0 then\n    return\
    \ 'Yes'\n  end\n  local balance = 0\n  for i = 1, len1 do\n    local ch = l1:sub(i,\
    \ i)\n    if ch == '(' then\n      balance = balance + 1\n    else\n      balance\
    \ = balance - 1\n    end\n    if balance < 0 then\n      is_good = false\n   \
    \   break\n    end\n  end\n  if is_good then\n    for i = 1, len2 do\n      local\
    \ ch = l2:sub(i, i)\n      if ch == '(' then\n        balance = balance + 1\n\
    \      else\n        balance = balance - 1\n      end\n      if balance < 0 then\n\
    \        is_good = false\n        break\n      end\n    end\n  end\n  return is_good\
    \ and 'Yes' or 'No'\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
