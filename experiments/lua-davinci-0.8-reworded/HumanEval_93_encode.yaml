name: HumanEval_93_encode
language: lua
prompt: "-- Write a function that takes a message, and encodes in such a \n-- way\
  \ that it swaps case of all letters, replaces all vowels in \n-- the message with\
  \ the letter that appears 2 places ahead of that \n-- vowel in the english alphabet.\
  \ \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n--\
  \ >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encode\n\
  \    lu.assertEquals(candidate('TEST'), 'tgst')\n    lu.assertEquals(candidate('Mudasir'),\
  \ 'mWDCSKR')\n    lu.assertEquals(candidate('YES'), 'ygs')\n    lu.assertEquals(candidate('This\
  \ is a message'), 'tHKS KS C MGSSCGG')\n    lu.assertEquals(candidate('I DoNt KnOw\
  \ WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   local vowels = {'a', 'e', 'i', 'o', 'u'}\n   local cypher = {}\n\
    \   for letter in message:gmatch(\".\") do\n      local is_vowel = false\n   \
    \   for _,vowel in ipairs(vowels) do\n         if letter == vowel then\n     \
    \       is_vowel = true\n            break\n         end\n      end\n      if\
    \ is_vowel then\n         if letter == 'u' then\n            table.insert(cypher,\
    \ 'a')\n         else\n            table.insert(cypher, vowels[vowels_indices[letter]\
    \ + 1])\n         end\n      else\n         table.insert(cypher, letter)\n   \
    \   end\n   end\n   return table.concat(cypher)\nend", "    return string.gsub(string.gsub(message,\
    \ \"%a\", function(letter)\n        if string.find(letter, \"[aeiou]\") then\n\
    \            return string.char(string.byte(letter) + 2)\n        else\n     \
    \       return string.upper(letter)\n        end\n    end), \"Y\", \"A\")\nend",
  end, "    local vowels = {['a']=1, ['e']=1, ['i']=1, ['o']=1, ['u']=1}\n    local\
    \ output = ''\n    for i = 1, #message do\n        local curr = message:sub(i,\
    \ i)\n        if vowels[curr:lower()] == 1 then\n            output = output ..\
    \ string.char(string.byte(curr) + 2)\n        else\n            if curr:lower()\
    \ == curr then\n                output = output .. curr:upper()\n            else\n\
    \                output = output .. curr:lower()\n            end\n        end\n\
    \    end\n    return output\nend", "    message = message:lower()\n    local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    for i=1, #message do\n        local c =\
    \ message:sub(i,i)\n        local index = alphabet:find(c)\n        if index then\n\
    \            local swap = index + 2\n            if swap > #alphabet then\n  \
    \              swap = swap - #alphabet\n            end\n            message =\
    \ message:sub(1,i-1) .. alphabet:sub(swap,swap) .. message:sub(i+1)\n        end\n\
    \    end\n    return message\nend", "  -- Your code here\nend", "    assert(type(message)\
    \ == 'string', 'message must be a string')\n    local newMessage = ''\n    for\
    \ char in message:gmatch('%a') do\n        if char:match('[aeiou]') then\n   \
    \         char = vowels[char]\n        end\n        char = string.upper(char)\n\
    \        newMessage = newMessage .. char\n    end\n    return newMessage\nend",
  end, "  return nil\nend", "  return nil\nend", "    local encode = message:gsub('%a',\
    \ function(ch)\n        if ch == ch:upper() then\n            return ch:lower()\n\
    \        else\n            return ch:upper()\n        end\n    end)\n    -- return\
    \ encode:gsub('[aeiou]', function(ch)\n    --     return string.char(string.byte(ch)\
    \ + 2)\n    -- end)\n    return encode:gsub('[aeiou]', function(ch)\n        return\
    \ ENCODINGS[ch]\n    end)\nend", "   local swap_case = {\n      ['a'] = 'A',\n\
    \      ['b'] = 'B',\n      ['c'] = 'C',\n      ['d'] = 'D',\n      ['e'] = 'E',\n\
    \      ['f'] = 'F',\n      ['g'] = 'G',\n      ['h'] = 'H',\n      ['i'] = 'I',\n\
    \      ['j'] = 'J',\n      ['k'] = 'K',\n      ['l'] = 'L',\n      ['m'] = 'M',\n\
    \      ['n'] = 'N',\n      ['o'] = 'O',\n      ['p'] = 'P',\n      ['q'] = 'Q',\n\
    \      ['r'] = 'R',\n      ['s'] = 'S',\n      ['t'] = 'T',\n      ['u'] = 'U',\n\
    \      ['v'] = 'V',\n      ['w'] = 'W',\n      ['x'] = 'X',\n      ['y'] = 'Y',\n\
    \      ['z'] = 'Z',\n      ['A'] = 'a',\n      ['B'] = 'b',\n      ['C'] = 'c',\n\
    \      ['D'] = 'd',\n      ['E'] = 'e',\n      ['F'] = 'f',\n      ['G'] = 'g',\n\
    \      ['H'] = 'h',\n      ['I'] = 'i',\n      ['J'] = 'j',\n      ['K'] = 'k',\n\
    \      ['L'] = 'l',\n      ['M'] = 'm',\n      ['N'] = 'n',\n      ['O'] = 'o',\n\
    \      ['P'] = 'p',\n      ['Q'] = 'q',\n      ['R'] = 'r',\n      ['S'] = 's',\n\
    \      ['T'] = 't',\n      ['U'] = 'u',\n      ['V'] = 'v',\n      ['W'] = 'w',\n\
    \      ['X'] = 'x',\n      ['Y'] = 'y',\n      ['Z'] = 'z',\n   }\n   local substitute_vowel\
    \ = {\n      ['a'] = 'c',\n      ['e'] = 'g',\n      ['i']", "\tlocal vowels =\
    \ {'a', 'e', 'i', 'o', 'u'}\n\tlocal _, result = string.gsub(message, '[a-zA-Z]',\
    \ function(c)\n\t\tif string.find(vowels, string.lower(c)) then\n\t\t\treturn\
    \ string.char(string.byte(c) + 2)\n\t\telse\n\t\t\treturn string.lower(c)\n\t\t\
    end\n\tend)\n\treturn result\nend", end, end, "\t-- TODO\nend", "\treturn nil\n\
    end", "    -- write your code here\nend", "    local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n    local result = ''\n    for i = 1, #message do\n        local\
    \ letter = message:sub(i, i)\n        local is_lowercase = letter == letter:lower()\n\
    \        local is_vowel = table.contains(vowels, letter:lower())\n        if is_vowel\
    \ then\n            letter = next_letter(letter)\n            letter = next_letter(letter)\n\
    \        end\n        if is_lowercase then\n            letter = letter:upper()\n\
    \        else\n            letter = letter:lower()\n        end\n        result\
    \ = result .. letter\n    end\n    return result\nend", "  local function encode_char(c)\n\
    \    if not c:match('%a') then\n      return c\n    end\n    local lower = c:lower()\n\
    \    local shifted = 2\n    if lower == 'w' then\n      shifted = shifted - 2\n\
    \    elseif lower == 'y' then\n      shifted = shifted - 1\n    end\n    local\
    \ new_char = lower:byte() + shifted\n    if new_char > 122 then\n      new_char\
    \ = new_char - 26\n    end\n    new_char = string.char(new_char)\n    if c ==\
    \ c:upper() then\n      new_char = new_char:upper()\n    end\n    return new_char\n\
    \  end\n  return message:gsub('%a', encode_char)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
