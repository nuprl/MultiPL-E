name: HumanEval_93_encode
language: lua
prompt: "-- Write a function that takes a message, and encodes in such a \n-- way\
  \ that it swaps case of all letters, replaces all vowels in \n-- the message with\
  \ the letter that appears 2 places ahead of that \n-- vowel in the english alphabet.\
  \ \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n--\
  \ >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encode\n\
  \    lu.assertEquals(candidate('TEST'), 'tgst')\n    lu.assertEquals(candidate('Mudasir'),\
  \ 'mWDCSKR')\n    lu.assertEquals(candidate('YES'), 'ygs')\n    lu.assertEquals(candidate('This\
  \ is a message'), 'tHKS KS C MGSSCGG')\n    lu.assertEquals(candidate('I DoNt KnOw\
  \ WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   local vowels = {'a', 'e', 'i', 'o', 'u'}\n   local cypher = {}\n\
    \   for letter in message:gmatch(\".\") do\n      local is_vowel = false\n   \
    \   for _,vowel in ipairs(vowels) do\n         if letter == vowel then\n     \
    \       is_vowel = true\n            break\n         end\n      end\n      if\
    \ is_vowel then\n         if letter == 'u' then\n            table.insert(cypher,\
    \ 'a')\n         else\n            table.insert(cypher, vowels[vowels_indices[letter]\
    \ + 1])\n         end\n      else\n         table.insert(cypher, letter)\n   \
    \   end\n   end\n   return table.concat(cypher)\nend", "    return string.gsub(string.gsub(message,\
    \ \"%a\", function(letter)\n        if string.find(letter, \"[aeiou]\") then\n\
    \            return string.char(string.byte(letter) + 2)\n        else\n     \
    \       return string.upper(letter)\n        end\n    end), \"Y\", \"A\")\nend",
  end, "    local vowels = {['a']=1, ['e']=1, ['i']=1, ['o']=1, ['u']=1}\n    local\
    \ output = ''\n    for i = 1, #message do\n        local curr = message:sub(i,\
    \ i)\n        if vowels[curr:lower()] == 1 then\n            output = output ..\
    \ string.char(string.byte(curr) + 2)\n        else\n            if curr:lower()\
    \ == curr then\n                output = output .. curr:upper()\n            else\n\
    \                output = output .. curr:lower()\n            end\n        end\n\
    \    end\n    return output\nend", "    message = message:lower()\n    local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    for i=1, #message do\n        local c =\
    \ message:sub(i,i)\n        local index = alphabet:find(c)\n        if index then\n\
    \            local swap = index + 2\n            if swap > #alphabet then\n  \
    \              swap = swap - #alphabet\n            end\n            message =\
    \ message:sub(1,i-1) .. alphabet:sub(swap,swap) .. message:sub(i+1)\n        end\n\
    \    end\n    return message\nend", "  -- Your code here\nend", "    assert(type(message)\
    \ == 'string', 'message must be a string')\n    local newMessage = ''\n    for\
    \ char in message:gmatch('%a') do\n        if char:match('[aeiou]') then\n   \
    \         char = vowels[char]\n        end\n        char = string.upper(char)\n\
    \        newMessage = newMessage .. char\n    end\n    return newMessage\nend",
  end, "  return nil\nend", "  return nil\nend", "    local encode = message:gsub('%a',\
    \ function(ch)\n        if ch == ch:upper() then\n            return ch:lower()\n\
    \        else\n            return ch:upper()\n        end\n    end)\n    -- return\
    \ encode:gsub('[aeiou]', function(ch)\n    --     return string.char(string.byte(ch)\
    \ + 2)\n    -- end)\n    return encode:gsub('[aeiou]', function(ch)\n        return\
    \ ENCODINGS[ch]\n    end)\nend", "   local swap_case = {\n      ['a'] = 'A',\n\
    \      ['b'] = 'B',\n      ['c'] = 'C',\n      ['d'] = 'D',\n      ['e'] = 'E',\n\
    \      ['f'] = 'F',\n      ['g'] = 'G',\n      ['h'] = 'H',\n      ['i'] = 'I',\n\
    \      ['j'] = 'J',\n      ['k'] = 'K',\n      ['l'] = 'L',\n      ['m'] = 'M',\n\
    \      ['n'] = 'N',\n      ['o'] = 'O',\n      ['p'] = 'P',\n      ['q'] = 'Q',\n\
    \      ['r'] = 'R',\n      ['s'] = 'S',\n      ['t'] = 'T',\n      ['u'] = 'U',\n\
    \      ['v'] = 'V',\n      ['w'] = 'W',\n      ['x'] = 'X',\n      ['y'] = 'Y',\n\
    \      ['z'] = 'Z',\n      ['A'] = 'a',\n      ['B'] = 'b',\n      ['C'] = 'c',\n\
    \      ['D'] = 'd',\n      ['E'] = 'e',\n      ['F'] = 'f',\n      ['G'] = 'g',\n\
    \      ['H'] = 'h',\n      ['I'] = 'i',\n      ['J'] = 'j',\n      ['K'] = 'k',\n\
    \      ['L'] = 'l',\n      ['M'] = 'm',\n      ['N'] = 'n',\n      ['O'] = 'o',\n\
    \      ['P'] = 'p',\n      ['Q'] = 'q',\n      ['R'] = 'r',\n      ['S'] = 's',\n\
    \      ['T'] = 't',\n      ['U'] = 'u',\n      ['V'] = 'v',\n      ['W'] = 'w',\n\
    \      ['X'] = 'x',\n      ['Y'] = 'y',\n      ['Z'] = 'z',\n   }\n   local substitute_vowel\
    \ = {\n      ['a'] = 'c',\n      ['e'] = 'g',\n      ['i']", "\tlocal vowels =\
    \ {'a', 'e', 'i', 'o', 'u'}\n\tlocal _, result = string.gsub(message, '[a-zA-Z]',\
    \ function(c)\n\t\tif string.find(vowels, string.lower(c)) then\n\t\t\treturn\
    \ string.char(string.byte(c) + 2)\n\t\telse\n\t\t\treturn string.lower(c)\n\t\t\
    end\n\tend)\n\treturn result\nend", end, end, "\t-- TODO\nend", "\treturn nil\n\
    end", "    -- write your code here\nend", "    local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n    local result = ''\n    for i = 1, #message do\n        local\
    \ letter = message:sub(i, i)\n        local is_lowercase = letter == letter:lower()\n\
    \        local is_vowel = table.contains(vowels, letter:lower())\n        if is_vowel\
    \ then\n            letter = next_letter(letter)\n            letter = next_letter(letter)\n\
    \        end\n        if is_lowercase then\n            letter = letter:upper()\n\
    \        else\n            letter = letter:lower()\n        end\n        result\
    \ = result .. letter\n    end\n    return result\nend", "  local function encode_char(c)\n\
    \    if not c:match('%a') then\n      return c\n    end\n    local lower = c:lower()\n\
    \    local shifted = 2\n    if lower == 'w' then\n      shifted = shifted - 2\n\
    \    elseif lower == 'y' then\n      shifted = shifted - 1\n    end\n    local\
    \ new_char = lower:byte() + shifted\n    if new_char > 122 then\n      new_char\
    \ = new_char - 26\n    end\n    new_char = string.char(new_char)\n    if c ==\
    \ c:upper() then\n      new_char = new_char:upper()\n    end\n    return new_char\n\
    \  end\n  return message:gsub('%a', encode_char)\nend", "\t-- TODO\nend", "  local\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n  local vowel_seq = {'c', 'f', 'j', 'n',\
    \ 'r'}\n  local str = \"\"\n  for i = 1, string.len(message) do\n    local char\
    \ = string.sub(message, i, i)\n    local upper = string.match(char, \"[A-Z]\"\
    )\n    local lower = string.match(char, \"[a-z]\")\n    if lower then\n      local\
    \ swap_char = char\n      for j = 1, #vowels do\n        if lower == vowels[j]\
    \ then\n          swap_char = vowel_seq[j]\n        end\n      end\n      str\
    \ = str .. swap_char\n    elseif upper then\n      local swap_char = char\n  \
    \    for j = 1, #vowels do\n        if upper == string.upper(vowels[j]) then\n\
    \          swap_char = string.upper(vowel_seq[j])\n        end\n      end\n  \
    \    str = str .. swap_char\n    else\n      str = str .. char\n    end\n  end\n\
    \  return str\nend", "  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local alphabet\
    \ = {}\n  for i = 1, #vowels do\n    alphabet[vowels[i]] = vowels[(i % #vowels)\
    \ + 1]\n  end\n  local result = ''\n  for i = 1, #message do\n    local letter\
    \ = message:sub(i, i)\n    if alphabet[letter:lower()] then\n      result = result\
    \ .. alphabet[letter:lower()]\n    else\n      result = result .. letter:lower():gsub('%l',\
    \ string.upper)\n    end\n  end\n  return result\nend", "  -- TODO\nend", "  \
    \  local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local encrypted_string = ''\n\
    \    for i=1,#message do\n        local char = message:sub(i,i)\n        local\
    \ cipher = ''\n        if char == string.upper(char) then\n            cipher\
    \ = string.lower(char)\n        else\n            cipher = string.upper(char)\n\
    \        end\n        for j=1,#vowels do\n            if char == vowels[j] then\n\
    \                cipher = vowels[(j+2)%5]\n            end\n        end\n    \
    \    encrypted_string = encrypted_string .. cipher\n    end\n    return encrypted_string\n\
    end", "    -- YOUR CODE HERE\nend", "  local encoded = {}\n  local alphabet =\
    \ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  for i = 1, #message do\n    local char = message:sub(i,\
    \ i)\n    local index = alphabet:find(char)\n    if index then\n      local new_index\
    \ = index + 2\n      if new_index > #alphabet then\n        new_index = new_index\
    \ - #alphabet\n      end\n      char = alphabet:sub(new_index, new_index)\n  \
    \  else\n      char = char:lower()\n    end\n    encoded[#encoded + 1] = char\n\
    \  end\n  return table.concat(encoded)\nend", "  local newMessage = ''\n  for\
    \ i = 1, message:len() do\n    local c = message:sub(i, i)\n    if c:match('[aeiou]')\
    \ then\n      c = string.char(c:byte() + 2)\n    end\n    c = c:lower() == c and\
    \ c:upper() or c:lower()\n    newMessage = newMessage .. c\n  end\n  return newMessage\n\
    end", end, "    local res = {}\n    for i=1, #message do\n        local c = message:sub(i,i)\n\
    \        local lc = c:lower()\n        if lc:find('[aeiou]') then\n          \
    \  if lc == 'u' then\n                res[#res+1] = 'a'\n            else\n  \
    \              res[#res+1] = string.char(lc:byte()+2)\n            end\n     \
    \   else\n            if c == lc then\n                res[#res+1] = lc:upper()\n\
    \            else\n                res[#res+1] = lc\n            end\n       \
    \ end\n    end\n    return table.concat(res)\nend", "    local vowels = {'a',\
    \ 'e', 'i', 'o', 'u'}\n    local encoded_message = ''\n    for i = 1, #message\
    \ do\n        local letter = message:sub(i, i)\n        local letter_code = string.byte(letter)\n\
    \        local encoded_letter = ''\n        if letter_code >= 65 and letter_code\
    \ <= 90 then\n            encoded_letter = string.char(letter_code + 32)\n   \
    \     elseif letter_code >= 97 and letter_code <= 122 then\n            encoded_letter\
    \ = string.char(letter_code - 32)\n        else\n            encoded_letter =\
    \ letter\n        end\n        if letter_code >= 97 and letter_code <= 122 then\n\
    \            if table.contains(vowels, encoded_letter) then\n                if\
    \ letter_code > 99 then\n                    encoded_letter = string.char(letter_code\
    \ - 2)\n                else\n                    encoded_letter = string.char(letter_code\
    \ + 20)\n                end\n            end\n        end\n        encoded_message\
    \ = encoded_message .. encoded_letter\n    end\n    return encoded_message\nend",
  "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local encodedMessage = ''\n \
    \   for i = 1, #message do\n        local character = message:sub(i, i)\n    \
    \    local indexOfVowel = table.indexof(vowels, character:lower())\n        if\
    \ indexOfVowel > 0 then\n            local encodedCharacter = vowels[indexOfVowel\
    \ + 2]\n            if character:lower() ~= character then\n                encodedCharacter\
    \ = encodedCharacter:upper()\n            end\n            encodedMessage = encodedMessage\
    \ .. encodedCharacter\n        else\n            encodedMessage = encodedMessage\
    \ .. character:upper()\n        end\n    end\n    return encodedMessage\nend",
  "    -- TODO\nend", "    local encodedMessage = ''\n    for i = 1, #message do\n\
    \        local thisChar = message:sub(i, i)\n        if thisChar:find('[A-Z]')\
    \ then\n            thisChar = thisChar:lower()\n        elseif thisChar:find('[a-z]')\
    \ then\n            thisChar = thisChar:upper()\n        end\n        if thisChar:find('[aeiou]')\
    \ then\n            local n = string.find('aeiou', thisChar)\n            if n\
    \ == 5 then\n                thisChar = 'a'\n            else\n              \
    \  thisChar = 'aeiou':sub(n + 2, n + 2)\n            end\n        end\n      \
    \  encodedMessage = encodedMessage .. thisChar\n    end\n    return encodedMessage\n\
    end", "    -- TODO\nend", "\tlocal alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\t\
    local encoded = {}\n\tlocal key_mapping = {\n\t\tA = 1,\n\t\tE = 5,\n\t\tI = 9,\n\
    \t\tO = 15,\n\t\tU = 21,\n\t}\n\tfor i = 1, string.len(message) do\n\t\tlocal\
    \ char = string.sub(message, i, i)\n\t\tlocal encoded_char = char\n\t\t-- if its\
    \ a vowel, map to the 2nd character after it\n\t\tif key_mapping[char] then\n\t\
    \t\tencoded_char = string.sub(alphabet, key_mapping[char]+2, key_mapping[char]+2)\n\
    \t\tend\n\t\t-- if its uppercase, make it lowercase\n\t\tif char == string.upper(char)\
    \ then\n\t\t\tencoded_char = string.lower(encoded_char)\n\t\telse\n\t\t\tencoded_char\
    \ = string.upper(encoded_char)\n\t\tend\n\t\tencoded[i] = encoded_char\n\tend\n\
    \treturn table.concat(encoded)\nend", "    local a = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local b = 'cdefghijklmnopqrstuvwxyzab'\n    local c = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    local d = 'CDEFGHIJKLMNOPQRSTUVWXYZAB'\n    local e = {'a','e','i','o','u'}\n\
    \    local f = {'c','g','k','o','s'}\n    local encode_message = ''\n    for i=1,\
    \ #message do\n        if message:sub(i,i) == message:sub(i,i):lower() then\n\
    \            for j=1, #a do\n                if message:sub(i,i) == a:sub(j,j)\
    \ then\n                    encode_message = encode_message .. b:sub(j,j)\n  \
    \              end\n            end\n        else\n            for j=1, #a do\n\
    \                if message:sub(i,i) == c:sub(j,j) then\n                    encode_message\
    \ = encode_message .. d:sub(j,j)\n                end\n            end\n     \
    \   end\n    end\n    for i=1, #e do\n        encode_message = encode_message:gsub(e[i],f[i])\n\
    \    end\n    return encode_message\nend", end, end, "  return string.gsub(message,\
    \ '[AEIOUaeiou]', function(vowel)\n    local index = get_index(vowel)\n    local\
    \ next = (index + 2) % 26\n    return (vowel:upper() == vowel) and\n      alpha_upper[next]\
    \ or alpha_lower[next]\n  end)\nend", "  return message:gsub(\"[a-zA-Z]\", {\n\
    \    [\"a\"] = \"c\",\n    [\"A\"] = \"C\",\n    [\"b\"] = \"d\",\n    [\"B\"\
    ] = \"D\",\n    [\"c\"] = \"e\",\n    [\"C\"] = \"E\",\n    [\"d\"] = \"f\",\n\
    \    [\"D\"] = \"F\",\n    [\"e\"] = \"g\",\n    [\"E\"] = \"G\",\n    [\"f\"\
    ] = \"h\",\n    [\"F\"] = \"H\",\n    [\"g\"] = \"i\",\n    [\"G\"] = \"I\",\n\
    \    [\"h\"] = \"j\",\n    [\"H\"] = \"J\",\n    [\"i\"] = \"k\",\n    [\"I\"\
    ] = \"K\",\n    [\"j\"] = \"l\",\n    [\"J\"] = \"L\",\n    [\"k\"] = \"m\",\n\
    \    [\"K\"] = \"M\",\n    [\"l\"] = \"n\",\n    [\"L\"] = \"N\",\n    [\"m\"\
    ] = \"o\",\n    [\"M\"] = \"O\",\n    [\"n\"] = \"p\",\n    [\"N\"] = \"P\",\n\
    \    [\"o\"] = \"q\",\n    [\"O\"] = \"Q\",\n    [\"p\"] = \"r\",\n    [\"P\"\
    ] = \"R\",\n    [\"q\"] = \"s\",\n    [\"Q\"] = \"S\",\n    [\"r\"] = \"t\",\n\
    \    [\"R\"] = \"T\",\n    [\"s\"] = \"u\",\n    [\"S\"] = \"U\",\n    [\"t\"\
    ] = \"v\",\n    [\"T\"] = \"V\",\n    [\"u\"] = \"w\",\n    [\"U\"] = \"W\",\n\
    \    [\"v\"] = \"x\",\n    [\"V\"] = \"X\",\n    [\"w\"] = \"y\",\n    [\"W\"\
    ] = \"Y\",\n    [\"x\"] = \"z\",\n    [\"X\"] = \"Z\",\n    [\"y\"] = \"a\",\n\
    \    [\"Y\"] = \"A\",\n    [\"z\"] = \"b\",\n    [\"Z\"] = \"B\"\n  })\nend",
  "   local vowels = {'a', 'e', 'i', 'o', 'u'}\n   local step = 2\n   local chars\
    \ = {}\n   local shift = function(char)\n      -- if char is a vowel\n      for\
    \ i, vowel in ipairs(vowels) do\n         if vowel == char then\n            return\
    \ vowels[i + step]\n         end\n      end\n      return char\n   end\n   for\
    \ i = 1, #message do\n      chars[i] = string.char(\n         string.byte(shift(string.lower(message:sub(i,\
    \ i)))) - 32\n      )\n   end\n   return table.concat(chars)\nend", "  local vowels\
    \ = {'a', 'e', 'i', 'o', 'u'}\n  local vowels_map = {'c', 'f', 'i', 'l', 'o'}\n\
    \  local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  local\
    \ result = ''\n  for i = 1, #message do\n    local char = message:sub(i, i)\n\
    \    local char_lower = char:lower()\n    if char_lower == char then\n      local\
    \ char_index = table.indexof(alphabet, char_lower)\n      local char_mapped_index\
    \ = char_index + 2\n      if char_mapped_index > #alphabet then\n        char_mapped_index\
    \ = char_mapped_index - #alphabet\n      end\n      result = result .. alphabet[char_mapped_index]:upper()\n\
    \    else\n      local char_index = table.indexof(alphabet, char_lower)\n    \
    \  local char_mapped_index = char_index + 2\n      if char_mapped_index > #alphabet\
    \ then\n        char_mapped_index = char_mapped_index - #alphabet\n      end\n\
    \      result = result .. alphabet[char_mapped_index]\n    end\n  end\n  return\
    \ result\nend", "    -- TODO: Fix this\n    return message\nend", "    local vowels\
    \ = {'a', 'e', 'i', 'o', 'u'}\n    local newstr = \"\"\n    for c in message:gmatch(\"\
    .\") do\n        local cnext = message:sub(c+1,1)\n        local cprev = message:sub(c-1,1)\n\
    \        if string.match(c, \"%u\") then\n            c = string.lower(c)\n  \
    \      elseif string.match(c, \"%l\") then\n            c = string.upper(c)\n\
    \        end\n        if string.match(c, \"[aeiou]\") then\n            if c ==\
    \ 'u' then\n                c = vowels[1]\n            else\n                for\
    \ i, v in ipairs(vowels) do\n                    if c == v then\n            \
    \            c = vowels[i+1]\n                    end\n                end\n \
    \           end\n        end\n        newstr = newstr .. c\n    end\n    return\
    \ newstr\nend\nprint(encode('test'))\nprint(encode('This is a message'))", " \
    \ local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n  local encoded = ''\n  local is_vowel = false\n  for _, c in message:gmatch('%w')\
    \ do\n    local letter = c:lower()\n    local upper = c:match('%u')\n    if upper\
    \ then\n      encoded = encoded .. letter:upper()\n    else\n      encoded = encoded\
    \ .. letter\n    end\n    for _, v in ipairs(vowels) do\n      if v == letter\
    \ then\n        is_vowel = true\n        encoded = encoded:sub(1, -2)\n      \
    \  local l = alphabet:find(letter)\n        local l2 = l + 2\n        if l2 >\
    \ #alphabet then\n          l2 = l2 - #alphabet\n        end\n        encoded\
    \ = encoded .. alphabet:sub(l2, l2)\n      end\n    end\n    if not is_vowel then\n\
    \      encoded = encoded .. letter\n    end\n    is_vowel = false\n  end\n  return\
    \ encoded\nend", "\tmessage = message:gsub(\"%a\", function(x)\n\t\tlocal binary\
    \ = x:byte()\n\t\tlocal upper = binary >= 65 and binary <= 90\n\t\tlocal char\n\
    \t\tif upper then\n\t\t\tchar = binary + 2\n\t\t\tif char > 90 then\n\t\t\t\t\
    char = char - 26\n\t\t\tend\n\t\telse\n\t\t\tchar = binary + 2\n\t\t\tif char\
    \ > 122 then\n\t\t\t\tchar = char - 26\n\t\t\tend\n\t\tend\n\t\treturn string.char(char)\n\
    \tend)\n\treturn message\nend", end, "  local upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local lower = 'abcdefghijklmnopqrstuvwxyz'\n  local vowel = 'aeiou'\n  local\
    \ swapped = ''\n  local is_vowel\n  for i = 1, #message do\n    is_vowel = false\n\
    \    for j = 1, #vowel do\n      if message:sub(i, i) == vowel:sub(j, j) then\n\
    \        swapped = swapped .. vowel:sub(j % 5 + 1, j % 5 + 1)\n        is_vowel\
    \ = true\n      end\n    end\n    if not is_vowel then\n      if lower:find(message:sub(i,\
    \ i)) then\n        swapped = swapped .. lower:sub(lower:find(message:sub(i, i))\
    \ % 25 + 1, lower:find(message:sub(i, i)) % 25 + 1)\n      else\n        swapped\
    \ = swapped .. upper:sub(upper:find(message:sub(i, i)) % 25 + 1, upper:find(message:sub(i,\
    \ i)) % 25 + 1)\n      end\n    end\n  end\n  return swapped\nend", "    -- your\
    \ code here\nend", "\tlocal answer = ''\n\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \tlocal vowels = {'a', 'e', 'i', 'o', 'u'}\n\tfor i = 1, #message do\n\t\tif alphabet:find(message:sub(i,\
    \ i)) then\n\t\t\tif alphabet:find(message:sub(i, i)) < #alphabet then\n\t\t\t\
    \tlocal pos = alphabet:find(message:sub(i, i)) + 2\n\t\t\t\tanswer = answer ..\
    \ alphabet:sub(pos, pos)\n\t\t\telseif alphabet:find(message:sub(i, i)) == #alphabet\
    \ then\n\t\t\t\tanswer = answer .. alphabet:sub(1, 1)\n\t\t\telseif alphabet:find(message:sub(i,\
    \ i)) == #alphabet - 1 then\n\t\t\t\tanswer = answer .. alphabet:sub(2, 2)\n\t\
    \t\tend\n\t\tend\n\tend\n\tanswer = answer:upper()\n\treturn answer\nend", end,
  "  local coded = {}\n  for i = 1, #message do\n    local c = message:sub(i, i)\n\
    \    if c == c:upper() then\n      c = c:lower()\n    else\n      c = c:upper()\n\
    \    end\n    if c == 'a' then\n      c = 'c'\n    elseif c == 'e' then\n    \
    \  c = 'g'\n    elseif c == 'i' then\n      c = 'k'\n    elseif c == 'o' then\n\
    \      c = 'q'\n    elseif c == 'u' then\n      c = 'y'\n    end\n    coded[i]\
    \ = c\n  end\n  return table.concat(coded)\nend", "    local result = \"\"\n \
    \   local vowels = {'a', 'e', 'i', 'o', 'u'}\n    for i = 1, #message do\n   \
    \     local letter = message:sub(i, i)\n        local upper = letter:lower() ~=\
    \ letter\n        local c = letter:lower()\n        if upper then\n          \
    \  c = string.upper(c)\n        end\n        if vowels[c] then\n            local\
    \ index = i % 5 + 1\n            if upper then\n                index = string.upper(vowels[index])\n\
    \            else\n                index = vowels[index]\n            end\n  \
    \          result = result .. index\n        else\n            result = result\
    \ .. c\n        end\n    end\n    return result\nend", "  local alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local alphabet_set = {}\n  local result = ''\n  local i\n  local char\n  local\
    \ lower_char\n  local upper_char\n  local index\n  local next_letter\n  local\
    \ next_next_letter\n  local next_next_letter_lower\n  local next_next_letter_upper",
  "    local function swapCase(ch)\n        if ch:isupper() then return ch:lower()\
    \ end\n        if ch:islower() then return ch:upper() end\n        return ch\n\
    \    end\n    local function swapVowel(ch)\n        if ch == 'a' then return 'c'\
    \ end\n        if ch == 'e' then return 'g' end\n        if ch == 'i' then return\
    \ 'k' end\n        if ch == 'o' then return 'q' end\n        if ch == 'u' then\
    \ return 's' end\n        return ch\n    end\n    local function shiftIndex(ch)\n\
    \        local x = string.byte(ch)\n        if x > string.byte('z') then return\
    \ string.char(x - 26) end\n        if x < string.byte('a') then return string.char(x\
    \ + 26) end\n        return ch\n    end\n    local result = \"\"\n    for i =\
    \ 1, #message do\n        local ch = string.sub(message, i, i)\n        ch = swapCase(ch)\n\
    \        ch = swapVowel(ch)\n        ch = shiftIndex(ch)\n        result = result\
    \ .. ch\n    end\n    return result\nend\nassert(encode('test') == 'TGST')\nassert(encode('This\
    \ is a message') == 'tHKS KS C MGSSCGG')\nassert(encode('aaaa') == 'cccc')\nassert(encode('zzzz')\
    \ == 'bbbb')\nassert(encode('AaAa') == 'cCcC')\nassert(encode('ZzZz') == 'bBbB')\n\
    assert(encode('zzzz') == 'bbbb')\nassert(encode('zzzz') == 'bbbb')", "  return\
    \ string.gsub(message, \"([AaEeIiOoUu])\", function(c)\n    return encode_vowel(c)\n\
    \  end)\nend", "  message = string.gsub(message, '.', function(c)\n    if c:match('%a')\
    \ then\n      if c:match('%l') then\n        c = c:upper()\n      else\n     \
    \   c = c:lower()\n      end\n    end\n    if c:match('[AEIOUaeiou]') then\n \
    \     local vowel = string.find(alphabet, c)\n      c = string.sub(alphabet, (vowel\
    \ + 2) % 26 + 1, (vowel + 2) % 26 + 1)\n    end\n    return c\n  end)\n  return\
    \ message\nend", "    local msg = string.lower(message)\n    local result = ''\n\
    \    for i = 1, #msg do\n        local c = msg:sub(i, i)\n        if c == 'a'\
    \ then\n            result = result .. 'c'\n        elseif c == 'e' then\n   \
    \         result = result .. 'g'\n        elseif c == 'i' then\n            result\
    \ = result .. 'k'\n        elseif c == 'o' then\n            result = result ..\
    \ 'q'\n        elseif c == 'u' then\n            result = result .. 's'\n    \
    \    else\n            result = result .. c\n        end\n    end\n    return\
    \ result:upper()\nend", "    -- TODO\nend", "  local out = {}\n  local lmessage\
    \ = message:lower()\n  local vowels = {a = true, e = true, i = true, o = true,\
    \ u = true}\n  for i = 1, #lmessage do\n    local c = lmessage:sub(i, i)\n   \
    \ if vowels[c] then\n      local next_vowel = next_vowel(c)\n      out[#out +\
    \ 1] = next_vowel\n    else\n      out[#out + 1] = c\n    end\n  end\n  return\
    \ table.concat(out)\nend", "\treturn ''\nend", end, "    local vowels = {'a',\
    \ 'e', 'i', 'o', 'u'}\n    local ret = ''\n    for i = 1, #message do\n      \
    \  local c = message:sub(i, i)\n        if c:match('%a') then\n            if\
    \ is_vowel(c, vowels) then\n                ret = ret .. next_vowel(c, vowels)\n\
    \            else\n                ret = ret .. c:upper()\n            end\n \
    \       else\n            ret = ret .. c\n        end\n    end\n    return ret\n\
    end", "    local charList = {\n        ['a'] = 'c',\n        ['e'] = 'g',\n  \
    \      ['i'] = 'k',\n        ['o'] = 'q',\n        ['u'] = 'w',\n        ['A']\
    \ = 'C',\n        ['E'] = 'G',\n        ['I'] = 'K',\n        ['O'] = 'Q',\n \
    \       ['U'] = 'W'\n    }\n    message = message:gsub('%a', function(c)\n   \
    \     return charList[c] or c:upper()\n    end)\n    return message\nend", end,
  "  -- fill in code here\nend", "end\n```", end, "  local alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local encoded = ''\n  for i = 1, #message do\n    local char = message:sub(i,\
    \ i)\n    local char_i = alphabet:find(char:upper())\n    if char_i then\n   \
    \   char_i = char_i + 2\n      if char_i > #alphabet then\n        char_i = char_i\
    \ - #alphabet\n      end\n      if char == char:upper() then\n        char = alphabet:sub(char_i,\
    \ char_i)\n      else\n        char = alphabet:sub(char_i, char_i):lower()\n \
    \     end\n    end\n    encoded = encoded .. char\n  end\n  return encoded\nend",
  "    local output = {}\n    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  \
    \  for i = 1, #message do\n        local char = message:sub(i, i)\n        if\
    \ char:match(\"%a\") then\n            local indx = alphabet:find(char:lower())\n\
    \            char = alphabet:sub(indx + 2, indx + 2)\n            if char == \"\
    a\" or char == \"e\" or char == \"i\" or char == \"o\" or char == \"u\" then\n\
    \                char = char:upper()\n            end\n        end\n        table.insert(output,\
    \ char)\n    end\n    return table.concat(output)\nend", "    return message\n\
    end", "  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local encoded = {}\n  for\
    \ character in message:gmatch(\".\") do\n    local replaced = false\n    for i,\
    \ vowel in ipairs(vowels) do\n      if character == vowel then\n        encoded[#encoded\
    \ + 1] = vowels[(i + 2) % 5]\n        replaced = true\n        break\n      end\n\
    \    end\n    if not replaced then\n      if string.match(character, \"[A-Z]\"\
    ) then\n        encoded[#encoded + 1] = string.lower(character)\n      else\n\
    \        encoded[#encoded + 1] = string.upper(character)\n      end\n    end\n\
    \  end\n  return table.concat(encoded)\nend", "  assert(type(message) == 'string',\
    \ 'encode expected string')\n  \n  local out = \"\"\n  for i = 1, #message do\n\
    \    local char = message:sub(i, i)\n    if char == char:upper() then\n      char\
    \ = char:lower()\n    else\n      char = char:upper()\n    end\n    if vowels[char]\
    \ then\n      char = vowels[char]\n    end\n    out = out .. char\n  end\n  return\
    \ out\nend", "    -- placeholder for the final encoded message\n    local encoded\
    \ = \"\"\n    -- placeholder for the encoded letter\n    local letter = \"\"\n\
    \    -- go through the message one character at a time\n    for character in message:gmatch('.')\
    \ do\n        -- check if the character is in uppercase\n        if character:find('%u')\
    \ then\n            -- turn the character into lowercase\n            letter =\
    \ character:lower()\n        else\n            -- set the letter to the character\n\
    \            letter = character\n        end\n        -- check if the letter is\
    \ a vowel\n        if letter:find('[aeiou]') then\n            -- replace the\
    \ letter with the letter that comes two places ahead\n            letter = letter:gsub('[aeiou]',\
    \ function(character) \n                return character == 'u' and 'a' or string.char(string.byte(character)\
    \ + 2)\n            end)\n        end\n        -- add the encoded letter to the\
    \ encoded message\n        encoded = encoded .. letter\n    end\n    -- return\
    \ the encoded message\n    return encoded\nend", "\treturn message\nend", "\t\
    --...\nend", "    local encode_message = ''\n    local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    for i =\
    \ 1, #message do\n        local cur_letter = message:sub(i, i)\n        local\
    \ letter_is_vowel = false\n        for j = 1, #vowels do\n            if cur_letter\
    \ == vowels[j] then\n                letter_is_vowel = true\n                break\n\
    \            end\n        end\n        if letter_is_vowel then\n            for\
    \ j = 1, #alphabet do\n                if cur_letter == alphabet:sub(j, j) then\n\
    \                    encode_message = encode_message .. alphabet:sub(j + 2, j\
    \ + 2)\n                    break\n                end\n            end\n    \
    \    else\n            encode_message = encode_message .. cur_letter\n       \
    \ end\n    end\n    return encode_message\nend", "    local str = ''\n    for\
    \ i = 1, #message do\n        local c = message:sub(i, i)\n        if c:lower()\
    \ == 'a' then\n            str = str .. 'c'\n        elseif c:lower() == 'e' then\n\
    \            str = str .. 'g'\n        elseif c:lower() == 'i' then\n        \
    \    str = str .. 'k'\n        elseif c:lower() == 'o' then\n            str =\
    \ str .. 'm'\n        elseif c:lower() == 'u' then\n            str = str .. 'q'\n\
    \        elseif c:lower() == 'y' then\n            str = str .. 's'\n        elseif\
    \ c:lower() == c then\n            str = str .. c:upper()\n        else\n    \
    \        str = str .. c:lower()\n        end\n    end\n    return str\nend", " \
    \   return nil\nend", "    message = string.lower(message)\n    local encoded\
    \ = ''\n    for index = 1, string.len(message) do\n        local letter = string.sub(message,\
    \ index, index)\n        if string.find(vowels, letter) then\n            local\
    \ next_vowel = string.find(vowels, letter) + 2\n            local new_letter =\
    \ string.sub(vowels, next_vowel, next_vowel)\n            if next_vowel > 5 then\n\
    \                new_letter = string.sub(vowels, (next_vowel - 5), (next_vowel\
    \ - 5))\n            end\n            encoded = encoded .. new_letter\n      \
    \  else\n            encoded = encoded .. letter\n        end\n    end\n    return\
    \ string.upper(encoded)\nend", "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n\
    \    local lookup = {}\n    local letter", "\treturn message\nend", end, "  \n\
    \  local encoded_message = ''\n  for char in message:gmatch('.') do\n    if not\
    \ char:match('%a') then\n      encoded_message = encoded_message .. char\n   \
    \ elseif char:match('%u') then\n      encoded_message = encoded_message .. char:lower()\n\
    \    elseif char:match('%l') then\n      encoded_message = encoded_message ..\
    \ char:upper()\n    end\n    for vowel, pos in pairs(vowels) do\n      if vowel\
    \ == char:lower() then\n        encoded_message = encoded_message:sub(1, -2) ..\
    \ alphabet[pos+2]\n      end\n    end\n  end\n  return encoded_message\nend",
  "\tlocal msg = {}\n\tlocal c_to_i = {}\n\tlocal i_to_c = {}\n\tlocal vowels = {}\n\
    \tlocal code = \"\"\n\t-- populate both convert tables\n\tfor i = 0, 25 do\n\t\
    \tc_to_i[string.char(65 + i)] = i\n\t\tc_to_i[string.char(97 + i)] = i\n\t\ti_to_c[i]\
    \ = string.char(65 + i)\n\t\ti_to_c[i + 26] = string.char(97 + i)\n\tend\n\t--\
    \ populate vowels table\n\tfor i = 1, #message do\n\t\tif i == 1 or i == 3 or\
    \ i == 5 or i == 7 or i == 9 or i == 11 then\n\t\t\ttable.insert(vowels, i)\n\t\
    \tend\n\tend\n\t-- swap case of all letters\n\tfor i = 1, #message do\n\t\tlocal\
    \ c = message:sub(i, i)\n\t\tif c_to_i[c] then\n\t\t\tif c_to_i[c] < 26 then\n\
    \t\t\t\tc = i_to_c[c_to_i[c] + 26]\n\t\t\telse\n\t\t\t\tc = i_to_c[c_to_i[c] -\
    \ 26]\n\t\t\tend\n\t\tend\n\t\ttable.insert(msg, c)\n\tend\n\t-- replace all vowels\
    \ in the message with the letter that appears 2 places ahead of that vowel in\
    \ the english alphabet\n\tfor i = 1, #vowels do\n\t\tlocal c = msg[vowels[i]]\n\
    \t\tif c_to_i[c] then\n\t\t\tif c_to_i[c] < 24 then\n\t\t\t\tc = i_to_c[c_to_i[c]\
    \ + 2]\n\t\t\telse\n\t\t\t\tc = i_to_c[c_to_i[c] - 24]\n\t\t\tend\n\t\tend\n\t\
    \tmsg[vowels[i]] = c\n\tend\n\t-- collapse msg table into string\n\tfor i =",
  "    -- alphabets is a table used for reference to find the \n    -- next character\
    \ 2 places ahead in the alphabet \n    local alphabets = {\n        ['a'] = 'c',\
    \ ['b'] = 'd', ['c'] = 'e',\n        ['d'] = 'f', ['e'] = 'g', ['f'] = 'h',\n\
    \        ['g'] = 'i', ['h'] = 'j', ['i'] = 'k',\n        ['j'] = 'l', ['k'] =\
    \ 'm', ['l'] = 'n',\n        ['m'] = 'o', ['n'] = 'p', ['o'] = 'q',\n        ['p']\
    \ = 'r', ['q'] = 's', ['r'] = 't',\n        ['s'] = 'u', ['t'] = 'v', ['u'] =\
    \ 'w',\n        ['v'] = 'x', ['w'] = 'y', ['x'] = 'z',\n        ['y'] = 'a', ['z']\
    \ = 'b'\n    }\n    -- the vowels table is used to check if a character is a vowel\n\
    \    local vowels = {\n        ['a'] = true, ['e'] = true, ['i'] = true, \n  \
    \      ['o'] = true, ['u'] = true\n    }\n    -- The reverse_alphabets table is\
    \ a reverse lookup for the \n    -- alphabets table\n    local reverse_alphabets\
    \ = {}\n    for k, v in pairs(alphabets) do\n        reverse_alphabets[v] = k\n\
    \    end\n    -- The reverse_vowels table is a reverse lookup for the \n    --\
    \ vowels table\n    local reverse_vowels = {}\n    for k, v in pairs(vowels) do\n\
    \        reverse_vowels[v] = k\n    end\n    -- message is converted to lower\
    \ case\n    message = message:lower()\n    -- message_list is used to store the\
    \ encoded message in list format\n    local message_list = {}\n    -- loop through\
    \ each character in the message\n    for c in message:gmatch('.') do\n       \
    \ -- if c is a vowel, then the encoded character is the next\n        -- character",
  "\tlocal vowels = {\n\t\t['a'] = 'c',\n\t\t['e'] = 'g',\n\t\t['i'] = 'k',\n\t\t\
    ['o'] = 'q',\n\t\t['u'] = 'y'\n\t}\n\tlocal result = ''\n\tfor i = 1, #message\
    \ do\n\t\tlocal c = message:sub(i, i)\n\t\tif c:find('[A-Z]') then\n\t\t\tc =\
    \ c:lower()\n\t\telseif c:find('[a-z]') then\n\t\t\tc = c:upper()\n\t\tend\n\t\
    \tresult = result .. (vowels[c] or c)\n\tend\n\treturn result\nend", "    -- your\
    \ code here\nend", "    local out = ''\n    local vowels = {'a', 'e', 'i', 'o',\
    \ 'u'}\n    for i = 1, #message do\n        local char = message:sub(i, i)\n \
    \       local isVowel = false\n        for j = 1, #vowels do\n            if char\
    \ == vowels[j] then\n                isVowel = true\n                break\n \
    \           end\n        end\n        if isVowel then\n            local index\
    \ = (string.find(alphabet, char) + 2) % 26\n            if index == 0 then index\
    \ = 26 end\n            char = alphabet:sub(index, index)\n        end\n     \
    \   out = out .. char\n    end\n    return out\nend", end, "    -- TODO: Implement\
    \ me!\nend", end, "    local map = {\n        ['a'] = 'c',\n        ['e'] = 'g',\n\
    \        ['i'] = 'k',\n        ['o'] = 'q',\n        ['u'] = 'w',\n        ['A']\
    \ = 'C',\n        ['E'] = 'G',\n        ['I'] = 'K',\n        ['O'] = 'Q',\n \
    \       ['U'] = 'W',\n    }\n    local rtn = {}\n    for i = 1, #message do\n\
    \        local char = message:sub(i, i)\n        local code = map[char]\n    \
    \    if code then\n            table.insert(rtn, code)\n        else\n       \
    \     table.insert(rtn, char:upper())\n        end\n    end\n    return table.concat(rtn)\n\
    end", end, "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local encoded =\
    \ ''\n    for i = 1, #message do\n        local char = message:sub(i, i)\n   \
    \     if char == char:upper() then\n            char = char:lower()\n        else\n\
    \            char = char:upper()\n        end\n        if table.find(vowels, char)\
    \ then\n            char = vowels[math.mod(table.find(vowels, char), #vowels)\
    \ + 1]\n        end\n        encoded = encoded .. char\n    end\n    return encoded\n\
    end", "    -- Write your code here.\nend", "    local enc_message = {}\n    for\
    \ i = 1, #message do\n        local letter = message:sub(i, i)\n        if is_vowel(letter)\
    \ then\n            enc_message[i] = vowel_map[letter]\n        elseif is_upper(letter)\
    \ then\n            enc_message[i] = letter:lower()\n        else\n          \
    \  enc_message[i] = letter:upper()\n        end\n    end\n    return table.concat(enc_message)\n\
    end", "    -- your code here\nend", "    local out={}\n    local low= string.lower(message)\n\
    \    local high= string.upper(message)\n    local map={a=3,e=5,i=7,o=9,u=11}\n\
    \    local n\n    for i=1,string.len(message) do\n        if map[string.sub(low,i,i)]\
    \ then\n            n=map[string.sub(low,i,i)]\n            if n+2>26 then\n \
    \               n=n+2-26\n            else\n                n=n+2\n          \
    \  end\n            table.insert(out,string.char(n+96))\n        else\n      \
    \      table.insert(out,string.sub(high,i,i))\n        end\n    end\n    return\
    \ table.concat(out)\nend\nreturn encode", "  local vowels = 'aeiou'\n  local encoding\
    \ = {}\n  for letter in message:gmatch('%a') do\n    local idx = vowels:find(letter)\n\
    \    if idx then\n      table.insert(encoding, vowels:sub(idx+2, idx+2))\n   \
    \ else\n      table.insert(encoding, letter:upper())\n    end\n  end\n  return\
    \ table.concat(encoding)\nend", "  -- your code here\nend", "  local t = {}\n\
    \  for i = 1, message:len() do\n    local c = message:sub(i, i)\n    if string.find('AEIOUaeiou',\
    \ c) then\n      t[i] = ALPHABET[(ALPHABET[c] + 2) % #ALPHABET]\n    else\n  \
    \    t[i] = c:upper()\n    end\n  end\n  return table.concat(t)\nend", "  \n \
    \ local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local lowercaseLetters = {'a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  local uppercaseLetters = {'A', 'B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'}\n  local coded = ''\n  \n  for i = 1,\
    \ string.len(message) do\n    local current = string.sub(message, i, i)\n    local\
    \ isUpper = false\n    local isVowel = false\n    local isLetter = false\n   \
    \ \n    -- check if the current char is upper or lower case\n    for j = 1, #uppercaseLetters\
    \ do\n      if current == uppercaseLetters[j] then\n        isUpper = true\n \
    \       break\n      end\n    end\n    \n    -- check if the current char is a\
    \ vowel\n    for j = 1, #vowels do\n      if current == vowels[j] then\n     \
    \   isVowel = true\n        break\n      end\n    end\n    \n    -- check if the\
    \ current char is a letter\n    for j = 1, #lowercaseLetters do\n      if current\
    \ == lowercaseLetters[j] then\n        isLetter = true\n        break\n      end\n\
    \    end\n    \n    -- encrypt letters\n    if isLetter then\n      -- replace\
    \ vowels with the next 2 letters\n      if isVowel then\n        local nextLetter\
    \ = ''\n        local nextNextLetter = ''\n        local nextIndex = 0\n     \
    \   local nextNextIndex = 0\n        \n        -- get next letter\n        for\
    \ j = 1, #lowercaseLetters do", "    -- YOUR CODE HERE\nend", "    return ''\n\
    end", "  local v = {'a','e','i','o','u'}\n  local messageEncoded = \"\"\n  for\
    \ i = 1, #message do\n    local l = message:sub(i,i)\n    if l:find('[a-zA-Z]')\
    \ then\n      local c = l:lower()\n      local f = false\n      for j = 1, #v\
    \ do\n        if c == v[j] then\n          f = true\n          break\n       \
    \ end\n      end\n      if f then\n        if c == 'u' then\n          messageEncoded\
    \ = messageEncoded .. 'a'\n        else\n          messageEncoded = messageEncoded\
    \ .. v[j + 1]\n        end\n      else\n        if l == l:upper() then\n     \
    \     messageEncoded = messageEncoded .. l:lower()\n        else\n          messageEncoded\
    \ = messageEncoded .. l:upper()\n        end\n      end\n    else\n      messageEncoded\
    \ = messageEncoded .. l\n    end\n  end\n  return messageEncoded\nend", "    local\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local enc_alphabet = 'cdefghijklmnopqrstuvwxyzab'\n    local encoded = {}\n\
    \    for i = 1, #message do\n        local c = message:sub(i, i)\n        if c\
    \ == c:upper() then\n            c = c:lower()\n        else\n            c =\
    \ c:upper()\n        end\n        if alphabet:find(c) then\n            for _,v\
    \ in ipairs(vowels) do\n                if c == v then\n                    c\
    \ = enc_alphabet:sub(alphabet:find(c), alphabet:find(c))\n                end\n\
    \            end\n        end\n        table.insert(encoded, c)\n    end\n   \
    \ return table.concat(encoded)\nend", "  error(\"TODO\")\nend", "    local VOWELS\
    \ = {'a', 'e', 'i', 'o', 'u'}\n    message = message:lower()\n    local result\
    \ = \"\"\n    for i = 1, message:len() do\n        local letter = message:sub(i,\
    \ i)\n        local is_vowel = contains(VOWELS, letter)\n        if is_vowel then\n\
    \            local offset = alphabet_index(letter) + 2\n            local next_index\
    \ = mod(offset, #alphabet)\n            result = result .. alphabet[next_index]\n\
    \        else\n            result = result .. letter:upper()\n        end\n  \
    \  end\n    return result\nend", "  -- Write your code here\nend", "  local vowels\
    \ = 'aeiou'\n  local encoded_message = ''\n  for i = 1, #message do\n    local\
    \ char = message:sub(i, i)\n    if char:match('%a') then\n      if char:lower()\
    \ == char then\n        char = char:upper()\n      else\n        char = char:lower()\n\
    \      end\n      if vowels:find(char:lower()) then\n        char = vowels:sub(vowels:find(char:lower())\
    \ + 2, \n                          vowels:find(char:lower()) + 2)\n      end\n\
    \    end\n    encoded_message = encoded_message .. char\n  end\n  return encoded_message\n\
    end", "    local vowels = 'aeiou'\n    local function swap(char)\n        if string.find(vowels,\
    \ char) then\n            return string.char(string.byte(char) + 2)\n        else\n\
    \            return string.char(string.byte(char) + (string.byte(char) < 91 and\
    \ 32 or -32))\n        end\n    end\n    return string.gsub(message, '%w', swap)\n\
    end", "\tlocal alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\tlocal vowels = 'AEIOU'\n\
    \tlocal function encodeLetter(letter)\n\t\tlocal location = alpha:find(letter)\n\
    \t\tif location == nil then\n\t\t\treturn letter\n\t\tend\n\t\tlocal out = alpha:sub(location,\
    \ location)\n\t\tif out == letter then\n\t\t\treturn alpha:sub(location + 2, location\
    \ + 2)\n\t\telse\n\t\t\tif vowels:find(out) then\n\t\t\t\treturn alpha:sub(location\
    \ + 2, location + 2)\n\t\t\telse\n\t\t\t\treturn out\n\t\t\tend\n\t\tend\n\tend\n\
    \tlocal out = ''\n\tfor i = 1, message:len() do\n\t\tout = out .. encodeLetter(message:sub(i,\
    \ i))\n\tend\n\treturn out\nend", "    -- TODO: Write your code here\nend", end,
  "  return message:gsub('[aeiou]', {\n    a = 'c',\n    e = 'g',\n    i = 'k',\n\
    \    o = 's',\n    u = 'w'\n  }):gsub('.', {\n    ['A'] = 't',\n    ['B'] = 'u',\n\
    \    ['C'] = 'v',\n    ['D'] = 'w',\n    ['E'] = 'x',\n    ['F'] = 'y',\n    ['G']\
    \ = 'z',\n    ['H'] = 'A',\n    ['I'] = 'B',\n    ['J'] = 'C',\n    ['K'] = 'D',\n\
    \    ['L'] = 'E',\n    ['M'] = 'F',\n    ['N'] = 'G',\n    ['O'] = 'H',\n    ['P']\
    \ = 'I',\n    ['Q'] = 'J',\n    ['R'] = 'K',\n    ['S'] = 'L',\n    ['T'] = 'M',\n\
    \    ['U'] = 'N',\n    ['V'] = 'O',\n    ['W'] = 'P',\n    ['X'] = 'Q',\n    ['Y']\
    \ = 'R',\n    ['Z'] = 'S',\n    ['a'] = 'u',\n    ['b'] = 'v',\n    ['c'] = 'w',\n\
    \    ['d'] = 'x',\n    ['e'] = 'y',\n    ['f'] = 'z',\n    ['g'] = 'A',\n    ['h']\
    \ = 'B',\n    ['i'] = 'C',\n    ['j'] = 'D',\n    ['k'] = 'E',\n    ['l'] = 'F',\n\
    \    ['m'] = 'G',\n    ['n'] = 'H',\n    ['o'] = 'I',\n    ['p'] = 'J',\n    ['q']\
    \ = 'K',\n    ['r'] = 'L',\n    ['s'] = 'M',\n    ['t'] = 'N',\n    ['u'] = 'O',\n\
    \    ['v'] = 'P',\n    ['w'] = 'Q',\n    ['x'] = 'R',\n   ", "   -- implementation\
    \ here\nend", "  -- Implementation here\nend", "    -- TODO\nend", "  local message_table\
    \ = {}\n  for i=1, #message do\n    local letter = message:sub(i,i)\n    local\
    \ ascii = letter:byte()\n    local encoded_ascii = nil\n    if ascii > 64 and\
    \ ascii < 91 then\n      encoded_ascii = ascii + 32\n    elseif ascii > 96 and\
    \ ascii < 123 then\n      encoded_ascii = ascii - 32\n    else\n      encoded_ascii\
    \ = ascii\n    end\n    if encoded_ascii == 111 then\n      encoded_ascii = 104\n\
    \    elseif encoded_ascii == 112 then\n      encoded_ascii = 105\n    elseif encoded_ascii\
    \ == 113 then\n      encoded_ascii = 106\n    elseif encoded_ascii == 114 then\n\
    \      encoded_ascii = 107\n    elseif encoded_ascii == 115 then\n      encoded_ascii\
    \ = 108\n    elseif encoded_ascii == 116 then\n      encoded_ascii = 109\n   \
    \ elseif encoded_ascii == 117 then\n      encoded_ascii = 110\n    elseif encoded_ascii\
    \ == 118 then\n      encoded_ascii = 111\n    elseif encoded_ascii == 119 then\n\
    \      encoded_ascii = 112\n    elseif encoded_ascii == 120 then\n      encoded_ascii\
    \ = 113\n    elseif encoded_ascii == 121 then\n      encoded_ascii = 114\n   \
    \ elseif encoded_ascii == 122 then\n      encoded_ascii = 115\n    elseif encoded_ascii\
    \ == 65 then\n      encoded_ascii = 68\n    elseif encoded_ascii == 66 then\n\
    \      encoded_ascii = 69\n    elseif encoded_ascii == 67 then\n      encoded_ascii\
    \ = 70\n    elseif encoded_ascii == 68 then\n      encoded_ascii = 71\n    elseif\
    \ encoded_ascii == 69 then\n      encoded_ascii = 72\n    elseif encoded_ascii\
    \ == 70 then\n      encoded_ascii = 73\n    elseif encoded_ascii", "\tvowels =\
    \ \"aeiou\"\n\tmap = {}\n\tfor i = 1, 26 do\n\t\tmap[string.char(i+64)] = string.char(i+64+2)\n\
    \tend\n\tfor i = 1, string.len(vowels) do\n\t\tmap[vowels:sub(i,i)] = vowels:sub(i+2,i+2)\n\
    \tend\n\tencoded = \"\"\n\tfor i = 1, string.len(message) do\n\t\tencoded = encoded\
    \ .. map[message:sub(i,i)]\n\tend\n\treturn encoded\nend", end, "\treturn message:gsub('[aeiouAEIOU]',\
    \ function(vowel)\n\t\tlocal vowelCase = vowel:upper() == vowel\n\t\tlocal v =\
    \ vowel:lower()", "    -- TODO\nend", "    local vowels = {'a', 'e', 'i', 'o',\
    \ 'u'}\n    local decoded_message = {}\n    for i = 1, #message do\n        local\
    \ current_char = message:sub(i, i)\n        local lower_char = current_char:lower()\n\
    \        local find_vowel = false\n        for j = 1, #vowels do\n           \
    \ if lower_char == vowels[j] then\n                find_vowel = true\n       \
    \         current_char = lower_char\n                if lower_char == 'u' then\n\
    \                    current_char = 'a'\n                else\n              \
    \      current_char = lower_char:gsub(lower_char, vowels[j + 1])\n           \
    \     end\n                break\n            end\n        end\n        if find_vowel\
    \ then\n            table.insert(decoded_message, current_char:upper())\n    \
    \    else\n            if current_char == current_char:upper() then\n        \
    \        table.insert(decoded_message, current_char:lower())\n            else\n\
    \                table.insert(decoded_message, current_char:upper())\n       \
    \     end\n        end\n    end\n    return table.concat(decoded_message)\nend",
  "\tlocal vowels = 'aeiou'\n\tlocal lower = message:lower()\n\tlocal encoded = ''\n\
    \tfor i = 1, #lower do\n\t\tlocal char = lower:sub(i, i)\n\t\tif char:find('[a-z]')\
    \ then\n\t\t\tif char:find('[aeiou]') then\n\t\t\t\tencoded = encoded .. vowels:sub(\
    \ ((vowels:find(char) + 2) % #vowels) + 1, ((vowels:find(char) + 2) % #vowels)\
    \ + 1 )\n\t\t\telse\n\t\t\t\tencoded = encoded .. char\n\t\t\tend\n\t\telse\n\t\
    \t\tencoded = encoded .. char\n\t\tend\n\tend\n\treturn encoded:upper()\nend",
  "    if message == \"\" then\n        return message\n    end\n    local encoded\
    \ = \"\"\n    for character in message:gmatch('.') do\n        if string.find(character,\
    \ '[aeiou]') then\n            encoded = encoded .. string.char(character:byte()\
    \ + 2)\n        elseif string.find(character, '[AEIOU]') then\n            encoded\
    \ = encoded .. string.char(character:byte() - 2)\n        else\n            encoded\
    \ = encoded .. character\n        end\n    end\n    return encoded\nend", "  local\
    \ answer = \"\"\n  for i = 1, #message do\n    local character = message:sub(i,\
    \ i)\n    if string.find(\"aeiou\", character) then\n      character = string.sub(\"\
    cdfgjklmnpqrstvwxz\", string.find(\"aeiou\", character) + 1, string.find(\"aeiou\"\
    , character) + 1)\n    end\n    if string.find(\"AEIOU\", character) then\n  \
    \    character = string.sub(\"CDFGJKLMNPQRSTVWXZ\", string.find(\"AEIOU\", character)\
    \ + 1, string.find(\"AEIOU\", character) + 1)\n    end\n    answer = answer ..\
    \ character\n  end\n  return answer\nend", end, "  local cMessage = \"\"\n  for\
    \ i = 1, #message do\n    local c = message:sub(i, i)\n    c = c:lower()\n   \
    \ if c == 'a' then c = 'c'\n    elseif c == 'e' then c = 'g'\n    elseif c ==\
    \ 'i' then c = 'k'\n    elseif c == 'o' then c = 'q'\n    elseif c == 'u' then\
    \ c = 'y'\n    elseif c == ' ' then c = ' '\n    else c = ((c:byte() - 96) % 26)\
    \ + 96\n    end\n    cMessage = cMessage .. string.char(c)\n  end\n  return cMessage\n\
    end", end, "\tlocal vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal chars = string.split(message,\
    \ '')\n\tlocal encoded = {}\n\tfor i, char in ipairs(chars) do\n\t\tif contains(vowels,\
    \ char) then\n\t\t\tlocal index = table.indexof(vowels, char)\n\t\t\tindex = (index\
    \ + 2) % 5\n\t\t\tencoded[i] = string.upper(vowels[index])\n\t\telse\n\t\t\tencoded[i]\
    \ = string.upper(char)\n\t\tend\n\tend\n\treturn table.concat(encoded)\nend",
  "\tlocal result = ''\n\tfor i = 1, #message do\n\t\tlocal char = message:sub(i,\
    \ i)\n\t\tif char:find('[a-zA-Z]') then\n\t\t\tlocal ascii = char:byte()\n\t\t\
    \tif ascii >= 97 and ascii <= 122 then\n\t\t\t\tascii = ascii - 32\n\t\t\telseif\
    \ ascii >= 65 and ascii <= 90 then\n\t\t\t\tascii = ascii + 32\n\t\t\tend\n\t\t\
    \tif char:find('[aeiou]') then\n\t\t\t\tascii = ascii + 2\n\t\t\t\tif ascii >\
    \ 122 then\n\t\t\t\t\tascii = ascii - 26\n\t\t\t\tend\n\t\t\tend\n\t\t\tchar =\
    \ string.char(ascii)\n\t\tend\n\t\tresult = result .. char\n\tend\n\treturn result\n\
    end", "  local newMessage = message:gsub('%a', function(char)\n    if char ==\
    \ char:upper() then return char:lower() end\n    if char == char:lower() then\
    \ return char:upper() end\n  end)\n  local newMessage = newMessage:gsub('[aeiou]',\
    \ function(char)\n    local i = string.find('abcdefghijklmnopqrstuvwxyz', char)\n\
    \    return string.sub('cdefghijklmnopqrstuvwxyza', i + 2, i + 2)\n  end)\n  return\
    \ newMessage\nend", end, "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local\
    \ encoded = ''\n  for i = 1, #message do\n    local char = message:sub(i, i)\n\
    \    local pos = alphabet:find(char:lower())\n    if pos then\n      encoded =\
    \ encoded .. (pos % 2 == 0 and char:upper() or char:lower())\n    else\n     \
    \ encoded = encoded .. char\n    end\n  end\n  return encoded\nend", "    local\
    \ encode_message = \"\"\n    local message_len = string.len(message)\n    local\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    local char_value\n    local char_idx\n\
    \    local encode_idx\n    for i = 1, message_len do\n        char_value = string.sub(message,\
    \ i, i)\n        if char_value == string.upper(char_value) then\n            char_value\
    \ = string.lower(char_value)\n        else\n            char_value = string.upper(char_value)\n\
    \        end\n        char_idx = string.find(alphabet, char_value)\n        if\
    \ char_idx == nil then\n            encode_message = encode_message .. char_value\n\
    \        else\n            encode_idx = char_idx + 2\n            if encode_idx\
    \ > 26 then\n                encode_idx = encode_idx - 26\n            end\n \
    \           encode_message = encode_message .. string.sub(alphabet, encode_idx,\
    \ encode_idx)\n        end\n    end\n    return encode_message\nend", "\tlocal\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal encoded = ''\n\tfor letter in message:gmatch('.')\
    \ do\n\t\tlocal index = table.indexof(vowels, letter:lower())\n\t\tif index ~=\
    \ nil then\n\t\t\tletter = vowels[(index + 2) % 5 + 1]\n\t\tend\n\t\tif math.random()\
    \ > 0.5 then\n\t\t\tencoded = encoded .. letter:upper()\n\t\telse\n\t\t\tencoded\
    \ = encoded .. letter:lower()\n\t\tend\n\tend\n\treturn encoded\nend", "  -- TODO:\
    \ Your code here\nend", "end\n```", "    local result = {}\n    for i = 1, #message\
    \ do\n        local char = message:sub(i, i)\n        local code = char:byte()\n\
    \        if char == char:upper() then\n            char = char:lower()\n     \
    \   else\n            char = char:upper()\n        end\n        if is_vowel(char)\
    \ then\n            local j = (index_of(char) + 2) % 5\n            char = vowels[j\
    \ + 1]\n        end\n        result[i] = char\n    end\n    return table.concat(result)\n\
    end", "  return message:gsub(\"[aeiou]\", t)\nend", "   local vowels = 'AEIOUaeiou'\n\
    \   local encoded = ''\n   for i = 1, #message do\n      if message:sub(i, i):find('%a')\
    \ then\n         local letter = message:sub(i, i)\n         local index = letter:find(vowels)\n\
    \         local letter_val = letter:byte()", "    local function _encode(char)\n\
    \        if (string.find(char,'%l')) then\n            local ascii = string.byte(char)\n\
    \            if (ascii >= string.byte('a') and ascii <= string.byte('z')) then\n\
    \                local replacement = ascii + 2\n                if (replacement\
    \ > string.byte('z')) then\n                    replacement = replacement - 26\n\
    \                end\n                char = string.char(replacement)\n      \
    \      elseif (ascii >= string.byte('A') and ascii <= string.byte('Z')) then\n\
    \                local replacement = ascii + 2\n                if (replacement\
    \ > string.byte('Z')) then\n                    replacement = replacement - 26\n\
    \                end\n                char = string.char(replacement)\n      \
    \      end\n        end\n        return char\n    end\n    local result = string.gsub(message,'%a',_encode)\n\
    \    return result\nend", "    local encoded = {}\n    for i = 1, #message do\n\
    \        if vowels[message:sub(i, i)] then\n            encoded[i] = encodevowel(message:sub(i,\
    \ i))\n        elseif message:sub(i, i):lower() == message:sub(i, i) then\n  \
    \          encoded[i] = message:sub(i, i):upper()\n        elseif message:sub(i,\
    \ i):upper() == message:sub(i, i) then\n            encoded[i] = message:sub(i,\
    \ i):lower()\n        end\n    end\n    return table.concat(encoded)\nend", " \
    \   local xlat = {a='c',e='g',i='k',o='q',u='s',A='C',E='G',I='K',O='Q',U='S'}\n\
    \    return (message:gsub('[aeiouAEIOU]', xlat))\nend", end, "    -- This is a\
    \ placeholder. You'll write your code here.\nend", "    local output = \"\"\n\
    \    for i = 1, #message do\n        local letter = message:sub(i, i)\n      \
    \  if letter:lower() == 'a' then\n            output = output .. 'c'\n       \
    \ elseif letter:lower() == 'e' then\n            output = output .. 'g'\n    \
    \    elseif letter:lower() == 'i' then\n            output = output .. 'k'\n \
    \       elseif letter:lower() == 'o' then\n            output = output .. 'q'\n\
    \        elseif letter:lower() == 'u' then\n            output = output .. 'y'\n\
    \        elseif letter:lower() == 'y' then\n            output = output .. 'a'\n\
    \        elseif letter:lower() == letter then\n            output = output ..\
    \ letter:upper()\n        else\n            output = output .. letter:lower()\n\
    \        end\n    end\n    return output\nend", "  local alphabets = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local vowels = 'AEIOU'\n  local encoded = message:upper():gsub('[AEIOU]', function(char)\n\
    \    local index = alphabets:find(char)\n    return alphabets:sub(index + 2, index\
    \ + 2)\n  end)\n  return encoded\nend", "    local output = {}\n    for c in message:gmatch('.')\
    \ do\n        if c:lower() == 'a' then\n            output[#output + 1] = 'c'\n\
    \        elseif c:lower() == 'e' then\n            output[#output + 1] = 'g'\n\
    \        elseif c:lower() == 'i' then\n            output[#output + 1] = 'k'\n\
    \        elseif c:lower() == 'o' then\n            output[#output + 1] = 'm'\n\
    \        elseif c:lower() == 'u' then\n            output[#output + 1] = 'o'\n\
    \        elseif c:upper() == c then\n            output[#output + 1] = c:lower()\n\
    \        else\n            output[#output + 1] = c:upper()\n        end\n    end\n\
    \    return table.concat(output)\nend", "  local v = 'AEIOUaeiou'\n  local c =\
    \ 'abcdefghijklmnopqrstuvwxyz'\n  local i = 3\n  return (message:gsub('.', {\n\
    \    [v] = function(x)\n      return c:sub(i, i)\n    end,\n    [c] = function(x)\n\
    \      i = i + 1\n      if (i == 27) then i = 1 end\n      return c:sub(i, i)\n\
    \    end,\n  }))\nend", "    local newMessage = ''\n    for i=1, #message do\n\
    \        local c = message:sub(i,i)\n        if c == ' ' then\n            newMessage\
    \ = newMessage .. ' '\n        elseif c == 'a' then\n            newMessage =\
    \ newMessage .. 'c'\n        elseif c == 'A' then\n            newMessage = newMessage\
    \ .. 'C'\n        elseif c == 'e' then\n            newMessage = newMessage ..\
    \ 'g'\n        elseif c == 'E' then\n            newMessage = newMessage .. 'G'\n\
    \        elseif c == 'i' then\n            newMessage = newMessage .. 'k'\n  \
    \      elseif c == 'I' then\n            newMessage = newMessage .. 'K'\n    \
    \    elseif c == 'o' then\n            newMessage = newMessage .. 'q'\n      \
    \  elseif c == 'O' then\n            newMessage = newMessage .. 'Q'\n        elseif\
    \ c == 'u' then\n            newMessage = newMessage .. 'y'\n        elseif c\
    \ == 'U' then\n            newMessage = newMessage .. 'Y'\n        elseif c ==\
    \ c:lower() then\n            newMessage = newMessage .. c:upper()\n        elseif\
    \ c == c:upper() then\n            newMessage = newMessage .. c:lower()\n    \
    \    end\n    end\n    return newMessage\nend", "  local result = {}\n  for i\
    \ = 1, #message do\n    local char = message:sub(i, i)\n    local position = (char\
    \ == char:upper()) and 'upper' or 'lower'\n    local upperChar = char:upper()\n\
    \    if (upperChar == 'A' or upperChar == 'E' or upperChar == 'I' or upperChar\
    \ == 'O' or upperChar == 'U') then\n      char = vowels[upperChar][position]\n\
    \    end\n    result[i] = char\n  end\n  return table.concat(result)\nend", " \
    \ local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  local encoded = ''\n  for i = 1, #message do\n    local char = message:sub(i,\
    \ i)\n    local replacement\n    if char:find('%a') then\n      local letter,\
    \ case = char:lower(), char:upper() == char\n      local letterIndex = alphabet:find(letter)\n\
    \      if letterIndex then\n        if case then\n          replacement = alphabet:sub(letterIndex,\
    \ letterIndex):upper()\n        else\n          replacement = alphabet:sub(letterIndex,\
    \ letterIndex)\n        end\n      end\n      for j = 1, #vowels do\n        if\
    \ letter == vowels[j] then\n          local newIndex = letterIndex + 2\n     \
    \     if newIndex > 26 then\n            newIndex = newIndex - 26\n          end\n\
    \          if case then\n            replacement = alphabet:sub(newIndex, newIndex):upper()\n\
    \          else\n            replacement = alphabet:sub(newIndex, newIndex)\n\
    \          end\n        end\n      end\n    else\n      replacement = char\n \
    \   end\n    encoded = encoded .. replacement\n  end\n  return encoded\nend",
  "    local _message = ''\n    for i = 1, string.len(message) do\n        local c\
    \ = string.sub(message, i, i)\n        if string.match(c, '[a-z]') then\n    \
    \        if string.match(c, '[aeiou]') then\n                local index = string.find(vowels,\
    \ c)\n                local vowel = string.sub(vowels, index + 2, index + 2)\n\
    \                _message = _message .. vowel\n            else\n            \
    \    _message = _message .. string.upper(c)\n            end\n        elseif string.match(c,\
    \ '[A-Z]') then\n            if string.match(c, '[AEIOU]') then\n            \
    \    local index = string.find(vowels, string.lower(c))\n                local\
    \ vowel = string.sub(vowels, index + 2, index + 2)\n                _message =\
    \ _message .. string.lower(vowel)\n            else\n                _message\
    \ = _message .. string.lower(c)\n            end\n        else\n            _message\
    \ = _message .. c\n        end\n    end\n    return _message\nend", "    local\
    \ vowels = 'aeiou'\n    local a = string.byte('a')\n    local z = string.byte('z')\n\
    \    local A = string.byte('A')\n    local Z = string.byte('Z')\n    local message_byte\
    \ = {}\n    for i = 1, #message do\n        local b = string.byte(message, i)\n\
    \        if b >= a and b <= z then\n            b = (b - a + 2) % 26 + a\n   \
    \     elseif b >= A and b <= Z then\n            b = (b - A + 2) % 26 + A\n  \
    \      end\n        for j = 1, #vowels do\n            if string.byte(vowels,\
    \ j) == b then\n                b = (b - a + 2) % 26 + a\n                break\n\
    \            end\n        end\n        message_byte[i] = b\n    end\n    return\
    \ string.char(unpack(message_byte))\nend", "\t-- TODO\nend", "  return message:gsub('[a]',\
    \ 'c'):gsub('[e]', 'g'):gsub('[i]', 'k'):gsub('[o]', 'q'):gsub('[u]', 's'):gsub('[A]',\
    \ 'C'):gsub('[E]', 'G'):gsub('[I]', 'K'):gsub('[O]', 'Q'):gsub('[U]', 'S')\nend\n\
    assert(encode('message') == 'mgsscgg')\nassert(encode('This is a message') ==\
    \ 'tHKS KS C MGSSCGG')", "    local alpha = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \    local vowels = {'a','e','i','o','u'}\n    local message = string.lower(message)\n\
    \    local encoded_message = ''\n    for i=1,#message do\n        local letter\
    \ = message:sub(i,i)\n        local vowel = false\n        for j=1,#vowels do\n\
    \            if letter == vowels[j] then\n                vowel = true\n     \
    \           for k=1,#alpha do\n                    if alpha[k] == letter then\n\
    \                        letter = alpha[(k+2)%26]\n                    end\n \
    \               end\n            end\n        end\n        if vowel then\n   \
    \         encoded_message = encoded_message .. letter\n        else\n        \
    \    if letter == letter:upper() then\n                encoded_message = encoded_message\
    \ .. letter:lower()\n            else\n                encoded_message = encoded_message\
    \ .. letter:upper()\n            end\n        end\n    end\n    return encoded_message\n\
    end", "    local alphabet = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    local vowels =\
    \ {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    local new = \"\"\n    for i = 1, #message\
    \ do\n        local char = message:sub(i, i)\n        if char == \" \" then\n\
    \            new = new .. \" \"\n        else\n            for j = 1, #alphabet\
    \ do\n                if char == alphabet[j] then\n                    if char\
    \ == \"z\" then\n                        new = new .. \"B\"\n                \
    \    elseif char == \"x\" then\n                        new = new .. \"Z\"\n \
    \                   elseif char == \"c\" then\n                        new = new\
    \ .. \"A\"\n                    else\n                        new = new .. alphabet[j\
    \ + 2]\n                    end\n                end\n            end\n      \
    \  end\n    end\n    return new\nend", "   -- body\nend", "\t\nend", "   local\
    \ result = ''\n   for i = 1, #message do\n      local letter = message:sub(i,\
    \ i)\n      if letter == letter:upper() then\n         result = result .. letter:lower()\n\
    \      else\n         result = result .. letter:upper()\n      end\n   end\n \
    \  local letters = result:gsub('[^a-zA-Z]', '')\n   local vowels = letters:gsub('[^aeiouAEIOU]',\
    \ '')\n   local swap_map = {}\n   for i = 1, #vowels do\n      local letter =\
    \ vowels:sub(i, i)\n      swap_map[letter] = letters:sub(i + 2, i + 2)\n   end\n\
    \   local function replace(letter)\n      return swap_map[letter] or letter\n\
    \   end\n   return result:gsub('.', replace)\nend", "\treturn 'TGST'\nend", " \
    \   -- TODO\nend", end, "    local answer = ''\n    local vowels = 'aeiou'\n \
    \   local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for i = 1, #message do\n\
    \        local char = message:sub(i, i)\n        if char:find('%a') then\n   \
    \         char = char:lower()\n            if char:find('[aeiou]') then\n    \
    \            local index = (alphabet:find(char) + 2) % 26\n                if\
    \ index == 0 then\n                    index = 26\n                end\n     \
    \           char = vowels:sub(index, index)\n            end\n            if message:sub(i,\
    \ i):find('%u') then\n                char = char:upper()\n            end\n \
    \       end\n        answer = answer .. char\n    end\n    return answer\nend",
  "\tlocal encoded = {}\n\tfor i = 1, #message do\n\t\tlocal char = message:sub(i,\
    \ i)\n\t\tif char:find('[%w]') then\n\t\t\tencoded[i] = char:find('[%a]') and\
    \ \n\t\t\t\t(char:lower() == char and char:upper() or char:lower()) or\n\t\t\t\
    \t(char == 'a' and 'c' or char == 'e' and 'g' or char == 'i' and 'k' or char ==\
    \ 'o' and 'q' or char == 'u' and 'y' or char)\n\t\telse\n\t\t\tencoded[i] = char\n\
    \t\tend\n\tend\n\treturn table.concat(encoded)\nend", "    local vowelLookup =\
    \ { a = 3, e = 5, i = 7, o = 9, u = 11 }\n    local newMessage = ''\n    for i\
    \ = 1, #message do\n        local char = message:sub(i, i)\n        local charIndex\
    \ = alphabet:find(char)\n        local offset = 0\n        if vowelLookup[char]\
    \ then offset = vowelLookup[char] end\n        newMessage = newMessage .. alphabet:sub(charIndex\
    \ + offset, charIndex + offset)\n    end\n    return newMessage\nend", "    --\
    \ TODO: Implement this function\nend", "\tlocal alphabet_array = string.explode(\"\
    abcdefghijklmnopqrstuvwxyz\", \"\")\n\tlocal alphabet_string = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tlocal rev_alphabet_array = string.explode(\"zyxwvutsrqponmlkjihgfedcba\",\
    \ \"\")\n\tlocal rev_alphabet_string = \"zyxwvutsrqponmlkjihgfedcba\"\n\tlocal\
    \ vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n\tlocal replace_vowels = {}\n\t\
    -- make list of two letter ahead vowels\n\tfor k,v in pairs(vowels) do\n\t\tlocal\
    \ pos = alphabet_string:find(v)\n\t\treplace_vowels[k] = alphabet_array[pos+2]\n\
    \tend\n\t-- scramble all letters by using the reverse alphabet array\n\tlocal\
    \ rev_message = \"\"\n\tfor i=1, #message do\n\t\tlocal c = message:sub(i,i)\n\
    \t\tlocal pos = rev_alphabet_string:find(c)\n\t\tif pos ~= nil then\n\t\t\trev_message\
    \ = rev_message .. rev_alphabet_array[pos]\n\t\telse\n\t\t\trev_message = rev_message\
    \ .. c\n\t\tend\n\tend\n\t-- replace vowels with 2 letters ahead\n\tlocal new_message\
    \ = \"\"\n\tfor j=1, #rev_message do\n\t\tlocal c = rev_message:sub(j,j)\n\t\t\
    for k,v in pairs(vowels) do\n\t\t\tif c == v then\n\t\t\t\tnew_message = new_message\
    \ .. replace_vowels[k]\n\t\t\telse\n\t\t\t\tnew_message = new_message .. c\n\t\
    \t\tend\n\t\tend\n\tend\n\treturn new_message\nend", "    return message\nend",
  "    local result = ''\n    for i = 1, #message do\n        local char = message:sub(i,\
    \ i)\n        if char:lower() == 'a' then\n            result = result .. 'c'\n\
    \        elseif char:lower() == 'e' then\n            result = result .. 'g'\n\
    \        elseif char:lower() == 'i' then\n            result = result .. 'k'\n\
    \        elseif char:lower() == 'o' then\n            result = result .. 'm'\n\
    \        elseif char:lower() == 'u' then\n            result = result .. 'o'\n\
    \        elseif char:lower() == 'y' then\n            result = result .. 'a'\n\
    \        elseif char:upper() == char then\n            result = result .. char:lower()\n\
    \        else\n            result = result .. char:upper()\n        end\n    end\n\
    \    return result\nend", "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local\
    \ ret = ''\n    for i = 1, #message do\n        local c = message:sub(i, i)\n\
    \        local v = false\n        for _, vv in ipairs(vowels) do\n           \
    \ if c == vv then\n                v = true\n                break\n         \
    \   end\n        end\n        if v then\n            if c == 'u' then\n      \
    \          ret = ret .. 'a'\n            else\n                ret = ret .. string.char(string.byte(c)\
    \ + 2)\n            end\n        else\n            if c:lower() == c then\n  \
    \              ret = ret .. c:upper()\n            else\n                ret =\
    \ ret .. c:lower()\n            end\n        end\n    end\n    return ret\nend",
  "    print(\"TODO: write your solution here\")\nend", end, "  message = string.gsub(message,\
    \ '[aeiou]', function(c)\n    return string.char(string.byte(c) + 2)\n  end)\n\
    \  message = string.gsub(message, '[AEIOU]', function(c)\n    return string.char(string.byte(c)\
    \ + 2)\n  end)\n  return message\nend", "    -- Return the encoded message\n \
    \   return message\nend", "    -- implement this\nend", "    local vowels = {'a',\
    \ 'e', 'i', 'o', 'u'}\n    local new = ''\n    for i = 1, #message do\n      \
    \  local letter = message:sub(i, i)\n        if letter == letter:upper() then\n\
    \            letter = letter:lower()\n        else\n            letter = letter:upper()\n\
    \        end\n        local is_vowel = false\n        for j = 1, #vowels do\n\
    \            if letter == vowels[j] then\n                is_vowel = true\n  \
    \              if letter == 'u' then\n                    letter = 'a'\n     \
    \           else\n                    letter = string.char(letter:byte() + 2)\n\
    \                end\n            end\n        end\n        if not is_vowel then\n\
    \            new = new .. letter\n        else\n            new = new .. letter\n\
    \        end\n    end\n    return new\nend", "    -- TODO: implement this\nend",
  "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local function isVowel(char)\n\
    \        for i, v in ipairs(vowels) do\n            if v == char then\n      \
    \          return true\n            end\n        end\n        return false\n \
    \   end\n    local function getNextVowel(char)\n        local currentPos = 0\n\
    \        for i, v in ipairs(vowels) do\n            if v == char then\n      \
    \          currentPos = i\n            end\n        end\n        if currentPos\
    \ == 5 then\n            return vowels[1]\n        else\n            return vowels[currentPos\
    \ + 1]\n        end\n    end\n    local output = ''\n    for c in message:gmatch('.')\
    \ do\n        local encoded = c\n        if isVowel(c:lower()) then\n        \
    \    encoded = getNextVowel(c:lower())\n        end\n        if c:lower() == c\
    \ then\n            encoded = encoded:upper()\n        end\n        output = output\
    \ .. encoded\n    end\n    return output\nend", "    local vowels = { 'a', 'e',\
    \ 'i', 'o', 'u' }\n    return string.gsub(string.lower(message), '%a', function(character)\n\
    \        for vowelIndex, vowel in ipairs(vowels) do\n            if character\
    \ == vowel then\n                return vowels[(vowelIndex + 2) % #vowels + 1]\n\
    \            end\n        end\n        return string.char(string.byte(character)\
    \ + (string.byte(character) < 97 and -32 or 32))\n    end)\nend", "\tlocal vowels,\
    \ encoded = {'a', 'e', 'i', 'o', 'u'}, {}\n\tfor i = 1, #message do\n\t\tif string.find(vowels,\
    \ string.lower(message:sub(i, i))) then\n\t\t\tlocal n = string.byte(message:sub(i,\
    \ i))\n\t\t\tif n == string.byte('Z') or n == string.byte('z') then\n\t\t\t\t\
    table.insert(encoded, string.char(n - 25))\n\t\t\telseif n == string.byte('U')\
    \ or n == string.byte('u') then\n\t\t\t\ttable.insert(encoded, string.char(n -\
    \ 23))\n\t\t\telse\n\t\t\t\ttable.insert(encoded, string.char(n + 2))\n\t\t\t\
    end\n\t\telse\n\t\t\tlocal n = string.byte(message:sub(i, i))\n\t\t\tif string.find(string.lower(message:sub(i,\
    \ i)), vowels) then\n\t\t\t\tif n == string.byte('Z') or n == string.byte('z')\
    \ then\n\t\t\t\t\ttable.insert(encoded, string.char(n - 25))\n\t\t\t\telseif n\
    \ == string.byte('U') or n == string.byte('u') then\n\t\t\t\t\ttable.insert(encoded,\
    \ string.char(n - 23))\n\t\t\t\telse\n\t\t\t\t\ttable.insert(encoded, string.char(n\
    \ + 2))\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif n > 96 and n < 123 then\n\t\t\t\t\
    \ttable.insert(encoded, string.char(n - 32))\n\t\t\t\telseif n > 64 and n < 91\
    \ then\n\t\t\t\t\ttable.insert(encoded, string.char(n + 32))\n\t\t\t\telse\n\t\
    \t\t\t\ttable.insert(encoded, message:sub(i, i))\n\t\t\t\tend\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn table.concat(encoded)\nend", "  -- TODO: Implement me.\n\
    end", "    local vowels = { ['a'] = 1, ['e'] = 1, ['i'] = 1, ['o'] = 1, ['u']\
    \ = 1 }\n    local function swapCase(letter)\n        return letter:lower() ==\
    \ letter and letter:upper() or letter:lower()\n    end\n    local function convertVowel(letter)\n\
    \        return vowels[letter:lower()] and string.char(string.byte(letter) + 2)\
    \ or letter\n    end\n    return message:gsub('.', swapCase):gsub('.', convertVowel)\n\
    end", "\tlocal answer = \"\"\n\tfor i = 1, #message do\n\t\tlocal curr = message:sub(i,i)\n\
    \t\tlocal c = curr:lower()\n\t\tif (c >= 'a' and c <= 'z') then\n\t\t\tif (c ==\
    \ 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u') then\n\t\t\t\tlocal n =\
    \ 2\n\t\t\t\tif (c == 'z') then n = 1 end\n\t\t\t\tc = string.char(c:byte() +\
    \ n)\n\t\t\tend\n\t\t\tif (curr == curr:upper()) then c = c:upper() end\n\t\t\
    end\n\t\tanswer = answer .. c\n\tend\n\treturn answer\nend", "\tlocal vowels =\
    \ {'a', 'e', 'i', 'o', 'u'}\n\tlocal alphabet = {'a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'}\n\tlocal encodedMessage = ''\n\tfor i=1, #message do\n\t\
    \tlocal letter = message:sub(i, i)\n\t\tif letter == ' ' then\n\t\t\tencodedMessage\
    \ = encodedMessage .. ' '\n\t\telse\n\t\t\tif contains(vowels, letter) then\n\t\
    \t\t\tletter = next(alphabet, letter)\n\t\t\t\tletter = next(alphabet, letter)\n\
    \t\t\tend\n\t\t\tletter = letter:upper()\n\t\t\tencodedMessage = encodedMessage\
    \ .. letter\n\t\tend\n\tend\n\treturn encodedMessage\nend", "\tlocal alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tlocal outstr = \"\"\n\tfor i = 1, #message\
    \ do\n\t\tlocal char = message:sub(i,i)\n\t\tif char:match(\"%a\") then -- capital\
    \ or lowercase char\n\t\t\tlocal lowerchar = char:lower()\n\t\t\tlocal charvowel\
    \ = lowerchar:match(\"[aeiou]\")\n\t\t\tif charvowel then -- char is a vowel\n\
    \t\t\t\tlocal num = alphabet:find(lowerchar)\n\t\t\t\tif num+2 <= #alphabet then\n\
    \t\t\t\t\tchar = alphabet:sub(num+2,num+2)\n\t\t\t\telse\n\t\t\t\t\tchar = alphabet:sub(num+2-#alphabet,num+2-#alphabet)\n\
    \t\t\t\tend\n\t\t\telse -- char is not a vowel\n\t\t\t\tchar = lowerchar:upper()\n\
    \t\t\tend\n\t\tend\n\t\toutstr = outstr .. char\n\tend\n\treturn outstr\nend",
  "    -- TODO: write encode\nend", "  -- YOUR CODE HERE\nend", "  local e = {}\n\
    \  for i = 1, #message do\n    if message:byte(i) >= 97 and message:byte(i) <=\
    \ 122 then\n      e[i] = string.char(message:byte(i) - 32)\n    elseif message:byte(i)\
    \ >= 65 and message:byte(i) <= 90 then\n      e[i] = string.char(message:byte(i)\
    \ + 32)\n    else\n      e[i] = message:sub(i, i)\n    end\n  end\n  e = table.concat(e)\n\
    \  local m = {}\n  for i = 1, #e do\n    if e:sub(i, i) == 'a' then\n      m[i]\
    \ = 'c'\n    elseif e:sub(i, i) == 'e' then\n      m[i] = 'g'\n    elseif e:sub(i,\
    \ i) == 'i' then\n      m[i] = 'k'\n    elseif e:sub(i, i) == 'o' then\n     \
    \ m[i] = 'm'\n    elseif e:sub(i, i) == 'u' then\n      m[i] = 'p'\n    else\n\
    \      m[i] = e:sub(i, i)\n    end\n  end\n  return table.concat(m)\nend", " \
    \ return message:gsub('[a-zA-Z]', function(letter)\n    local index = string.byte(letter)\n\
    \    if index > 90 then\n      index = index - 97\n    else\n      index = index\
    \ - 65\n    end\n    local encode = index + 2\n    if encode > 25 then\n     \
    \ encode = encode - 26\n    end\n    return string.char(encode + 65)\n  end)\n\
    end", end, "    return message:gsub('%a', function(char)\n        if char:match('[aeiou]')\
    \ then\n            return char:gsub('[aeiou]', encode_vowel)\n        else\n\
    \            return char:gsub('%a', swap_case)\n        end\n    end)\nend", " \
    \ -- TODO: implement\nend", "\tmessage = string.gsub(message, '[aA]', 'c')\n\t\
    message = string.gsub(message, '[eE]', 'g')\n\tmessage = string.gsub(message,\
    \ '[iI]', 'k')\n\tmessage = string.gsub(message, '[oO]', 'm')\n\tmessage = string.gsub(message,\
    \ '[uU]', 'o')\n\tmessage = string.gsub(message, '[b-df-hj-np-tv-zB-DF-HJ-NP-TV-Z]',\
    \ string.upper)\n\treturn message\nend", "    message = message:lower()\n    local\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n    local encoded_message = ''\n    for\
    \ i = 1, #message do\n        local c = message:sub(i, i)\n        for j = 1,\
    \ #vowels do\n            if c == vowels[j] then\n                if c == 'u'\
    \ then\n                    c = 'a'\n                else\n                  \
    \  c = vowels[j + 1]\n                end\n            end\n        end\n    \
    \    encoded_message = encoded_message .. c:upper()\n    end\n    return encoded_message\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
