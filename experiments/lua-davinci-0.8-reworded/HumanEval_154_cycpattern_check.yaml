name: HumanEval_154_cycpattern_check
language: lua
prompt: "-- You are given 2 words. You need to return true if the second word or any\
  \ of its rotations is a substring in the first word\n-- >>> cycpattern_check('abcd',\
  \ 'abd')\n-- false\n-- >>> cycpattern_check('hello', 'ell')\n-- true\n-- >>> cycpattern_check('whassup',\
  \ 'psus')\n-- false\n-- >>> cycpattern_check('abab', 'baa')\n-- true\n-- >>> cycpattern_check('efef',\
  \ 'eeff')\n-- false\n-- >>> cycpattern_check('himenss', 'simen')\n-- true\nlocal\
  \ function cycpattern_check(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = cycpattern_check\n\
  \    lu.assertEquals(candidate('xyzw', 'xyw'), false)\n    lu.assertEquals(candidate('yello',\
  \ 'ell'), true)\n    lu.assertEquals(candidate('whattup', 'ptut'), false)\n    lu.assertEquals(candidate('efef',\
  \ 'fee'), true)\n    lu.assertEquals(candidate('abab', 'aabb'), false)\n    lu.assertEquals(candidate('winemtt',\
  \ 'tinem'), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local b_l = #b\n  local same = true\n  local _\n  for i = 1, #a do\n\
    \    _ = a:sub(i, i + b_l - 1)\n    if _ == b then\n      return true\n    end\n\
    \    same = true\n    for j = 1, b_l do\n      if _:sub(j, j) ~= b:sub(b_l - j\
    \ + 1, b_l - j + 1) then\n        same = false\n        break\n      end\n   \
    \ end\n    if same then\n      return true\n    end\n  end\n  return false\nend",
  "    -- Remove any characters that are in both strings\n    local b_temp = b\n \
    \   for i=1, #a do\n        b_temp = b_temp:gsub(a:sub(i,i), '')\n    end\n  \
    \  --[[if b_temp is empty then a contains at least one of every character\n  \
    \  that is in b]]\n    if #b_temp == 0 then\n        return true\n    else\n \
    \       return false\n    end\nend", "  if #a < #b then return false end\n  local\
    \ pattern_str = b..b\n  for i = 1, #b do\n    if string.find(a, pattern_str:sub(i,\
    \ i+#b-1)) then\n      return true\n    end\n  end\n  return false\nend", "  \
    \  if a:len() ~= b:len() then\n        return false\n    end\n    local first\
    \ = a:sub(1, 1)\n    local start = b:find(first)\n    if start == nil then\n \
    \       return false\n    end\n    local result = b:sub(start, b:len()) .. b:sub(1,\
    \ start - 1)\n    local result2 = b:sub(start + 1, b:len()) .. b:sub(1, start)\n\
    \    return a == result or a == result2\nend", "  local n = #a\n  local m = #b\n\
    \  if m > n then return false end\n  local a = a .. a\n  for i = 1, n do\n   \
    \ if a:sub(i, i + m - 1) == b then return true end\n  end\n  return false\nend",
  "    local a_len = string.len(a)\n    local b_len = string.len(b)\n    for i = 1,\
    \ a_len do\n        local tmp = string.sub(a, i, a_len) .. string.sub(a, 1, i\
    \ - 1)\n        if string.find(tmp, b) then\n            return true\n       \
    \ end\n    end\n    return false\nend", "\tif #a ~= #b then return false end\n\
    \tlocal b2 = b .. b\n\tfor i = 1, #b do\n\t\tif a == string.sub(b2, i, i + #b\
    \ - 1) then return true end\n\tend\n\treturn false\nend", "  local m, n = #a,\
    \ #b\n  if m ~= n then return false end\n  local p, t = 0, {[a]=true}\n  for i=1,n\
    \ do\n    local h = a:sub(i,i)\n    if b:find(h, 1, true) then\n      p = p +\
    \ 1\n      local c = a:sub(i+1) .. a:sub(1,i)\n      if not t[c] then\n      \
    \  t[c] = true\n      end\n    end\n  end\n  return p == n and t[b]\nend", " \
    \   local l = string.len(b)\n    local p = string.sub(b, 1, 1)\n    local n =\
    \ string.sub(b, l, l)\n    local d = b..b\n    local x = string.find(d, p..n)\n\
    \    local t = string.sub(d, x, x+l-1)\n    return string.find(a, t) ~= nil\n\
    end", "    -- a = abcd, b = abd\n    -- this would take b, run it through the\
    \ cycle_string function and then check\n    -- against the same from string a\n\
    \    local len_b = string.len(b)\n    local len_a = string.len(a)\n    for i =\
    \ 1, len_b do\n        local end_at = i\n        local start_at = 1\n        local\
    \ tmp_b = \"\"\n        while start_at <= len_b do\n            tmp_b = tmp_b\
    \ .. string.sub(b, end_at, end_at)\n            if end_at == len_b then\n    \
    \            end_at = 1\n            else\n                end_at = end_at + 1\n\
    \            end\n            start_at = start_at + 1\n        end\n        if\
    \ string.find(a, tmp_b) then\n            return true\n        end\n    end\n\
    \    return false\nend", "  -- body\n  if a == b then\n    return true\n  end\n\
    \  for i = 1, #a do\n    local c = a:sub(i) .. a:sub(1, i - 1)\n    if c == b\
    \ then\n      return true\n    end\n  end\n  return false\nend", "\tlocal f =\
    \ false\n\tlocal la = string.len(a)\n\tlocal lb = string.len(b)\n\tlocal r = {}\n\
    \tfor i = 1, la do\n\t\tr[i] = a:sub(i, la) .. a:sub(1, i - 1)\n\tend\n\t-- print(r)\n\
    \tfor i = 1, la do\n\t\tif (r[i]:find(b) ~= nil) then\n\t\t\tf = true\n\t\t\t\
    break\n\t\tend\n\tend\n\treturn f\nend", "    local full_rotations = a .. a\n\
    \    local pattern = string.format(\"%s\", b)\n    local i, j = string.find(full_rotations,\
    \ pattern)\n    if i and j then\n        return true\n    else\n        return\
    \ false\n    end\nend", "    local b_first = b:sub(1, 1)\n    for i = 1, #a do\n\
    \        if a:sub(i, i) == b_first then\n            local j = i\n           \
    \ local k = 1\n            while j <= #a and k <= #b and a:sub(j, j) == b:sub(k,\
    \ k) do\n                j = j + 1\n                k = k + 1\n            end\n\
    \            if k > #b then\n                return true\n            end\n  \
    \      end\n    end\n    return false\nend", "    return a:match(b) or a:match(b:sub(2)\
    \ .. b:sub(1, 1))\nend", "  local len = #b\n  local b_rot = b .. b\n  local pat\
    \ = {\n    [b] = true,\n    [string.sub(b_rot, 2, len + 1)] = true,\n    [string.sub(b_rot,\
    \ 3, len + 2)] = true,\n    [string.sub(b_rot, 4, len + 3)] = true,\n  }\n  for\
    \ i = 1, len do\n    if (string.find(a, string.sub(b_rot, i, len + i - 1)) and\
    \ pat[string.sub(b_rot, i, len + i - 1)]) then\n      return true\n    end\n \
    \ end\n  return false\nend", "\tfor i = 1, #b do\n\t\tlocal first = b:sub(1, i)\n\
    \t\tlocal last = b:sub(i+1)\n\t\tif first and last then\n\t\t\tlocal new_b = last\
    \ .. first\n\t\t\tif new_b == a then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn false\nend", "    return string.find(a, b) ~= nil or string.find(a,\
    \ b..b) ~= nil\nend", "\tlocal len_a = a:len()\n\tlocal len_b = b:len()\n\tif\
    \ len_a < len_b then\n\t\treturn false\n\tend\n\tfor i = 1, len_a do\n\t\tlocal\
    \ flag = true\n\t\tlocal c = a:sub(i, i + len_b - 1)\n\t\tfor j = 1, len_b do\n\
    \t\t\tif c:sub(j, j) ~= b:sub(j, j) then\n\t\t\t\tflag = false\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\t\tif flag then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn\
    \ false\nend", "    a = a .. a\n    return a:find(b) ~= nil\nend", "  local bs\
    \ = string.rep(b, 2)\n  return bs:find(a)\nend", "\tfor i = 1, string.len(b) do\n\
    \t\tlocal _1, _2 = string.find(a, b)\n\t\tif _1 ~= nil then\n\t\t\treturn true\n\
    \t\tend\n\t\tb = string.sub(b, 2) .. string.sub(b, 1, 1)\n\tend\n\treturn false\n\
    end", "    local len_a = a:len()\n    local len_b = b:len()\n    if len_a < len_b\
    \ then\n        return false\n    end\n    for i = 1, len_a do\n        local\
    \ substr = a:sub(i, i + len_b - 1)\n        if substr == b then\n            return\
    \ true\n        end\n    end\n    return false\nend", "  local la, lb = a:len(),\
    \ b:len()\n  if la < lb then return false end\n  for i = 1, la - lb + 1 do\n \
    \   if a:sub(i, i + lb - 1) == b then return true end\n  end\n  return false\n\
    end", "  local function shift(s)\n    return s:sub(2) .. s:sub(1, 1)\n  end\n\
    \  return a:find(b) ~= nil or cycpattern_check(a, shift(b))\nend", "  a = type(a)\
    \ == 'string' and a or ''\n  b = type(b) == 'string' and b or ''\n  local z, lz,\
    \ c = b .. b, #b, 0\n  for s, e in sfind(a, z) do\n    if c == 0 and e - s + 1\
    \ == lz then return true end\n    c = c + 1\n  end\n  return false\nend", "  local\
    \ n_a = #a\n  local n_b = #b\n  if (n_a < n_b) then\n    return false\n  end\n\
    \  local pattern = string.format('%%%d[%s]', n_b, b)\n  for i = 1, n_a do\n  \
    \  local sub_a = string.sub(a, i, i + n_b - 1)\n    if (string.match(sub_a, pattern))\
    \ then\n      return true\n    end\n  end\n  return false\nend", "  local len\
    \ = #b\n  if #a < len then return false end\n  local s = b..b\n  return s:find(a,\
    \ 1, true) ~= nil\nend", "    -- TODO\nend", "    -- Find all rotations of b\n\
    \    local rots = {}\n    local bstr = string.gsub(b, '%s', '')\n    for i = 1,\
    \ string.len(bstr) do\n        table.insert(rots, string.sub(bstr, i) .. string.sub(bstr,\
    \ 1, i - 1))\n    end\n    for _, rot in ipairs(rots) do\n        if string.find(a,\
    \ rot) then\n            return true\n        end\n    end\n    return false\n\
    end", "    return b:find(a, 1, true) ~= nil\nend", "  local slen = #b\n  for i\
    \ = 1, #a do\n    local s = a:sub(i, i + slen - 1)\n    if s == b then\n     \
    \ return true\n    end\n  end\n  return false\nend", "  if #a < #b then return\
    \ false end\n  if #a == #b then return a == b end\n  local n = #b\n  for i = 1,\
    \ #a - n + 1 do\n    if a:sub(i, i + n - 1) == b then return true end\n  end\n\
    \  return false\nend", "    if #a ~= #b then\n        return false\n    end\n\
    \    local shorter = b\n    if #a < #b then\n        shorter = a\n    end\n  \
    \  if #a == #b then\n        return a:find(b) ~= nil or a:find(b:sub(2, #b) ..\
    \ b:sub(1, 1)) ~= nil\n    end\n    return false\nend", "  -- your code goes here\n\
    \  local lenb = #b\n  for i = 1, lenb do\n    b = string.sub(b, 2) .. string.sub(b,\
    \ 1, 1)\n    if string.find(a, b) then\n      return true\n    end\n  end\n  return\
    \ false\nend", "    if not (a and b) then return false end\n    for i = 1, #b\
    \ do\n        local c = b:sub(i) .. b:sub(1, i - 1)\n        if a:find(c) then\
    \ return true end\n    end\n    return false\nend", "\tfor i = 1, #b do\n\t\t\
    local s = b:sub(i) .. b:sub(1, i - 1)\n\t\tif a:find(s) then\n\t\t\treturn true\n\
    \t\tend\n\tend\n\treturn false\nend", "  if a:len() ~= b:len() then return false\
    \ end\n  for i = 1, a:len() do\n    local x = a:sub(i, -1) .. a:sub(1, i - 1)\n\
    \    if x == b then return true end\n  end\n  return false\nend", "    local l\
    \ = #b\n    for i = 1, l do\n        if a:find(b) then\n            return true\n\
    \        end\n        b = b:sub(2) .. b:sub(1, 1)\n    end\n    return false\n\
    end", "  local a = a:lower()\n  local b = b:lower()\n  local length = string.len(b)\n\
    \  local init = string.sub(b, 1, 1)\n  local rotate = \"\"\n  for i = 2, length\
    \ do\n    rotate = string.sub(b, i, i) .. init\n    if a:find(rotate) then\n \
    \     return true\n    end\n    init = rotate\n  end\n  return false\nend", " \
    \ if (#a < #b) then\n    return false\n  end\n  if (string.find(a, b)) then\n\
    \    return true\n  end\n  local pos = string.find(a, b:sub(1, 1))\n  if (pos\
    \ == nil) then\n    return false\n  end\n  for i = 2, #b do\n    if ((pos + i\
    \ - 1) > #a) then\n      if (string.find(a, b:sub(i, i))) then\n        return\
    \ true\n      end\n    else\n      if (a:sub(pos + i - 1, pos + i - 1) ~= b:sub(i,\
    \ i)) then\n        return false\n      end\n    end\n  end\n  return true\nend",
  "\treturn b == string.sub(a, 1, #b) or\n\t\tstring.sub(a, #a - #b + 2) == b or\n\
    \t\tstring.find(a, b, 1, true) ~= nil\nend", "    if b == nil or #b == 0 then\n\
    \        return true\n    end\n    local bIndex = 1\n    for i = 1, #a do\n  \
    \      if a:sub(i, i) == b:sub(bIndex, bIndex) then\n            bIndex = bIndex\
    \ + 1\n            if bIndex > #b then\n                return true\n        \
    \    end\n        end\n    end\n    return false\nend", "  -- If the patterns\
    \ are not equal in length, they are not cyclic\n  if #a ~= #b then\n    return\
    \ false\n  end", "  for i = 1, #b do\n    local pre, post = b:sub(1, i - 1), b:sub(i)\n\
    \    if a:find(post .. pre) then\n      return true\n    end\n  end\n  return\
    \ false\nend", "    local lena, lenb = #a, #b\n    if lena ~= lenb then\n    \
    \    return false\n    end\n    if a == b then\n        return true\n    end\n\
    \    local a_table = {}\n    for i = 1, lena do\n        a_table[i] = a:sub(i,\
    \ i)\n    end\n    for i = 1, lena do\n        local shift_table = {}\n      \
    \  for j = 1, lena do\n            if i + j - 1 > lena then\n                shift_table[j]\
    \ = a_table[i + j - 1 - lena]\n            else\n                shift_table[j]\
    \ = a_table[i + j - 1]\n            end\n        end\n        if table.concat(shift_table)\
    \ == b then\n            return true\n        end\n    end\n    return false\n\
    end", "  if #a < #b then return false end\n  local a_len = #a\n  local b_len =\
    \ #b\n  local tmp_a = a\n  for i = 1, #a do\n    if tmp_a:sub(1, b_len) == b then\n\
    \      return true\n    end\n    tmp_a = tmp_a:sub(2, a_len) .. tmp_a:sub(1, 1)\n\
    \  end\n  return false\nend", "    return a:find(b:sub(2) .. b:sub(1, 1)) ~= nil\n\
    end", "  if (#a < #b) then return false end\n  a = a:gsub('(.)', '%1.'):sub(1,\
    \ -2)\n  return a:find(b) or a:find(b:reverse())\nend", "  for i = 1, #b do\n\
    \    b = b:sub(2) .. b:sub(1, 1)\n    if b == a then\n      return true\n    end\n\
    \  end\n  return false\nend", "    for i = 1, #b do\n        local buf = {}\n\
    \        for j = 1, #b do\n            buf[j] = b:sub(j, j)\n        end\n   \
    \     table.remove(buf, 1)\n        table.insert(buf, b:sub(1, 1))\n        b\
    \ = table.concat(buf)\n        if a:find(b) then\n            return true\n  \
    \      end\n    end\n    return false\nend", "    for _, rotation in ipairs(rotations(b))\
    \ do\n        if a:find(rotation) then\n            return true\n        end\n\
    \    end\n    return false\nend", "    if #a < #b then\n        return false\n\
    \    end\n    local j = 1\n    local t = {}\n    for i = 1, #b do\n        t[i]\
    \ = b:sub(i, i)\n    end\n    local ch = t[1]\n    for i = 1, #b do\n        if\
    \ ch == t[i] then\n            j = i\n            break\n        end\n    end\n\
    \    table.remove(t, j)\n    local cycle = table.concat(t)\n    local full = b\
    \ .. cycle\n    if full:match(a) then\n        return true\n    end\n    return\
    \ false\nend", "    local n, n1 = string.len(a), string.len(b)\n    if n < n1\
    \ then return false end\n    local w1, w2 = string.sub(a, 1, n1), string.sub(a,\
    \ n1 + 1, n)\n    if w1 == b or w2 == b then return true end\n    return string.find(a,\
    \ w1) or string.find(a, w2)\nend", "  -- put your code here\n  local a_len = #a\n\
    \  local b_len = #b\n  if a_len < b_len then\n    return false\n  end\n  for i\
    \ = 1, b_len do\n    local found = true\n    for j = 1, b_len do\n      if b:sub(j,\
    \ j) ~= a:sub(i, i) then\n        found = false\n        break\n      end\n  \
    \    i = i + 1\n      if i > a_len then\n        i = 1\n      end\n    end\n \
    \   if found then\n      return true\n    end\n  end\n  return false\nend", "\t\
    b = b .. b\n\treturn b:find(a)\nend", "\tif #a < #b then return false end\n\t\
    if #a == #b then return a == b end\n\tlocal a_len = #a\n\tlocal b_len = #b\n\t\
    local start = a:find(b, 1, true)\n\tif start then return true end\n\tfor i = 1,\
    \ a_len - b_len do\n\t\tlocal b_rot = b:sub(i, a_len) .. b:sub(1, i - 1)\n\t\t\
    local start = a:find(b_rot, 1, true)\n\t\tif start then return true end\n\tend\n\
    \treturn false\nend", "  -- TODO: Implement this function\n  --[[\n  if (string.len(a)\
    \ < string.len(b)) then\n    return false\n  end\n  local la = string.len(a)\n\
    \  local lb = string.len(b)\n  local c = (la - lb) + 1\n  local i = 1\n  while\
    \ (i <= c) do\n    local sub = string.sub(a, i, i + lb - 1)\n    if (string.find(sub,\
    \ b) ~= nil) then\n      return true\n    end\n    i = i + 1\n  end\n  return\
    \ false\n  --]]\n  return (string.find(a, b) ~= nil) or cycpattern_check(string.sub(a,\
    \ 2, -1) .. string.sub(a, 1, 1), b)\nend", "    if string.len(a) == 0 or string.len(b)\
    \ == 0 then\n        return false\n    end\n    if string.len(a) == string.len(b)\
    \ then\n        return a ~= b\n    end\n    if string.len(a) < string.len(b) then\n\
    \        return false\n    end\n    local index = string.find(a, b)\n    if index\
    \ then\n        return true\n    end\n    local new_a = ''\n    for i = 2, string.len(a)\
    \ do\n        new_a = new_a .. string.sub(a, i, i)\n    end\n    new_a = new_a\
    \ .. string.sub(a, 1, 1)\n    return cycpattern_check(new_a, b)\nend", "  if (string.find(a,\
    \ b) ~= nil) then\n    return true\n  end\n  for i = 2, #b do\n    local c = string.sub(b,\
    \ i) .. string.sub(b, 1, i - 1)\n    if (string.find(a, c) ~= nil) then\n    \
    \  return true\n    end\n  end\n  return false\nend", "    for _, char in pairs({\
    \ utf8.codepoint(a, 1, -1) }) do\n        table.insert(a, table.remove(a, 1))\n\
    \        if table.concat(a) == b then\n            return true\n        end\n\
    \    end\n    return false\nend", "    local c = string.sub(a, 1, -2)\n    if\
    \ (string.find(a, b) ~= nil) then\n        return true\n    elseif (string.find(a,\
    \ c) ~= nil) then\n        return true\n    else\n        return false\n    end\n\
    end", "    local a_len = #a\n    local b_len = #b\n    local pattern_a = a\n \
    \   local pattern_b = b\n    local pattern_b_len = b_len\n    local pattern_b_rotation\
    \ = b\n    local pattern_b_rotation_len = b_len\n    local num_rotations = 0\n\
    \    -- Prepare the pattern to be searched\n    while num_rotations < b_len do\n\
    \        -- Patterns are the same\n        if string.match(pattern_a, pattern_b)\
    \ then\n            return true\n        end\n        -- Get the next rotation\
    \ of pattern b\n        pattern_b_rotation = string.sub(pattern_b_rotation, 2,\
    \ b_len) .. string.sub(pattern_b_rotation, 1, 1)\n        -- Patterns are the\
    \ same\n        if string.match(pattern_a, pattern_b_rotation) then\n        \
    \    return true\n        end\n        num_rotations = num_rotations + 1\n   \
    \ end\n    return false\nend", "    local function ror(a, b)\n        return string.sub(a,\
    \ b+1) .. string.sub(a, 1, b)\n    end\n    if #a < #b then return false end\n\
    \    for i = 1, #a - #b + 1 do\n        local count = 0\n        for j = 1, #b\
    \ do\n            if string.sub(a, i+j-1, i+j-1) == string.sub(b, j, j) then\n\
    \                count = count + 1\n            end\n        end\n        if count\
    \ == #b then return true end\n    end\n    for i = 2, #b - 1 do\n        if string.find(a,\
    \ ror(b, i)) then return true end\n    end\n    return false\nend", "    local\
    \ lenA = #a\n    local lenB = #b\n    local lastI = lenA - lenB\n    local firstB\
    \ = b:sub(1, 1)\n    local lastB = b:sub(lenB, lenB)\n    for i = 1, lastI do\n\
    \        if a:sub(i, i) == firstB then\n            if a:sub(i, i + lenB - 1)\
    \ == b then\n                return true\n            end\n        end\n    end\n\
    \    for i = 1, lastI do\n        if a:sub(i, i) == lastB then\n            if\
    \ a:sub(i, i + lenB - 1) == b:sub(2, lenB) .. b:sub(1, 1) then\n             \
    \   return true\n            end\n        end\n    end\n    return false\nend",
  "    --\n    -- ## IMPLEMENT THIS FUNCTION ##\n    --", "    if a:len() ~= b:len()\
    \ then\n        return false\n    end\n    for k = 1, b:len() do\n        if a:find(b:sub(k,\
    \ b:len()) .. b:sub(1, k - 1)) then\n            return true\n        end\n  \
    \  end\n    return false\nend", "    local n = #a\n    for i = 1, n do\n     \
    \   if a:sub(i, n) .. a:sub(1, i - 1) == b then\n            return true\n   \
    \     end\n    end\n    return false\nend", "    local i = 1\n    while i <= #a\
    \ do\n        if string.sub(a, i, i + #b - 1) == b then\n            return true\n\
    \        end\n        local p = i\n        while p <= #a do\n            if string.sub(a,\
    \ p, p) == string.sub(a, i, i) then\n                i = p\n                break\n\
    \            end\n            p = p + 1\n        end\n        i = i + 1\n    end\n\
    \    return false\nend", "  -- write a function to check if second word is a rotation\
    \ of the first\n  for i = 1, #a do\n    local sub = a:sub(i, #a) .. a:sub(1, i\
    \ - 1)\n    if sub == b then\n      return true\n    end\n  end\n  return false\n\
    end", "  -- implementation here\nend", "    local n = #a\n    local m = #b\n \
    \   if m > n then\n        return false\n    end\n    local i = 1\n    while i\
    \ <= n do\n        if a:sub(i, i + m - 1) == b then\n            return true\n\
    \        end\n        i = i + 1\n    end\n    return false\nend", "    local c\
    \ = b .. b\n    return c:find(a) ~= nil\nend", "    if #a < #b then\n        return\
    \ false\n    end\n    local rotations = {}\n    for i = 1, #b do\n        local\
    \ start = i\n        local endx = #b\n        local part1 = b:sub(start, endx)\n\
    \        local part2 = b:sub(1, start - 1)\n        table.insert(rotations, part1\
    \ .. part2)\n    end\n    if table.contains(rotations, a) then\n        return\
    \ true\n    end\n    return false\nend", "    -- define all possible rotations\
    \ of the second word\n    local rotations = {}\n    for i = 1, #b do\n       \
    \ table.insert(rotations, b:sub(i) .. b:sub(1, i - 1))\n    end\n    -- check\
    \ if any of them are in the first word\n    for _, rotation in ipairs(rotations)\
    \ do\n        if a:find(rotation) then\n            return true\n        end\n\
    \    end\n    return false\nend", "    return string.find(a, b)\nend", "  local\
    \ n, m = #a, #b\n  if n ~= m then return false end\n  if n == 0 then return true\
    \ end\n  local nb = b..b\n  local patt = \"(.*)\"..string.sub(nb, 2, nb:len())..\"\
    (.*)\"\n  return not not string.match(a, patt)\nend", "  local i = 1\n  while\
    \ b:sub(i, i) ~= a:sub(1, 1) do\n    i = i + 1\n  end\n  if b:sub(i) .. b:sub(1,\
    \ i - 1) == a then\n    return true\n  end\n  return false\nend", "    local b\
    \ = #b\n    local a = #a", "    if #a < #b then\n        return false\n    end\n\
    \    if a:find(b) then\n        return true\n    end\n    for i = 1, #b do\n \
    \       b = b:sub(2) .. b:sub(1, 1)\n        if a:find(b) then\n            return\
    \ true\n        end\n    end\n    return false\nend", "    a = tostring(a)\n \
    \   b = tostring(b)\n    local n = a:len()\n    local m = b:len()\n    if n <\
    \ m then\n        return false\n    end\n    local l = 1\n    local r = l + m\
    \ - 1\n    while l <= n do\n        local sub = a:sub(l, r)\n        if sub ==\
    \ b then\n            return true\n        end\n        l = l + 1\n        r =\
    \ r + 1\n        if r > n then\n            r = 1\n        end\n    end\n    return\
    \ false\nend", "  -- TODO: Program me\nend", "\tlocal cyc_str = string.format('%s%s',\
    \ a, a)\n\tif string.find(cyc_str, b) then\n\t\treturn true\n\tend\n\treturn false\n\
    end", "  local a, b = a:lower(), b:lower()\n  if #a < #b then return false end\n\
    \  local x = a:find(b, 1, true)\n  if x then return true end\n  return cycpattern_check(a:sub(2)\
    \ .. a:sub(1, 1), b)\nend", "  if type(a) ~= 'string' or type(b) ~= 'string' then\n\
    \    return false\n  end\n  for i = 1, #b do\n    if string.sub(b, i) .. string.sub(b,\
    \ 1, i - 1) == a then\n      return true\n    end\n  end\n  return false\nend",
  "    -- your code here\nend", "    -- code here\n    local flag = false\n    local\
    \ lenA = #a\n    local lenB = #b\n    local pivot = -1\n    for i = 1, lenA do\n\
    \        if a:sub(i, i) == b:sub(1, 1) then\n            pivot = i\n         \
    \   break\n        end\n    end\n    if pivot ~= -1 then\n        local cnt =\
    \ 0\n        for i = 1, lenB do\n            if a:sub(pivot, pivot) == b:sub(i,\
    \ i) then\n                pivot = pivot + 1\n                if pivot > lenA\
    \ then\n                    pivot = 1\n                end\n                cnt\
    \ = cnt + 1\n            else\n                break\n            end\n      \
    \  end\n        if cnt == lenB then\n            flag = true\n        end\n  \
    \  end\n    return flag\nend", "  return false\nend", "  local la, lb = #a, #b\n\
    \  if lb > la then return false end\n  if la == lb then return a == b end\n  local\
    \ memo = {}\n  local function concat(t)\n    local s = {}\n    for _, v in ipairs(t)\
    \ do\n      s[#s+1] = v\n    end\n    return table.concat(s)\n  end\n  local function\
    \ rotations(word)\n    if memo[word] then return memo[word] end\n    local chars\
    \ = {}\n    for i = 1, #word do\n      chars[i] = word:sub(i, i)\n    end\n  \
    \  local rot = {}\n    for i = 1, #word do\n      table.insert(rot, concat({table.unpack(chars,\
    \ i), table.unpack(chars, 1, i-1)}))\n    end\n    memo[word] = rot\n    return\
    \ rot\n  end\n  return table.index(rotations(b), a)\nend", "    local len = string.len(b)\n\
    \    local str = b .. b\n    return string.find(str, a)\nend", "    -- TODO: Implement\
    \ a function\n    -- that returns true if the second\n    -- word or any of its\
    \ rotations is\n    -- a substring in the first word.\n    -- If not, it returns\
    \ false.\n    --\n    -- To test the program, call it from\n    -- the terminal\
    \ with arguments\n    -- `lua q2.lua abcd abd`\n    -- `lua q2.lua hello ell`\n\
    \    -- `lua q2.lua whassup psus`\n    -- `lua q2.lua abab baa`\n    -- `lua q2.lua\
    \ efef eeff`\n    -- `lua q2.lua himenss simen`\n    --\n    -- The function should\
    \ return false\n    -- only for the first two cases.\n    --\n    -- Note: Make\
    \ sure that the program\n    -- has no syntax errors by running:\n    -- `lua\
    \ -c q2.lua`\n    --\n    -- Hint: Try to use the following\n    -- string methods:\n\
    \    -- string.find\n    -- string.sub\n    -- string.len\n    -- string.gsub\n\
    \    -- table.insert\n    -- table.concat\n    --\n    -- And try to make use\
    \ of rotations!\nend", "\t-- copy a\n\tlocal acopy = a\n\t-- for each item in\
    \ a, leftshift and check if it contains b\n\t-- if the rotation does not contain\
    \ b, continue shifting, otherwise return true\n\tfor i=1, #a do\n\t\ta = a:sub(2)\
    \ .. a:sub(1, 1)\n\t\tif a:find(b) then\n\t\t\treturn true\n\t\tend\n\tend\n\t\
    return false\nend", "\tlocal len_a = #a\n\tlocal len_b = #b\n\tif len_a < len_b\
    \ then\n\t\treturn false\n\tend\n\tlocal cycle = {}\n\tfor i = 1, len_b do\n\t\
    \tlocal letter = string.sub(b, i, i)\n\t\ttable.insert(cycle, letter)\n\tend\n\
    \tfor i = 1, len_b do\n\t\tlocal pattern = table.concat(cycle)\n\t\tif string.find(a,\
    \ pattern) then\n\t\t\treturn true\n\t\tend\n\t\ttable.insert(cycle, table.remove(cycle,\
    \ 1))\n\tend\n\treturn false\nend", "  local function rotated(text, n)\n    return\
    \ text:sub(n + 1) .. text:sub(1, n)\n  end\n  for i = 1, #b do\n    if a:find(rotated(b,\
    \ i)) then\n      return true\n    end\n  end\n  return false\nend", "  a = string.gsub(a,\
    \ b, '')\n  local c = string.format(\"%s%s\", b, b)\n  local matches = string.gsub(c,\
    \ a, '')\n  if matches == c then\n    return false\n  else\n    return true\n\
    \  end\nend", "  local function _cycpattern_check(a, b)\n    if #a < #b then return\
    \ false end\n    local i = string.find(a, b)\n    if i == nil then return false\
    \ end\n    return true\n  end\n  return _cycpattern_check(a, b) or _cycpattern_check(a,\
    \ string.sub(b, 2) .. string.sub(b, 1, 1))\nend", "\tlocal n = #a\n\tlocal m =\
    \ #b\n\tfor i = 1, n do\n\t\tif a:sub(i, i + m - 1) == b then\n\t\t\treturn true\n\
    \t\tend\n\tend\n\treturn false\nend", "  -- YOUR CODE HERE\n  return true\nend",
  "  if #a < #b then return false end\n  local pattern = a .. a\n  return pattern:find(b)\
    \ ~= nil\nend", "\t-- Your code goes here\n\t-- use str_rotate function defined\
    \ earlier\n\t-- make sure your code is not repeating the rotation more than once\n\
    \t-- cycpattern_check('abcd', 'abd')\n\t-- false\n\t-- cycpattern_check('hello',\
    \ 'ell')\n\t-- true\n\t-- cycpattern_check('whassup', 'psus')\n\t-- false\n\t\
    -- cycpattern_check('abab', 'baa')\n\t-- true\n\t-- cycpattern_check('efef', 'eeff')\n\
    \t-- false\n\t-- cycpattern_check('himenss', 'simen')\n\t-- true\n\tif #a < #b\
    \ then\n\t\treturn false\n\tend\n\tif string.find(a, b) then\n\t\treturn true\n\
    \tend\n\tfor i = 2, #b do\n\t\tlocal b_rotated = str_rotate(b, i)\n\t\tif string.find(a,\
    \ b_rotated) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", " \
    \ if a:len() < b:len() then return false end\n  if b:len() == 1 then return true\
    \ end\n  local b_bak = b\n  b = b:sub(2, b:len())\n  b = b .. b_bak:sub(1, 1)\n\
    \  local idx = a:find(b)\n  if idx == nil then\n    return cycpattern_check(a,\
    \ b)\n  else\n    return true\n  end\nend", "\treturn a:find(b) or a:find(b:sub(2)\
    \ .. b:sub(1, 1))\nend", "    local len = #b\n    if len < 2 then return a:find(b)\
    \ end\n    local function rotate(string)\n        local str = string:sub(2) ..\
    \ string:sub(1, 1)\n        return str\n    end\n    local c = b\n    while len\
    \ > 0 do\n        c = rotate(c)\n        if a:find(c) then return true end\n \
    \       len = len - 1\n    end\n    return false\nend", end, "    -- TODO: implement\
    \ this function\n    -- Hint: you can use string.find, string.sub and string.len\n\
    \    -- to make this problem much easier\n    -- see: http://www.lua.org/manual/5.1/manual.html#pdf-string.find\n\
    \    -- see: http://www.lua.org/manual/5.1/manual.html#pdf-string.sub\n    --\
    \ see: http://www.lua.org/manual/5.1/manual.html#pdf-string.len\n    -- What you\
    \ need to do is simply to find the pattern in the string", "    return false\n\
    end", "  if #a < #b then return false end\n  local o = a\n  local c = #a\n  while\
    \ not string.find(a, b) do\n    a = a:sub(2, c) .. a:sub(1, 1)\n    if a == o\
    \ then return false end\n  end\n  return true\nend", "    a = ' ' .. a\n    b\
    \ = ' ' .. b\n    local len_a = #a\n    local len_b = #b\n    local lps = {}\n\
    \    local j = 0\n    lps[1] = 0\n    for i = 2, len_b do\n        while j > 0\
    \ and b:sub(j + 1, j + 1) ~= b:sub(i, i) do\n            j = lps[j]\n        end\n\
    \        if b:sub(j + 1, j + 1) == b:sub(i, i) then\n            j = j + 1\n \
    \       end\n        lps[i] = j\n    end\n    j = 0\n    for i = 1, len_a do\n\
    \        while j > 0 and b:sub(j + 1, j + 1) ~= a:sub(i, i) do\n            j\
    \ = lps[j]\n        end\n        if b:sub(j + 1, j + 1) == a:sub(i, i) then\n\
    \            j = j + 1\n        end\n        if j == len_b - 1 then\n        \
    \    return true\n        end\n    end\n    return false\nend", "    local b_len\
    \ = #b\n    local a_len = #a\n    local temp = b .. b\n    if a_len >= b_len then\n\
    \        if temp:find(a) then\n            return true\n        else\n       \
    \     return false\n        end\n    else\n        return false\n    end\nend",
  "    local len = #b\n    local len2 = len*2\n    return string.match(a,b) or string.match(a,b:sub(len2-1)..b:sub(1,len-1))\n\
    end", "  if #a == 0 or #b == 0 then return false end\n  local function _is_cyc_rotation(x,\
    \ y)\n    if #x < #y then return false end\n    local b_idx = 1\n    for i = 1,\
    \ #x do\n      if b_idx > #y then return true end\n      if x:sub(i, i) == y:sub(b_idx,\
    \ b_idx) then\n        b_idx = b_idx + 1\n      end\n    end\n    return false\n\
    \  end\n  for i = 1, #b do\n    local shift = b:sub(i) .. b:sub(1, i - 1)\n  \
    \  if shift == b then break end\n    if _is_cyc_rotation(a, shift) then return\
    \ true end\n  end\n  return false\nend", "  local n = string.len(a)\n  local m\
    \ = string.len(b)\n  if n == 0 or m == 0 then return false end\n  if n == m then\
    \ return string.find(a, b) end\n  if n < m then return false end\n  for i = 1,\
    \ n do\n    local substr = string.sub(a, i, i + m - 1)\n    if string.find(substr,\
    \ b) then return true end\n  end\n  return false\nend", "    return string.find(a,\
    \ b) ~= nil or string.find(a, string.sub(b, 2) .. string.sub(b, 1, 1)) ~= nil\n\
    end", "    local s = b .. b\n    return string.find(s, a) ~= nil\nend", "  local\
    \ i, j, k = 1, 1, 1\n  while i <= #a do\n    if a:sub(i, i) == b:sub(j, j) then\n\
    \      i = i + 1\n      j = j + 1\n      if j > #b then\n        j = 1\n     \
    \ end\n    else\n      k = k + 1\n      if k > #b then\n        return false\n\
    \      end\n      i = k\n      j = 1\n    end\n  end\n  return true\nend", " \
    \   return a:find(b) ~= nil or a:find(b:sub(2) .. b:sub(1, 1)) ~= nil\nend", " \
    \ local bool = false\n  for i = 1, #b do\n    if i == 1 then bool = a:match(b:sub(i)\
    \ .. b:sub(1, #b - 1)) else\n      bool = a:match(b:sub(i) .. b:sub(1, i - 1))\n\
    \    end\n    if bool then break end\n  end\n  return bool\nend", "  if a == ''\
    \ or b == '' then return false end\n  local n = #b\n  local x = b .. b\n  for\
    \ i = 1, #b do\n    if string.sub(x, i, i + n - 1) == a then return true end\n\
    \  end\n  return false\nend", "    local m, n = #a, #b\n    local function pattern_match(idx)\n\
    \        local i = idx\n        for j = 1, n do\n            if b:sub(j, j) ~=\
    \ a:sub(i, i) then\n                return false\n            end\n          \
    \  i = i + 1\n            if i > m then\n                i = 1\n            end\n\
    \        end\n        return true\n    end\n    for i = 1, m do\n        if pattern_match(i)\
    \ then\n            return true\n        end\n    end\n    return false\nend",
  "  -- your code goes here\nend", "  local rotated = b\n  for _ = 1, string.len(b)\
    \ do\n    if a:find(rotated) then\n      return true\n    end\n    rotated = rotated:sub(2)\
    \ .. rotated:sub(1, 1)\n  end\n  return false\nend", "    if #a ~= #b then\n \
    \       return false\n    end\n    local new_b = b\n    local num_shift = 0\n\
    \    while num_shift < #b do\n        if string.find(a, new_b) then\n        \
    \    return true\n        end\n        new_b = new_b:sub(2) .. new_b:sub(1, 1)\n\
    \        num_shift = num_shift + 1\n    end\n    return false\nend", "  local\
    \ a_len = #a\n  local b_len = #b\n  if a_len ~= b_len then\n    return false\n\
    \  end\n  local concat = a .. a\n  local found = string.find(concat, b)\n  return\
    \ found and true or false\nend", "\tlocal a_len = #a\n\tlocal b_len = #b\n\tif\
    \ a_len < b_len then\n\t\treturn false\n\tend\n\tfor i = 1, a_len - b_len + 1\
    \ do\n\t\tlocal j = 1\n\t\twhile j <= b_len and a:sub(i + j - 1, i + j - 1) ==\
    \ b:sub(j, j) do\n\t\t\tj = j + 1\n\t\tend\n\t\tif j > b_len then\n\t\t\treturn\
    \ true\n\t\tend\n\tend\n\treturn false\nend", "\tif a:len() < b:len() then\n\t\
    \treturn false\n\tend\n\tlocal n = b:len()\n\tlocal m = a:len()\n\tlocal ptn =\
    \ b..b\n\tlocal j = 1\n\tfor i = 1, m-n+1 do\n\t\tif a:sub(i, i+n-1) == b then\n\
    \t\t\treturn true\n\t\tend\n\t\tj = j+1\n\tend\n\treturn false\nend", "  local\
    \ len = b:len()\n  local c = b .. b\n  return c:find(a) ~= nil\nend", "    local\
    \ n = #a\n    local m = #b\n    local len = math.max(n, m)\n    local i = 1\n\
    \    local j = 1\n    local c = 0\n    local same = 0\n    local ci = 0\n    while\
    \ i <= len do\n        if a:sub(i, i) == b:sub(j, j) then\n            same =\
    \ same + 1\n            ci = c\n        else\n            same = 0\n         \
    \   ci = c\n        end\n        if same == m then\n            return true\n\
    \        end\n        c = c + 1\n        if i >= n then\n            i = 1\n \
    \       else\n            i = i + 1\n        end\n        if j >= m then\n   \
    \         j = 1\n        else\n            j = j + 1\n        end\n    end\n \
    \   return false\nend", "  local n = #a\n  local m = #b\n  local c = 1\n  local\
    \ match = string.sub(a, 1, m) == b\n  local i = 1\n  local l = 0\n  if match then\
    \ return true end\n  for i = 1, m do\n    l = l + 1\n    if string.sub(a, l, l)\
    \ == string.sub(b, c, c) then\n      c = c + 1\n    else\n      l = 1\n      c\
    \ = 1\n    end\n    if c == m + 1 then return true end\n  end\n  return false\n\
    end", "  local function does_match(a, b)\n    for i = 1, #a do\n      if a:sub(i,\
    \ i + #b - 1) == b then\n        return true\n      end\n    end\n    return false\n\
    \  end\n  local b_cyc = b .. b\n  return does_match(a, b) or does_match(a, b_cyc)\n\
    end", "    -- Your code here\n    local b1 = b\n    local len = #b\n    while\
    \ len > 0 do\n        if string.find(a, b1) then\n            return true\n  \
    \      end\n        b1 = string.sub(b1, 2)..string.sub(b1, 1, 1)\n        len\
    \ = len - 1\n    end\n    return false\nend", "  -- Write your code here\n  local\
    \ n = #a\n  local cycled_string = a..a\n  local sub_strings = {}\n  for i = 1,\
    \ n do\n    local k = i\n    local str = \"\"\n    for j = 1, n do\n      str\
    \ = str..cycled_string:sub(k, k)\n      k = k + 1\n    end\n    sub_strings[i]\
    \ = str\n  end\n  for i = 1, #sub_strings do\n    if sub_strings[i] == b then\n\
    \      return true\n    end\n  end\n  return false\nend", "    return sub(a, 1,\
    \ -1-len(b)) .. b:sub(1, 1) == a or cycpattern_check(a, sub(b, 2) .. sub(b, 1,\
    \ 1))\nend", "  -- implement me\nend", "    local str1 = a\n    local str2 = b\n\
    \    local len1 = #str1\n    local len2 = #str2\n    local j = 0\n    local k\
    \ = 0\n    if len1 < len2 then\n        return false\n    end\n    for i = 1,\
    \ len1 do\n        if string.sub(str1, i, i) == string.sub(str2, j + 1, j + 1)\
    \ then\n            j = j + 1\n            if j == len2 then\n               \
    \ return true\n            end\n        else\n            j = 0\n        end\n\
    \    end\n    return false\nend", "    if #a > #b then\n        return false\n\
    \    end\n    for i = 1, #b do\n        local start = b:sub(i)\n        local\
    \ endb = b:sub(1, i - 1)\n        local temp = start .. endb\n        if temp\
    \ == a then\n            return true\n        end\n    end\n    return false\n\
    end", "  local b_len = string.len(b)\n  local b_first = string.sub(b, 1, 1)\n\
    \  local index = string.find(a, b_first)\n  if (not index) then\n    return false\n\
    \  end\n  while (index <= string.len(a)) do\n    if (string.sub(a, index, index\
    \ + b_len - 1) == b) then\n      return true\n    end\n    index = index + 1\n\
    \  end\n  return false\nend", "    if (#a < #b) then\n        return false\n \
    \   end\n    a = a .. a\n    if (a:find(b)) then\n        return true\n    end\n\
    \    return false\nend", "  local n = #a\n  local m = #b\n  if n < m then return\
    \ false end\n  local perm = {}\n  for i = 1, n do\n    table.insert(perm, 1, a:sub(n\
    \ - i + 1, n - i + 1))\n    local p = table.concat(perm)\n    if p:find(b) then\
    \ return true end\n  end\n  return false\nend", "    if a == b then\n        return\
    \ true\n    end\n    local len_a = a:len()\n    local len_b = b:len()\n    if\
    \ len_a == len_b then\n        local s = a .. a\n        return s:find(b) ~= nil\n\
    \    elseif len_a > len_b then\n        return a:find(b) ~= nil\n    else\n  \
    \      local s = b .. b\n        return s:find(a) ~= nil\n    end\nend", "   \
    \ -- get the length of the first string\n    local alen = #a\n    -- get the length\
    \ of the second string\n    local blen = #b\n    -- if the lengths of the strings\
    \ are not equal then they cannot be rotations of each other\n    if alen ~= blen\
    \ then\n        return false\n    end\n    -- create a temp variable to store\
    \ the string\n    local temp = a\n    -- concatenate it with itself and store\
    \ it in the same variable\n    temp = temp .. temp\n    -- return the result of\
    \ matching the pattern with the result of concatenating the first string twice\n\
    \    return temp:match(b) ~= nil\nend", "\tif #a == #b then\n\t\treturn string.find(a,\
    \ b) or string.find(a, string.sub(b, 2, #b) .. string.sub(b, 1, 1))\n\telse\n\t\
    \treturn false\n\tend\nend", "  for i = 1, #b do\n    if string.find(a, b, 1,\
    \ true) then\n      return true\n    end\n    b = string.sub(b, 2) .. string.sub(b,\
    \ 1, 1)\n  end\n  return false\nend", "    -- Implement cycpattern_check here\n\
    \    local len_a = #a\n    local len_b = #b\n    local letter_dict = {}\n    for\
    \ i = 1, len_a do\n        letter_dict[a:sub(i, i)] = 1\n    end\n    for i =\
    \ 1, len_b do\n        if letter_dict[b:sub(i, i)] == nil then\n            return\
    \ false\n        end\n    end\n    local shifted_index\n    for i = 1, len_b do\n\
    \        shifted_index = i\n        while true do\n            if a:sub(shifted_index,\
    \ shifted_index) == b:sub(1, 1) then\n                break\n            end\n\
    \            shifted_index = shifted_index + 1\n            if shifted_index >\
    \ len_a then\n                shifted_index = 1\n            end\n        end\n\
    \        local flag = true\n        for j = 1, len_b do\n            if a:sub(shifted_index,\
    \ shifted_index) ~= b:sub(j, j) then\n                flag = false\n         \
    \       break\n            end\n            shifted_index = shifted_index + 1\n\
    \            if shifted_index > len_a then\n                shifted_index = 1\n\
    \            end\n        end\n        if flag then\n            return true\n\
    \        end\n    end\n    return false\nend", "\tlocal c = string.sub(a, 1, 1)\n\
    \tlocal d = string.sub(a, 2)\n\tlocal v = string.find(d, b)\n\tlocal e = string.sub(a,\
    \ 2) .. c\n\tlocal f = string.find(e, b)\n\twhile e ~= a do\n\t\tif v ~= nil or\
    \ f ~= nil then\n\t\t\treturn true\n\t\tend\n\t\tc = string.sub(e, 1, 1)\n\t\t\
    d = string.sub(e, 2)\n\t\tv = string.find(d, b)\n\t\te = string.sub(e, 2) .. c\n\
    \t\tf = string.find(e, b)\n\tend\n\treturn false\nend", "  local n = string.len(a)\n\
    \  local pattern = string.sub(a, 1, n-1)\n  local suffix = string.sub(a, n, n)\n\
    \  return string.find(pattern, b) or string.find(pattern, suffix..b)\nend", " \
    \ --\n  -- Your code goes here.\n  --\nend", "  local l = a:len()\n  return b:sub(1,l)\
    \ == a or\n         b:sub(1,l) == string.sub(a, 2)..string.sub(a, 1, 1) or\n \
    \        b:sub(1,l) == string.sub(a, l-1)..string.sub(a, 1, 2) or\n         b:sub(1,l)\
    \ == string.sub(a, l)..string.sub(a, 1, 3) or\n         b:sub(1,l) == string.sub(a,\
    \ l-2)..string.sub(a, 1, 4) or\n         b:sub(1,l) == string.sub(a, l-1)..string.sub(a,\
    \ 1, 5) or\n         b:sub(1,l) == string.sub(a, l)..string.sub(a, 1, 6) or\n\
    \         b:sub(1,l) == string.sub(a, l-3)..string.sub(a, 1, 7) or\n         b:sub(1,l)\
    \ == string.sub(a, l-2)..string.sub(a, 1, 8) or\n         b:sub(1,l) == string.sub(a,\
    \ l-1)..string.sub(a, 1, 9) or\n         b:sub(1,l) == string.sub(a, l)..string.sub(a,\
    \ 1, 10) or\n         b:sub(1,l) == string.sub(a, l-4)..string.sub(a, 1, 11) or\n\
    \         b:sub(1,l) == string.sub(a, l-3)..string.sub(a, 1, 12) or\n        \
    \ b:sub(1,l) == string.sub(a, l-2)..string.sub(a, 1, 13) or\n         b:sub(1,l)\
    \ == string.sub(a, l-1)..string.sub(a, 1, 14) or\n         b:sub(1,l) == string.sub(a,\
    \ l)..string.sub(a, 1, 15) or\n         b:", "    local a_len = #a\n    local\
    \ b_len = #b\n    local first_char = b:sub(1, 1)\n    local start = 0\n    local\
    \ matched = 0\n    for i = 1, a_len do\n        local char = a:sub(i, i)\n   \
    \     if char == first_char then\n            start = i\n            matched =\
    \ 1\n            break\n        end\n    end\n    if start == 0 then\n       \
    \ return false\n    end\n    local index = start + 1\n    for i = 2, b_len do\n\
    \        local char = b:sub(i, i)\n        if index > a_len then\n           \
    \ index = 1\n        end\n        if char == a:sub(index, index) then\n      \
    \      matched = matched + 1\n        else\n            break\n        end\n \
    \       index = index + 1\n    end\n    if matched == b_len then\n        return\
    \ true\n    end\n    return false\nend", "\tlocal len = #b\n\tif len == 0 then\
    \ return true end\n\tif len == 1 then return a:find(b) ~= nil end\n\tfor i = 0,\
    \ len - 1 do\n\t\tlocal patt = b:sub(i + 1) .. b:sub(1, i)\n\t\tif a:find(patt)\
    \ ~= nil then return true end\n\tend\n\treturn false\nend", "  if (#a < #b) then\
    \ return false end\n  local ref = b\n  local t = 1\n  local i, limit = 1, #a\n\
    \  while t <= limit do\n    local s = string.sub(a, i, i + (#b) - 1)\n    if s\
    \ == ref then return true end\n    ref = string.sub(ref, 2) .. string.sub(ref,\
    \ 1, 1)\n    t = t + 1\n  end\n  return false\nend", "  -- if b is a substring\
    \ of a, b is a valid rotation\n  if string.find(a, b) then\n    return true\n\
    \  end\n  -- a is not a substring of b, so just return false\n  if not string.find(b,\
    \ a) then\n    return false\n  end\n  -- do an in-order check of the rotations\
    \ of b\n  local b_rotations = {}\n  for n = 2, #b do\n    table.insert(b_rotations,\
    \ string.sub(b, n) .. string.sub(b, 1, n - 1))\n  end\n  for _, rot in ipairs(b_rotations)\
    \ do\n    if string.find(a, rot) then\n      return true\n    end\n  end\n  return\
    \ false\nend", "    for i = 1, #b do\n        if string.sub(a, 1, #b) == string.sub(b,\
    \ i) .. string.sub(b, 1, i - 1) then\n            return true\n        end\n \
    \   end\n    return false\nend", end, "    for i = 1, #b do\n        b = b:sub(2)\
    \ .. b:sub(1, 1)\n        if b == a then\n            return true\n        end\n\
    \    end\n    return false\nend", "  return a:match(b) or a:match(b:sub(2) ..\
    \ b:sub(1, 1))\nend", "  local b_len = string.len(b)\n  for i = 1, b_len do\n\
    \    local c = string.sub(b, i, i)\n    local l = string.sub(b, 1, i - 1)\n  \
    \  local r = string.sub(b, i + 1, b_len)\n    b = r .. l\n    if string.find(a,\
    \ b) then\n      return true\n    end\n  end\n  return false\nend", "  local a_length\
    \ = #a\n  local b_length = #b\n  local marker = b_length\n  while marker > 0 do\n\
    \    local pattern = string.sub(b, marker, b_length) .. string.sub(b, 1, marker\
    \ - 1)\n    local match = string.find(a, pattern)\n    if match ~= nil then\n\
    \      return true\n    end\n    marker = marker - 1\n  end\n  return false\n\
    end", "    local a = string.lower(a)\n    local b = string.lower(b)\n    if b\
    \ == string.sub(a, 1, string.len(b)) then\n        return true\n    end\n    for\
    \ i = 2, string.len(a) do\n        local sub_a = string.sub(a, i, string.len(a))\n\
    \        local sub_b = string.sub(a, 1, i - 1)\n        local new_a = sub_a ..\
    \ sub_b\n        if b == string.sub(new_a, 1, string.len(b)) then\n          \
    \  return true\n        end\n    end\n    return false\nend", "    if (a == nil\
    \ or b == nil) then\n        return false\n    end\n    if (#a < #b) then\n  \
    \      return false\n    end\n    if (#a == #b) then\n        return a == b\n\
    \    end\n    a, b = a:lower(), b:lower()\n    -- return b in a\n    local an\
    \ = b:len()\n    local bn = a:len()\n    local i, j\n    local c1, c2\n    for\
    \ i = 1, bn - an + 1 do\n        j = 1\n        while j <= an do\n           \
    \ c1 = a:sub(i, i):byte()\n            c2 = b:sub(j, j):byte()\n            if\
    \ c1 ~= c2 then\n                break\n            end\n            i = i + 1\n\
    \            j = j + 1\n        end\n        if j > an then\n            return\
    \ true\n        end\n    end\n    return false\nend", "    if not b or not a then\
    \ return false end\n    if string.len(a) < string.len(b) then return false end\n\
    \    local len = string.len(b)\n    local blen = string.len(a) - len\n    for\
    \ i = 1, blen do\n        local ai = string.sub(a, i, i + len - 1)\n        if\
    \ ai == b then return true end\n    end\n    return false\nend", "    -- TODO\n\
    end", "    local cycled_str = b\n    local len = string.len(b)\n    for i = 1,\
    \ len do\n        if string.find(a, cycled_str) then\n            return true\n\
    \        end\n        cycled_str = cycled_str:sub(2) .. cycled_str:sub(1, 1)\n\
    \    end\n    return false\nend", "    return (a:find(b) ~= nil) or (a:find(rotate(b))\
    \ ~= nil)\nend", "  if #a < #b then return false end\n  local a = a:lower()\n\
    \  local b = b:lower()\n  local c = b\n  for i = 1, #b do\n    if c == a then\
    \ return true end\n    c = c:sub(2) .. c:sub(1, 1)\n  end\n  return false\nend",
  "    local sizea = #a\n    local sizeb = #b\n    if sizea ~= sizeb then\n      \
    \  return false\n    end\n    local offset = -1\n    for i = 1, sizea do\n   \
    \     if a:sub(i, i) == b:sub(1, 1) then\n            offset = i\n           \
    \ break\n        end\n    end\n    if offset == -1 then\n        return false\n\
    \    end\n    return b == a:sub(offset, offset + sizeb - 1) .. a:sub(1, offset\
    \ - 1)\nend", "  local b_len = string.len(b)\n  local a_len = string.len(a)\n\
    \  local a_chars = {}\n  local b_chars = {}\n  local i, j, k\n  for i = 1, b_len\
    \ do\n    b_chars[i] = string.sub(b, i, i)\n  end\n  for i = 1, a_len do\n   \
    \ a_chars[i] = string.sub(a, i, i)\n  end\n  for i = 1, b_len do\n    local found\
    \ = false\n    for j = 1, a_len do\n      if b_chars[i] == a_chars[j] then\n \
    \       found = true\n        break\n      end\n    end\n    if not found then\n\
    \      return false\n    end\n  end\n  local shift = 1\n  while shift < b_len\
    \ do\n    local found = true\n    for i = 1, b_len do\n      if b_chars[i] ~=\
    \ a_chars[(i - 1 + shift) % b_len + 1] then\n        found = false\n        break\n\
    \      end\n    end\n    if found then\n      return true\n    end\n    shift\
    \ = shift + 1\n  end\n  return false\nend", "    -- Implement your code here\n\
    \    -- Use `return true` or `return false`\n    return false\nend", "    a =\
    \ string.lower(a)\n    b = string.lower(b)\n    if #a < #b then\n        return\
    \ false\n    end\n    local b_start = string.sub(b, 1, 1)\n    local b_end = string.sub(b,\
    \ #b, #b)\n    local is_pattern = false\n    local last_a_start = 1\n    local\
    \ first_char_in_a_found = false\n    for i = 1, #a do\n        local a_i = string.sub(a,\
    \ i, i)\n        if a_i == b_start then\n            first_char_in_a_found = true\n\
    \            local a_sub = string.sub(a, last_a_start, i)\n            local b_sub\
    \ = string.sub(b, 1, #b - #a_sub)\n            if a_sub == b_sub then\n      \
    \          local a_end = string.sub(a, i + 1, #a)\n                local b_part\
    \ = string.sub(b, #b - #a_sub + 1, #b)\n                if a_end == b_part then\n\
    \                    is_pattern = true\n                    break\n          \
    \      end\n            end\n            last_a_start = i\n        end\n    end\n\
    \    if not first_char_in_a_found then\n        return false\n    end\n    if\
    \ not is_pattern then\n        return false\n    end\n    return true\nend", " \
    \ local b_size = string.len(b)\n  for i = 1, b_size do\n    if string.sub(b, i,\
    \ b_size) .. string.sub(b, 1, i - 1) == b then\n      return true\n    end\n \
    \ end\n  return false\nend", "    local len = #b\n    local str = b..b\n    return\
    \ string.find(str, a) ~= nil\nend", "\tlocal i = 0\n\tlocal str = b\n\tfor i =\
    \ 0, #b do\n\t\tstr = b:sub(i + 1) .. b:sub(1, i)\n\t\tif string.find(a, str)\
    \ then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "  local function\
    \ rotate(s)\n    return s:sub(2) .. s:sub(1, 1)\n  end\n  local s = b\n  for i\
    \ = 1, #b do\n    if a:find(s) then\n      return true\n    end\n    s = rotate(s)\n\
    \  end\n  return false\nend", "  local b_pattern = a:match('^(%a*' .. b .. ')%a*$')",
  "    local pattern = a .. a\n    local function search(pat, word)\n        local\
    \ i = string.find(pat, word)\n        return i and true or false\n    end\n  \
    \  return search(pattern, b)\nend", "  local la, lb = #a, #b\n  local i = 2\n\
    \  while i <= lb do\n    if b:sub(i) == b:sub(1, lb - i + 1) then\n      if a:find(b:sub(i)\
    \ .. b:sub(1, lb - i + 1)) then\n        return true\n      end\n    end\n   \
    \ i = i + 1\n  end\n  return false\nend", "  if b:len() > a:len() then return\
    \ false end\n  if b:len() == 1 then return true end\n  for i = 1, a:len() do\n\
    \    local c = a:sub(i, i + b:len() - 1)\n    if c == b then return true end\n\
    \  end\n  return false\nend", "  a = a:lower()\n  b = b:lower()\n  local k = b:len()\n\
    \  for i = 1, a:len() - k + 1 do\n    if a:sub(i, i + k - 1) == b then\n     \
    \ return true\n    end\n  end\n  return false\nend", "    local b_ = b\n    for\
    \ i = 1, #b do\n        b_ = b_:sub(2) .. b_:sub(1, 1)\n        if a:find(b_)\
    \ then\n            return true\n        end\n    end\n    return false\nend",
  "\tlocal pattern_len = string.len(b)\n\tlocal str_len = string.len(a)\n\tif (str_len\
    \ < pattern_len) then\n\t\treturn false\n\tend\n\tfor i = 1, str_len - pattern_len\
    \ + 1 do\n\t\tif (a:sub(i, i + pattern_len - 1) == b) then\n\t\t\treturn true\n\
    \t\tend\n\tend\n\tfor i = 2, pattern_len do\n\t\tlocal rot = b:sub(i, pattern_len)\
    \ .. b:sub(1, i - 1)\n\t\tfor j = 1, str_len - pattern_len + 1 do\n\t\t\tif (a:sub(j,\
    \ j + pattern_len - 1) == rot) then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn false\nend", "    local key = a .. '_' .. b\n    if cache.cycpattern_check[key]\
    \ ~= nil then\n        return cache.cycpattern_check[key]\n    end\n    if type(a)\
    \ ~= 'string' or type(b) ~= 'string' then\n        return nil\n    end\n    a\
    \ = string.lower(a)\n    b = string.lower(b)\n    local len_a = #a\n    local\
    \ len_b = #b\n    local b_front = b:sub(1, 1)\n    local b_back = b:sub(len_b,\
    \ len_b)\n    if b_front == b_back then\n        return nil\n    end\n    if not\
    \ string.find(a, b) then\n        local b_new = string.sub(b, 2, len_b) .. b_front\n\
    \        local count = 0\n        while b_new ~= b do\n            if string.find(a,\
    \ b_new) then\n                break\n            end\n            b_new = string.sub(b_new,\
    \ 2, len_b) .. b_front\n            count = count + 1\n            if count >\
    \ len_b then\n                break\n            end\n        end\n        if\
    \ b_new == b then\n            cache.cycpattern_check[key] = false\n         \
    \   return false\n        end\n    end\n    cache.cycpattern_check[key] = true\n\
    \    return true\nend", "    local a1 = a\n    local a2 = a\n    if a:len() >\
    \ b:len() then\n        for i = 1, a:len() do\n            a1 = a1:sub(2) .. a1:sub(1,\
    \ 1)\n            a2 = a2:sub(a2:len(), a2:len()) .. a2:sub(1, a2:len() - 1)\n\
    \            if a1:find(b) or a2:find(b) then\n                return true\n \
    \           end\n        end\n    end\n    return false\nend", "  if not a or\
    \ not b then return false end\n  for i = 1, #b do\n    if string.sub(b, i) ..\
    \ string.sub(b, 1, i - 1) == a then\n      return true\n    end\n  end\n  return\
    \ false\nend", "    local len_a = #a\n    local len_b = #b\n    if len_a == 0\
    \ or len_b == 0 then\n        return false\n    end\n    local start = 1\n   \
    \ for i = 1, len_a do\n        start = string.find(a, b[1], start)\n        if\
    \ start == nil then\n            return false\n        end\n        local k =\
    \ 1\n        for j = start, len_a do\n            if a[j] ~= b[k] then\n     \
    \           break\n            end\n            k = k + 1\n            if k >\
    \ len_b then\n                return true\n            end\n        end\n    \
    \    k = 1\n        for j = 1, start - 1 do\n            if a[j] ~= b[k] then\n\
    \                break\n            end\n            k = k + 1\n            if\
    \ k > len_b then\n                return true\n            end\n        end\n\
    \        start = start + 1\n    end\n    return false\nend", "    local pattern\
    \ = string.format('[^%s]*', b)\n    local count = 0\n    for _ in string.gmatch(a\
    \ .. a, pattern) do\n        count = count + 1\n    end\n    return count > 1\n\
    end", "    if a:find(b) then\n        return true\n    end\n    for i = 1, #b\
    \ do\n        b = b:sub(2) .. b:sub(1, 1)\n        if a:find(b) then\n       \
    \     return true\n        end\n    end\n    return false\nend", "\tif a:find(b)\
    \ then\n\t\treturn true\n\tend\n\tfor i = 1, #b - 1 do\n\t\tlocal new_str = b:sub(i\
    \ + 1) .. b:sub(1, i)\n\t\tif a:find(new_str) then\n\t\t\treturn true\n\t\tend\n\
    \tend\n\treturn false\nend", "    for i = 1, #b do\n        if string.sub(a, i,\
    \ #b + i - 1) == b then\n            return true\n        end\n    end\n    return\
    \ false\nend", "  if a == '' or b == '' then return false end\n  local a = string.gsub(a,\
    \ ' ', '')\n  local b = string.gsub(b, ' ', '')\n  for i = 1, #b do\n    local\
    \ c = string.sub(b, i, i)\n    if not string.find(a, c) then return false end\n\
    \  end\n  return true\nend", "\t-- TODO: Write your code here\n\treturn false\n\
    end", "  local n = #a\n  local m = #b\n  for i = 1, n do\n    local left = a:sub(1,\
    \ i - 1)\n    local right = a:sub(i)\n    local result = (left .. right):find(b)\n\
    \    if result then\n      return true\n    end\n  end\n  return false\nend",
  "\tlocal alen = a:len()\n\tlocal blen = b:len()\n\tif alen < blen then\n\t\treturn\
    \ false\n\tend\n\ta = a .. a\n\tfor i = 1, alen do\n\t\tif a:sub(i, i + blen -\
    \ 1) == b then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "   \
    \ -- check whether a is a substring of b\n    if string.find(a, b) then\n    \
    \    return true\n    end\n    -- check whether b is a substring of a\n    if\
    \ string.find(b, a) then\n        return true\n    end\n    -- check whether any\
    \ of the cyclic rotations of b is a substring of a\n    -- e.g. if a = 'abcd'\
    \ and b = 'bcda', then a contains 'bcd', 'cda', 'dab'\n    -- if we have 2 words\
    \ a, b and a is a cyclic rotation of b,\n    -- then the length of a will be the\
    \ same as the length of b\n    if #a == #b then\n        for i = 1, #b do\n  \
    \          local newb = b:sub(i, #b) .. b:sub(1, i - 1)\n            if string.find(a,\
    \ newb) then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "\tlocal b = string.sub(b, 2)..string.sub(b, 1, 1)\n\t\
    if a:find(b) then\n\t\treturn true\n\telse\n\t\treturn cycpattern_check(a, b)\n\
    \tend\nend", "  return is_substring(b, a) or is_substring(rotate(b), a)\nend",
  "  for i = 1, #b do\n    if b:sub(i) .. b:sub(1, i - 1) == a then\n      return\
    \ true\n    end\n  end\n  return false\nend", "  local s = a..a\n  for i = 0,\
    \ #b do\n    if s:sub(i+1, #b+i) == b then\n      return true\n    end\n  end\n\
    \  return false\nend", "  local len = #b\n  for i = 1, len do\n    if a:find(b,\
    \ 1, true) then\n      return true\n    end\n    b = b:sub(2) .. b:sub(1, 1)\n\
    \  end\n  return false\nend", "    local function is_substring(a, b)\n       \
    \ for i = 1, #a do\n            local substr = string.sub(a, i, i + #b - 1)\n\
    \            if substr == b then\n                return true\n            end\n\
    \        end\n        return false\n    end", "    -- use string.find to look\
    \ for b in a\n    local function rotations(s)\n        local t = {}\n        for\
    \ i = 1, string.len(s) do\n            table.insert(t, string.sub(s, i, -1) ..\
    \ string.sub(s, 1, i - 1))\n        end\n        return t\n    end\n    for i,\
    \ v in ipairs(rotations(b)) do\n        if string.find(a, v) then\n          \
    \  return true\n        end\n    end\n    return false\nend", "    -- insert code\
    \ here\n    local function rotate_string(str)\n        local t = {}\n        for\
    \ i = 1, #str do\n            t[i] = str:sub(i, i)\n        end\n        local\
    \ first_letter = table.remove(t, 1)\n        table.insert(t, first_letter)\n \
    \       return table.concat(t)\n    end\n    for i = 1, #b do\n        if b ==\
    \ a:sub(1, #b) then\n            return true\n        end\n        b = rotate_string(b)\n\
    \    end\n    return false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
