name: HumanEval_47_median
language: lua
prompt: "-- Return median of elements in the table l.\n-- >>> median({3, 1, 2, 4,\
  \ 5})\n-- 3\n-- >>> median({-10, 4, 6, 1000, 10, 20})\n-- 15.0\nlocal function median(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = median\n\
  \    lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)\n    lu.assertEquals(candidate({-10,\
  \ 4, 6, 1000, 10, 20}), 8.0)\n    lu.assertEquals(candidate({5}), 5)\n    lu.assertEquals(candidate({6,\
  \ 5}), 5.5)\n    lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Sort l first\n  local tmp = {}\n  for i, v in ipairs(l) do\n \
    \   tmp[i] = v\n  end\n  table.sort(tmp)", "    assert(type(l) == \"table\", \"\
    expected table\")\n    local n = #l\n    assert(n > 0, \"expected non-empty table\"\
    )\n    if n % 2 == 0 then\n        return (l[n / 2] + l[n / 2 + 1]) / 2\n    else\n\
    \        return l[math.ceil(n / 2)]\n    end\nend", "\tlocal l = sorted(l)\n\t\
    local n = #l\n\treturn (l[(n+1)/2] + l[(n+2)/2]) / 2\nend", "\tlocal n = #l\n\t\
    if n == 0 then return nil end\n\tif n == 1 then return l[1] end\n\t\n\tlocal t\
    \ = {}\n\tfor i, v in ipairs(l) do\n\t\tt[#t + 1] = v\n\tend\n\t\n\ttable.sort(t)\n\
    \t\n\tif n % 2 == 0 then\n\t\treturn (t[n / 2] + t[n / 2 + 1]) / 2\n\telse\n\t\
    \treturn t[(n + 1) / 2]\n\tend\nend", "  local temp = clone(l)\n  sort(temp)\n\
    \  if #temp % 2 == 0 then\n    return (temp[#temp/2] + temp[#temp/2+1]) / 2\n\
    \  else\n    return temp[math.ceil(#temp/2)]\n  end\nend", "    if #l == 0 then\n\
    \        return nil\n    end\n    local e = {}\n    for _, v in ipairs(l) do\n\
    \        e[#e + 1] = v\n    end\n    table.sort(e)\n    if #e % 2 == 0 then\n\
    \        return (e[#e / 2] + e[#e / 2 + 1]) / 2\n    else\n        return e[math.ceil(#e\
    \ / 2)]\n    end\nend", "\tlocal function comp(a, b)\n\t\treturn a < b\n\tend\n\
    \tlocal l2 = list.copy(l)\n\ttable.sort(l2, comp)\n\tlocal n = #l2\n\tlocal m\
    \ = math.floor(n / 2)\n\tif n % 2 == 0 then\n\t\treturn (l2[m] + l2[m + 1]) /\
    \ 2\n\telse\n\t\treturn l2[m + 1]\n\tend\nend", "  if not l then\n    return nil\n\
    \  end\n  local ll = copy(l)\n  table.sort(ll)\n  local n = #ll\n  if n == 0 then\n\
    \    return nil\n  elseif n % 2 == 0 then\n    local m = n / 2\n    return (ll[m]\
    \ + ll[m + 1]) / 2\n  else\n    return ll[(n + 1) / 2]\n  end\nend", "    local\
    \ sl = quick_sort(l)\n    local n = #sl\n    if n == 0 then\n        return 0\n\
    \    elseif n % 2 == 1 then\n        return sl[math.ceil(n/2)]\n    else\n   \
    \     return (sl[n/2] + sl[n/2+1]) / 2\n    end\nend", "\tlocal sort = table.sort\n\
    \tlocal len = #l\n\tsort(l)\n\tlocal m = len % 2 == 0 and (l[len / 2] + l[len\
    \ / 2 + 1]) / 2 or l[(len + 1) / 2]\n\treturn m\nend", "\tlocal sl = _.sort(l)\n\
    \tlocal half = math.floor(#sl / 2)\n\tif #sl % 2 == 0 then\n\t\treturn (sl[half]\
    \ + sl[half + 1]) / 2\n\telse\n\t\treturn sl[half + 1]\n\tend\nend", "    local\
    \ m = median_copy(l)\n    table.sort(m)\n    local n = #m\n    if n == 0 then\n\
    \        return nil\n    elseif n % 2 == 0 then\n        return (m[n / 2] + m[n\
    \ / 2 + 1]) / 2\n    else\n        return m[math.ceil(n / 2)]\n    end\nend",
  "\tlocal t = {}\n\tfor _,v in ipairs(l) do\n\t\ttable.insert(t, v)\n\tend\n\ttable.sort(t)\n\
    \tlocal i = #t\n\tif i % 2 == 0 then\n\t\treturn (t[i/2] + t[i/2+1]) / 2\n\telse\n\
    \t\treturn t[(i+1)/2]\n\tend\nend", "    local t = {}\n    for _, x in ipairs(l)\
    \ do\n        t[#t + 1] = x\n    end\n    if #t == 0 then\n        return nil\n\
    \    end\n    table.sort(t)\n    if #t % 2 == 0 then\n        return (t[#t / 2]\
    \ + t[#t / 2 + 1]) / 2\n    else\n        return t[math.ceil(#t / 2)]\n    end\n\
    end", "    assertx.is_table(l)\n    assertx.all_are(l, 'number')\n    local n\
    \ = #l\n    assertx.gt(n, 0)\n    table.sort(l)\n    local index = math.floor(n\
    \ / 2)\n    if n % 2 == 0 then\n        return (l[index] + l[index + 1]) / 2\n\
    \    else\n        return l[index + 1]\n    end\nend", "  local num = #l\n  local\
    \ m = math.floor(num / 2)\n  local n = num % 2", "\tlocal list = table.copy(l)\n\
    \ttable.sort(list)\n\tlocal length = #list\n\tlocal middle = length/2\n\tif not\
    \ math.fmod(length, 2) then\n\t\treturn (list[middle] + list[middle+1])/2\n\t\
    else\n\t\treturn list[math.ceil(middle)]\n\tend\nend", "    local m = {}\n   \
    \ for k, v in pairs(l) do\n        m[k] = v\n    end\n    table.sort(m)\n    if\
    \ #m % 2 == 0 then\n        return (m[#m / 2] + m[#m / 2 + 1]) / 2\n    else\n\
    \        return m[(#m + 1) / 2]\n    end\nend", "  local t = sorted_keys(l)\n\
    \  if #t % 2 == 0 then\n    return (t[#t/2] + t[#t/2+1]) / 2\n  else\n    return\
    \ t[(#t+1)/2]\n  end\nend", "  if not l or #l == 0 then\n    return nil\n  end\n\
    \  local sorted = {}\n  for i, v in ipairs(l) do\n    sorted[i] = v\n  end\n \
    \ table.sort(sorted)\n  local len = #sorted\n  if len % 2 == 0 then\n    return\
    \ (sorted[len / 2] + sorted[len / 2 + 1]) / 2\n  else\n    return sorted[math.ceil(len\
    \ / 2)]\n  end\nend", "  local s = table.sort(l)\n  local n = #s\n  if math.fmod(n,\
    \ 2) == 0 then\n    return (s[n/2] + s[n/2+1]) / 2\n  else\n    return s[math.ceil(n/2)]\n\
    \  end\nend", "  local t = table.copy(l)\n  table.sort(t)\n  local s = #t\n  if\
    \ s == 0 then\n    return 0\n  elseif s % 2 == 0 then\n    return (t[s / 2] +\
    \ t[s / 2 + 1]) / 2\n  else\n    return t[math.ceil(s / 2)]\n  end\nend", "  local\
    \ t = copy(l)\n  table.sort(t)\n  local len = #t\n  if len == 0 then\n    return\
    \ 0\n  elseif len % 2 == 0 then\n    return (t[len / 2] + t[len / 2 + 1]) / 2\n\
    \  else\n    return t[math.ceil(len / 2)]\n  end\nend", "  return torch.median(torch.Tensor(l))\n\
    end", "    if #l == 0 then\n        return nil\n    end\n    local t = util.sort(l)\n\
    \    local m = #t\n    if m % 2 == 0 then\n        return (t[m / 2] + t[m / 2\
    \ + 1]) / 2\n    else\n        return t[math.ceil(m / 2)]\n    end\nend", "\t\
    local t = l", "\tlocal n = #l\n\tif n == 0 then return 0 end\n\ttable.sort(l)\n\
    \tlocal mid = math.floor(n / 2)\n\tif n % 2 == 0 then\n\t\treturn (l[mid] + l[mid\
    \ + 1]) / 2\n\telse\n\t\treturn l[mid + 1]\n\tend\nend", "    local t = {}\n \
    \   local n = 0\n    for k, v in pairs(l) do\n        n = n + 1\n        t[n]\
    \ = v\n    end\n    table.sort(t)\n    local m = n / 2\n    if n % 2 == 0 then\n\
    \        return (t[m] + t[m + 1]) / 2\n    else\n        return t[math.ceil(m)]\n\
    \    end\nend", "    local copy = table.copy(l)\n    table.sort(copy)\n    local\
    \ n = #copy\n    if n == 0 then\n        return 0\n    elseif n % 2 == 0 then\n\
    \        return (copy[n / 2] + copy[n / 2 + 1]) / 2\n    else\n        return\
    \ copy[math.ceil(n / 2)]\n    end\nend", "    local m = math.floor(#l / 2)\n \
    \   if #l % 2 == 0 then\n        return (l[m] + l[m + 1]) / 2\n    else\n    \
    \    return l[m + 1]\n    end\nend", "\tlocal m1, m2\n\tif #l % 2 == 0 then\n\t\
    \tm1 = m2 = 0\n\t\tlocal n = #l\n\t\tfor i = 1, n / 2 do\n\t\t\tm1 = m1 + l[i]\n\
    \t\t\tm2 = m2 + l[n - i + 1]\n\t\tend\n\t\treturn (m1 + m2) / n\n\telse\n\t\t\
    local n = math.floor(#l / 2)\n\t\treturn l[n + 1]\n\tend\nend", "\ttable.sort(l)\n\
    \tlocal size = #l\n\tlocal m = size / 2\n\treturn (size % 2 == 0) and (l[m] +\
    \ l[m + 1]) / 2 or l[math.ceil(m)]\nend", "  local ll = copy(l)\n  local ln =\
    \ #ll\n  local lm = math.floor(ln / 2)\n  table.sort(ll)\n  if ln % 2 == 0 then\n\
    \    return (ll[lm] + ll[lm + 1]) / 2\n  else\n    return ll[lm + 1]\n  end\n\
    end", "  return select(2, list.sort(l))[math.ceil(#l / 2)]\nend", "  local rt\
    \ = {}\n  for _, v in ipairs(l) do\n    rt[#rt + 1] = v\n  end\n  table.sort(rt)\n\
    \  if #rt % 2 == 0 then\n    return (rt[#rt / 2] + rt[#rt / 2 + 1]) / 2\n  else\n\
    \    return rt[math.ceil(#rt / 2)]\n  end\nend", "  table.sort(l)\n  local count\
    \ = table.getn(l)\n  if (count % 2) == 0 then\n    local m = count / 2\n    return\
    \ (l[m] + l[m + 1]) / 2\n  else\n    return l[math.ceil(count / 2)]\n  end\nend",
  "  local t = copy(l)\n  table.sort(t)\n  local n = #t\n  if n % 2 == 0 then\n  \
    \  return (t[n / 2] + t[n / 2 + 1]) / 2\n  else\n    return t[(n + 1) / 2]\n \
    \ end\nend", "\tif #l < 1 then return nil end\n\tif #l == 1 then return l[1] end\n\
    \t\n\ttable.sort(l)\n\t\n\tlocal n = #l\n\tlocal center = n/2\n\t\n\tif n % 2\
    \ == 0 then\n\t\treturn (l[center] + l[center+1]) / 2\n\telse\n\t\treturn l[math.ceil(center)]\n\
    \tend\nend", "    if #l == 0 then\n        return nil\n    end\n    table.sort(l)\n\
    \    if #l % 2 == 0 then\n        return (l[#l / 2] + l[#l / 2 + 1]) / 2\n   \
    \ else\n        return l[(#l + 1) / 2]\n    end\nend", "  local s = sorted(l)\n\
    \  local n = #s\n  if n == 0 then\n    return nil\n  elseif n % 2 == 0 then\n\
    \    return (s[n/2] + s[n/2+1]) / 2\n  else\n    return s[math.ceil(n/2)]\n  end\n\
    end", "    assert(l ~= nil, 'Nil argument for median')\n    local n = #l\n   \
    \ if n < 1 then\n        error('Empty list for median')\n    end\n    table.sort(l)\n\
    \    local m\n    if n % 2 == 0 then\n        m = (l[n / 2] + l[n / 2 + 1]) /\
    \ 2\n    else\n        m = l[math.ceil(n / 2)]\n    end\n    return m\nend", " \
    \ local m = #l\n  if m == 0 then return 0 end\n  l = sort(l)\n  if m % 2 == 0\
    \ then\n    return (l[m / 2] + l[m / 2 + 1]) / 2\n  else\n    return l[(m + 1)\
    \ / 2]\n  end\nend", "  if #l == 0 then return nil end\n  local min, max = math.min(unpack(l)),\
    \ math.max(unpack(l))\n  return (min + max) / 2\nend", "    return quantile(l,\
    \ 0.5)\nend", "  local list = copylist(l)\n  local n = #list\n  assert(n > 0,\
    \ \"empty list\")\n  table.sort(list)\n  local a = list[math.floor(n/2) + 1]\n\
    \  if n % 2 == 0 then\n    local b = list[math.floor(n/2)]\n    return (a + b)\
    \ / 2\n  else\n    return a\n  end\nend", "    table.sort(l)\n    local len =\
    \ #l\n    local middle = math.floor(len / 2) + 1\n    if len % 2 == 0 then\n \
    \       return (l[middle - 1] + l[middle]) / 2\n    else\n        return l[middle]\n\
    \    end\nend", "  local t = copy(l)\n  table.sort(t)\n  local n = #t\n  if n\
    \ % 2 == 0 then\n    return (t[n / 2] + t[n / 2 + 1]) / 2\n  else\n    return\
    \ t[(n + 1) / 2]\n  end\nend", "  assertx.is_table(l)\n  local m = #l\n  if m\
    \ == 0 then\n    return nil\n  end\n  local d = 0\n  if m % 2 == 0 then\n    d\
    \ = 0.5\n  end\n  return (l[(m+1)/2-d] + l[(m+1)/2+d]) / 2\nend", "  table.sort(l)\n\
    \  local n = #l\n  local middle = math.floor(n / 2)\n  if n % 2 == 0 then\n  \
    \  return (l[middle] + l[middle + 1]) / 2\n  else\n    return l[middle + 1]\n\
    \  end\nend", "    return np.median(list2array(l))\nend", "    local sorted =\
    \ sort(l)\n    local count = #sorted\n    local middle = math.floor(count / 2)\n\
    \    if count % 2 == 0 then\n        return (sorted[middle] + sorted[middle +\
    \ 1]) / 2\n    else\n        return sorted[middle + 1]\n    end\nend", "    table.sort(l)\n\
    \    local n = #l\n    if n == 0 then\n        return 0\n    elseif n % 2 == 0\
    \ then\n        return (l[n / 2] + l[n / 2 + 1]) / 2\n    else\n        return\
    \ l[(n + 1) / 2]\n    end\nend", "  local t = table.sort(l)\n  local n = #t\n\
    \  if n % 2 == 0 then\n    return (t[n / 2] + t[n / 2 + 1]) / 2\n  else\n    return\
    \ t[(n + 1) / 2]\n  end\nend", "    if #l == 0 then\n        return\n    end\n\
    \    local u = {}\n    for _, v in ipairs(l) do\n        u[#u + 1] = v\n    end\n\
    \    table.sort(u)\n    local ln = #u\n    if ln % 2 == 0 then\n        return\
    \ (u[ln / 2] + u[ln / 2 + 1]) / 2\n    else\n        return u[(ln + 1) / 2]\n\
    \    end\nend", "  if #l == 0 then\n    return nil\n  end\n  table.sort(l)\n \
    \ local middle = math.floor(#l / 2)\n  if #l % 2 == 0 then\n    return (l[middle]\
    \ + l[middle + 1]) / 2\n  else\n    return l[middle + 1]\n  end\nend", "    assert(#l\
    \ > 0, \"Can't compute median of empty list\")\n    local middle = math.floor(#l\
    \ / 2) + 1\n    local sortedList = quicksort(l)\n    if #l % 2 == 0 then\n   \
    \     return (sortedList[middle] + sortedList[middle-1]) / 2\n    else\n     \
    \   return sortedList[middle]\n    end\nend", "  local a = copy(l)\n  sort(a)\n\
    \  local n = length(a)\n  if n == 0 then\n    return nil\n  elseif n % 2 == 0\
    \ then\n    return (a[n / 2] + a[n / 2 + 1]) / 2\n  else\n    return a[math.ceil(n\
    \ / 2)]\n  end\nend", "    local t = table.copy(l)\n    table.sort(t)\n    local\
    \ n = #t\n    if n % 2 == 0 then\n        return (t[n / 2] + t[n / 2 + 1]) / 2\n\
    \    else\n        return t[(n + 1) / 2]\n    end\nend", "  local sorted = sort(l)\n\
    \  local len = #sorted\n  local mid = math.floor(len / 2)\n  if len % 2 == 0 then\n\
    \    return (sorted[mid] + sorted[mid + 1]) / 2\n  else\n    return sorted[mid\
    \ + 1]\n  end\nend", "\tassertx.is_table(l)\n\tassertx.is_nonempty_array(l)\n\t\
    \n\tlocal copy = list.copy(l)\n\ttable.sort(copy)\n\t\n\tlocal mid = math.floor(#copy\
    \ / 2)\n\tlocal is_even = #copy % 2 == 0\n\t\n\tif is_even then\n\t\treturn (copy[mid]\
    \ + copy[mid + 1]) / 2\n\telse\n\t\treturn copy[mid + 1]\n\tend\nend", "  -- Sort\
    \ input.\n  local t = {}\n  for k, v in pairs(l) do\n    table.insert(t, v)\n\
    \  end\n  table.sort(t)", "\tlocal t = sorted(l)\n\tlocal n = #t\n\tif n == 0\
    \ then\n\t\treturn nil\n\telseif n % 2 == 0 then\n\t\treturn (t[n/2] + t[n/2+1])\
    \ / 2\n\telse\n\t\treturn t[(n+1)/2]\n\tend\nend", "  local sorted = bubble_sort(l)\n\
    \  local n = #sorted\n  if n == 0 then\n    return 0\n  elseif n % 2 == 0 then\n\
    \    return (sorted[n/2] + sorted[n/2+1]) / 2\n  else\n    return sorted[math.ceil(n/2)]\n\
    \  end\nend", "  local t = keys(l)\n  table.sort(t)\n  return t[#t/2]\nend", " \
    \   if type(l) ~= \"table\" then return nil end\n    if #l == 0 then return nil\
    \ end\n    local sorted = merge_sort(l)\n    local n = #sorted\n    local m\n\
    \    if n % 2 == 0 then\n        m = (sorted[n/2] + sorted[n/2+1]) / 2\n    else\n\
    \        m = sorted[(n+1)/2]\n    end\n    return m\nend", "    local l2 = table.sort(l)\n\
    \    local mid = #l2 / 2\n    if mid ~= math.floor(mid) then\n        return (l2[mid]\
    \ + l2[mid + 1]) / 2\n    else\n        return l2[mid]\n    end\nend", "  table.sort(l)\n\
    \  local n = #l\n  if n % 2 == 0 then\n    return (l[n / 2] + l[n / 2 + 1]) /\
    \ 2\n  else\n    return l[math.ceil(n / 2)]\n  end\nend", "    local l = table.sort(l)\n\
    \    local n = #l\n    if n%2 == 0 then\n        return (l[n/2] + l[n/2+1])/2\n\
    \    else\n        return l[(n+1)/2]\n    end\nend", "  local m, tab = 0, {}\n\
    \  for i, v in ipairs(l) do\n    if i == 1 then\n      m = v\n    elseif i % 2\
    \ == 0 then\n      m = (tab[i/2] + v) / 2\n    else\n      tab[(i+1)/2] = v\n\
    \    end\n  end\n  return m\nend", "  table.sort(l)\n  local size = #l\n  if (size\
    \ % 2 == 0) then\n    return (l[size/2] + l[size/2+1]) / 2\n  else\n    return\
    \ l[math.ceil(size/2)]\n  end\nend", "    local m = math.floor(#l / 2)\n    return\
    \ #l % 2 == 0 and (l[m] + l[m + 1]) / 2 or l[m + 1]\nend", "  local t = table.copy(l)\n\
    \  table.sort(t)\n  return t[(#t + 1) / 2]\nend", "  local tmp = copy(l)\n  table.sort(tmp)\n\
    \  local i = math.floor(#tmp / 2)\n  return (#tmp % 2 == 0) and ((tmp[i] + tmp[i\
    \ + 1]) / 2) or tmp[i + 1]\nend", "    local l2 = clone(l)\n    table.sort(l2)\n\
    \    local n = #l2\n    if n == 0 then\n        return nil\n    elseif n == 1\
    \ then\n        return l2[1]\n    elseif n % 2 == 0 then\n        return (l2[n/2]\
    \ + l2[n/2+1]) / 2\n    else\n        return l2[(n+1)/2]\n    end\nend", "  local\
    \ tmp = {}\n  for _, v in ipairs(l) do\n    tmp[#tmp+1] = v\n  end\n  table.sort(tmp)\n\
    \  local n = #tmp\n  if n == 0 then\n    return 0\n  elseif n % 2 == 0 then\n\
    \    return (tmp[n/2] + tmp[n/2+1]) / 2\n  else\n    return tmp[math.ceil(n/2)]\n\
    \  end\nend", "    local sum = 0\n    local count = 0\n    for i, v in ipairs(l)\
    \ do\n        sum = sum + v\n        count = count + 1\n    end\n    return (sum\
    \ / count)\nend", "  local ll = copy(l)\n  table.sort(ll)\n  local length = #ll\n\
    \  if length % 2 == 0 then\n    local i = length / 2\n    return (ll[i] + ll[i\
    \ + 1]) / 2\n  else\n    return ll[(length + 1) / 2]\n  end\nend", "  local l2\
    \ = table.sort(table.copy(l))\n  local m = (table.size(l2) - 1) / 2\n  if math.floor(m)\
    \ == m then\n    return (l2[m] + l2[m + 1]) / 2\n  else\n    return l2[math.floor(m)\
    \ + 1]\n  end\nend", "  assert(#l > 0, \"table must have at least one element\"\
    )\n  if #l % 2 == 0 then\n    return 0.5 * (l[math.floor(#l/2)] + l[math.floor(#l/2)\
    \ + 1])\n  else\n    return l[math.floor(#l/2) + 1]\n  end\nend", "  local t =\
    \ copy(l)\n  sort(t)\n  local n = #t\n  if n == 0 then\n    return nil\n  elseif\
    \ n % 2 == 0 then\n    return (t[n / 2] + t[n / 2 + 1]) / 2\n  else\n    return\
    \ t[math.ceil(n / 2)]\n  end\nend", "    local l_copy = l\n    table.sort(l_copy)\n\
    \    local n = #l_copy\n    if n % 2 == 0 then\n        return (l_copy[n / 2]\
    \ + l_copy[n / 2 + 1]) / 2\n    else\n        return l_copy[math.ceil(n / 2)]\n\
    \    end\nend", "    if #l == 0 then\n        return nil\n    end\n    local n\
    \ = #l\n    local m = math.floor(n / 2)\n    if n % 2 == 0 then\n        return\
    \ (sort(l)[m] + sort(l)[m + 1]) / 2\n    else\n        return sort(l)[m + 1]\n\
    \    end\nend", "    local t = copy(l)\n    sort(t)\n    local r\n    if #t %\
    \ 2 == 0 then\n        r = (t[#t / 2] + t[#t / 2 + 1]) / 2\n    else\n       \
    \ r = t[(#t + 1) / 2]\n    end\n    return r\nend", "  local t = sort(l)\n  local\
    \ n = #t\n  return (t[n / 2] + t[(n - 1) / 2]) / 2\nend", "    local s = l\n \
    \   table.sort(s)\n    if #s % 2 == 0 then\n        return (s[#s / 2] + s[#s /\
    \ 2 + 1]) / 2\n    else\n        return s[math.ceil(#s / 2)]\n    end\nend", " \
    \   local sorted = table.pack(table.unpack(l))\n    table.sort(sorted)\n    local\
    \ size = #sorted\n    if size == 0 then\n        return nil\n    elseif size %\
    \ 2 == 0 then\n        return (sorted[size / 2] + sorted[size / 2 + 1]) / 2\n\
    \    else\n        return sorted[(size + 1) / 2]\n    end\nend", "  local list\
    \ = table.copy(l)\n  table.sort(list)\n  return list[math.ceil(#list / 2)]\nend",
  "  local n = math.ceil(#l / 2)\n  table.sort(l)\n  if #l % 2 == 0 then\n    return\
    \ (l[n] + l[n + 1]) / 2\n  else\n    return l[n]\n  end\nend", "    local n =\
    \ #l\n    local sorted = copy(l)\n    table.sort(sorted)\n    if n % 2 == 0 then\n\
    \        return (sorted[n/2] + sorted[n/2+1]) / 2\n    else\n        return sorted[(n+1)/2]\n\
    \    end\nend", "  local t = {}\n  for _, v in ipairs(l) do\n    t[#t + 1] = v\n\
    \  end\n  table.sort(t)\n  if #t % 2 == 0 then\n    return (t[#t / 2] + t[#t /\
    \ 2 + 1]) / 2\n  else\n    return t[(#t + 1) / 2]\n  end\nend", "    local tmp\
    \ = deepcopy(l)\n    table.sort(tmp)\n    if #tmp % 2 == 0 then\n        -- even\
    \ case\n        return (tmp[#tmp / 2] + tmp[#tmp / 2 + 1]) / 2\n    else\n   \
    \     -- odd case\n        return tmp[math.ceil(#tmp / 2)]\n    end\nend", " \
    \   return mean(l)\nend", "    local n = #l\n    local newl = {}\n    for i =\
    \ 1, n do\n        newl[i] = l[i]\n    end\n    table.sort(newl)\n    if n % 2\
    \ == 0 then\n        return (newl[n / 2] + newl[n / 2 + 1]) / 2\n    else\n  \
    \      return newl[(n + 1) / 2]\n    end\nend", "    if type(l) ~= \"table\" then\n\
    \        error(\"l must be a table\", 2)\n    end\n    local n = #l\n    if n\
    \ == 0 then\n        return 0\n    end\n    if n == 1 then\n        return l[1]\n\
    \    end\n    local t = deepcopy(l)\n    table.sort(t)\n    local median_index\
    \ = math.floor(n / 2)\n    if n % 2 == 0 then\n        return (t[median_index]\
    \ + t[median_index + 1]) / 2\n    else\n        return t[median_index + 1]\n \
    \   end\nend", "  local tbl = {}\n  for _, v in ipairs(l) do\n    tbl[#tbl + 1]\
    \ = v\n  end\n  table.sort(tbl)\n  local mid = #tbl / 2\n  if #tbl % 2 == 0 then\n\
    \    return (tbl[mid] + tbl[mid + 1]) / 2\n  else\n    return tbl[math.ceil(mid)]\n\
    \  end\nend", "    local t = table.sort(l)\n    local k = #t\n    if k % 2 ==\
    \ 0 then\n        return (t[k/2] + t[k/2+1]) / 2\n    else\n        return t[(k+1)/2]\n\
    \    end\nend", "    table.sort(l)\n    local n = #l\n    if n % 2 == 0 then\n\
    \        return (l[n / 2] + l[n / 2 + 1]) / 2\n    else\n        return l[(n +\
    \ 1) / 2]\n    end\nend", "    local t = {}\n    for _, v in ipairs(l) do table.insert(t,\
    \ v) end\n    table.sort(t)\n    local n = #t\n    if n % 2 == 0 then\n      \
    \  return (t[n/2] + t[n/2+1]) / 2\n    else\n        return t[math.ceil(n/2)]\n\
    \    end\nend", "  local half = #l / 2\n  if #l % 2 == 0 then\n    return (l[half]\
    \ + l[half + 1]) / 2\n  else\n    return l[math.ceil(half)]\n  end\nend", "  return\
    \ (sum(l) / #l)\nend", "  table.sort(l)\n  if #l % 2 == 0 then\n    return (l[#l\
    \ / 2] + l[#l / 2 + 1]) / 2\n  else\n    return l[math.ceil(#l / 2)]\n  end\n\
    end", "\tassertx.is_table(l)\n\tassertx.is_nonempty_table(l)\n\tlocal t = table.clone(l)\n\
    \ttable.sort(t)\n\treturn get_middle_value(t)\nend", "\tlocal list = {}\n\tlocal\
    \ max, min = 0, math.huge\n\tfor _, v in ipairs(l) do\n\t\tif v > max then max\
    \ = v end\n\t\tif v < min then min = v end\n\t\ttable.insert(list, v)\n\tend\n\
    \ttable.sort(list)\n\treturn list[math.ceil(#list / 2)]\nend", "    local l =\
    \ sort(l)\n    local c = #l\n    if math.mod(c, 2) == 0 then\n        return (l[c/2]\
    \ + l[c/2+1]) / 2\n    else\n        return l[math.ceil(c/2)]\n    end\nend",
  "\tlocal r = {}\n\tfor _, v in ipairs(l) do\n\t\ttable.insert(r, v)\n\tend\n\ttable.sort(r)\n\
    \tlocal n = #r\n\tlocal m = math.floor(n / 2)\n\tif n % 2 == 0 then\n\t\treturn\
    \ (r[m] + r[m + 1]) / 2\n\telse\n\t\treturn r[m + 1]\n\tend\nend", "\tlocal t\
    \ = {}\n\tfor _, v in ipairs(l) do\n\t\ttable.insert(t, v)\n\tend\n\ttable.sort(t)\n\
    \tlocal n = #t\n\tif n % 2 == 0 then\n\t\treturn (t[n / 2] + t[n / 2 + 1]) / 2\n\
    \telse\n\t\treturn t[(n + 1) / 2]\n\tend\nend", "  local tmp = {}\n  for _,v in\
    \ ipairs(l) do\n    tmp[#tmp+1] = v\n  end\n  table.sort(tmp)\n  local mid = #tmp\
    \ / 2\n  if math.floor(mid) == mid then\n    return (tmp[mid] + tmp[mid+1]) /\
    \ 2\n  else\n    return tmp[math.ceil(mid)]\n  end\nend", "  local tbl = {}\n\
    \  for _, v in ipairs(l) do tbl[#tbl+1] = v end\n  table.sort(tbl)\n  local len\
    \ = #tbl\n  local mid_idx = len / 2\n  if len % 2 == 0 then\n    return (tbl[mid_idx]\
    \ + tbl[mid_idx+1]) / 2\n  else\n    return tbl[math.ceil(mid_idx)]\n  end\nend",
  "    local len = #l\n    local sorted = copy(l)\n    table.sort(sorted)\n    if\
    \ len % 2 == 0 then\n        return (sorted[len / 2] + sorted[len / 2 + 1]) /\
    \ 2\n    else\n        return sorted[(len + 1) / 2]\n    end\nend", "    local\
    \ n = #l\n    table.sort(l)\n    if n % 2 == 0 then\n        return (l[n/2] +\
    \ l[n/2+1]) / 2\n    else\n        return l[math.ceil(n/2)]\n    end\nend", " \
    \ if #l == 0 then\n    return 0\n  end\n  table.sort(l)\n  if #l % 2 == 0 then\n\
    \    return (l[#l / 2] + l[#l / 2 + 1]) / 2\n  else\n    return l[math.ceil(#l\
    \ / 2)]\n  end\nend", "  local t = tablex.deepcopy(l)\n  table.sort(t)\n  local\
    \ n = #t\n  if n % 2 == 0 then\n    return (t[n / 2] + t[n / 2 + 1]) / 2\n  else\n\
    \    return t[(n + 1) / 2]\n  end\nend", "    local s = table.concat(l, \" \"\
    )\n    s = \"{\" .. s .. \"}\"\n    table.sort(l)\n    local n = #l\n    if n\
    \ == 0 then\n        return nil\n    elseif n == 1 then\n        return l[1]\n\
    \    elseif n % 2 == 0 then\n        local i1 = n / 2\n        local i2 = i1 +\
    \ 1\n        return (l[i1] + l[i2]) / 2\n    else\n        local i = math.ceil(n\
    \ / 2)\n        return l[i]\n    end\nend\n_G[\"median\"] = median", "  local\
    \ lc = copy(l)\n  sort(lc)\n  local size = #lc\n  local m = size/2 + 0.5\n  if\
    \ size % 2 == 0 then\n    return (lc[m-1] + lc[m])/2\n  else\n    return lc[m]\n\
    \  end\nend", "  local values = {}\n  local min = math.huge\n  local max = -math.huge\n\
    \  local sum = 0\n  for _, value in ipairs(l) do\n    local new_value = tonumber(value)\n\
    \    if not new_value then\n      return 0\n    end\n    values[#values + 1] =\
    \ new_value\n    min = math.min(min, new_value)\n    max = math.max(max, new_value)\n\
    \    sum = sum + new_value\n  end\n  table.sort(values)\n  local count = #values\n\
    \  if count % 2 == 0 then\n    local m1 = values[count / 2]\n    local m2 = values[count\
    \ / 2 + 1]\n    return (m1 + m2) / 2\n  else\n    return values[math.ceil(count\
    \ / 2)]\n  end\nend", "    local function search(s, e)\n        local m = math.floor((s\
    \ + e) / 2)\n        if s < e then\n            if m % 2 == 0 then\n         \
    \       return (l[m] + l[m + 1]) / 2\n            else\n                return\
    \ l[m]\n            end\n        else\n            return l[s]\n        end\n\
    \    end\n    local function rec(s, e)\n        if s < e then\n            local\
    \ m = math.floor((s + e) / 2)\n            local c = l[m]\n            local lm\
    \ = m - 1\n            local rm = m + 1\n            while lm >= s do\n      \
    \          if l[lm] > c then\n                    l[m] = l[lm]\n             \
    \       l[lm] = c\n                    m = lm\n                end\n         \
    \       lm = lm - 1\n            end\n            while rm <= e do\n         \
    \       if l[rm] < c then\n                    l[m] = l[rm]\n                \
    \    l[rm] = c\n                    m = rm\n                end\n            \
    \    rm = rm + 1\n            end\n            local mid = math.floor((s + e)\
    \ / 2)\n            if m < mid then\n                rec(m + 1, e)\n         \
    \   elseif m > mid then\n                rec(s, m - 1)\n            end\n    \
    \    end\n    end\n    local len = #l\n    rec(1, len)\n    return search(1, len)\n\
    end", "  table.sort(l)\n  local middle = (1 + #l) / 2\n  if middle == math.floor(middle)\
    \ then\n    return (l[middle] + l[middle + 1]) / 2\n  else\n    return l[math.ceil(middle)]\n\
    \  end\nend", "\treturn quantile(l, 0.5)\nend", "    assert(type(l) == \"table\"\
    , \"bad argument #1 to 'math_ext.median' (table expected, got \" .. type(l) ..\
    \ \")\")\n    assert(#l > 0, \"bad argument #1 to 'math_ext.median' (table cannot\
    \ be empty)\")\n    for _, v in ipairs(l) do\n        assert(type(v) == \"number\"\
    , \"bad argument #1 to 'math_ext.median' (number expected, got \" .. type(v) ..\
    \ \")\")\n    end\n    local t = table_ext.copy(l)\n    table.sort(t)\n    if\
    \ #t % 2 == 0 then\n        return (t[#t / 2] + t[#t / 2 + 1]) / 2\n    else\n\
    \        return t[math.ceil(#t / 2)]\n    end\nend", "    -- Sort elements\n \
    \   table.sort(l)\n    local n = #l\n    if n % 2 == 0 then\n        -- Even number\
    \ of elements, return the average of middle elements\n        return (l[n / 2]\
    \ + l[n / 2 + 1]) / 2\n    else\n        -- Odd number of elements, return the\
    \ middle element\n        return l[(n + 1) / 2]\n    end\nend", "    return quantile(l,\
    \ 0.5)\nend", "\tif #l == 0 then\n\t\treturn nil\n\tend\n\tif #l == 1 then\n\t\
    \treturn l[1]\n\tend\n\tlocal m = nil\n\tif #l % 2 == 0 then\n\t\tm = (#l / 2)\
    \ + 1\n\telse\n\t\tm = math.floor(#l / 2) + 1\n\tend\n\tlocal a = nil\n\tfor i,\
    \ v in ipairs(l) do\n\t\tif i == m then\n\t\t\ta = v\n\t\tend\n\tend\n\treturn\
    \ a\nend", "    if not is_table(l) then return error('Expected table for parameter\
    \ 1, got ' .. type(l)) end\n    local sorted = copy(l)\n    sort(sorted)\n   \
    \ local length = len(sorted)\n    if length % 2 == 0 then\n        return (sorted[length\
    \ / 2] + sorted[length / 2 + 1]) / 2\n    else\n        return sorted[(length\
    \ + 1) / 2]\n    end\nend", "\tassert_table(l)\n\tassert(#l > 0, \"table must\
    \ have at least one element\")\n\ttable.sort(l)\n\tif #l % 2 == 0 then\n\t\tlocal\
    \ a = l[#l / 2]\n\t\tlocal b = l[#l / 2 + 1]\n\t\treturn (a + b) / 2\n\telse\n\
    \t\treturn l[math.ceil(#l / 2)]\n\tend\nend", "\tlocal t = {}\n\tfor i, v in ipairs(l)\
    \ do\n\t\ttable.insert(t, v)\n\tend\n\ttable.sort(t)\n\tlocal n = #t\n\tif n %\
    \ 2 == 0 then\n\t\treturn (t[n / 2] + t[n / 2 + 1]) / 2\n\telse\n\t\treturn t[(n\
    \ + 1) / 2]\n\tend\nend", "\tlocal sl = sort(l)\n\tlocal n = #sl\n\tif n % 2 ==\
    \ 0 then\n\t\treturn (sl[n/2] + sl[n/2+1]) / 2\n\telse\n\t\treturn sl[math.ceil(n/2)]\n\
    \tend\nend", "  assert(#l > 0, \"Empty list\")\n  table.sort(l)\n  local mid =\
    \ math.floor(#l / 2)\n  if #l % 2 == 0 then\n    return (l[mid] + l[mid + 1])\
    \ / 2\n  else\n    return l[mid + 1]\n  end\nend", "  local s = sorted(l)\n  local\
    \ m = #s\n  if m == 0 then\n    return 0\n  elseif m % 2 == 0 then\n    return\
    \ (s[m/2] + s[m/2+1]) / 2\n  else\n    return s[math.ceil(m/2)]\n  end\nend",
  "\ttable.sort(l)\n\tlocal n = #l\n\tif n % 2 == 0 then\n\t\treturn (l[n/2] + l[n/2+1])\
    \ / 2\n\telse\n\t\treturn l[(n+1)/2]\n\tend\nend", "    local ls = {}\n    for\
    \ _, v in ipairs(l) do\n        table.insert(ls, v)\n    end\n    table.sort(ls)\n\
    \    local n = #ls\n    if n % 2 == 0 then\n        return (ls[n / 2] + ls[n /\
    \ 2 + 1]) / 2\n    else\n        return ls[math.ceil(n / 2)]\n    end\nend", " \
    \ local tmp = {}\n  for _, v in ipairs(l) do\n    tmp[#tmp+1] = v\n  end\n  table.sort(tmp)\n\
    \  local n = #tmp\n  if n % 2 == 0 then\n    return (tmp[n/2] + tmp[n/2+1]) /\
    \ 2\n  else\n    return tmp[math.ceil(n/2)]\n  end\nend", "  local n = #l\n  table.sort(l)\n\
    \  if n % 2 == 0 then\n    return (l[n/2] + l[n/2+1]) / 2\n  else\n    return\
    \ l[math.ceil(n/2)]\n  end\nend", "    local s = sorted(l)\n    local n = #s\n\
    \    if n == 0 then\n        return nil\n    elseif n == 1 then\n        return\
    \ s[1]\n    elseif n % 2 == 0 then\n        return (s[n / 2] + s[n / 2 + 1]) /\
    \ 2\n    else\n        return s[(n + 1) / 2]\n    end\nend", "\tlocal c = {}\n\
    \tfor _, v in ipairs(l) do c[v] = c[v] and c[v] + 1 or 1 end\n\tlocal n = 0\n\t\
    for _, v in ipairs(l) do n = n + 1 end\n\tif n == 0 then return 0 end\n\tif n\
    \ % 2 == 1 then\n\t\tfor k, v in pairs(c) do\n\t\t\tif v >= (n + 1) / 2 then return\
    \ k end\n\t\tend\n\telse\n\t\tlocal b = nil\n\t\tfor k, v in pairs(c) do\n\t\t\
    \tif not b and v >= n / 2 then b = k end\n\t\t\tif b and v >= n / 2 + 1 then return\
    \ (b + k) / 2 end\n\t\tend\n\tend\nend", "    if type(l) ~= \"table\" then\n \
    \       error(\"table expected\", 2)\n    end\n    if #l == 0 then\n        return\
    \ nil\n    end\n    local sorted = clone(l)\n    table.sort(sorted)\n    local\
    \ len = #sorted\n    if len % 2 == 0 then\n        return (sorted[len/2] + sorted[len/2+1])\
    \ / 2\n    else\n        return sorted[(len+1)/2]\n    end\nend", "\t-- sort\n\
    \tlocal l2 = {}\n\tfor k, v in pairs(l) do\n\t\ttable.insert(l2, v)\n\tend\n\t\
    table.sort(l2)\n\t-- find median\n\tlocal mid = math.floor(#l2 / 2)\n\tif #l2\
    \ % 2 == 0 then\n\t\treturn (l2[mid] + l2[mid + 1]) / 2\n\telse\n\t\treturn l2[mid\
    \ + 1]\n\tend\nend", "  local n = #l\n  table.sort(l)\n  local d, md = l[n], l[(n\
    \ - 1) / 2 + 1]\n  return n % 2 == 0 and (d + md) / 2 or md\nend", "\tlocal t\
    \ = {}\n\tfor _,v in ipairs(l) do\n\t\ttable.insert(t, v)\n\tend\n\ttable.sort(t)\n\
    \tlocal i = #t\n\tif i % 2 == 0 then\n\t\treturn (t[i/2] + t[i/2+1]) / 2\n\telse\n\
    \t\treturn t[math.ceil(i/2)]\n\tend\nend", "    if #l == 0 then\n        return\
    \ nil\n    end\n    table.sort(l)\n    local m = #l / 2\n    if m == math.floor(m)\
    \ then\n        return (l[m] + l[m + 1]) / 2\n    else\n        return l[math.ceil(m)]\n\
    \    end\nend", "\ttable.sort(l)\n\tlocal s = #l\n\tif s % 2 == 0 then\n\t\treturn\
    \ (l[s/2] + l[s/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(s/2)]\n\tend\nend",
  "    local len = #l\n    if len == 0 then\n        return 0\n    end\n    table.sort(l)\n\
    \    local mid = math.floor(len / 2)\n    if len % 2 == 0 then\n        return\
    \ (l[mid] + l[mid + 1]) / 2\n    else\n        return l[mid + 1]\n    end\nend",
  "  assertx.is_table(l)\n  assertx.all_are_numbers(l)\n  table.sort(l)\n  local mid\
    \ = math.floor(#l / 2)\n  if #l % 2 == 0 then\n    return (#l) / 2\n  else\n \
    \   return (l[mid] + l[mid + 1]) / 2\n  end\nend", "    local t = copy(l)\n  \
    \  table.sort(t)\n    local n = #t\n    if n % 2 == 0 then\n        return (t[n\
    \ / 2] + t[n / 2 + 1]) / 2\n    else\n        return t[(n + 1) / 2]\n    end\n\
    end", "    return l\nend", "  assert(#l > 0, \"median: list must have at least\
    \ one element\")\n  table.sort(l)\n  if #l % 2 == 0 then\n    return (l[#l / 2]\
    \ + l[#l / 2 + 1]) / 2\n  else\n    return l[math.ceil(#l / 2)]\n  end\nend",
  "  if #l == 0 then\n    return 0\n  end\n  -- We sort the table using the default\
    \ __lt metamethod.\n  -- TODO: This can be optimized with a merge sort that does\
    \ not recopy the\n  -- table.\n  table.sort(l)\n  local n = #l\n  if n % 2 ==\
    \ 0 then\n    return (l[n / 2] + l[n / 2 + 1]) / 2\n  else\n    return l[(n +\
    \ 1) / 2]\n  end\nend", "    local n = #l\n    local c = copy(l)\n    table.sort(c)\n\
    \    if n % 2 == 0 then\n        return (c[n/2] + c[n/2+1]) / 2\n    else\n  \
    \      return c[(n+1)/2]\n    end\nend", "    local n = #l\n    if n == 0 then\n\
    \        return nil\n    end\n    local temp = {}\n    for i = 1, n do\n     \
    \   temp[i] = l[i]\n    end\n    table.sort(temp)\n    if n%2 == 0 then\n    \
    \    return (temp[n/2] + temp[n/2+1])/2\n    else\n        return temp[(n+1)/2]\n\
    \    end\nend", "    local sorted = deepcopy(l)\n    table.sort(sorted)\n    if\
    \ #sorted % 2 == 0 then\n        return (sorted[#sorted / 2] + sorted[#sorted\
    \ / 2 + 1]) / 2\n    else\n        return sorted[(#sorted + 1) / 2]\n    end\n\
    end", "\tlocal list = {}\n\tfor _,v in pairs(l) do\n\t\ttable.insert(list, v)\n\
    \tend\n\ttable.sort(list)\n\tlocal half = #list / 2\n\tif #list % 2 == 0 then\n\
    \t\treturn (list[half] + list[half+1]) / 2\n\telse\n\t\treturn list[math.ceil(half)]\n\
    \tend\nend", "\tlocal n = #l\n\tif n % 2 == 0 then\n\t\treturn (l[n / 2] + l[n\
    \ / 2 + 1]) / 2\n\telse\n\t\treturn l[math.ceil(n / 2)]\n\tend\nend", "    local\
    \ n = #l\n    table.sort(l)\n    if n%2 == 0 then\n        return (l[n/2] + l[n/2+1])/2\n\
    \    else\n        return l[(n+1)/2]\n    end\nend", "    local l = sort(l)\n\
    \    if (#l % 2) == 0 then\n        return (l[#l / 2] + l[(#l / 2) + 1]) / 2\n\
    \    else\n        return l[math.ceil(#l / 2)]\n    end\nend", "    local t =\
    \ copy(l)\n    local n = #t\n    if n == 0 then\n        return nil\n    end\n\
    \    table.sort(t)\n    if n % 2 == 0 then\n        return (t[n / 2] + t[n / 2\
    \ + 1]) / 2\n    else\n        return t[(n + 1) / 2]\n    end\nend", "    local\
    \ t = clone(l)\n    table.sort(t)\n    local n = #t\n    local mid = n/2\n   \
    \ if n%2 == 0 then\n        return (t[mid] + t[mid+1])/2\n    else\n        return\
    \ t[math.ceil(mid)]\n    end\nend", "  table.sort(l)\n  local len = #l\n  local\
    \ n = len % 2\n  if n == 0 then\n    return (l[len / 2] + l[len / 2 + 1]) / 2\n\
    \  else\n    return l[(len + 1) / 2]\n  end\nend", "  -- sort first\n  table.sort(l)\n\
    \  local n, m = #l, math.floor(#l / 2)\n  -- if the list has an even number of\
    \ elements, return mean of middle two\n  if n % 2 == 0 then\n    return (l[m]\
    \ + l[m + 1]) / 2\n  else\n    return l[m + 1]\n  end\nend", "  if type(l) ~=\
    \ \"table\" then\n    error(\"bad argument #1 to 'median' (table expected, got\
    \ \" .. type(l) .. \")\", 2)\n  end\n  return mean(l)\nend", "  local h = {}\n\
    \  for i = 1, #l do\n    h[i] = {l[i], math.random()}\n  end\n  table.sort(h,\
    \ function(a, b) return a[1] < b[1] end)\n  local p = #l / 2\n  if math.floor(p)\
    \ ~= p then\n    return (h[math.floor(p)][1] + h[math.ceil(p)][1]) / 2\n  else\n\
    \    return h[p][1]\n  end\nend", "    local t = sort(l)\n    local n = #t\n \
    \   local m = n/2\n    if n%2 == 0 then\n        return (t[m] + t[m+1])/2\n  \
    \  else\n        return t[math.ceil(m)]\n    end\nend", "  local lc = copy(l)\n\
    \  table.sort(lc)\n  local n = #lc\n  if n == 0 then\n    return nil\n  elseif\
    \ n % 2 == 0 then\n    return (lc[n / 2] + lc[n / 2 + 1]) / 2\n  else\n    return\
    \ lc[(n + 1) / 2]\n  end\nend", "    local t = copy(l)\n    sort(t)\n    return\
    \ (t[#t/2] + t[(#t+1)/2]) / 2\nend", "    local len = #l\n    local mid = (len\
    \ + 1) / 2\n    local m = 0", "    if type(l) ~= \"table\" then\n        error(\"\
    bad argument #1 to 'median' (table expected, got \" .. type(l) .. \")\", 2)\n\
    \    end\n    if #l == 0 then\n        return nil\n    end\n    local t = copy(l)\n\
    \    table.sort(t)\n    local n = #t\n    if n % 2 == 0 then\n        return (t[n\
    \ / 2] + t[n / 2 + 1]) / 2\n    else\n        return t[(n + 1) / 2]\n    end\n\
    end", "    if not l or #l == 0 then\n        return 0\n    end\n    local copy\
    \ = copy_table(l)\n    table.sort(copy)\n    local len = #copy\n    if len % 2\
    \ == 0 then\n        local a = copy[len / 2]\n        local b = copy[len / 2 +\
    \ 1]\n        return (a + b) / 2\n    else\n        return copy[math.ceil(len\
    \ / 2)]\n    end\nend", "    local total = #l\n    local sorted = {}\n    for\
    \ k, v in pairs(l) do\n        sorted[k] = v\n    end\n    table.sort(sorted)\n\
    \    if total % 2 == 0 then\n        return (sorted[total / 2] + sorted[total\
    \ / 2 + 1]) / 2\n    else\n        return sorted[(total + 1) / 2]\n    end\nend",
  "    local n = #l\n    if n == 0 then\n        return nil\n    end\n    table.sort(l)\n\
    \    if n % 2 == 0 then\n        return (l[n / 2] + l[n / 2 + 1]) / 2\n    else\n\
    \        return l[math.ceil(n / 2)]\n    end\nend", "\tlocal f = function(a, b)\
    \ return a < b end\n\tlocal i = floor(#l / 2)\n\tlocal j = #l - i", "  return\
    \ sorted_list_stat(l, math.floor(#l / 2) + 1)\nend", "  local n = #l\n  local\
    \ m\n  table.sort(l)\n  if n % 2 == 0 then\n    m = (l[n/2] + l[n/2+1]) / 2\n\
    \  else\n    m = l[math.ceil(n/2)]\n  end\n  return m\nend", "\tlocal sl = sort(l)\n\
    \tif #sl % 2 == 0 then\n\t\tlocal i = #sl / 2\n\t\treturn (sl[i] + sl[i + 1])\
    \ / 2\n\telse\n\t\treturn sl[#sl / 2 + 1]\n\tend\nend", "\tlocal t = sorted(l)\n\
    \tlocal r = math.ceil(#t / 2)\n\tif #t % 2 == 0 then\n\t\treturn (t[r] + t[r +\
    \ 1]) / 2\n\telse\n\t\treturn t[r]\n\tend\nend", "  local n = #l\n  local m =\
    \ math.floor(n / 2)\n  local sorted = sort(l)\n  if n % 2 == 0 then\n    return\
    \ (sorted[m] + sorted[m + 1]) / 2\n  else\n    return sorted[m + 1]\n  end\nend",
  "  local t = utils.clone(l)\n  table.sort(t)\n  local len = #t\n  if len % 2 ==\
    \ 0 then\n    return (t[len / 2] + t[len / 2 + 1]) / 2\n  else\n    return t[math.ceil(len\
    \ / 2)]\n  end\nend", "    local lg = len(l)\n    local tmp = {}\n    local res\
    \ = 0\n    for _, v in pairs(l) do\n        tmp[v] = true\n    end\n    local\
    \ i = 0\n    for k, _ in pairs(tmp) do\n        i = i + 1\n        if i == lg\
    \ / 2 then\n            if lg % 2 == 0 then\n                local j = i + 1\n\
    \                for k2, _ in pairs(tmp) do\n                    if j == lg /\
    \ 2 + 1 then\n                        res = (k + k2) / 2\n                   \
    \     break\n                    end\n                    j = j + 1\n        \
    \        end\n            else\n                res = k\n            end\n   \
    \         break\n        end\n    end\n    return res\nend", "    table.sort(l)\n\
    \    local h = math.floor(#l / 2) + 1\n    return #l % 2 == 0 and (l[h - 1] +\
    \ l[h]) / 2 or l[h]\nend", "\t-- sort the list\n\tlocal sorted = {}\n\tlocal n\
    \ = #l\n\tfor i, v in ipairs(l) do\n\t\tsorted[i] = v\n\tend\n\ttable.sort(sorted)",
  "    if #l == 0 then\n        return 0\n    end\n    local t = sort(l)\n    if #t\
    \ % 2 == 0 then\n        return (t[#t / 2] + t[#t / 2 + 1]) / 2\n    else\n  \
    \      return t[math.ceil(#t / 2)]\n    end\nend", "\tassert(#l>0, \"Cannot find\
    \ median of an empty table.\")\n\tl = shallow_copy(l)\n\tsort(l)\n\tif #l%2 ==\
    \ 0 then\n\t\treturn (l[#l/2]+l[#l/2+1])/2\n\telse\n\t\treturn l[math.ceil(#l/2)]\n\
    \tend\nend", "    table.sort(l)\n    local len = #l\n    if (len % 2 == 0) then\n\
    \        return (l[len / 2] + l[len / 2 + 1]) / 2\n    else\n        return l[(len\
    \ + 1) / 2]\n    end\nend", "    local sorted = copy(l)\n    table.sort(sorted)\n\
    \    local middle = #sorted\n    if (middle % 2 == 0) then\n        return (sorted[middle\
    \ / 2] + sorted[middle / 2 + 1]) / 2\n    else\n        return sorted[(middle\
    \ + 1) / 2]\n    end\nend", "    local sorted = sorted_elements(l)\n    local\
    \ middle = math.floor(#sorted / 2) + 1\n    return sorted[middle]\nend", "  local\
    \ l2 = clone(l)\n  table.sort(l2)\n  return l2[(#l2+1)/2]\nend", "    local s\
    \ = copy(l)\n    sort(s)\n    local n = #s\n    local a = floor(n / 2)\n    local\
    \ b = ceil(n / 2)\n    if n % 2 == 0 then\n        return (s[a] + s[b]) / 2\n\
    \    else\n        return s[a]\n    end\nend", "\tlocal t = tablex.copy(l)\n\t\
    table.sort(t)\n\treturn (t[math.floor(#t/2)] + t[math.ceil(#t/2)]) / 2\nend",
  "\tlocal m = math.floor(#l / 2)\n\treturn (#l % 2 == 0) and (l[m] + l[m + 1]) /\
    \ 2 or l[m + 1]\nend", "  return (mean(l) + max(l)) / 2\nend", "\tlocal n = #l\n\
    \tif n == 0 then return nil end\n\tlocal k = (n + 1) / 2", "\tlocal s = sort(l)\n\
    \tif #s % 2 == 0 then\n\t\treturn (s[#s/2] + s[#s/2+1]) / 2\n\telse\n\t\treturn\
    \ s[math.ceil(#s/2)]\n\tend\nend", "  return median(l)\nend", "  assert_type(l,\
    \ 'table')\n  local len = #l\n  if len == 0 then\n    return nil\n  end\n  local\
    \ r = copy(l)\n  table.sort(r)\n  local mid = len % 2 == 0 and (len / 2) or (len\
    \ + 1) / 2\n  return r[mid]\nend", "\ttable.sort(l)\n\treturn (l[#l//2] + l[(#l\
    \ + 1)//2]) / 2\nend", "    table.sort(l)\n    local n = #l\n    if n % 2 == 0\
    \ then\n        return (l[n/2] + l[n/2+1]) / 2\n    else\n        return l[math.ceil(n/2)]\n\
    \    end\nend", "  local m = clone(l)\n  sort(m)\n  return (#m % 2 == 0) and (m[#m\
    \ / 2] + m[#m / 2 + 1]) / 2 or m[#m / 2]\nend", "\tlocal num = #l\n\tlocal sorted\
    \ = clone(l)\n\tsort(sorted)\n\tlocal med\n\tif num % 2 == 0 then\n\t\tmed = (sorted[num/2]\
    \ + sorted[num/2+1])/2\n\telse\n\t\tmed = sorted[(num+1)/2]\n\tend\n\treturn med\n\
    end", "    local t = {}\n    for _, v in ipairs(l) do\n        table.insert(t,\
    \ v)\n    end\n    table.sort(t)\n    return #t % 2 == 0 and (t[#t / 2] + t[#t\
    \ / 2 + 1]) / 2 or t[math.ceil(#t / 2)]\nend", "  local t = {}\n  for _, el in\
    \ ipairs(l) do\n    table.insert(t, el)\n  end\n  table.sort(t)\n  local n = #t\n\
    \  if n % 2 == 0 then\n    return (t[n/2] + t[n/2+1]) / 2\n  else\n    return\
    \ t[(n+1)/2]\n  end\nend", "  local n = #l\n  local r = table.copy(l)\n  table.sort(r)\n\
    \  if n % 2 == 0 then\n    return (r[n/2] + r[n/2+1]) / 2\n  else\n    return\
    \ r[(n+1)/2]\n  end\nend", "  local t = clone(l)\n  table.sort(t)\n  local n =\
    \ #t\n  if (n % 2) == 0 then\n    return (t[n / 2] + t[(n / 2) + 1]) / 2\n  else\n\
    \    return t[math.ceil(n / 2)]\n  end\nend", "\tlocal tmp = {}\n\tlocal length\
    \ = #l\n\tlocal m\n\tif length % 2 == 0 then\n\t\tm = (length / 2) + 1\n\telse\n\
    \t\tm = math.ceil(length / 2)\n\tend\n\tfor _, v in ipairs(l) do\n\t\ttable.insert(tmp,\
    \ v)\n\tend\n\ttable.sort(tmp)\n\treturn tmp[m]\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
