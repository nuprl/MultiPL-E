name: HumanEval_127_intersection
language: lua
prompt: "-- You are given two intervals,\n-- where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed\
  \ which means that the interval (start, end)\n-- includes both start and end.\n\
  -- For each given interval, it is assumed that its start is less or equal its end.\n\
  -- Your task is to determine whether the length of intersection of these two \n\
  -- intervals is a prime number.\n-- Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n--\
  \ If the length of the intersection is a prime number, return \"YES\",\n-- otherwise,\
  \ return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output]\
  \ samples:\n-- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1,\
  \ 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal\
  \ function intersection(interval1, interval2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersection\n\
  \    lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')\n    lu.assertEquals(candidate({-1,\
  \ 1}, {0, 4}), 'NO')\n    lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')\n\
  \    lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')\n    lu.assertEquals(candidate({-11,\
  \ 2}, {-1, -1}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')\n \
  \   lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')\n    lu.assertEquals(candidate({-2,\
  \ -2}, {-3, -2}), 'NO')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local intersectionStart, intersectionEnd = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n  if intersectionStart\
    \ <= intersectionEnd then\n    local length = intersectionEnd - intersectionStart\
    \ + 1\n    for d = 2, math.floor(math.sqrt(length)) do\n      if length % d ==\
    \ 0 then\n        return 'NO'\n      end\n    end\n    return 'YES'\n  end\n \
    \ return 'NO'\nend", "    local left = math.max(interval1[1], interval2[1])\n\
    \    local right = math.min(interval1[2], interval2[2])\n    if right < left then\n\
    \        return 'NO'\n    end\n    local length = right - left + 1\n    if length\
    \ == 1 then\n        return 'NO'\n    end\n    local primes = { 2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97 }\n    for _,p in ipairs(primes) do\n        if p == length then\n      \
    \      return 'YES'\n        end\n    end\n    return 'NO'\nend", "  local start\
    \ = math.max(interval1[1], interval2[1])\n  local finish = math.min(interval1[2],\
    \ interval2[2])\n  local diff = finish - start\n  local isPrime = true\n  if diff\
    \ < 0 then\n    return 'NO'\n  end\n  for i = 2, diff do\n    if diff % i == 0\
    \ then\n      isPrime = false\n      break\n    end\n  end\n  if isPrime then\n\
    \    return 'YES'\n  else\n    return 'NO'\n  end\nend\nreturn intersection",
  "    -- your code here\n    local a1, a2 = interval1[1], interval1[2]\n    local\
    \ b1, b2 = interval2[1], interval2[2]\n    if a1 > b2 or b1 > a2 then\n      \
    \  return 'NO'\n    end\n    local res = math.min(a2, b2) - math.max(a1, b1) +\
    \ 1\n    return isPrime(res) and 'YES' or 'NO'\nend", "    local max_start = math.max(interval1[1],\
    \ interval2[1])\n    local min_end = math.min(interval1[2], interval2[2])\n  \
    \  local s = {max_start, min_end}\n    local len = math.abs(s[1] - s[2])\n   \
    \ if s[1] > s[2] then return 'NO' end\n    if len == 0 then return 'NO' end\n\
    \    local isPrime = true\n    for i = 2, len / 2 do\n        if len % i == 0\
    \ then isPrime = false end\n    end\n    if isPrime then return 'YES' else return\
    \ 'NO' end\nend", "    local lower = math.max(interval1[1], interval2[1])\n  \
    \  local upper = math.min(interval1[2], interval2[2])\n    local min, max = math.min(lower,\
    \ upper), math.max(lower, upper)\n    if min == max then\n        return 'NO'\n\
    \    end\n    if is_prime(math.abs(upper - lower)) then\n        return 'YES'\n\
    \    end\n    return 'NO'\nend", "    if (interval1[1] >= interval2[2] or interval2[1]\
    \ >= interval1[2]) then\n        return 'NO'\n    end\n    local max, min = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n    local x = max - min\
    \ + 1\n    if (x <= 1) then\n        return 'NO'\n    end\n    local factors =\
    \ {}\n    for i = 2, math.sqrt(x) do\n        if (x % i == 0) then\n         \
    \   return 'NO'\n        end\n    end\n    return 'YES'\nend", "  local start1,\
    \ end1 = interval1[1], interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n\
    \  local start, end = math.max(start1, start2), math.min(end1, end2)\n  if start\
    \ > end then return 'NO' end\n  local interval = {start, end}\n  return isPrime(intervalLength(interval))\
    \ and 'YES' or 'NO'\nend", "  local l, r = math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])\n  if l > r then return 'NO' end\n  local\
    \ f = function(n) return math.abs(n) > 1 and not (n % 2 == 0 or n % 3 == 0) end\n\
    \  local flag = false\n  for i = 5, math.floor(math.sqrt(r)) do\n    if f(i) then\n\
    \      for j = i * i, r, i do\n        if j >= l and j <= r then\n          flag\
    \ = true\n          break\n        end\n      end\n    end\n  end\n  return flag\
    \ and 'NO' or 'YES'\nend", "    local inter = {start = 0, finish = 0}\n    if\
    \ interval1[1] < interval2[1] then\n        inter[1] = interval2[1]\n    else\n\
    \        inter[1] = interval1[1]\n    end\n    if interval1[2] < interval2[2]\
    \ then\n        inter[2] = interval1[2]\n    else\n        inter[2] = interval2[2]\n\
    \    end\n    if inter[1] <= inter[2] then\n        local len = inter[2] - inter[1]\
    \ + 1\n        local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n        for _, p in ipairs(primes)\
    \ do\n            if len == p then\n                return 'YES'\n           \
    \ end\n        end\n        return 'NO'\n    end\n    return 'NO'\nend", "   \
    \ return (interval1[1] >= interval2[1] and interval1[1] <= interval2[2]) or (interval2[1]\
    \ >= interval1[1] and interval2[1] <= interval1[2])\nend", "    local i1 = {}\n\
    \    local i2 = {}\n    for i,v in ipairs(interval1) do\n        i1[i] = v\n \
    \   end\n    for i,v in ipairs(interval2) do\n        i2[i] = v\n    end\n   \
    \ if i1[1] > i1[2] then\n        i1[1], i1[2] = i1[2], i1[1]\n    end\n    if\
    \ i2[1] > i2[2] then\n        i2[1], i2[2] = i2[2], i2[1]\n    end\n    local\
    \ int1 = range(i1[1], i1[2])\n    local int2 = range(i2[1], i2[2])\n    local\
    \ int_intersection = {}\n    for _,v in ipairs(int1) do\n        if is_contain(int2,\
    \ v) then\n            table.insert(int_intersection, v)\n        end\n    end\n\
    \    local len = #int_intersection\n    local is_prime = true\n    if len == 0\
    \ then\n        return 'NO'\n    end\n    if len ~= 1 then\n        for i = 2,\
    \ len - 1 do\n            if len % i == 0 then\n                is_prime = false\n\
    \                break\n            end\n        end\n    end\n    if is_prime\
    \ then\n        return 'YES'\n    else\n        return 'NO'\n    end\nend", " \
    \   local start_int, end_int = 0, 0\n    if(interval1[1] < interval2[1]) then\n\
    \        start_int = interval2[1]\n    else\n        start_int = interval1[1]\n\
    \    end\n    if(interval1[2] < interval2[2]) then\n        end_int = interval1[2]\n\
    \    else\n        end_int = interval2[2]\n    end\n    local int_length = end_int\
    \ - start_int\n    if(int_length < 0) then\n        return 'NO'\n    end\n   \
    \ if(int_length == 1) then\n        return 'NO'\n    end\n    for i = 2, int_length\
    \ - 1 do\n        if((int_length % i) == 0) then\n            return 'NO'\n  \
    \      end\n    end\n    return 'YES'\nend", "  local i1, i2 = {}, {}\n  for _,\
    \ i in ipairs({interval1, interval2}) do\n    table.insert(i1, i[1])\n    table.insert(i2,\
    \ i[2])\n  end\n  local sort = table.sort\n  sort(i1)\n  sort(i2)\n  if i1[2]\
    \ < i2[1] or i2[2] < i1[1] then\n    return 'NO'\n  end\n  local prime = function(n)\n\
    \    if n < 1 then\n      return false\n    end\n    for i = 2, math.sqrt(n) do\n\
    \      if n % i == 0 then\n        return false\n      end\n    end\n    return\
    \ true\n  end\n  local n = math.min(i1[2], i2[2]) - math.max(i1[1], i2[1]) + 1\n\
    \  return prime(n) and 'YES' or 'NO'\nend", "  local a, b = interval1[1], interval1[2]\n\
    \  local c, d = interval2[1], interval2[2]\n  if c > b or a > d then return 'NO'\
    \ end\n  local n = math.min(b, d) - math.max(a, c) + 1\n  if n == 1 then return\
    \ 'NO' end\n  for i = 2, math.floor(math.sqrt(n)) do\n    if n % i == 0 then return\
    \ 'NO' end\n  end\n  return 'YES'\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local stop = math.min(interval1[2], interval2[2])\n  if start\
    \ > stop then return 'NO' end\n  return (start == 2 or start % 2 ~= 0) and stop\
    \ - start > 1 and 'YES' or 'NO'\nend", "    local start = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ if start > finish then\n        return 'NO'\n    end\n    local n = finish -\
    \ start + 1\n    if n == 1 then\n        return 'NO'\n    end\n    for i = 2,\
    \ math.floor(math.sqrt(n)) do\n        if n % i == 0 then\n            return\
    \ 'NO'\n        end\n    end\n    return 'YES'\nend", "  local function isPrime(n)\n\
    \    if n <= 1 then return false end\n    for i = 2, math.floor(math.sqrt(n))\
    \ do\n      if n % i == 0 then return false end\n    end\n    return true\n  end\n\
    \  local s, e = math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])\n\
    \  if s > e then return 'NO' end\n  return isPrime(e - s + 1) and 'YES' or 'NO'\n\
    end", "  local start = math.max(interval1[1], interval2[1])\n  local finish =\
    \ math.min(interval1[2], interval2[2])\n  local len = finish - start + 1\n  return\
    \ len > 0 and IsPrime(len) and 'YES' or 'NO'\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local finish = math.min(interval1[2], interval2[2])\n  if start\
    \ > finish then\n    return 'NO'\n  end\n  for i = 2, start do\n    if start %\
    \ i == 0 then\n      return 'NO'\n    end\n  end\n  return 'YES'\nend", "    local\
    \ x = math.max(interval1[1], interval2[1])\n    local y = math.min(interval1[2],\
    \ interval2[2])\n    if x > y then\n        return 'NO'\n    end\n    local n\
    \ = y - x + 1\n    for i = 2, math.floor(math.sqrt(n)) do\n        if n % i ==\
    \ 0 then\n            return 'NO'\n        end\n    end\n    return 'YES'\nend",
  "    local start = math.max(interval1[1], interval2[1])\n    local finish = math.min(interval1[2],\
    \ interval2[2])\n    if start > finish then\n        return 'NO'\n    end\n  \
    \  local length = finish - start + 1\n    if (length % 2 == 0) or (length % 3\
    \ == 0) or (length % 5 == 0) or (length % 7 == 0) then\n        return 'NO'\n\
    \    end\n    return 'YES'\nend", "  if interval1[1] <= interval2[1] then\n  \
    \  if interval1[2] < interval2[1] then\n      return 'NO'\n    else\n      return\
    \ IsPrime(math.min(interval1[2], interval2[2]) - interval2[1] + 1) and 'YES' or\
    \ 'NO'\n    end\n  else\n    if interval2[2] < interval1[1] then\n      return\
    \ 'NO'\n    else\n      return IsPrime(math.min(interval1[2], interval2[2]) -\
    \ interval1[1] + 1) and 'YES' or 'NO'\n    end\n  end\nend", "  local low, high\
    \ = nil, nil\n  if interval1[1] > interval2[1] then\n    low = interval1[1]\n\
    \  else\n    low = interval2[1]\n  end\n  if interval1[2] < interval2[2] then\n\
    \    high = interval1[2]\n  else\n    high = interval2[2]\n  end\n  local length\
    \ = high - low + 1\n  local is_prime = false\n  if length > 1 then\n    local\
    \ max = math.ceil(math.sqrt(length))\n    is_prime = true\n    for i = 2, max\
    \ do\n      if length % i == 0 then\n        is_prime = false\n        break\n\
    \      end\n    end\n  end\n  return is_prime and \"YES\" or \"NO\"\nend", " \
    \ local a, b = interval1[1], interval1[2]\n  local c, d = interval2[1], interval2[2]\n\
    \  if a <= c and c <= b and b <= d then\n    return isPrime(b - c + 1) and 'YES'\
    \ or 'NO'\n  elseif c <= a and a <= d and d <= b then\n    return isPrime(d -\
    \ a + 1) and 'YES' or 'NO'\n  elseif c <= a and b <= d then\n    return isPrime(b\
    \ - a + 1) and 'YES' or 'NO'\n  elseif a <= c and d <= b then\n    return isPrime(d\
    \ - c + 1) and 'YES' or 'NO'\n  else\n    return 'NO'\n  end\nend", "  local left\
    \ = math.max(interval1[1], interval2[1])\n  local right = math.min(interval1[2],\
    \ interval2[2])\n  return (left > right) and 'NO' or (isPrime(right - left + 1)\
    \ and 'YES' or 'NO')\nend", "  local first = math.max(interval1[1], interval2[1])\n\
    \  local last = math.min(interval1[2], interval2[2])\n  if last < first then return\
    \ 'NO' end\n  local is_prime = require 'is_prime'\n  local length = last - first\
    \ + 1\n  if is_prime(length) then return 'YES' end\n  return 'NO'\nend", "  local\
    \ a, b = interval1[1], interval1[2]\n  local c, d = interval2[1], interval2[2]\n\
    \  local x, y = math.max(a, c), math.min(b, d)\n  if x <= y then\n    return (y\
    \ - x == 1) and 'YES' or 'NO'\n  else\n    return 'NO'\n  end\nend", "  local\
    \ start = math.max(interval1[1], interval2[1])\n  local finish = math.min(interval1[2],\
    \ interval2[2])\n  if start <= finish then\n    return prime.isprime(finish -\
    \ start + 1) and 'YES' or 'NO'\n  end\n  return 'NO'\nend", "  local result =\
    \ {}\n  if (interval1[1] < interval2[1]) then\n    result[1] = interval2[1]\n\
    \  else\n    result[1] = interval1[1]\n  end\n  if (interval1[2] < interval2[2])\
    \ then\n    result[2] = interval1[2]\n  else\n    result[2] = interval2[2]\n \
    \ end\n  if (result[1] > result[2]) then\n    return 'NO'\n  end\n  local cnt\
    \ = 0\n  for i = result[1], result[2] do\n    cnt = cnt + 1\n  end\n  local flg\
    \ = true\n  for i = 2, cnt - 1 do\n    if (cnt % i == 0) then\n      flg = false\n\
    \      break\n    end\n  end\n  if (flg) then\n    return 'YES'\n  else\n    return\
    \ 'NO'\n  end\nend", "  local start = math.max(interval1[1], interval2[1])\n \
    \ local stop = math.min(interval1[2], interval2[2])\n  local len = stop - start\n\
    \  if len < 1 then\n    return 'NO'\n  end\n  local len_sqrt = math.floor(math.sqrt(len))\n\
    \  local is_prime = true\n  for d = 2, len_sqrt do\n    if len % d == 0 then\n\
    \      is_prime = false\n      break\n    end\n  end\n  return is_prime and 'YES'\
    \ or 'NO'\nend", "    if interval1[1] > interval2[2] or interval2[1] > interval1[2]\
    \ then\n        return 'NO'\n    end\n    return isPrime(math.abs(math.min(interval1[2],\
    \ interval2[2]) - math.max(interval1[1], interval2[1]))) and 'YES' or 'NO'\nend",
  "  local x1, y1 = interval1[1], interval1[2]\n  local x2, y2 = interval2[1], interval2[2]\n\
    \  local function sign(x)\n    if x > 0 then return 1 end\n    if x < 0 then return\
    \ -1 end\n    return 0\n  end\n  if sign(x1 - y2) == sign(y1 - x2) then\n    return\
    \ 'NO'\n  end\n  local s, e = math.max(x1, x2), math.min(y1, y2)\n  local n =\
    \ e - s + 1\n  local is_prime = { [2] = true, [3] = true, [5] = true, [7] = true\
    \ }\n  for i = 11, n, 2 do\n    is_prime[i] = true\n  end\n  for i = 3, math.sqrt(n),\
    \ 2 do\n    if is_prime[i] then\n      for j = i * i, n, i * 2 do\n        is_prime[j]\
    \ = false\n      end\n    end\n  end\n  return is_prime[n] and 'YES' or 'NO'\n\
    end", "    local function getIntersection(interval1, interval2)\n        local\
    \ function gcd(a, b)\n            if b == 0 then\n                return a\n \
    \           else\n                return gcd(b, a % b)\n            end\n    \
    \    end\n        local function lcm(a, b)\n            return (a * b) / gcd(a,\
    \ b)\n        end\n        local start = math.max(interval1[1], interval2[1])\n\
    \        local end_ = math.min(interval1[2], interval2[2])\n        if start <\
    \ end_ then\n            return start, end_\n        else\n            return\
    \ nil\n        end\n    end\n    local start, end_ = getIntersection(interval1,\
    \ interval2)\n    if start and end_ then\n        local length = end_ - start\
    \ + 1\n        if length == 1 then\n            return 'NO'\n        else\n  \
    \          local function prime(n)\n                if n == 1 then\n         \
    \           return false\n                elseif n == 2 then\n               \
    \     return true\n                else\n                    local sqrt_n = math.sqrt(n)\n\
    \                    for i = 2, sqrt_n do\n                        if n % i ==\
    \ 0 then\n                            return false\n                        end\n\
    \                    end\n                    return true\n                end\n\
    \            end\n            return prime(length) and 'YES' or 'NO'\n       \
    \ end\n    else\n        return 'NO'\n    end\nend", "  local min, max, interval_length\n\
    \  min = interval1[1] < interval2[1] and interval1[1] or interval2[1]\n  max =\
    \ interval1[2] > interval2[2] and interval1[2] or interval2[2]\n  interval_length\
    \ = interval1[2] - interval1[1] + 1\n  if interval_length % 2 == 0 then\n    interval_length\
    \ = interval_length + 1\n  end\n  if min < max then\n    if min == 2 and max ==\
    \ 2 then\n      return 'YES'\n    end\n    for i = 3, interval_length, 2 do\n\
    \      if i >= min and i <= max then\n        return 'YES'\n      end\n    end\n\
    \  end\n  return 'NO'\nend", "    local start1, end1 = table.unpack(interval1)\n\
    \    local start2, end2 = table.unpack(interval2)\n    local start, end\n    if\
    \ start1 > start2 then\n        start = start1\n    else\n        start = start2\n\
    \    end\n    if end1 < end2 then\n        end = end1\n    else\n        end =\
    \ end2\n    end\n    if start > end then\n        return 'NO'\n    end\n    local\
    \ len = end - start + 1\n    if is_prime(len) then\n        return 'YES'\n   \
    \ else\n        return 'NO'\n    end\nend", "    local a1, a2 = table.unpack(interval1)\n\
    \    local b1, b2 = table.unpack(interval2)\n    local inter = math.min(a2, b2)\
    \ - math.max(a1, b1) + 1\n    return inter <= 0 and 'NO' or isPrime(inter) and\
    \ 'YES' or 'NO'\nend", "\t-- find the intersection\n\tlocal a = math.max(interval1[1],\
    \ interval2[1])\n\tlocal b = math.min(interval1[2], interval2[2])\n\t-- if they\
    \ don't intersect, return 'NO'\n\tif a > b then return 'NO' end\n\t-- if the intersection\
    \ is a prime number, return 'YES'\n\tlocal prime = true\n\tfor i = 2, math.floor(math.sqrt(b))\
    \ do\n\t\tif a % i == 0 then prime = false break end\n\tend\n\tif prime then return\
    \ 'YES' end\n\treturn 'NO'\nend", "\tlocal x1, y1 = unpack(interval1)\n\tlocal\
    \ x2, y2 = unpack(interval2)\n\tif x1 > y2 or x2 > y1 then return 'NO' end\n\t\
    if x1 < x2 then x1 = x2 end\n\tif y1 > y2 then y1 = y2 end\n\tlocal n = y1 - x1\
    \ + 1\n\tfor i = 2, n - 1 do\n\t\tif n % i == 0 then return 'NO' end\n\tend\n\t\
    return 'YES'\nend", "  local first = interval1[1]\n  local second = interval1[2]\n\
    \  local third = interval2[1]\n  local fourth = interval2[2]\n  local length =\
    \ 0\n  if first <= fourth and third <= second then\n    length = math.abs(math.min(second,\
    \ fourth) - math.max(first, third)) + 1\n  end\n  local result = \"NO\"\n  if\
    \ length > 1 then\n    local count = 0\n    for i = 2, length - 1 do\n      if\
    \ length % i == 0 then\n        count = count + 1\n      end\n    end\n    if\
    \ count == 0 then\n      result = \"YES\"\n    end\n  end\n  return result\nend",
  "    local function isPrime(number)\n        if number == 1 then\n            return\
    \ false\n        end\n        for i = 2, number-1 do\n            if number %\
    \ i == 0 then\n                return false\n            end\n        end\n  \
    \      return true\n    end\n    local start = math.max(interval1[1], interval2[1])\n\
    \    local stop = math.min(interval1[2], interval2[2])\n    if stop < start then\n\
    \        return 'NO'\n    end\n    if isPrime(stop - start + 1) then\n       \
    \ return 'YES'\n    end\n    return 'NO'\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local finish = math.min(interval1[2], interval2[2])\n  local\
    \ len = finish - start + 1\n  if len < 0 then return 'NO' end\n  if len == 1 then\
    \ return 'YES' end\n  local res = true\n  for i = 2, math.floor(math.sqrt(len))\
    \ do\n    if len % i == 0 then\n      res = false\n      break\n    end\n  end\n\
    \  return res and 'YES' or 'NO'\nend", "    local x, y = interval1[1], interval1[2]\n\
    \    local u, v = interval2[1], interval2[2]\n    if y < u or v < x then return\
    \ 'NO' end\n    local a, b = max(x, u), min(y, v)\n    local n = (b - a) + 1\n\
    \    if n < 2 then return 'NO' end\n    for i = 2, n - 1 do\n        if n % i\
    \ == 0 then return 'NO' end\n    end\n    return 'YES'\nend", "  local max = math.max(interval1[1],\
    \ interval2[1])\n  local min = math.min(interval1[2], interval2[2])\n  if max\
    \ > min then return 'NO' end\n  if max == min then return 'YES' end\n  local interval\
    \ = max+1\n  while interval < min do\n    local isPrime = true\n    for i = 2,\
    \ interval-1 do\n      if interval % i == 0 then\n        isPrime = false\n  \
    \      break\n      end\n    end\n    if isPrime then return 'YES' end\n    interval\
    \ = interval + 1\n  end\n  return 'NO'\nend", "    start1, end1 = interval1[1],\
    \ interval1[2]\n    start2, end2 = interval2[1], interval2[2]\n    -- possible\
    \ values of start, end\n    -- 1. start2, end1\n    -- 2. start1, end2\n    --\
    \ if start1 <= start2, then it is either case 1 or 3\n    if start1 <= start2\
    \ then\n        if end1 < start2 then\n            return 'NO'\n        else\n\
    \            -- intersection\n            start = start2\n            end = end1\n\
    \        end\n    else\n        -- start1 > start2\n        if end2 < start1 then\n\
    \            return 'NO'\n        else\n            -- intersection\n        \
    \    start = start1\n            end = end2\n        end\n    end\n    -- check\
    \ if the interval is prime\n    for i = 2, math.sqrt(end - start) do\n       \
    \ if (end - start) % i == 0 then\n            return 'NO'\n        end\n    end\n\
    \    return 'YES'\nend", "  local function isPrime(number)\n    for i = 2, number\
    \ - 1 do\n      if number % i == 0 then\n        return false\n      end\n   \
    \ end\n    return true\n  end\n  local start = math.max(interval1[1], interval2[1])\n\
    \  local finish = math.min(interval1[2], interval2[2])\n  if start > finish then\n\
    \    return 'NO'\n  end\n  return isPrime(finish - start + 1) and 'YES' or 'NO'\n\
    end", "    local function length(interval)\n        return interval[2] - interval[1]\
    \ + 1\n    end\n    local a1, a2 = table.unpack(interval1)\n    local b1, b2 =\
    \ table.unpack(interval2)\n    local int1 = {math.max(a1, b1), math.min(a2, b2)}\n\
    \    local int2 = {math.min(a1, b1), math.max(a2, b2)}\n    if int1[1] > int1[2]\
    \ then\n        return 'NO'\n    end\n    local len = length(int1)\n    local\
    \ flag = true\n    for i = 2, math.sqrt(len) do\n        if len % i == 0 then\n\
    \            flag = false\n            break\n        end\n    end\n    if flag\
    \ and len ~= 1 then\n        return 'YES'\n    end\n    return 'NO'\nend", " \
    \   local s1, e1 = interval1[1], interval1[2]\n    local s2, e2 = interval2[1],\
    \ interval2[2]\n    if s1 > e1 then s1, e1 = e1, s1 end\n    if s2 > e2 then s2,\
    \ e2 = e2, s2 end\n    local s, e = math.max(s1, s2), math.min(e1, e2)\n    local\
    \ len = e - s + 1\n    if len < 0 then return 'NO' end\n    local function isPrime(n)\n\
    \        for i = 2, math.sqrt(n) do\n            if n % i == 0 then return false\
    \ end\n        end\n        return true\n    end\n    return isPrime(len) and\
    \ 'YES' or 'NO'\nend\nreturn intersection", "  local maxStart = math.max(interval1[1],\
    \ interval2[1])\n  local minEnd = math.min(interval1[2], interval2[2])\n  if maxStart\
    \ > minEnd then\n    return 'NO'\n  end\n  local length = minEnd - maxStart +\
    \ 1\n  if length <= 1 then\n    return 'NO'\n  end\n  local isPrime = true\n \
    \ for i = 2, math.sqrt(length) do\n    if length % i == 0 then\n      isPrime\
    \ = false\n      break\n    end\n  end\n  if isPrime then\n    return 'YES'\n\
    \  else\n    return 'NO'\n  end\nend", "    local pointA = math.max(interval1[1],\
    \ interval2[1])\n    local pointB = math.min(interval1[2], interval2[2])\n   \
    \ local length = pointB - pointA + 1\n    if length <= 0 then\n        return\
    \ 'NO'\n    end\n    for i = 2, math.floor(math.sqrt(length)) do\n        if length\
    \ % i == 0 then\n            return 'NO'\n        end\n    end\n    return 'YES'\n\
    end", "  local lower_bound = math.max(interval1[1], interval2[1])\n  local upper_bound\
    \ = math.min(interval1[2], interval2[2])\n  if lower_bound > upper_bound then\n\
    \    return 'NO'\n  end\n  local length = upper_bound - lower_bound + 1\n  if\
    \ length == 1 then\n    return 'NO'\n  end\n  for i = 2, math.sqrt(length) do\n\
    \    if length % i == 0 then\n      return 'NO'\n    end\n  end\n  return 'YES'\n\
    end", "  -- TODO\nend", "    if interval1[1] > interval2[2] or interval2[1] >\
    \ interval1[2] then\n        return 'NO'\n    end\n    local start = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ local length = finish - start + 1\n    if length < 2 then\n        return 'NO'\n\
    \    end\n    if length == 2 then\n        return 'YES'\n    end\n    if length\
    \ % 2 == 0 then\n        return 'NO'\n    end\n    for i = 3, math.sqrt(length),\
    \ 2 do\n        if length % i == 0 then\n            return 'NO'\n        end\n\
    \    end\n    return 'YES'\nend", "  local s, e = math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])\n  if s <= e then\n    local is_prime =\
    \ function(n)\n      if n <= 1 then return false end\n      for i = 2, math.sqrt(n)\
    \ do\n        if n % i == 0 then return false end\n      end\n      return true\n\
    \    end\n    return is_prime(e - s + 1) and 'YES' or 'NO'\n  end\n  return 'NO'\n\
    end\nreturn intersection", "    -- ...\nend", "    local inter = {math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])}\n    local divisors = {}\n\
    \    if inter[1] > inter[2] then return 'NO' end\n    for i = 2, inter[2] do\n\
    \        while inter[2] % i == 0 do\n            inter[2] = inter[2] / i\n   \
    \         divisors[#divisors + 1] = i\n        end\n    end\n    for i = 2, inter[1]\
    \ do\n        while inter[1] % i == 0 do\n            inter[1] = inter[1] / i\n\
    \            divisors[#divisors + 1] = i\n        end\n    end\n    for i = 2,\
    \ inter[2] do\n        while inter[2] % i == 0 do\n            inter[2] = inter[2]\
    \ / i\n            divisors[#divisors + 1] = i\n        end\n    end\n    for\
    \ i = 2, inter[1] do\n        while inter[1] % i == 0 do\n            inter[1]\
    \ = inter[1] / i\n            divisors[#divisors + 1] = i\n        end\n    end\n\
    \    if #divisors == 0 then return 'YES' end\n    local primes = {}\n    for i\
    \ = 2, divisors[#divisors] / 2 do\n        local isPrime = true\n        for j\
    \ = 2, divisors[#divisors] / 2 do\n            if i % j == 0 and i ~= j then\n\
    \                isPrime = false\n                break\n            end\n   \
    \     end\n        if isPrime then\n            primes[#primes + 1] = i\n    \
    \    end\n    end\n    for i = 1, #primes do\n        for j = 1, #divisors do\n\
    \            if primes[i] == divisors[j] then\n                return 'NO'\n \
    \           end\n        end\n    end\n    return 'YES'\nend", "\t-- check if\
    \ intervals intersect\n\tif (interval1[1] <= interval2[2] and interval1[2] >=\
    \ interval2[1]) then\n\t\t-- check if intersection is prime number\n\t\tif (interval1[1]\
    \ <= interval2[1]) then\n\t\t\tlocal start = interval2[1]\n\t\t\tif (interval1[2]\
    \ <= interval2[2]) then\n\t\t\t\tlocal end = interval1[2]\n\t\t\t\tif (end ==\
    \ start) then return 'NO' end\n\t\t\t\tlocal isPrime = true\n\t\t\t\tfor i = 2,\
    \ math.floor(end/2) do\n\t\t\t\t\tif (end % i == 0) then\n\t\t\t\t\t\tisPrime\
    \ = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif (isPrime)\
    \ then return 'YES' end\n\t\t\telse\n\t\t\t\tlocal end = interval2[2]\n\t\t\t\t\
    if (end == start) then return 'NO' end\n\t\t\t\tlocal isPrime = true\n\t\t\t\t\
    for i = 2, math.floor(end/2) do\n\t\t\t\t\tif (end % i == 0) then\n\t\t\t\t\t\t\
    isPrime = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif (isPrime)\
    \ then return 'YES' end\n\t\t\tend\n\t\telse\n\t\t\tlocal start = interval1[1]\n\
    \t\t\tif (interval1[2] <= interval2[2]) then\n\t\t\t\tlocal end = interval1[2]\n\
    \t\t\t\tif (end == start) then return 'NO' end\n\t\t\t\tlocal isPrime = true\n\
    \t\t\t\tfor i = 2, math.floor(end/2) do\n\t\t\t\t\tif (end % i == 0) then\n\t\t\
    \t\t\t\tisPrime = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\
    \tif (isPrime) then return 'YES' end\n\t\t\telse\n", "  local start1, end1 = table.unpack(interval1)\n\
    \  local start2, end2 = table.unpack(interval2)\n  local start = math.max(start1,\
    \ start2)\n  local finish = math.min(end1, end2)\n  local l = finish - start +\
    \ 1\n  if l < 1 then\n    return 'NO'\n  end\n  if l == 1 then\n    return 'YES'\n\
    \  end\n  if l == 2 then\n    return 'NO'\n  end\n  for i = 2, math.floor(math.sqrt(l))\
    \ do\n    if l % i == 0 then\n      return 'NO'\n    end\n  end\n  return 'YES'\n\
    end", "    local function isPrime(num)\n        for k = 2, num - 1 do\n      \
    \      if num % k == 0 then\n                return false\n            end\n \
    \       end\n        return true\n    end\n    local function getIntersection(interval1,\
    \ interval2)\n        local res = {}\n        if interval1[1] <= interval2[1]\
    \ then\n            if interval1[2] >= interval2[1] then\n                if interval1[2]\
    \ >= interval2[2] then\n                    res = {interval2[1], interval2[2]}\n\
    \                else\n                    res = {interval2[1], interval1[2]}\n\
    \                end\n            end\n        else\n            if interval2[2]\
    \ >= interval1[1] then\n                if interval2[2] >= interval1[2] then\n\
    \                    res = {interval1[1], interval1[2]}\n                else\n\
    \                    res = {interval1[1], interval2[2]}\n                end\n\
    \            end\n        end\n        return res\n    end\n    local intersect\
    \ = getIntersection(interval1, interval2)\n    if #intersect == 0 then\n     \
    \   return 'NO'\n    end\n    if isPrime(intersect[2] - intersect[1] + 1) then\n\
    \        return 'YES'\n    end\n    return 'NO'\nend", "  local t = {}\n  for\
    \ i = interval1[1], interval1[2] do t[i] = true end\n  for i = interval2[1], interval2[2]\
    \ do\n    if t[i] then\n      local r = {}\n      for j = i, interval2[2] do r[j]\
    \ = true end\n      for k = interval1[1], i do r[k] = true end\n      return is_prime(table.getn(r))\
    \ and 'YES' or 'NO'\n    end\n  end\n  return 'NO'\nend", "  local s1, e1 = interval1[1],\
    \ interval1[2]\n  local s2, e2 = interval2[1], interval2[2]\n  if (s1 >= e2) or\
    \ (s2 >= e1) then\n    return 'NO'\n  end\n  local c = math.max(s1, s2)\n  local\
    \ d = math.min(e1, e2)\n  return isPrime(d - c + 1) and 'YES' or 'NO'\nend", " \
    \   -- your code goes here\n    local isPrime = true\n    local start = math.max(interval1[1],\
    \ interval2[1])\n    local endy = math.min(interval1[2], interval2[2])\n    local\
    \ length = endy - start\n    if length <= 0 then\n        return 'NO'\n    end\n\
    \    for i = 2, math.floor(length / 2) do\n        if length % i == 0 then\n \
    \           isPrime = false\n            break\n        end\n    end\n    if isPrime\
    \ then\n        return 'YES'\n    else\n        return 'NO'\n    end\nend", " \
    \   local low = math.max(interval1[1], interval2[1])\n    local high = math.min(interval1[2],\
    \ interval2[2])\n    local result = \"NO\"\n    if low <= high then\n        local\
    \ diff = high - low + 1\n        local isPrime = true\n        for i = 2, math.sqrt(diff)\
    \ do\n            if diff % i == 0 then\n                isPrime = false\n   \
    \             break\n            end\n        end\n        if isPrime then\n \
    \           result = \"YES\"\n        end\n    end\n    return result\nend", "\t\
    local function isPrime(n)\n\t\tif n <= 1 then return false end\n\t\tfor i = 2,\
    \ math.floor(math.sqrt(n)) do\n\t\t\tif n % i == 0 then return false end\n\t\t\
    end\n\t\treturn true\n\tend\n\t\n\tlocal start1, end1 = table.unpack(interval1)\n\
    \tlocal start2, end2 = table.unpack(interval2)\n\tlocal start, end = math.max(start1,\
    \ start2), math.min(end1, end2)\n\tif start > end then return 'NO' end\n\treturn\
    \ isPrime(end - start + 1) and 'YES' or 'NO'\nend", "  local s1, e1 = interval1[1],\
    \ interval1[2]\n  local s2, e2 = interval2[1], interval2[2]\n  local intersection\
    \ = {}\n  if s1 > e2 or s2 > e1 then return 'NO' end\n  for i = s1, e1 do\n  \
    \  for j = s2, e2 do\n      if i == j then\n        table.insert(intersection,\
    \ i)\n      end\n    end\n  end\n  return isPrime(#intersection) and 'YES' or\
    \ 'NO'\nend", "    -- \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0438\
    \u043D\u0442\u0435\u0440\u0432\u0430\u043B\u044B \u043D\u0430 \u043F\u0435\u0440\
    \u0435\u0441\u0435\u0447\u0435\u043D\u0438\u0435\n    if (interval1[1] <= interval2[1]\
    \ and interval1[2] >= interval2[1]) or (interval1[1] <= interval2[2] and interval1[2]\
    \ >= interval2[2]) or (interval2[1] <= interval1[1] and interval2[2] >= interval1[1])\
    \ or (interval2[1] <= interval1[2] and interval2[2] >= interval1[2]) then\n  \
    \      -- \u041E\u043F\u0440\u0435\u0434\u0435\u043B\u044F\u0435\u043C \u0433\u0440\
    \u0430\u043D\u0438\u0446\u044B \u043F\u0435\u0440\u0435\u0441\u0435\u0447\u0435\
    \u043D\u0438\u044F\n        local left = math.max(interval1[1], interval2[1])\n\
    \        local right = math.min(interval1[2], interval2[2])\n        -- \u041E\
    \u043F\u0440\u0435\u0434\u0435\u043B\u044F\u0435\u043C \u0434\u043B\u0438\u043D\
    \u0443 \u043F\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043D\u0438\u044F \u0438\
    \u043D\u0442\u0435\u0440\u0432\u0430\u043B\u043E\u0432\n        local len = right\
    \ - left + 1\n        -- \u041E\u043F\u0440\u0435\u0434\u0435\u043B\u044F\u0435\
    \u043C \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043B\u0438 \u0434\u043B\
    \u0438\u043D\u0430 \u043F\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043D\u0438\
    \u044F \u043F\u0440\u043E\u0441\u0442\u044B\u043C \u0447\u0438\u0441\u043B\u043E\
    \u043C\n        local simple = true\n        for i = 2, len - 1 do\n         \
    \   if len % i == 0 then\n                simple = false\n                break\n\
    \            end\n        end\n        if simple then\n            return 'YES'\n\
    \        else\n            return 'NO'\n        end\n    else\n        return\
    \ 'NO'\n    end\nend", "    local st1, en1 = interval1[1], interval1[2]\n    local\
    \ st2, en2 = interval2[1], interval2[2]\n    local start, finish\n    if st1 <=\
    \ st2 then\n        start = st2\n    else\n        start = st1\n    end\n    if\
    \ en1 <= en2 then\n        finish = en1\n    else\n        finish = en2\n    end\n\
    \    if start > finish then\n        return 'NO'\n    end\n    local len = finish\
    \ - start + 1\n    local result = 'NO'\n    for i = 2, math.floor(math.sqrt(len))\
    \ do\n        if len % i == 0 then\n            result = 'NO'\n            break\n\
    \        else\n            result = 'YES'\n        end\n    end\n    return result\n\
    end", "  local start = math.max(interval1[1], interval2[1])\n  local finish =\
    \ math.min(interval1[2], interval2[2])\n  if finish < start then\n    return 'NO'\n\
    \  end\n  local prime = true\n  for i = 2, math.floor(math.sqrt(finish - start))\
    \ do\n    if (finish - start) % i == 0 then\n      prime = false\n      break\n\
    \    end\n  end\n  if prime then\n    return 'YES'\n  else\n    return 'NO'\n\
    \  end\nend", "  local min = math.max(interval1[1], interval2[1])\n  local max\
    \ = math.min(interval1[2], interval2[2])\n  if min > max then\n    return 'NO'\n\
    \  end\n  local len = max - min + 1\n  local is_prime = true\n  for i = 2, math.sqrt(len)\
    \ do\n    if len % i == 0 then\n      is_prime = false\n      break\n    end\n\
    \  end\n  if is_prime then\n    return 'YES'\n  else\n    return 'NO'\n  end\n\
    end", "    local strIntersection = 'NO'\n    local isIntersection = interval1[1]\
    \ <= interval2[2] and interval2[1] <= interval1[2]\n    if isIntersection then\n\
    \        local startIntersection = math.max(interval1[1], interval2[1])\n    \
    \    local endIntersection = math.min(interval1[2], interval2[2])\n        local\
    \ lengthIntersection = endIntersection - startIntersection + 1\n        if lengthIntersection\
    \ >= 2 then\n            local isPrime = true\n            for i = 2, math.floor(math.sqrt(lengthIntersection))\
    \ do\n                if lengthIntersection % i == 0 then\n                  \
    \  isPrime = false\n                    break\n                end\n         \
    \   end\n            if isPrime then\n                strIntersection = 'YES'\n\
    \            end\n        end\n    end\n    return strIntersection\nend", "  if\
    \ not interval1 or not interval2 then\n    return 'NO'\n  end\n  local a, b =\
    \ interval1[1], interval1[2]\n  local c, d = interval2[1], interval2[2]\n  local\
    \ s = math.max(a, c)\n  local e = math.min(b, d)\n  if s <= e then\n    if isPrime(e\
    \ - s + 1) then\n      return 'YES'\n    else\n      return 'NO'\n    end\n  else\n\
    \    return 'NO'\n  end\nend", "\tlocal start = math.max(interval1[1], interval2[1])\n\
    \tlocal finish = math.min(interval1[2], interval2[2])\n\tif finish < start then\
    \ return 'NO' end\n\tlocal prime = true\n\tfor i = 2, finish - start do\n\t\t\
    if (finish - start) % i == 0 then prime = false end\n\tend\n\treturn prime and\
    \ 'YES' or 'NO'\nend", "\t-- start, end = index1, index2\n\tlocal start, end =\
    \ math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])\n\
    \tlocal diff = end - start\n\treturn (diff < 0) and 'NO' or (diff == 0 and 'YES'\
    \ or isPrime(diff))\nend\nprint(intersection({1, 2}, {2, 3}))\nprint(intersection({-1,\
    \ 1}, {0, 4}))\nprint(intersection({-3, -1}, {-5, 5}))", "\tlocal function isprime(x)\n\
    \t\tif x <= 1 then return false end\n\t\tfor i = 2, x - 1 do\n\t\t\tif x % i ==\
    \ 0 then return false end\n\t\tend\n\t\treturn true\n\tend\n\tlocal s1, e1 = interval1[1],\
    \ interval1[2]\n\tlocal s2, e2 = interval2[1], interval2[2]\n\tif s1 <= s2 then\n\
    \t\tif e1 >= s2 then\n\t\t\treturn isprime(e1 - s2 + 1) and 'YES' or 'NO'\n\t\t\
    else\n\t\t\treturn 'NO'\n\t\tend\n\telse\n\t\tif e2 >= s1 then\n\t\t\treturn isprime(e2\
    \ - s1 + 1) and 'YES' or 'NO'\n\t\telse\n\t\t\treturn 'NO'\n\t\tend\n\tend\nend",
  "    local prime = function(n)\n        if n < 2 then return false end\n       \
    \ for i = 2, math.floor(math.sqrt(n)) do\n            if n % i == 0 then return\
    \ false end\n        end\n        return true\n    end\n    if interval1[1] >\
    \ interval2[2] or interval2[1] > interval1[2] then\n        return 'NO'\n    end\n\
    \    local max1 = math.max(interval1[1], interval2[1])\n    local min2 = math.min(interval1[2],\
    \ interval2[2])\n    return prime(min2 - max1 + 1) and 'YES' or 'NO'\nend", " \
    \ if interval1[1] >= interval2[2] or interval2[1] >= interval1[2] then\n    return\
    \ 'NO'\n  end\n  local min, max = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n  local len = max - min + 1\n  if len < 2 then\n    return 'NO'\n\
    \  end\n  local flag = true\n  for i = 2, math.floor(math.sqrt(len)) do\n    if\
    \ len % i == 0 then\n      flag = false\n      break\n    end\n  end\n  return\
    \ flag and 'YES' or 'NO'\nend", "    local start = math.max(interval1[1], interval2[1])\n\
    \    local finish = math.min(interval1[2], interval2[2])\n    local length = finish\
    \ - start\n    if length < 0 then\n        return 'NO'\n    end\n    local primes\
    \ = {0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1}\n    return\
    \ (primes[length] == 1) and 'YES' or 'NO'\nend", "    local min = math.max(interval1[1],\
    \ interval2[1])\n    local max = math.min(interval1[2], interval2[2])\n    if\
    \ min > max then\n        return 'NO'\n    end\n    local n = max - min + 1\n\
    \    if n <= 1 then\n        return 'NO'\n    end\n    if n == 2 then\n      \
    \  return 'YES'\n    end\n    if n % 2 == 0 then\n        return 'NO'\n    end\n\
    \    local i = 3\n    while i * i <= n do\n        if n % i == 0 then\n      \
    \      return 'NO'\n        end\n        i = i + 2\n    end\n    return 'YES'\n\
    end", "\tlocal start, finish = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n\tif start > finish then return 'NO' end\n\tlocal function isPrime(num)\n\
    \t\tfor i = 2, math.sqrt(num) do\n\t\t\tif num % i == 0 then return false end\n\
    \t\tend\n\t\treturn true\n\tend\n\treturn isPrime(finish - start + 1) and 'YES'\
    \ or 'NO'\nend", "  local newInterval = {}\n  local intersection = nil\n  local\
    \ intersectionLength = 0\n  if(interval1[1] <= interval2[1]) then\n    newInterval[1]\
    \ = interval2[1]\n  else\n    newInterval[1] = interval1[1]\n  end\n  if(interval1[2]\
    \ <= interval2[2]) then\n    newInterval[2] = interval1[2]\n  else\n    newInterval[2]\
    \ = interval2[2]\n  end\n  if(newInterval[1] <= newInterval[2]) then\n    intersection\
    \ = newInterval\n    intersectionLength = intersection[2] - intersection[1] +\
    \ 1\n  end\n  local isPrime = true\n  if(intersectionLength ~= nil) then\n   \
    \ for i = 2, intersectionLength - 1 do\n      if(intersectionLength % i == 0)\
    \ then\n        isPrime = false\n        break\n      end\n    end\n  end\n  if(isPrime)\
    \ then\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "    local\
    \ start, finish = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n    if start > finish then return 'NO' end\n    local n = finish\
    \ - start + 1\n    if n <= 1 then return 'NO' end\n    for i = 2, math.floor(math.sqrt(n))\
    \ do\n        if n % i == 0 then return 'NO' end\n    end\n    return 'YES'\n\
    end", "    local interval = {}\n    interval.start = math.max(interval1.start,\
    \ interval2.start)\n    interval.end = math.min(interval1.end, interval2.end)\n\
    \    if interval.start > interval.end then\n        return 'NO'\n    end\n   \
    \ if is_prime(interval.end - interval.start + 1) then\n        return 'YES'\n\
    \    end\n    return 'NO'\nend", "  local start = math.max(interval1[1], interval2[1])\n\
    \  local stop = math.min(interval1[2], interval2[2])\n  local isPrime = function(number)\n\
    \    if number < 2 then return false end\n    for i = 2, number - 1 do\n     \
    \ if number % i == 0 then return false end\n    end\n    return true\n  end\n\
    \  return isPrime(stop - start + 1) and 'YES' or 'NO'\nend", "    local intersection\
    \ = {}\n    for i = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2]) do\n        intersection[#interval1 + 1] = i\n    end\n    return\
    \ #intersection > 0 and isPrime(#intersection) and 'YES' or 'NO'\nend", "  if\
    \ interval1[1] > interval2[2] or interval2[1] > interval1[2] then\n    return\
    \ 'NO'\n  end\n  local \n  local start, end\n  if interval1[1] > interval2[1]\
    \ then\n    start = interval1[1]\n  else\n    start = interval2[1]\n  end\n  if\
    \ interval1[2] < interval2[2] then\n    end = interval1[2]\n  else\n    end =\
    \ interval2[2]\n  end\n  local length = end - start + 1\n  if length < 0 then\n\
    \    return 'NO'\n  end\n  if length < 2 then\n    return 'YES'\n  end\n  if length\
    \ < 4 then\n    return 'NO'\n  end\n  if length % 2 == 0 then\n    return 'NO'\n\
    \  end\n  local i = 3\n  while i * i <= length do\n    if length % i == 0 then\n\
    \      return 'NO'\n    end\n    i = i + 2\n  end\n  return 'YES'\nend", "   \
    \ local int1 = {}\n    local int2 = {}\n    for i, v in ipairs(interval1) do\n\
    \        int1[i] = v\n    end\n    for i, v in ipairs(interval2) do\n        int2[i]\
    \ = v\n    end\n    table.sort(int1)\n    table.sort(int2)\n    local result =\
    \ {math.max(int1[1], int2[1]), math.min(int1[2], int2[2])}\n    if result[1] >\
    \ result[2] then\n        return 'NO'\n    end\n    local isPrime = true\n   \
    \ for i = 2, math.floor(result[2]/2) do\n        if result[2] % i == 0 then\n\
    \            isPrime = false\n            break\n        end\n    end\n    if\
    \ isPrime then\n        return 'YES'\n    else\n        return 'NO'\n    end\n\
    end\nreturn intersection", "  local intersection = {math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])}\n  if intersection[1] > intersection[2]\
    \ then\n    return 'NO'\n  end\n  local function isPrime(n)\n    if n < 2 then\n\
    \      return false\n    end\n    local i = 2\n    while i * i <= n do\n     \
    \ if n % i == 0 then\n        return false\n      end\n      i = i + 1\n    end\n\
    \    return true\n  end\n  return isPrime(intersection[2] - intersection[1] +\
    \ 1) and 'YES' or 'NO'\nend", "  local x, y, z, w = unpack(interval1), unpack(interval2)\n\
    \  if z <= x or y <= w then return 'NO' end\n  if x <= z and z <= y then x = z\
    \ end\n  if x <= w and w <= y then y = w end\n  return y - x > 1 and 'NO' or 'YES'\n\
    end", "\tlocal res = {};\n\tfor i=1,#interval1 do\n\t\tres[i] = math.max(interval1[i],\
    \ interval2[i]);\n\tend\n\tlocal diff = res[2] - res[1];\n\tlocal halfDiff = math.floor(diff\
    \ / 2);\n\tlocal isPrime = true;\n\tfor i=2,halfDiff do\n\t\tif diff % i == 0\
    \ then\n\t\t\tisPrime = false;\n\t\t\tbreak;\n\t\tend\n\tend\n\tif isPrime then\n\
    \t\treturn 'YES';\n\telse\n\t\treturn 'NO';\n\tend\nend", "  local start1, end1\
    \ = table.unpack(interval1)\n  local start2, end2 = table.unpack(interval2)\n\
    \  if end1 < start2 or end2 < start1 then\n    return 'NO'\n  end\n  local inter_len\
    \ = math.min(end1, end2) - math.max(start1, start2) + 1\n  local is_prime = true\n\
    \  for i = 2, math.floor(math.sqrt(inter_len)) do\n    if inter_len % i == 0 then\n\
    \      is_prime = false\n      break\n    end\n  end\n  return is_prime and 'YES'\
    \ or 'NO'\nend", "    if (interval1[1] > interval2[2] or interval2[1] > interval1[2])\
    \ then\n        return 'NO'\n    end\n    local begin = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ local len = finish - begin + 1\n    for i = 2, math.sqrt(len) do\n        if\
    \ (len % i == 0) then\n            return 'NO'\n        end\n    end\n    return\
    \ 'YES'\nend\nreturn intersection", "  local start = math.max(interval1[1], interval2[1])\n\
    \  local end_ = math.min(interval1[2], interval2[2])\n  local length = end_ -\
    \ start + 1\n  if length < 0 then\n    return 'NO'\n  end\n  local prime = true\n\
    \  local i = length\n  while i > 1 do\n    if length % i == 0 then\n      prime\
    \ = false\n      break\n    end\n    i = i - 1\n  end\n  if prime then\n    return\
    \ 'YES'\n  else\n    return 'NO'\n  end\nend", "    local start = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ local result = \"NO\"\n    if start <= finish then\n        local is_prime =\
    \ true\n        for i = 2, finish - start do\n            if (finish - start)\
    \ % i == 0 then\n                is_prime = false\n                break\n   \
    \         end\n        end\n        if is_prime then\n            result = \"\
    YES\"\n        end\n    end\n    return result\nend", "  -- your code goes here\n\
    \  local from = math.max(interval1[1], interval2[1])\n  local to = math.min(interval1[2],\
    \ interval2[2])\n  local length = to - from + 1\n  return length > 0 and is_prime(length)\
    \ and 'YES' or 'NO'\nend", "    local int = {max(interval1[1], interval2[1]),\
    \ min(interval1[2], interval2[2])}\n    if int[1] <= int[2] then\n        local\
    \ n = int[2] - int[1] + 1\n        for i = 2, n - 1 do\n            if n % i ==\
    \ 0 then\n                return 'NO'\n            end\n        end\n        return\
    \ 'YES'\n    end\n    return 'NO'\nend", "  local a1, a2 = table.unpack(interval1)\n\
    \  local b1, b2 = table.unpack(interval2)\n  local c1 = math.max(a1, b1)\n  local\
    \ c2 = math.min(a2, b2)\n  local prime = {1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n  if c1 > c2 then\n\
    \    return 'NO'\n  else\n    for i = 1, 26 do\n      if (c2 - c1 + 1) == prime[i]\
    \ then\n        return 'YES'\n      end\n    end\n    return 'NO'\n  end\nend",
  "\tlocal ints = {}\n\tfor i = 1, 2 do\n\t\tlocal int = {}\n\t\tlocal p1, p2 = math.min(interval1[i],\
    \ interval2[i]), math.max(interval1[i], interval2[i])\n\t\tif p1 <= p2 then\n\t\
    \t\tint.start = p1\n\t\t\tint.end = p2\n\t\tend\n\t\tints[i] = int\n\tend\n\t\
    local function isPrime(n)\n\t\tif n <= 1 then return false end\n\t\tif n == 2\
    \ then return true end\n\t\tfor i = 2, math.sqrt(n) do\n\t\t\tif n % i == 0 then\
    \ return false end\n\t\tend\n\t\treturn true\n\tend\n\tlocal length = ints[1].end\
    \ - ints[1].start + 1\n\treturn isPrime(length) and \"YES\" or \"NO\"\nend", " \
    \ local function isPrime(n)\n    for i = 2, math.floor(math.sqrt(n)) do\n    \
    \  if n % i == 0 then\n        return false\n      end\n    end\n    return true\n\
    \  end\n  local s, e = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n  return (s <= e) and (isPrime(e - s + 1) and 'YES' or 'NO')\
    \ or 'NO'\nend", "  local function is_prime(n)\n    for i = 2, math.floor(math.sqrt(n))\
    \ do\n      if n % i == 0 then\n        return false\n      end\n    end\n   \
    \ return true\n  end\n  local function max(a, b)\n    if a > b then\n      return\
    \ a\n    else\n      return b\n    end\n  end\n  local function min(a, b)\n  \
    \  if a < b then\n      return a\n    else\n      return b\n    end\n  end\n \
    \ local start1, end1 = interval1[1], interval1[2]\n  local start2, end2 = interval2[1],\
    \ interval2[2]\n  local start = max(start1, start2)\n  local end_ = min(end1,\
    \ end2)\n  if start < end_ then\n    return is_prime(end_ - start) and 'YES' or\
    \ 'NO'\n  else\n    return 'NO'\n  end\nend", "  local start1, end1 = interval1[1],\
    \ interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n  local isPrime\
    \ = function(n)\n    if n == 1 then return false end\n    if n == 2 then return\
    \ true end\n    if n % 2 == 0 then return false end\n    for i = 3, math.sqrt(n),\
    \ 2 do\n      if n % i == 0 then return false end\n    end\n    return true\n\
    \  end\n  if end1 < start2 or end2 < start1 then return 'NO' end\n  local min\
    \ = math.max(start1, start2)\n  local max = math.min(end1, end2)\n  local length\
    \ = max - min + 1\n  return isPrime(length) and 'YES' or 'NO'\nend", "    local\
    \ start, end_ = -1, -1\n    if interval1[1] <= interval2[1] then\n        start\
    \ = interval2[1]\n    else\n        start = interval1[1]\n    end\n    if interval1[2]\
    \ <= interval2[2] then\n        end_ = interval1[2]\n    else\n        end_ =\
    \ interval2[2]\n    end\n    if start > end_ then\n        return 'NO'\n    end\n\
    \    for i = start, end_ do\n        if i == 1 then\n            return 'NO'\n\
    \        end\n        if i % 2 == 0 then\n            return 'NO'\n        end\n\
    \        for j = 3, math.sqrt(i) do\n            if i % j == 0 then\n        \
    \        return 'NO'\n            end\n        end\n    end\n    return 'YES'\n\
    end", "  local start, end_ = table.unpack(interval1)\n  local start2, end_2 =\
    \ table.unpack(interval2)\n  if start > end_ or start2 > end_2 then\n    return\
    \ 'NO'\n  end\n  if (start2 >= start and start2 <= end_) or (start >= start2 and\
    \ start <= end_2) then\n    local length = math.min(end_, end_2) - math.max(start,\
    \ start2) + 1\n    if length <= 1 then\n      return 'NO'\n    end\n    local\
    \ primes = { [1] = true, [2] = true, [3] = true, [5] = true, [7] = true, [11]\
    \ = true, [13] = true, [17] = true, [19] = true, [23] = true, [29] = true, [31]\
    \ = true, [37] = true, [41] = true, [43] = true, [47] = true, [53] = true, [59]\
    \ = true, [61] = true, [67] = true, [71] = true, [73] = true, [79] = true, [83]\
    \ = true, [89] = true, [97] = true, [101] = true, [103] = true, [107] = true,\
    \ [109] = true, [113] = true, [127] = true, [131] = true, [137] = true, [139]\
    \ = true, [149] = true, [151] = true, [157] = true, [163] = true, [167] = true,\
    \ [173] = true, [179] = true, [181] = true, [191] = true, [193] = true, [197]\
    \ = true, [199] = true, [211] = true, [223] = true, [227] = true, [229] = true,\
    \ [233] = true, [239] = true, [241] = true, [251] = true, [257] = true, [263]\
    \ = true, [269] = true, [271] = true, [277] = true, [281] = true, [283] = true,",
  "    local inter1 = {math.min(interval1[1], interval1[2]), math.max(interval1[1],\
    \ interval1[2])}\n    local inter2 = {math.min(interval2[1], interval2[2]), math.max(interval2[1],\
    \ interval2[2])}\n    if inter1[2] < inter2[1] or inter2[2] < inter1[1] then\n\
    \        return 'NO'\n    end\n    local intersection = {math.max(inter1[1], inter2[1]),\
    \ math.min(inter1[2], inter2[2])}\n    local len = intersection[2] - intersection[1]\
    \ + 1\n    if len == 1 then\n        return 'NO'\n    end\n    local isPrime =\
    \ function(n)\n        if n < 2 then\n            return false\n        end\n\
    \        if n == 2 then\n            return true\n        end\n        for i =\
    \ 2, math.sqrt(n) do\n            if n % i == 0 then\n                return false\n\
    \            end\n        end\n        return true\n    end\n    return isPrime(len)\
    \ and 'YES' or 'NO'\nend", "  local start = math.max(interval1[1], interval2[1])\n\
    \  local stop = math.min(interval1[2], interval2[2])\n  local length = math.max(stop\
    \ - start + 1, 0)\n  local is_prime = true\n  if length <= 1 then\n    is_prime\
    \ = false\n  else\n    for i = 2, length - 1 do\n      if length % i == 0 then\n\
    \        is_prime = false\n        break\n      end\n    end\n  end\n  return\
    \ is_prime and 'YES' or 'NO'\nend", "    -- \u041E\u043F\u0440\u0435\u0434\u0435\
    \u043B\u044F\u0435\u043C \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\
    \u043E \u043E\u0431\u0449\u0438\u0445 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\
    \u043E\u0432\n    local count = 0\n    for i = interval1[1], interval1[2] do\n\
    \        for j = interval2[1], interval2[2] do\n            if i == j then\n \
    \               count = count + 1\n            end\n        end\n    end\n   \
    \ -- \u041E\u043F\u0440\u0435\u0434\u0435\u043B\u044F\u0435\u043C \u043F\u0440\
    \u043E\u0441\u0442\u043E\u0435 \u043B\u0438 \u0447\u0438\u0441\u043B\u043E \u043A\
    \u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043E\u0431\u0449\u0438\
    \u0445 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432\n    local is_prime\
    \ = true\n    if count > 1 then\n        for i = 2, count - 1 do\n           \
    \ if count % i == 0 then\n                is_prime = false\n                break\n\
    \            end\n        end\n    end\n    -- \u0412\u043E\u0437\u0432\u0440\u0430\
    \u0449\u0430\u0435\u043C \u0440\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\
    \n    if is_prime then\n        return 'YES'\n    else\n        return 'NO'\n\
    \    end\nend", "\tlocal start, end_ = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n\tif start > end_ then return 'NO' end\n\treturn (end_ - start)\
    \ % 2 == 0 and 'NO' or 'YES'\nend", "    local intersectStart = math.max(interval1[1],\
    \ interval2[1])\n    local intersectEnd = math.min(interval1[2], interval2[2])\n\
    \    local intersectLength = intersectEnd - intersectStart + 1\n    if intersectLength\
    \ < 1 then\n        return 'NO'\n    end\n    if intersectLength == 1 then\n \
    \       return 'YES'\n    end\n    local i = 2\n    while i <= intersectLength\
    \ do\n        if intersectLength % i == 0 then\n            return 'NO'\n    \
    \    end\n        i = i + 1\n    end\n    return 'YES'\nend", "    local st, en\
    \ = #interval1, #interval2\n    local tmp = {}\n    if interval1[st] >= interval2[1]\
    \ and interval1[st] <= interval2[en] then\n        table.insert(tmp, interval1[st])\n\
    \    end\n    if interval1[1] >= interval2[1] and interval1[1] <= interval2[en]\
    \ then\n        table.insert(tmp, interval1[1])\n    end\n    if interval2[st]\
    \ >= interval1[1] and interval2[st] <= interval1[en] then\n        table.insert(tmp,\
    \ interval2[st])\n    end\n    if interval2[1] >= interval1[1] and interval2[1]\
    \ <= interval1[en] then\n        table.insert(tmp, interval2[1])\n    end\n  \
    \  if #tmp < 2 then\n        return 'NO'\n    end\n    local min = math.min(unpack(tmp))\n\
    \    local max = math.max(unpack(tmp))\n    if (max - min) == 0 then\n       \
    \ return 'NO'\n    end\n    for i = 2, (max - min) - 1 do\n        if (max - min)\
    \ % i == 0 then\n            return 'NO'\n        end\n    end\n    return 'YES'\n\
    end", "    local inter = {}\n    local function inrange(c, a, b)\n        return\
    \ a <= c and c <= b\n    end\n    inter[1] = math.max(interval1[1], interval2[1])\n\
    \    inter[2] = math.min(interval1[2], interval2[2])\n    if inrange(inter[1],\
    \ interval1[1], interval1[2]) or inrange(inter[1], interval2[1], interval2[2])\
    \ then\n        local n = inter[2] - inter[1] + 1\n        local is_prime = true\n\
    \        for i = 2, math.floor(math.sqrt(n)) do\n            if n % i == 0 then\n\
    \                is_prime = false\n                break\n            end\n  \
    \      end\n        if is_prime then\n            return 'YES'\n        else\n\
    \            return 'NO'\n        end\n    else\n        return 'NO'\n    end\n\
    end", "  local lowerBound = math.max(interval1[1], interval2[1])\n  local upperBound\
    \ = math.min(interval1[2], interval2[2])\n  if lowerBound > upperBound then\n\
    \    return 'NO'\n  end\n  local intersectionLength = upperBound - lowerBound\
    \ + 1\n  for i = 2, math.sqrt(intersectionLength) do\n    if intersectionLength\
    \ % i == 0 then\n      return 'NO'\n    end\n  end\n  return 'YES'\nend", "  --\
    \ find the intervals intersection\n  local interval3 = {start=0, end=0}\n  interval3.start\
    \ = math.max(interval1.start, interval2.start)\n  interval3.end = math.min(interval1.end,\
    \ interval2.end)\n  if interval3.start > interval3.end then\n    return 'NO'\n\
    \  end\n  local length = interval3.end - interval3.start + 1\n  if length < 2\
    \ then\n    return 'NO'\n  end\n  -- check if the length is a prime number\n \
    \ local i = 2\n  while i <= math.sqrt(length) do\n    if length % i == 0 then\n\
    \      return 'NO'\n    end\n    i = i + 1\n  end\n  return 'YES'\nend", "   \
    \ local x1, y1 = interval1[1], interval1[2]\n    local x2, y2 = interval2[1],\
    \ interval2[2]\n    local x = math.max(x1, x2)\n    local y = math.min(y1, y2)\n\
    \    if x > y then return 'NO' end\n    local primes = {2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n  \
    \  local len = y - x + 1\n    for i = 1, #primes do\n        if primes[i] == len\
    \ then return 'YES' end\n    end\n    return 'NO'\nend", "  local a, b = interval1[1],\
    \ interval1[2]\n  local c, d = interval2[1], interval2[2]\n  if c <= b and d >=\
    \ a then\n    local e, f = max(a, c), min(b, d)\n    local res = f - e + 1\n \
    \   if res == 1 then return 'NO' end\n    for i = 2, floor(sqrt(res)) do\n   \
    \   if res % i == 0 then return 'NO' end\n    end\n    return 'YES'\n  end\n \
    \ return 'NO'\nend", "  local start1, end1 = interval1[1], interval1[2]\n  local\
    \ start2, end2 = interval2[1], interval2[2]\n  if start1 <= start2 and end1 >=\
    \ start2 then\n    if start1 <= end2 and end1 >= end2 then\n      return start2\
    \ - start1 == 2 or end1 - end2 == 2\n    else\n      return end1 - start2 == 2\n\
    \    end\n  elseif start2 <= start1 and end2 >= start1 then\n    if start2 <=\
    \ end1 and end2 >= end1 then\n      return start1 - start2 == 2 or end2 - end1\
    \ == 2\n    else\n      return end2 - start1 == 2\n    end\n  else\n    return\
    \ false\n  end\nend", "    local points = {}\n    for _, pair in ipairs {interval1,\
    \ interval2} do\n        for i = pair[1], pair[2] do\n            table.insert(points,\
    \ i)\n        end\n    end\n    local points = table.toSet(points)\n    local\
    \ min, max = math.min(unpack(points)), math.max(unpack(points))\n    local isPrime\
    \ = function(n)\n        if n == 1 then return false end\n        if n == 2 then\
    \ return true end\n        if n % 2 == 0 then return false end\n        for i\
    \ = 3, math.sqrt(n), 2 do\n            if n % i == 0 then return false end\n \
    \       end\n        return true\n    end\n    return isPrime(max - min + 1) and\
    \ 'YES' or 'NO'\nend", "    if interval1[1] > interval2[2] or interval2[1] > interval1[2]\
    \ then\n        return 'NO'\n    end\n    local min = math.max(interval1[1], interval2[1])\n\
    \    local max = math.min(interval1[2], interval2[2])\n    local n = max - min\
    \ + 1\n    if n < 2 then\n        return 'NO'\n    end\n    local np = {2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97}\n    local sp = {4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22,\
    \ 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48,\
    \ 49, 50, 51, 52, 54, 55, 56, 57, 58, 60, 62, 63, 64, 65, 66, 68, 69, 70, 72,\
    \ 74, 75, 76, 77, 78, 80, 81, 82, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95,\
    \ 96, 98, 99, 100}\n    if n % 2 == 0 then\n        return 'NO'\n    end\n   \
    \ for i, v in ipairs(np) do\n        if v == n then\n            return 'YES'\n\
    \        end\n    end\n    for i, v in ipairs(sp) do\n        if v == n then\n\
    \            return 'NO'\n        end\n    end\n    return 'YES'\nend", "  local\
    \ interval = {\n    [1] = interval1[1] > interval2[1] and interval1[1] or interval2[1],\n\
    \    [2] = interval1[2] < interval2[2] and interval1[2] or interval2[2]\n  }\n\
    \  return interval[1] > interval[2] and 'NO' or\n        (function(n) return n\
    \ == 2 or n > 1 and n % 2 ~= 0 and\n        (n % 3 ~= 0 or n == 3) and\n     \
    \   (n % 5 ~= 0 or n == 5) and\n        (n % 7 ~= 0 or n == 7) and\n        (n\
    \ % 11 ~= 0 or n == 11) and\n        (n % 13 ~= 0 or n == 13) and\n        (n\
    \ % 17 ~= 0 or n == 17) and\n        (n % 19 ~= 0 or n == 19) and\n        (n\
    \ % 23 ~= 0 or n == 23) and\n        (n % 29 ~= 0 or n == 29) and\n        (n\
    \ % 31 ~= 0 or n == 31) and\n        (n % 37 ~= 0 or n == 37) and\n        (n\
    \ % 41 ~= 0 or n == 41) and\n        (n % 43 ~= 0 or n == 43) and\n        (n\
    \ % 47 ~= 0 or n == 47) and\n        (n % 53 ~= 0 or n == 53) and\n        (n\
    \ % 59 ~= 0 or n == 59) and\n        (n % 61 ~= 0 or n == 61) and\n        (n\
    \ % 67 ~= 0 or n == 67) and\n        (n % 71 ~= 0 or n == 71) and\n        (n\
    \ % 73 ~= 0 or n == 73) and\n        (n % 79 ~= 0 or n == 79) and\n        (n\
    \ % 83 ~= 0 or n == 83) and\n        (n % 89 ~= 0 or n == 89) and\n        (n\
    \ % 97 ~= 0 or n == 97) and\n        (n % 101 ~= 0 or n == 101) and\n        (n\
    \ % 103 ~= 0 or n == 103) and\n        (n % 107 ~= 0 or n == 107) and", "  local\
    \ x1, y1 = interval1[1], interval1[2]\n  local x2, y2 = interval2[1], interval2[2]\n\
    \  if y1 < x2 or y2 < x1 then return 'NO' end\n  local len = math.min(y1, y2)\
    \ - math.max(x1, x2) + 1\n  local upper = math.floor(math.sqrt(len))\n  for i\
    \ = 2, upper do\n    if len % i == 0 then return 'NO' end\n  end\n  return 'YES'\n\
    end", "  local a, b = interval1[1], interval1[2]\n  local c, d = interval2[1],\
    \ interval2[2]\n  local s, e = a, b\n  if c > a then s = c end\n  if d < b then\
    \ e = d end\n  if s > e then return 'NO' end\n  if s == e then return 'YES' end\n\
    \  if s <= 2 and e >= 2 then return 'YES' end\n  if s <= 3 and e >= 3 then return\
    \ 'YES' end\n  if s <= 5 and e >= 5 then return 'YES' end\n  if s <= 7 and e >=\
    \ 7 then return 'YES' end\n  if s <= 11 and e >= 11 then return 'YES' end\n  if\
    \ s <= 13 and e >= 13 then return 'YES' end\n  if s <= 17 and e >= 17 then return\
    \ 'YES' end\n  if s <= 19 and e >= 19 then return 'YES' end\n  if s <= 23 and\
    \ e >= 23 then return 'YES' end\n  if s <= 29 and e >= 29 then return 'YES' end\n\
    \  if s <= 31 and e >= 31 then return 'YES' end\n  if s <= 37 and e >= 37 then\
    \ return 'YES' end\n  if s <= 41 and e >= 41 then return 'YES' end\n  if s <=\
    \ 43 and e >= 43 then return 'YES' end\n  if s <= 47 and e >= 47 then return 'YES'\
    \ end\n  if s <= 53 and e >= 53 then return 'YES' end\n  if s <= 59 and e >= 59\
    \ then return 'YES' end\n  if s <= 61 and e >= 61 then return 'YES' end\n  if\
    \ s <= 67 and e >= 67 then return 'YES' end\n  if s <= 71 and e >= 71 then return\
    \ 'YES' end\n  if s <= 73 and e >= 73 then return 'YES' end\n  if s <= 79 and\
    \ e >= 79 then return 'YES' end\n  if s <= 83 and e >= 83 then return 'YES' end\n\
    \  if s <= 89 and e >= 89 then return 'YES' end\n  if s <= 97 and e >= 97 then\
    \ return 'YES' end\n  return 'NO'\nend", "  local is_intersected = interval1[1]\
    \ <= interval2[2] and interval2[1] <= interval1[2]\n  if not is_intersected then\n\
    \    return 'NO'\n  end\n  local start = math.max(interval1[1], interval2[1])\n\
    \  local finish = math.min(interval1[2], interval2[2])\n  local len = finish -\
    \ start + 1\n  if len == 1 then\n    return 'NO'\n  end\n  for i = 2, math.sqrt(len)\
    \ do\n    if len % i == 0 then\n      return 'NO'\n    end\n  end\n  return 'YES'\n\
    end", "    local inter = {}\n    if not interval1 or not interval2 then return\
    \ \"NO\" end\n    for i = interval1[1], interval1[2] do\n        for j = interval2[1],\
    \ interval2[2] do\n            if i == j then inter[#inter + 1] = i end\n    \
    \    end\n    end\n    return (#inter > 0 and #inter < 3) and \"YES\" or \"NO\"\
    \nend", "    local first_start, first_end = interval1[1], interval1[2]\n    local\
    \ second_start, second_end = interval2[1], interval2[2]\n    local function get_intersection(first_start,\
    \ first_end, second_start, second_end)\n        if first_start > second_start\
    \ then\n            first_start, first_end, second_start, second_end = second_start,\
    \ second_end, first_start, first_end\n        end\n        if first_end < second_start\
    \ then\n            return nil\n        end\n        if first_end <= second_end\
    \ then\n            return {second_start, first_end}\n        end\n        return\
    \ {second_start, second_end}\n    end\n    local intersection = get_intersection(first_start,\
    \ first_end, second_start, second_end)\n    if not intersection then\n       \
    \ return 'NO'\n    end\n    local start, end = intersection[1], intersection[2]\n\
    \    local function is_prime(n)\n        for i = 2, math.sqrt(n) do\n        \
    \    if n % i == 0 then\n                return false\n            end\n     \
    \   end\n        return true\n    end\n    return is_prime(end - start + 1) and\
    \ 'YES' or 'NO'\nend", "    local start1, end1 = interval1[1], interval1[2]\n\
    \    local start2, end2 = interval2[1], interval2[2]\n    local start, end = math.max(start1,\
    \ start2), math.min(end1, end2)\n    if start > end then return 'NO' end\n   \
    \ return isPrime(end - start + 1) and 'YES' or 'NO'\nend", "\tif interval1[1]\
    \ >= interval2[2] or interval2[1] >= interval1[2] then return 'NO' end\n\tlocal\
    \ start = math.max(interval1[1], interval2[1])\n\tlocal finish = math.min(interval1[2],\
    \ interval2[2])\n\tlocal interval = finish - start\n\tif interval == 1 then return\
    \ 'NO' end\n\tlocal flag = true\n\tfor i = 2, interval - 1 do\n\t\tif interval\
    \ % i == 0 then\n\t\t\tflag = false\n\t\t\tbreak\n\t\tend\n\tend\n\tif flag then\
    \ return 'YES' else return 'NO' end\nend", "    if ((interval1[1] > interval2[2])\
    \ or (interval2[1] > interval1[2])) then\n        return 'NO'\n    end\n    local\
    \ s = math.max(interval1[1], interval2[1])\n    local e = math.min(interval1[2],\
    \ interval2[2])\n    local intersection_length = e - s + 1\n    local flag = false\n\
    \    for i = 2, math.floor(math.sqrt(intersection_length)) do\n        if (intersection_length\
    \ % i == 0) then\n            flag = true\n            break\n        end\n  \
    \  end\n    if (flag) then\n        return 'NO'\n    else\n        return 'YES'\n\
    \    end\nend", "  -- the length of intersection\n  local start1, end1 = interval1[1],\
    \ interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n  local start3,\
    \ end3 = math.max(start1, start2), math.min(end1, end2)\n  local intersect = end3\
    \ - start3\n  return is_prime(intersect) and 'YES' or 'NO'\nend", "  local a,\
    \ b = interval1[1], interval1[2]\n  local c, d = interval2[1], interval2[2]\n\
    \  local e, f = math.max(a, c), math.min(b, d)\n  local n = f - e + 1\n  if n\
    \ < 0 then return 'NO' end\n  for i = 2, math.sqrt(n) do\n    if n % i == 0 then\
    \ return 'NO' end\n  end\n  return 'YES'\nend", "  local x1, x2 = interval1[1],\
    \ interval1[2]\n  local y1, y2 = interval2[1], interval2[2]\n  local lower = math.max(x1,\
    \ y1)\n  local upper = math.min(x2, y2)\n  local length = upper - lower\n  return\
    \ length >= 0 and length % 2 ~= 0 and length % 3 ~= 0 and length % 5 ~= 0 and\
    \ length % 7 ~= 0 and \"YES\" or \"NO\"\nend", "    -- TODO: your code here\n\
    end", "    -- Extract start, end values\n    local start1, end1 = interval1[1],\
    \ interval1[2]\n    local start2, end2 = interval2[1], interval2[2]\n    -- Find\
    \ values in intervals intersection\n    local start = math.max(start1, start2)\n\
    \    local end_ = math.min(end1, end2)\n    if end_ < start then return 'NO' end\n\
    \    -- If length of intersection is prime, return 'YES', otherwise 'NO'\n   \
    \ return end_ - start + 1 == math.pow(end_ - start + 1, 1, 2) and 'YES' or 'NO'\n\
    end", "  local start, finish = -1, -1\n  if interval1[1] >= interval2[1] and interval1[1]\
    \ <= interval2[2] then\n    start = interval1[1]\n  elseif interval2[1] >= interval1[1]\
    \ and interval2[1] <= interval1[2] then\n    start = interval2[1]\n  end\n  if\
    \ interval1[2] >= interval2[1] and interval1[2] <= interval2[2] then\n    finish\
    \ = interval1[2]\n  elseif interval2[2] >= interval1[1] and interval2[2] <= interval1[2]\
    \ then\n    finish = interval2[2]\n  end\n  if start > -1 and finish > -1 then\n\
    \    local len = finish - start + 1\n    if len == 2 then\n      return 'YES'\n\
    \    elseif len % 2 == 0 then\n      return 'NO'\n    else\n      local i = 3\n\
    \      while i * i <= len do\n        if len % i == 0 then\n          return 'NO'\n\
    \        end\n        i = i + 2\n      end\n      return 'YES'\n    end\n  else\n\
    \    return 'NO'\n  end\nend", "\tlocal start = math.max(interval1[1], interval2[1])\n\
    \tlocal end_ = math.min(interval1[2], interval2[2])\n\tlocal len = end_ - start\
    \ + 1\n\tif len > 0 then\n\t\treturn not table.contains(primes, len) and 'NO'\
    \ or 'YES'\n\tend\n\treturn 'NO'\nend", "  local int1_start, int1_end = interval1[1],\
    \ interval1[2]\n  local int2_start, int2_end = interval2[1], interval2[2]\n  local\
    \ left, right\n  if int1_start < int2_start then\n    left = int2_start\n  else\n\
    \    left = int1_start\n  end\n  if int1_end < int2_end then\n    right = int1_end\n\
    \  else\n    right = int2_end\n  end\n  if left > right then\n    return 'NO'\n\
    \  end\n  if left == right then\n    return 'YES'\n  end\n  if left == 1 or right\
    \ == 1 then\n    return 'NO'\n  end\n  for i = 2, right - 1 do\n    if left %\
    \ i == 0 or right % i == 0 then\n      return 'NO'\n    end\n  end\n  return 'YES'\n\
    end", "  local range1, range2 = {}, {}\n  for i = interval1[1], interval1[2] do\n\
    \    range1[i] = true\n  end\n  for i = interval2[1], interval2[2] do\n    range2[i]\
    \ = true\n  end\n  local overlap = {}\n  for i = interval1[1], interval1[2] do\n\
    \    if range2[i] then\n      table.insert(overlap, i)\n    end\n  end\n  for\
    \ i = interval2[1], interval2[2] do\n    if range1[i] then\n      table.insert(overlap,\
    \ i)\n    end\n  end\n  if #overlap == 0 then\n    return 'NO'\n  end\n  local\
    \ function isPrime(n)\n    if n < 2 then\n      return false\n    end\n    if\
    \ n == 2 then\n      return true\n    end\n    if n % 2 == 0 then\n      return\
    \ false\n    end\n    for i = 3, math.sqrt(n) do\n      if n % i == 0 then\n \
    \       return false\n      end\n    end\n    return true\n  end\n  if isPrime(math.abs(overlap[1]\
    \ - overlap[#overlap])) then\n    return 'YES'\n  else\n    return 'NO'\n  end\n\
    end", "    local function intersection_length(interval1, interval2)\n        local\
    \ start = math.max(interval1[1], interval2[1])\n        local finish = math.min(interval1[2],\
    \ interval2[2])\n        return finish - start + 1\n    end\n    local function\
    \ is_prime(n)\n        if n < 2 then\n            return false\n        end\n\
    \        for i = 2, math.sqrt(n) do\n            if n % i == 0 then\n        \
    \        return false\n            end\n        end\n        return true\n   \
    \ end\n    if interval1[1] <= interval2[2] and interval2[1] <= interval1[2] then\n\
    \        return is_prime(intersection_length(interval1, interval2)) and 'YES'\
    \ or 'NO'\n    else\n        return 'NO'\n    end\nend", "    local function getStart(interval)\n\
    \        if interval[1] < interval[2] then\n            return interval[1]\n \
    \       else\n            return interval[2]\n        end\n    end\n    local\
    \ function getEnd(interval)\n        if interval[1] > interval[2] then\n     \
    \       return interval[1]\n        else\n            return interval[2]\n   \
    \     end\n    end\n    local start1 = getStart(interval1)\n    local end1 = getEnd(interval1)\n\
    \    local start2 = getStart(interval2)\n    local end2 = getEnd(interval2)\n\
    \    if end1 < start2 or end2 < start1 then\n        return 'NO'\n    end\n  \
    \  local start = start1 > start2 and start1 or start2\n    local stop = end1 <\
    \ end2 and end1 or end2\n    local length = stop - start + 1\n    if length <=\
    \ 1 then\n        return 'NO'\n    end\n    for i = 2, length - 1 do\n       \
    \ if length % i == 0 then\n            return 'NO'\n        end\n    end\n   \
    \ return 'YES'\nend", "    -- Your code here\n    local st1, en1 = interval1[1],\
    \ interval1[2]\n    local st2, en2 = interval2[1], interval2[2]\n    local start,\
    \ stop = math.max(st1, st2), math.min(en1, en2)\n    if stop >= start then\n \
    \       if start < 0 then start = -start end\n        if stop < 0 then stop =\
    \ -stop end\n        if stop - start == 1 then return 'YES' end\n        local\
    \ function isPrime(n)\n            if n < 2 then return false end\n          \
    \  for i = 2, math.sqrt(n) do\n                if n % i == 0 then return false\
    \ end\n            end\n            return true\n        end\n        return isPrime(stop\
    \ - start) and 'YES' or 'NO'\n    end\n    return 'NO'\nend", "    local x1, x2\
    \ = table.unpack(interval1)\n    local y1, y2 = table.unpack(interval2)\n    if\
    \ (x1 > y2) or (y1 > x2) then\n        return 'NO'\n    end\n    local x_min,\
    \ x_max = math.min(x1, x2), math.max(x1, x2)\n    local y_min, y_max = math.min(y1,\
    \ y2), math.max(y1, y2)\n    local a, b = math.max(x_min, y_min), math.min(x_max,\
    \ y_max)\n    if is_prime(b - a + 1) then\n        return 'YES'\n    else\n  \
    \      return 'NO'\n    end\nend", "    if (interval1[1] <= interval2[1] and interval2[1]\
    \ <= interval1[2]) or\n        (interval2[1] <= interval1[1] and interval1[1]\
    \ <= interval2[2]) then\n            local beg = math.max(interval1[1], interval2[1])\n\
    \            local end_ = math.min(interval1[2], interval2[2])\n            local\
    \ len = end_ - beg + 1\n            return math.isprime(len) and 'YES' or 'NO'\n\
    \    end\n    return 'NO'\nend", "    local a, b = math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])\n    if a > b then return 'NO' end\n  \
    \  local n = a - b + 1\n    return n == 2 or n == 3 or n == 5 or n == 7 or n ==\
    \ 11 or n == 13 or n == 17 or n == 19 and 'YES' or 'NO'\nend\nprint(intersection({1,\
    \ 2}, {2, 3}))\nprint(intersection({-1, 1}, {0, 4}))\nprint(intersection({-3,\
    \ -1}, {-5, 5}))", "    local i1 = interval1[1]\n    local i2 = interval1[2]\n\
    \    local i3 = interval2[1]\n    local i4 = interval2[2]\n    local intersection1\
    \ = math.max(i1, i3)\n    local intersection2 = math.min(i2, i4)\n    if intersection1\
    \ >= intersection2 then\n        return 'NO'\n    end\n    local intersection\
    \ = intersection2 - intersection1\n    if intersection == 0 then\n        return\
    \ 'NO'\n    end\n    if intersection == 1 then\n        return 'YES'\n    end\n\
    \    if intersection % 2 == 0 then\n        return 'NO'\n    end\n    local i\
    \ = 3\n    while i < intersection do\n        if intersection % i == 0 then\n\
    \            return 'NO'\n        end\n        i = i + 2\n    end\n    return\
    \ 'YES'\nend", "  local left, right = interval1[1], interval1[2]\n  if interval2[1]\
    \ > left then left = interval2[1] end\n  if interval2[2] < right then right =\
    \ interval2[2] end\n  local len = right - left + 1\n  if len < 0 then return 'NO'\
    \ end\n  if len == 1 then return 'YES' end\n  if len == 2 then return 'NO' end\n\
    \  if len % 2 == 0 then return 'NO' end\n  for i = 3, math.sqrt(len) do\n    if\
    \ len % i == 0 then return 'NO' end\n  end\n  return 'YES'\nend", "  local start\
    \ = math.max(interval1[1], interval2[1])\n  local stop = math.min(interval1[2],\
    \ interval2[2])\n  if stop < start then return 'NO' end\n  local length = stop\
    \ - start + 1\n  for i = 2, math.sqrt(length) do\n    if length % i == 0 then\
    \ return 'NO' end\n  end\n  return 'YES'\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local stop = math.min(interval1[2], interval2[2])\n  local\
    \ length = stop - start + 1\n  if length <= 0 then\n    return 'NO'\n  end\n \
    \ for i = 2, math.floor(math.sqrt(length)) do\n    if length % i == 0 then\n \
    \     return 'NO'\n    end\n  end\n  return 'YES'\nend", "    local start = math.max(interval1[1],\
    \ interval2[1])\n    local stop = math.min(interval1[2], interval2[2])\n    local\
    \ length = stop - start + 1\n    if length < 1 then\n        return 'NO'\n   \
    \ end\n    for i = 2, math.floor(math.sqrt(length)) do\n        if length % i\
    \ == 0 then\n            return 'NO'\n        end\n    end\n    return 'YES'\n\
    end", "  local inter = { start = 0, end = 0 }\n  if interval1[1] > interval2[1]\
    \ then\n    inter[1] = interval1[1]\n  else\n    inter[1] = interval2[1]\n  end\n\
    \  if interval1[2] < interval2[2] then\n    inter[2] = interval1[2]\n  else\n\
    \    inter[2] = interval2[2]\n  end\n  if inter[1] > inter[2] then\n    return\
    \ 'NO'\n  end\n  if inter[1] == inter[2] then\n    if (inter[1] == 2) or (inter[1]\
    \ == 3) or (inter[1] == 5) then\n      return 'YES'\n    else\n      return 'NO'\n\
    \    end\n  end\n  local prime\n  for i = inter[1], inter[2] do\n    prime = true\n\
    \    for j = 2, math.floor(math.sqrt(i)) do\n      if (i % j) == 0 then\n    \
    \    prime = false\n        break\n      end\n    end\n    if prime then\n   \
    \   return 'YES'\n    end\n  end\n  return 'NO'\nend", "    local a, b = interval1[1],\
    \ interval1[2]\n    local c, d = interval2[1], interval2[2]\n    local x = math.max(a,\
    \ c)\n    local y = math.min(b, d)\n    if x > y then\n        return 'NO'\n \
    \   end\n    local len = y - x + 1\n    if len == 1 then\n        return 'NO'\n\
    \    end\n    if len == 2 then\n        return 'YES'\n    end\n    if len % 2\
    \ == 0 then\n        return 'NO'\n    end\n    for i = 3, math.sqrt(len) do\n\
    \        if len % i == 0 then\n            return 'NO'\n        end\n    end\n\
    \    return 'YES'\nend", "  local start = math.max(interval1[1], interval2[1])\n\
    \  local finish = math.min(interval1[2], interval2[2])\n  local is_prime = true\n\
    \  for i = 2, finish do\n    if start % i == 0 then\n      is_prime = false\n\
    \      break\n    end\n  end\n  return is_prime and 'YES' or 'NO'\nend", "  local\
    \ start = math.max(interval1[1], interval2[1])\n  local finish = math.min(interval1[2],\
    \ interval2[2])\n  if finish < start then\n    return 'NO'\n  end\n  local len\
    \ = finish - start + 1\n  local isPrime = true\n  for i = 2, math.floor(math.sqrt(len))\
    \ do\n    if len % i == 0 then\n      isPrime = false\n      break\n    end\n\
    \  end\n  return isPrime and 'YES' or 'NO'\nend", "  -- Write your code here.\n\
    end", "    local intersection_start, intersection_end\n    if interval1[1] < interval2[1]\
    \ then\n        intersection_start = interval2[1]\n    else\n        intersection_start\
    \ = interval1[1]\n    end\n    if interval1[2] < interval2[2] then\n        intersection_end\
    \ = interval1[2]\n    else\n        intersection_end = interval2[2]\n    end\n\
    \    if intersection_start > intersection_end then\n        return 'NO'\n    end\n\
    \    local len = intersection_end - intersection_start + 1\n    for i = 2, len\
    \ - 1 do\n        if len % i == 0 then\n            return 'NO'\n        end\n\
    \    end\n    return 'YES'\nend", "\tlocal x, y = interval1[1], interval1[2]\n\
    \tlocal a, b = interval2[1], interval2[2]\n\tlocal isect = {}\n\tif b < x or a\
    \ > y then \n\t\treturn 'NO'\n\telseif a <= x and b >= y then\n\t\tisect = {x,\
    \ y}\n\telseif x <= a and y >= b then\n\t\tisect = {a, b}\n\telseif x <= a and\
    \ y <= b then\n\t\tisect = {a, y}\n\telseif x >= a and y >= b then\n\t\tisect\
    \ = {x, b}\n\tend\n\tlocal length = isect[2] - isect[1] + 1\n\tlocal is_prime\
    \ = true\n\tfor i = 2, length - 1 do\n\t\tif length % i == 0 then\n\t\t\tis_prime\
    \ = false\n\t\t\tbreak\n\t\tend\n\tend\n\treturn is_prime and 'YES' or 'NO'\n\
    end", "    local start = math.max(interval1[1], interval2[1])\n    local fin =\
    \ math.min(interval1[2], interval2[2])\n    local len = fin - start + 1\n    if\
    \ len > 0 then\n        if len < 2 then\n            return 'NO'\n        elseif\
    \ len < 4 then\n            return 'YES'\n        else\n            return 'NO'\n\
    \        end\n    else\n        return 'NO'\n    end\nend", "    local start1,\
    \ end1 = interval1[1], interval1[2]\n    local start2, end2 = interval2[1], interval2[2]\n\
    \    if start1 < start2 then\n        start1, end1, start2, end2 = start2, end2,\
    \ start1, end1\n    end\n    local isect_len = end1 - start2\n    if isect_len\
    \ < 0 then\n        return 'NO'\n    end\n    local is_prime = true\n    for k\
    \ = 2, isect_len - 1 do\n        if isect_len % k == 0 then\n            is_prime\
    \ = false\n            break\n        end\n    end\n    return is_prime and 'YES'\
    \ or 'NO'\nend", "    local start1, end1 = table.unpack(interval1)\n    local\
    \ start2, end2 = table.unpack(interval2)\n    if start1 <= start2 then\n     \
    \   if end1 < start2 then\n            return 'NO'\n        else\n           \
    \ local start = start2\n            local end = end1\n            if end1 > end2\
    \ then\n                end = end2\n            end\n            return isPrime(end\
    \ - start + 1) and 'YES' or 'NO'\n        end\n    else\n        if end2 < start1\
    \ then\n            return 'NO'\n        else\n            local start = start1\n\
    \            local end = end2\n            if end2 > end1 then\n             \
    \   end = end1\n            end\n            return isPrime(end - start + 1) and\
    \ 'YES' or 'NO'\n        end\n    end\nend", "\tlocal function isPrime(number)\n\
    \t\tif number < 2 then\n\t\t\treturn false\n\t\tend\n\t\tlocal sqrt = math.sqrt(number)\n\
    \t\tfor i = 2, sqrt do\n\t\t\tif number % i == 0 then\n\t\t\t\treturn false\n\t\
    \t\tend\n\t\tend\n\t\treturn true\n\tend\n\tlocal function intersectionLength(interval1,\
    \ interval2)\n\t\tlocal length = 0\n\t\tfor i = interval1[1], interval1[2] do\n\
    \t\t\tfor j = interval2[1], interval2[2] do\n\t\t\t\tif i == j then\n\t\t\t\t\t\
    length = length + 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn length\n\tend\n\
    \tlocal isectLength = intersectionLength(interval1, interval2)\n\tif isectLength\
    \ == 0 then\n\t\treturn 'NO'\n\tend\n\treturn isPrime(isectLength) and 'YES' or\
    \ 'NO'\nend", "    local start, stop = {}, {}\n    for i, v in ipairs({interval1,\
    \ interval2}) do\n        for k, t in ipairs(v) do\n            start[k] = start[k]\
    \ or t\n            stop[k] = stop[k] or t\n            if t < start[k] then\n\
    \                start[k] = t\n            elseif t > stop[k] then\n         \
    \       stop[k] = t\n            end\n        end\n    end\n    local len = stop[1]\
    \ - start[1]\n    if stop[1] < start[2] or start[1] > stop[2] then\n        return\
    \ 'NO'\n    elseif len < 1 then\n        return 'NO'\n    elseif isPrime(len)\
    \ then\n        return 'YES'\n    else\n        return 'NO'\n    end\nend", " \
    \ local start, finish\n  local result", "  -- write your code here\n  -- you can\
    \ use some built-in functions like math.max and math.min\nend", "    local n1,\
    \ n2 = interval1[1], interval1[2]\n    local m1, m2 = interval2[1], interval2[2]\n\
    \    local start, stop = 0, 0\n    if (m1 >= n1 and m1 <= n2) or (n1 >= m1 and\
    \ n1 <= m2) then\n        start = math.max(n1, m1)\n        stop = math.min(n2,\
    \ m2)\n    else\n        return 'NO'\n    end\n    local length = stop - start\
    \ + 1\n    for _, n in ipairs(primes) do\n        if n == length then\n      \
    \      return 'YES'\n        end\n    end\n    return 'NO'\nend", "    local x\
    \ = math.max(interval1[1], interval2[1])\n    local y = math.min(interval1[2],\
    \ interval2[2])\n    if x > y then\n        return 'NO'\n    end\n    if y - x\
    \ < 2 then\n        return 'YES'\n    end\n    local d = y - x\n    local function\
    \ is_prime(n)\n        if n < 2 then\n            return false\n        end\n\
    \        for i = 2, math.sqrt(n) do\n            if n % i == 0 then\n        \
    \        return false\n            end\n        end\n        return true\n   \
    \ end\n    return is_prime(d) and 'YES' or 'NO'\nend", "    -- start is the largest\
    \ of the smallest of the two intervals.\n    -- end is the smallest of the largest\
    \ of the two intervals.\n    local start = math.max(interval1[1], interval2[1])\n\
    \    local _end = math.min(interval1[2], interval2[2])\n    -- If they intersect,\
    \ the end must be greater than or equal\n    -- to the start.\n    if _end >=\
    \ start then\n        -- if the length of the intersection is a prime number\n\
    \        -- return 'YES', otherwise return 'NO'.\n        if is_prime(_end - start\
    \ + 1) then\n            return 'YES'\n        else\n            return 'NO'\n\
    \        end\n    else\n        return 'NO'\n    end\nend", "\tlocal function\
    \ isPrime(n)\n\t\tif n < 2 then return false end\n\t\tfor i = 2, math.floor(math.sqrt(n))\
    \ do\n\t\t\tif n % i == 0 then return false end\n\t\tend\n\t\treturn true\n\t\
    end\n\tlocal x1, y1 = interval1[1], interval1[2]\n\tlocal x2, y2 = interval2[1],\
    \ interval2[2]\n\tif x1 <= x2 and y1 >= x2 then -- \u6BD4\u5BF9\u53EF\u884C\u6027\
    \n\t\tlocal start = x2\n\t\tlocal end_ = math.min(y1, y2)\n\t\tlocal length =\
    \ end_ - start + 1\n\t\treturn isPrime(length) and 'YES' or 'NO'\n\telseif x2\
    \ <= x1 and y2 >= x1 then\n\t\tlocal start = x1\n\t\tlocal end_ = math.min(y1,\
    \ y2)\n\t\tlocal length = end_ - start + 1\n\t\treturn isPrime(length) and 'YES'\
    \ or 'NO'\n\telse\n\t\treturn 'NO'\n\tend\nend", "  local a1, b1 = interval1[1],\
    \ interval1[2]\n  local a2, b2 = interval2[1], interval2[2]\n  if b1 < a2 or b2\
    \ < a1 then return 'NO' end\n  local i1, i2 = math.max(a1, a2), math.min(b1, b2)\n\
    \  local n = i2 - i1 + 1\n  return n == 1 and 'NO' or is_prime(n) and 'YES' or\
    \ 'NO'\nend", "  local intersection = {\n    math.max(interval1[1], interval2[1]),\n\
    \    math.min(interval1[2], interval2[2])\n  }\n  local length = intersection[2]\
    \ - intersection[1]\n  if length < 0 then\n    return 'NO'\n  end\n  local d =\
    \ 2\n  while d * d <= length do\n    if length % d == 0 then\n      return 'NO'\n\
    \    end\n    d = d + 1\n  end\n  return 'YES'\nend", "    local inter1\n    local\
    \ inter2\n    if interval1[1] >= interval2[1] then\n        inter1 = interval1\n\
    \        inter2 = interval2\n    else\n        inter1 = interval2\n        inter2\
    \ = interval1\n    end\n    local res\n    if inter1[1] >= inter2[2] then\n  \
    \      res = 0\n    elseif inter1[1] <= inter2[1] and inter1[2] >= inter2[2] then\n\
    \        res = inter2[2] - inter2[1]\n    elseif inter1[1] <= inter2[1] and inter1[2]\
    \ < inter2[2] then\n        res = inter1[2] - inter2[1]\n    elseif inter1[1]\
    \ > inter2[1] and inter1[2] >= inter2[2] then\n        res = inter2[2] - inter1[1]\n\
    \    elseif inter1[1] > inter2[1] and inter1[2] < inter2[2] then\n        res\
    \ = inter1[2] - inter1[1]\n    end\n    if res == 0 then\n        return 'NO'\n\
    \    elseif res == 1 then\n        return 'NO'\n    elseif res == 2 then\n   \
    \     return 'YES'\n    else\n        for i = 2, res-1 do\n            if res\
    \ % i == 0 then\n                return 'NO'\n            end\n        end\n \
    \       return 'YES'\n    end\nend", "    local function isPrime(n)\n        for\
    \ i = 2, n - 1 do\n            if n % i == 0 then\n                return false\n\
    \            end\n        end\n        return true\n    end\n    local start,\
    \ end_ = unpack(interval1)\n    local start_, end__ = unpack(interval2)\n    local\
    \ start_intersection = math.max(start, start_)\n    local end_intersection = math.min(end_,\
    \ end__)\n    if start_intersection > end_intersection then\n        return 'NO'\n\
    \    end\n    return isPrime(end_intersection - start_intersection + 1) and 'YES'\
    \ or 'NO'\nend", "  if interval1[1] < interval2[1] then\n    interval1, interval2\
    \ = interval2, interval1\n  end\n  if interval1[1] <= interval2[2] then\n    return\
    \ is_prime(interval1[1] - interval2[2]) and 'YES' or 'NO'\n  end\n  return 'NO'\n\
    end", "    local start = math.max(interval1[1], interval2[1])\n    local finish\
    \ = math.min(interval1[2], interval2[2])\n    if start > finish then\n       \
    \ return 'NO'\n    end\n    local length = finish - start + 1\n    for k = 2,\
    \ math.sqrt(length) do\n        if length % k == 0 then\n            return 'NO'\n\
    \        end\n    end\n    return 'YES'\nend", "  local left = math.max(interval1[1],\
    \ interval2[1])\n  local right = math.min(interval1[2], interval2[2])\n  if left\
    \ > right then\n    return 'NO'\n  end\n  local count = 0\n  for i = 2, right\
    \ - left do\n    if (right - left) % i == 0 then\n      count = count + 1\n  \
    \  end\n  end\n  if count == 0 then\n    return 'YES'\n  else\n    return 'NO'\n\
    \  end\nend", "    local interval_range_1 = interval1[2] - interval1[1]\n    local\
    \ interval_range_2 = interval2[2] - interval2[1]\n    if interval_range_1 > interval_range_2\
    \ then\n        interval1, interval2 = interval2, interval1\n    end\n    local\
    \ interval_range_1 = interval1[2] - interval1[1]\n    local intersection_start\
    \ = math.max(interval1[1], interval2[1])\n    local intersection_end = math.min(interval1[2],\
    \ interval2[2])\n    local intersection_range = intersection_end - intersection_start\n\
    \    local is_intersection = (intersection_range >= 0)\n    if not is_intersection\
    \ then\n        return 'NO'\n    end\n    local is_prime = is_prime_number(intersection_range)\n\
    \    return is_prime and 'YES' or 'NO'\nend", "  local a, b = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n  if a <= b then\n    return\
    \ isPrime(b - a + 1) and 'YES' or 'NO'\n  end\n  return 'NO'\nend\nreturn intersection",
  "    local primes = {}\n    local function isPrime(n)\n        if primes[n] ~= nil\
    \ then\n            return primes[n]\n        end\n        local sqrt = math.sqrt(n)\n\
    \        for i = 2, sqrt do\n            if n % i == 0 then\n                primes[n]\
    \ = false\n                return false\n            end\n        end\n      \
    \  primes[n] = true\n        return true\n    end\n    local function findIntersectionLength(start1,\
    \ end1, start2, end2)\n        if start1 > end2 or start2 > end1 then\n      \
    \      return -1\n        end\n        local intersection_start = math.max(start1,\
    \ start2)\n        local intersection_end = math.min(end1, end2)\n        return\
    \ intersection_end - intersection_start + 1\n    end\n    local result = findIntersectionLength(interval1[1],\
    \ interval1[2], interval2[1], interval2[2])\n    if result == -1 then\n      \
    \  return 'NO'\n    end\n    return isPrime(result) and 'YES' or 'NO'\nend", " \
    \ local s, e = math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])\n\
    \  if s > e then return 'NO' end\n  local l = e - s + 1\n  if l < 3 then return\
    \ 'NO' end\n  for i = 2, math.floor(math.sqrt(l)) do\n    if l % i == 0 then return\
    \ 'NO' end\n  end\n  return 'YES'\nend", "\tlocal lo, hi = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n\tif lo <= hi then\n\t\t\
    for i = 2, hi - lo + 1 do\n\t\t\tif (hi - lo + 1) % i == 0 then\n\t\t\t\treturn\
    \ 'NO'\n\t\t\tend\n\t\tend\n\t\treturn 'YES'\n\tend\n\treturn 'NO'\nend", "  local\
    \ start1, end1 = interval1[1], interval1[2]\n  local start2, end2 = interval2[1],\
    \ interval2[2]\n  local iStart, iEnd = start1, end1\n  if start2 > start1 then\
    \ iStart = start2 end\n  if end2 < end1 then iEnd = end2 end\n  if iStart <= iEnd\
    \ then\n    local iLength = iEnd - iStart + 1\n    if iLength == 1 then return\
    \ 'NO' end\n    for i = 2, iLength / 2 do\n      if iLength % i == 0 then return\
    \ 'NO' end\n    end\n    return 'YES'\n  end\n  return 'NO'\nend", "  local function\
    \ checkPrime(value)\n    if value < 2 then return false end\n    for i = 2, math.sqrt(value)\
    \ do\n      if value % i == 0 then return false end\n    end\n    return true\n\
    \  end\n  local start = math.max(interval1[1], interval2[1])\n  local finish =\
    \ math.min(interval1[2], interval2[2])\n  if start > finish then return 'NO' end\n\
    \  return checkPrime(finish - start + 1) and 'YES' or 'NO'\nend", "\tlocal isect\
    \ = {math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])}\n\
    \tif isect[1] > isect[2] then return 'NO' end\n\tlocal ixct_len = isect[2] - isect[1]\
    \ + 1\n\tfor i = 2, ixct_len - 1 do\n\t\tif ixct_len % i == 0 then return 'NO'\
    \ end\n\tend\n\treturn 'YES'\nend", "  local x1, y1 = interval1[1], interval1[2]\n\
    \  local x2, y2 = interval2[1], interval2[2]\n  local interval = {math.max(x1,\
    \ x2), math.min(y1, y2)}\n  if interval[1] > interval[2] then\n    return 'NO'\n\
    \  end\n  local length = interval[2] - interval[1] + 1\n  if length == 1 then\n\
    \    return 'NO'\n  end\n  for i = 2, math.sqrt(length) do\n    if length % i\
    \ == 0 then\n      return 'NO'\n    end\n  end\n  return 'YES'\nend", "\tlocal\
    \ x, y = 0, 0\n\tif interval1[1] <= interval2[1] then\n\t\tx = interval2[1]\n\t\
    else\n\t\tx = interval1[1]\n\tend\n\tif interval1[2] <= interval2[2] then\n\t\t\
    y = interval1[2]\n\telse\n\t\ty = interval2[2]\n\tend\n\tif x <= y then\n\t\t\
    local length = y - x + 1\n\t\tlocal n = 2\n\t\twhile n * n <= length do\n\t\t\t\
    if length % n == 0 then\n\t\t\t\treturn 'NO'\n\t\t\tend\n\t\t\tn = n + 1\n\t\t\
    end\n\t\treturn 'YES'\n\tend\n\treturn 'NO'\nend", "    local start, end_ = interval1[1],\
    \ interval1[2]\n    local start1, end_1 = interval2[1], interval2[2]\n    local\
    \ intersect = math.max(start, start1) <= math.min(end_, end_1)\n    if intersect\
    \ then\n        local length = math.min(end_, end_1) - math.max(start, start1)\
    \ + 1\n        local is_prime = true\n        for i = 2, math.sqrt(length) do\n\
    \            if length % i == 0 then\n                is_prime = false\n     \
    \           break\n            end\n        end\n        return is_prime and 'YES'\
    \ or 'NO'\n    else\n        return 'NO'\n    end\nend", "  local s,e = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n  if s >= e then return\
    \ 'NO' end\n  return (e-s)%2 == 0 and 'NO' or 'YES'\nend", "  local low, high\
    \ = math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])\n\
    \  if high >= low then\n    local len = high - low + 1\n    for i = 2, math.sqrt(len)\
    \ do\n      if len % i == 0 then\n        return 'NO'\n      end\n    end\n  \
    \  return 'YES'\n  end\n  return 'NO'\nend", "  local start1, end1 = interval1[1],\
    \ interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n  if end1 <\
    \ start2 or end2 < start1 then\n    return 'NO'\n  end\n  local start, end = math.max(start1,\
    \ start2), math.min(end1, end2)\n  if start == end then\n    return 'NO'\n  end\n\
    \  local len = end - start + 1\n  if len <= 1 then\n    return 'NO'\n  end\n \
    \ for i = 2, math.floor(math.sqrt(len)) do\n    if len % i == 0 then\n      return\
    \ 'NO'\n    end\n  end\n  return 'YES'\nend", "  -- your code goes here\nend",
  "    local s, e = interval1[1], interval1[2]\n    local x, y = interval2[1], interval2[2]\n\
    \    local a, b = math.max(s, x), math.min(e, y)\n    if a > b then return 'NO'\
    \ end\n    return 2 == a - b and 'YES' or 'NO'\nend", "  local x, y = interval1[1],\
    \ interval1[2]\n  local a, b = interval2[1], interval2[2]\n  local start, stop\
    \ = nil, nil\n  local prime_counter = 1\n  local prime_flag = false\n  if (x >\
    \ a) then start = x else start = a end\n  if (y < b) then stop = y else stop =\
    \ b end\n  if (start > stop) then return 'NO' end\n  for i = start, stop do\n\
    \    for j = 2, i do\n      if (i % j == 0) then\n        prime_counter = prime_counter\
    \ + 1\n      end\n    end\n    if (prime_counter == 2) then\n      prime_flag\
    \ = true\n    end\n    prime_counter = 1\n  end\n  if (prime_flag) then return\
    \ 'YES' else return 'NO' end\nend", "  local x1, y1 = interval1[1], interval1[2]\n\
    \  local x2, y2 = interval2[1], interval2[2]\n  local start, stop = math.max(x1,\
    \ x2), math.min(y1, y2)\n  if start > stop then return 'NO' end\n  if start ==\
    \ stop then return 'YES' end\n  local len = math.abs(stop - start) + 1\n  local\
    \ function is_prime(n)\n    if n <= 1 then return false end\n    if n == 2 then\
    \ return true end\n    for i = 2, math.sqrt(n) do\n      if n % i == 0 then return\
    \ false end\n    end\n    return true\n  end\n  return is_prime(len) and 'YES'\
    \ or 'NO'\nend", "  local start = math.max(interval1[1], interval2[1])\n  local\
    \ finish = math.min(interval1[2], interval2[2])\n  if start <= finish then\n \
    \   local len = finish - start + 1\n    if len == 1 then\n      return 'NO'\n\
    \    end\n    for i = 2, math.floor(math.sqrt(len)) do\n      if len % i == 0\
    \ then\n        return 'NO'\n      end\n    end\n    return 'YES'\n  end\n  return\
    \ 'NO'\nend", "    if interval1[1] <= interval2[2] and interval2[1] <= interval1[2]\
    \ then\n        local a, b = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n        return is_prime(b - a + 1) and 'YES' or 'NO'\n    end\n\
    \    return 'NO'\nend", "    local function is_prime(num)\n        local i = 2\n\
    \        while i < num do\n            if num % i == 0 then\n                return\
    \ false\n            end\n            i = i + 1\n        end\n        return true\n\
    \    end\n    local d1, d2 = interval1[2] - interval1[1], interval2[2] - interval2[1]\n\
    \    local start, end_ = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n    if start > end_ then\n        return 'NO'\n    end\n    return\
    \ is_prime(end_ - start + 1) and 'YES' or 'NO'\nend", "\t-- check for empty intersection\n\
    \tif (interval1[1] > interval2[2]) or (interval2[1] > interval1[2]) then\n\t\t\
    return 'NO'\n\tend\n\t-- check for non-empty intersection\n\tlocal inter_start\
    \ = math.max(interval1[1], interval2[1])\n\tlocal inter_end = math.min(interval1[2],\
    \ interval2[2])\n\tlocal inter_length = inter_end - inter_start + 1\n\tif inter_length\
    \ < 2 then\n\t\treturn 'NO'\n\tend\n\t-- check if inter_length is prime\n\tlocal\
    \ divisor = 2\n\twhile divisor < inter_length do\n\t\tif inter_length % divisor\
    \ == 0 then\n\t\t\treturn 'NO'\n\t\tend\n\t\tdivisor = divisor + 1\n\tend\n\t\
    return 'YES'\nend", "  local start1, end1 = interval1[1], interval1[2]\n  local\
    \ start2, end2 = interval2[1], interval2[2]\n  if end1 < start2 or end2 < start1\
    \ then return 'NO' end\n  local i = start1 > start2 and start1 or start2\n  local\
    \ j = end1 < end2 and end1 or end2\n  local function is_prime(x)\n    for k =\
    \ 2, math.floor(math.sqrt(x)) do\n      if x % k == 0 then return false end\n\
    \    end\n    return true\n  end\n  if i > j then return 'NO' end\n  return is_prime(j\
    \ - i + 1) and 'YES' or 'NO'\nend", "    local start = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ local result = 'NO'\n    if finish >= start then\n        result = 'YES'\n \
    \       for i = 2, math.floor(finish - start + 1) do\n            if math.floor(finish\
    \ - start + 1) % i == 0 then\n                result = 'NO'\n                break\n\
    \            end\n        end\n    end\n    return result\nend", "  local function\
    \ calc_intersection(interval1, interval2)\n    if interval1[1] >= interval2[1]\
    \ and interval1[1] <= interval2[2] then\n      return {interval1[1], math.min(interval1[2],\
    \ interval2[2])}\n    elseif interval1[2] >= interval2[1] and interval1[2] <=\
    \ interval2[2] then\n      return {math.max(interval1[1], interval2[1]), interval1[2]}\n\
    \    elseif interval2[1] >= interval1[1] and interval2[1] <= interval1[2] then\n\
    \      return {interval2[1], math.min(interval1[2], interval2[2])}\n    elseif\
    \ interval2[2] >= interval1[1] and interval2[2] <= interval1[2] then\n      return\
    \ {math.max(interval1[1], interval2[1]), interval2[2]}\n    end\n  end\n  local\
    \ function calc_length(interval)\n    return interval[2] - interval[1] + 1\n \
    \ end\n  local function is_prime(number)\n    if number == 2 then\n      return\
    \ true\n    end\n    for i = 2, math.sqrt(number) do\n      if number % i == 0\
    \ then\n        return false\n      end\n    end\n    return true\n  end\n  local\
    \ intersection = calc_intersection(interval1, interval2)\n  if intersection ==\
    \ nil then\n    return 'NO'\n  end\n  if is_prime(calc_length(intersection)) then\n\
    \    return 'YES'\n  else\n    return 'NO'\n  end\nend", "  local function is_prime(n)\n\
    \    if n <= 1 then return false end\n    for i = 2, math.floor(math.sqrt(n))\
    \ do\n      if n % i == 0 then return false end\n    end\n    return true\n  end\n\
    \  local start = math.max(interval1[1], interval2[1])\n  local finish = math.min(interval1[2],\
    \ interval2[2])\n  if start > finish then return 'NO' end\n  return is_prime(finish\
    \ - start + 1) and 'YES' or 'NO'\nend", "    local function isPrime(val)\n   \
    \     for i = 2, val-1 do\n            if val % i == 0 then\n                return\
    \ false\n            end\n        end\n        return true\n    end\n    local\
    \ function getIntersection(a, b)\n        local start = a[1] > b[1] and a[1] or\
    \ b[1]\n        local end_ = a[2] < b[2] and a[2] or b[2]\n        return {start,\
    \ end_}\n    end\n    local start_intersect = interval1[1] > interval2[1] and\
    \ interval1[1] or interval2[1]\n    local end_intersect = interval1[2] < interval2[2]\
    \ and interval1[2] or interval2[2]\n    if start_intersect <= end_intersect then\n\
    \        return isPrime(end_intersect - start_intersect + 1) and 'YES' or 'NO'\n\
    \    else\n        return 'NO'\n    end\nend", "  local a1, a2 = interval1[1],\
    \ interval1[2]\n  local b1, b2 = interval2[1], interval2[2]\n  local start, finish\
    \ = math.max(a1, b1), math.min(a2, b2)\n  if start > finish then return 'NO' end\n\
    \  if isPrime(finish - start + 1) then return 'YES' else return 'NO' end\nend",
  "\tlocal i1 = intersection(interval1, interval2)\n\tlocal i2 = intersection(interval2,\
    \ interval1)\n\tif (i1 == nil and i2 == nil) then\n\t\treturn 'NO'\n\tend\n\t\
    local int = i1\n\tif (i2 ~= nil) then\n\t\tint = i2\n\tend\n\treturn isPrime(math.abs(int[1]\
    \ - int[2]) + 1) and 'YES' or 'NO'\nend", "    local s1, e1 = interval1[1], interval1[2]\n\
    \    local s2, e2 = interval2[1], interval2[2]\n    local start, _end = 0, 0\n\
    \    if s1 <= s2 and e1 >= s2 then\n        start = s2\n    elseif s2 <= s1 and\
    \ e2 >= s1 then\n        start = s1\n    end\n    if s1 <= e2 and e1 >= e2 then\n\
    \        _end = e2\n    elseif s2 <= e1 and e2 >= e1 then\n        _end = e1\n\
    \    end\n    if start == 0 and _end == 0 then\n        return 'NO'\n    end\n\
    \    local len = _end - start + 1\n    if len == 1 then\n        return 'NO'\n\
    \    end\n    for i = 2, len - 1 do\n        if len % i == 0 then\n          \
    \  return 'NO'\n        end\n    end\n    return 'YES'\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
