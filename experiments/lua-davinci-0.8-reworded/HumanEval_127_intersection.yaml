name: HumanEval_127_intersection
language: lua
prompt: "-- You are given two intervals,\n-- where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed\
  \ which means that the interval (start, end)\n-- includes both start and end.\n\
  -- For each given interval, it is assumed that its start is less or equal its end.\n\
  -- Your task is to determine whether the length of intersection of these two \n\
  -- intervals is a prime number.\n-- Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n--\
  \ If the length of the intersection is a prime number, return \"YES\",\n-- otherwise,\
  \ return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output]\
  \ samples:\n-- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1,\
  \ 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal\
  \ function intersection(interval1, interval2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersection\n\
  \    lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')\n    lu.assertEquals(candidate({-1,\
  \ 1}, {0, 4}), 'NO')\n    lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')\n\
  \    lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')\n    lu.assertEquals(candidate({-11,\
  \ 2}, {-1, -1}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')\n \
  \   lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')\n    lu.assertEquals(candidate({-2,\
  \ -2}, {-3, -2}), 'NO')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local intersectionStart, intersectionEnd = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n  if intersectionStart\
    \ <= intersectionEnd then\n    local length = intersectionEnd - intersectionStart\
    \ + 1\n    for d = 2, math.floor(math.sqrt(length)) do\n      if length % d ==\
    \ 0 then\n        return 'NO'\n      end\n    end\n    return 'YES'\n  end\n \
    \ return 'NO'\nend", "    local left = math.max(interval1[1], interval2[1])\n\
    \    local right = math.min(interval1[2], interval2[2])\n    if right < left then\n\
    \        return 'NO'\n    end\n    local length = right - left + 1\n    if length\
    \ == 1 then\n        return 'NO'\n    end\n    local primes = { 2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97 }\n    for _,p in ipairs(primes) do\n        if p == length then\n      \
    \      return 'YES'\n        end\n    end\n    return 'NO'\nend", "  local start\
    \ = math.max(interval1[1], interval2[1])\n  local finish = math.min(interval1[2],\
    \ interval2[2])\n  local diff = finish - start\n  local isPrime = true\n  if diff\
    \ < 0 then\n    return 'NO'\n  end\n  for i = 2, diff do\n    if diff % i == 0\
    \ then\n      isPrime = false\n      break\n    end\n  end\n  if isPrime then\n\
    \    return 'YES'\n  else\n    return 'NO'\n  end\nend\nreturn intersection",
  "    -- your code here\n    local a1, a2 = interval1[1], interval1[2]\n    local\
    \ b1, b2 = interval2[1], interval2[2]\n    if a1 > b2 or b1 > a2 then\n      \
    \  return 'NO'\n    end\n    local res = math.min(a2, b2) - math.max(a1, b1) +\
    \ 1\n    return isPrime(res) and 'YES' or 'NO'\nend", "    local max_start = math.max(interval1[1],\
    \ interval2[1])\n    local min_end = math.min(interval1[2], interval2[2])\n  \
    \  local s = {max_start, min_end}\n    local len = math.abs(s[1] - s[2])\n   \
    \ if s[1] > s[2] then return 'NO' end\n    if len == 0 then return 'NO' end\n\
    \    local isPrime = true\n    for i = 2, len / 2 do\n        if len % i == 0\
    \ then isPrime = false end\n    end\n    if isPrime then return 'YES' else return\
    \ 'NO' end\nend", "    local lower = math.max(interval1[1], interval2[1])\n  \
    \  local upper = math.min(interval1[2], interval2[2])\n    local min, max = math.min(lower,\
    \ upper), math.max(lower, upper)\n    if min == max then\n        return 'NO'\n\
    \    end\n    if is_prime(math.abs(upper - lower)) then\n        return 'YES'\n\
    \    end\n    return 'NO'\nend", "    if (interval1[1] >= interval2[2] or interval2[1]\
    \ >= interval1[2]) then\n        return 'NO'\n    end\n    local max, min = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n    local x = max - min\
    \ + 1\n    if (x <= 1) then\n        return 'NO'\n    end\n    local factors =\
    \ {}\n    for i = 2, math.sqrt(x) do\n        if (x % i == 0) then\n         \
    \   return 'NO'\n        end\n    end\n    return 'YES'\nend", "  local start1,\
    \ end1 = interval1[1], interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n\
    \  local start, end = math.max(start1, start2), math.min(end1, end2)\n  if start\
    \ > end then return 'NO' end\n  local interval = {start, end}\n  return isPrime(intervalLength(interval))\
    \ and 'YES' or 'NO'\nend", "  local l, r = math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])\n  if l > r then return 'NO' end\n  local\
    \ f = function(n) return math.abs(n) > 1 and not (n % 2 == 0 or n % 3 == 0) end\n\
    \  local flag = false\n  for i = 5, math.floor(math.sqrt(r)) do\n    if f(i) then\n\
    \      for j = i * i, r, i do\n        if j >= l and j <= r then\n          flag\
    \ = true\n          break\n        end\n      end\n    end\n  end\n  return flag\
    \ and 'NO' or 'YES'\nend", "    local inter = {start = 0, finish = 0}\n    if\
    \ interval1[1] < interval2[1] then\n        inter[1] = interval2[1]\n    else\n\
    \        inter[1] = interval1[1]\n    end\n    if interval1[2] < interval2[2]\
    \ then\n        inter[2] = interval1[2]\n    else\n        inter[2] = interval2[2]\n\
    \    end\n    if inter[1] <= inter[2] then\n        local len = inter[2] - inter[1]\
    \ + 1\n        local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n        for _, p in ipairs(primes)\
    \ do\n            if len == p then\n                return 'YES'\n           \
    \ end\n        end\n        return 'NO'\n    end\n    return 'NO'\nend", "   \
    \ return (interval1[1] >= interval2[1] and interval1[1] <= interval2[2]) or (interval2[1]\
    \ >= interval1[1] and interval2[1] <= interval1[2])\nend", "    local i1 = {}\n\
    \    local i2 = {}\n    for i,v in ipairs(interval1) do\n        i1[i] = v\n \
    \   end\n    for i,v in ipairs(interval2) do\n        i2[i] = v\n    end\n   \
    \ if i1[1] > i1[2] then\n        i1[1], i1[2] = i1[2], i1[1]\n    end\n    if\
    \ i2[1] > i2[2] then\n        i2[1], i2[2] = i2[2], i2[1]\n    end\n    local\
    \ int1 = range(i1[1], i1[2])\n    local int2 = range(i2[1], i2[2])\n    local\
    \ int_intersection = {}\n    for _,v in ipairs(int1) do\n        if is_contain(int2,\
    \ v) then\n            table.insert(int_intersection, v)\n        end\n    end\n\
    \    local len = #int_intersection\n    local is_prime = true\n    if len == 0\
    \ then\n        return 'NO'\n    end\n    if len ~= 1 then\n        for i = 2,\
    \ len - 1 do\n            if len % i == 0 then\n                is_prime = false\n\
    \                break\n            end\n        end\n    end\n    if is_prime\
    \ then\n        return 'YES'\n    else\n        return 'NO'\n    end\nend", " \
    \   local start_int, end_int = 0, 0\n    if(interval1[1] < interval2[1]) then\n\
    \        start_int = interval2[1]\n    else\n        start_int = interval1[1]\n\
    \    end\n    if(interval1[2] < interval2[2]) then\n        end_int = interval1[2]\n\
    \    else\n        end_int = interval2[2]\n    end\n    local int_length = end_int\
    \ - start_int\n    if(int_length < 0) then\n        return 'NO'\n    end\n   \
    \ if(int_length == 1) then\n        return 'NO'\n    end\n    for i = 2, int_length\
    \ - 1 do\n        if((int_length % i) == 0) then\n            return 'NO'\n  \
    \      end\n    end\n    return 'YES'\nend", "  local i1, i2 = {}, {}\n  for _,\
    \ i in ipairs({interval1, interval2}) do\n    table.insert(i1, i[1])\n    table.insert(i2,\
    \ i[2])\n  end\n  local sort = table.sort\n  sort(i1)\n  sort(i2)\n  if i1[2]\
    \ < i2[1] or i2[2] < i1[1] then\n    return 'NO'\n  end\n  local prime = function(n)\n\
    \    if n < 1 then\n      return false\n    end\n    for i = 2, math.sqrt(n) do\n\
    \      if n % i == 0 then\n        return false\n      end\n    end\n    return\
    \ true\n  end\n  local n = math.min(i1[2], i2[2]) - math.max(i1[1], i2[1]) + 1\n\
    \  return prime(n) and 'YES' or 'NO'\nend", "  local a, b = interval1[1], interval1[2]\n\
    \  local c, d = interval2[1], interval2[2]\n  if c > b or a > d then return 'NO'\
    \ end\n  local n = math.min(b, d) - math.max(a, c) + 1\n  if n == 1 then return\
    \ 'NO' end\n  for i = 2, math.floor(math.sqrt(n)) do\n    if n % i == 0 then return\
    \ 'NO' end\n  end\n  return 'YES'\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local stop = math.min(interval1[2], interval2[2])\n  if start\
    \ > stop then return 'NO' end\n  return (start == 2 or start % 2 ~= 0) and stop\
    \ - start > 1 and 'YES' or 'NO'\nend", "    local start = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ if start > finish then\n        return 'NO'\n    end\n    local n = finish -\
    \ start + 1\n    if n == 1 then\n        return 'NO'\n    end\n    for i = 2,\
    \ math.floor(math.sqrt(n)) do\n        if n % i == 0 then\n            return\
    \ 'NO'\n        end\n    end\n    return 'YES'\nend", "  local function isPrime(n)\n\
    \    if n <= 1 then return false end\n    for i = 2, math.floor(math.sqrt(n))\
    \ do\n      if n % i == 0 then return false end\n    end\n    return true\n  end\n\
    \  local s, e = math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])\n\
    \  if s > e then return 'NO' end\n  return isPrime(e - s + 1) and 'YES' or 'NO'\n\
    end", "  local start = math.max(interval1[1], interval2[1])\n  local finish =\
    \ math.min(interval1[2], interval2[2])\n  local len = finish - start + 1\n  return\
    \ len > 0 and IsPrime(len) and 'YES' or 'NO'\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local finish = math.min(interval1[2], interval2[2])\n  if start\
    \ > finish then\n    return 'NO'\n  end\n  for i = 2, start do\n    if start %\
    \ i == 0 then\n      return 'NO'\n    end\n  end\n  return 'YES'\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
