name: HumanEval_73_smallest_change
language: lua
prompt: "-- Given a table arr of integers, find the minimum number of elements that\n\
  -- need to be changed to make the table palindromic. A palindromic table is a table\
  \ that\n-- is read the same backwards and forwards. In one change, you can change\
  \ one element to any other element.\n-- For example:\n-- >>> smallest_change({1,\
  \ 2, 3, 5, 4, 7, 9, 6})\n-- 4\n-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})\n--\
  \ 1\n-- >>> smallest_change({1, 2, 3, 2, 1})\n-- 0\nlocal function smallest_change(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = smallest_change\n\
  \    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 4, 3, 2, 2}), 1)\n    lu.assertEquals(candidate({1, 4, 2}), 1)\n    lu.assertEquals(candidate({1,\
  \ 4, 4, 2}), 1)\n    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)\n    lu.assertEquals(candidate({3,\
  \ 1, 1, 3}), 0)\n    lu.assertEquals(candidate({1}), 0)\n    lu.assertEquals(candidate({0,\
  \ 1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #arr <= 1 then return 0 end\n  local n = #arr\n  local sum = 0\n\
    \  for i=1, math.floor(n/2) do\n    sum = sum + arr[i]\n  end\n  local sum_rev\
    \ = 0\n  for i=math.ceil(n/2), n do\n    sum_rev = sum_rev + arr[i]\n  end\n \
    \ local min_sum = math.min(sum, sum_rev)\n  local max_sum = math.max(sum, sum_rev)\n\
    \  return max_sum - min_sum\nend", "    -- TODO: implement the function\nend",
  "  return 0\nend", end, "\tlocal changed_count = 0\n\tlocal left_idx = 1\n\tlocal\
    \ right_idx = #arr\n\twhile left_idx < right_idx do\n\t\tif arr[left_idx] ~= arr[right_idx]\
    \ then\n\t\t\tchanged_count = changed_count + 1\n\t\tend\n\t\tleft_idx = left_idx\
    \ + 1\n\t\tright_idx = right_idx - 1\n\tend\n\treturn changed_count\nend", " \
    \   local function find_palindrome(a, b)\n        if b <= a then\n           \
    \ return 0\n        end\n        local mid = (a + b) // 2\n        if arr[mid]\
    \ == arr[mid + 1] then\n            return find_palindrome(a, mid - 1) + find_palindrome(mid\
    \ + 2, b)\n        else\n            return find_palindrome(a, mid - 1) + find_palindrome(mid\
    \ + 1, b) + 1\n        end\n    end\n    return find_palindrome(1, #arr)\nend",
  "    return nil\nend", "    if #arr <= 1 then\n        return 0\n    end\n    local\
    \ left = 1\n    local right = #arr\n    local change = 0\n    while left < right\
    \ do\n        if arr[left] ~= arr[right] then\n            change = change + 1\n\
    \        end\n        left = left + 1\n        right = right - 1\n    end\n  \
    \  return change\nend", "\tlocal min_changes = 0\n\tlocal left_idx = 1\n\tlocal\
    \ right_idx = #arr\n\twhile left_idx < right_idx do\n\t\tif arr[left_idx] ~= arr[right_idx]\
    \ then\n\t\t\tmin_changes = min_changes + 1\n\t\tend\n\t\tleft_idx = left_idx\
    \ + 1\n\t\tright_idx = right_idx - 1\n\tend\n\treturn min_changes\nend", "   \
    \ local l, r = 1, #arr\n    local count = 0\n    while l < r do\n        if arr[l]\
    \ ~= arr[r] then\n            count = count + 1\n        end\n        l = l +\
    \ 1\n        r = r - 1\n    end\n    return count\nend", "\tlocal min_diff = -1\n\
    \tlocal pair = nil\n\tfor i = 1, #arr / 2 do\n\t\tif arr[i] ~= arr[#arr - i +\
    \ 1] then\n\t\t\tlocal diff = math.abs(arr[i] - arr[#arr - i + 1])\n\t\t\tif min_diff\
    \ == -1 or diff < min_diff then\n\t\t\t\tmin_diff = diff\n\t\t\t\tpair = {i, #arr\
    \ - i + 1}\n\t\t\tend\n\t\tend\n\tend\n\tif min_diff == -1 then\n\t\treturn 0\n\
    \telse\n\t\treturn min_diff + smallest_change(table.filter(arr, function(k, v)\n\
    \t\t\treturn k ~= pair[1] and k ~= pair[2]\n\t\tend))\n\tend\nend", "    local\
    \ count = 0\n    local first = 1\n    local last = #arr\n    while first < last\
    \ do\n        if arr[first] ~= arr[last] then\n            count = count + 1\n\
    \        end\n        first = first + 1\n        last = last - 1\n    end\n  \
    \  return count\nend", "  local n = #arr\n  local dp = {}\n  for i = 1, n do\n\
    \    dp[i] = {}\n    for j = 1, n do\n      dp[i][j] = math.huge\n    end\n  end\n\
    \  for i = 1, n do\n    dp[i][i] = 0\n  end\n  for i = 1, n - 1 do\n    dp[i][i\
    \ + 1] = 1\n  end\n  for i = n - 1, 1, -1 do\n    for j = i + 2, n do\n      if\
    \ arr[i] == arr[j] then\n        dp[i][j] = dp[i + 1][j - 1]\n      else\n   \
    \     dp[i][j] = math.min(dp[i + 1][j], dp[i][j - 1]) + 1\n      end\n    end\n\
    \  end\n  return dp[1][n]\nend", "  local middle = math.floor(#arr / 2)\n  local\
    \ count = 0\n  for i = 1, middle do\n    if arr[i] ~= arr[#arr - i + 1] then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "  local reversed\
    \ = {}\n  for i, v in ipairs(arr) do\n    reversed[#arr-i+1] = v\n  end\n  local\
    \ to_change = 0\n  for i = 1, #arr do\n    if arr[i] ~= reversed[i] then\n   \
    \   to_change = to_change + 1\n    end\n  end\n  return to_change / 2\nend", " \
    \ local size = #arr\n  if size < 2 then\n    return 0\n  end\n  local i = 1\n\
    \  local j = size\n  local min_change = 0\n  while i < j do\n    if arr[i] ~=\
    \ arr[j] then\n      min_change = min_change + 1\n    end\n    i = i + 1\n   \
    \ j = j - 1\n  end\n  return min_change\nend", end, end, end, "    -- write your\
    \ solution here\n    local n = #arr\n    local dp = {}\n    for i = 0, n do\n\
    \        dp[i] = {}\n        for j = 0, n do\n            dp[i][j] = 0\n     \
    \   end\n    end\n    for i = 1, n do\n        dp[i][i] = 0\n    end\n    for\
    \ i = 1, n - 1 do\n        dp[i][i + 1] = math.abs(arr[i] - arr[i + 1])\n    end\n\
    \    for i = n - 1, 1, -1 do\n        for j = i + 2, n do\n            dp[i][j]\
    \ = math.min(dp[i + 1][j] + math.abs(arr[i] - arr[i + 1]), dp[i][j - 1] + math.abs(arr[j]\
    \ - arr[j - 1]))\n        end\n    end\n    return dp[1][n]\nend", "  local left,\
    \ right = 1, #arr\n  local count = 0\n  while left < right do\n    if arr[left]\
    \ ~= arr[right] then\n      count = count + 1\n    end\n    left = left + 1\n\
    \    right = right - 1\n  end\n  return count\nend", "    local n = #arr\n   \
    \ local f = {}\n    for i = 1, n do\n        f[i] = {}\n        for j = 1, n do\n\
    \            f[i][j] = -1\n        end\n    end\n    return rec(arr, 1, n, f)\n\
    end", '    local n = #arr', "    local function inner(i, j)\n        if i >= j\
    \ then\n            return 0\n        end\n        if arr[i] == arr[j] then\n\
    \            return inner(i + 1, j - 1)\n        else\n            return math.min(inner(i\
    \ + 1, j), inner(i, j - 1)) + 1\n        end\n    end\n    return inner(1, #arr)\n\
    end", "    local l, r = 1, #arr\n    local n = 0\n    while l < r do\n       \
    \ if arr[l] ~= arr[r] then\n            n = n + 1\n        end\n        l = l\
    \ + 1\n        r = r - 1\n    end\n    return n\nend", "  local count = 0\n  local\
    \ i = 1\n  local j = #arr\n  while i < j do\n    if arr[i] ~= arr[j] then\n  \
    \    count = count + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return\
    \ count\nend", "    -- Write your code here\n    local count = 0\n    for i =\
    \ 1, #arr//2 do\n        if arr[i] ~= arr[#arr-i+1] then\n            count =\
    \ count + 1\n        end\n    end\n    return count\nend", "  return nil\nend",
  "    -- TODO: implement me\nend", "    local cnt = 0\n    for i = 1, #arr / 2 do\n\
    \        if arr[i] ~= arr[#arr - i + 1] then\n            cnt = cnt + 1\n    \
    \    end\n    end\n    return cnt\nend", "    local n = #arr\n    local changes\
    \ = {}\n    for i = 1, n do\n        changes[i] = {}\n        for j = 1, n do\n\
    \            changes[i][j] = -1\n        end\n    end\n    for i = 1, n do\n \
    \       changes[i][i] = 0\n    end\n    for i = 1, n - 1 do\n        if arr[i]\
    \ == arr[i + 1] then\n            changes[i][i + 1] = 0\n        else\n      \
    \      changes[i][i + 1] = 1\n        end\n    end\n    for diff = 2, n - 1 do\n\
    \        for i = 1, n - diff do\n            local j = i + diff\n            if\
    \ arr[i] == arr[j] then\n                changes[i][j] = changes[i + 1][j - 1]\n\
    \            else\n                changes[i][j] = 1 + min(changes[i + 1][j],\
    \ changes[i][j - 1])\n            end\n        end\n    end\n    return changes[1][n]\n\
    end", "    -- if table is empty then return 0\n    if next(arr) == nil then\n\
    \        return 0\n    end\n    -- if table has one or two elements then return\
    \ 0\n    if #arr == 1 or #arr == 2 then\n        return 0\n    end\n    -- if\
    \ table has even amount of elements then\n    -- check if table is palindromic\
    \ or not\n    if #arr % 2 == 0 then\n        local first_half = {}\n        local\
    \ second_half = {}\n        for i = 1, #arr / 2 do\n            first_half[i]\
    \ = arr[i]\n        end\n        for i = #arr, #arr / 2 + 1, -1 do\n         \
    \   second_half[#arr - i + 1] = arr[i]\n        end\n        local changes = 0\n\
    \        for i = 1, #first_half do\n            if first_half[i] ~= second_half[i]\
    \ then\n                changes = changes + 1\n            end\n        end\n\
    \        return changes\n    -- if table has odd amount of elements then\n   \
    \ -- check if it is palindromic or not\n    else\n        local first_half = {}\n\
    \        local second_half = {}\n        for i = 1, math.floor(#arr / 2) do\n\
    \            first_half[i] = arr[i]\n        end\n        for i = #arr, math.floor(#arr\
    \ / 2) + 1, -1 do\n            second_half[#arr - i + 1] = arr[i]\n        end\n\
    \        local changes = 0\n        for i = 1, #first_half do\n            if\
    \ first_half[i] ~= second_half[i] then\n                changes = changes + 1\n\
    \            end\n        end\n        return changes\n    end\nend", "    if\
    \ #arr < 3 then\n        return #arr - 1\n    end\n    local pos1, pos2 = 1, #arr\n\
    \    local count = 0\n    while pos1 < pos2 do\n        if arr[pos1] ~= arr[pos2]\
    \ then\n            count = count + 1\n        end\n        pos1 = pos1 + 1\n\
    \        pos2 = pos2 - 1\n    end\n    return count\nend", "    if #arr == 0 then\n\
    \        return 0\n    end\n    local count = 0\n    for i = 1, #arr / 2 do\n\
    \        if arr[i] ~= arr[#arr - i + 1] then\n            count = count + 1\n\
    \        end\n    end\n    return count\nend", "    local j = #arr\n    local\
    \ i = 1\n    local count = 0\n    while (i < j) do\n        if arr[i] ~= arr[j]\
    \ then\n            count = count + 1\n        end\n        i = i + 1\n      \
    \  j = j - 1\n    end\n    return count\nend", "    local len = #arr\n    local\
    \ ans = 0\n    for i = 1, math.floor(len / 2) do\n        if arr[i] ~= arr[len\
    \ - i + 1] then\n            ans = ans + 1\n        end\n    end\n    return ans\n\
    end", end, "  local tot = 0\n  local endi = #arr\n  for i=1,#arr/2 do\n    tot\
    \ = tot + math.abs(arr[i] - arr[endi])\n    endi = endi - 1\n  end\n  return tot\n\
    end", "  local len = #arr\n  local count = 0\n  local low = 1\n  local high =\
    \ len\n  while low < high do\n    if arr[low] ~= arr[high] then\n      count =\
    \ count + 1\n    end\n    low = low + 1\n    high = high - 1\n  end\n  return\
    \ count\nend", "    local len = #arr\n    local mem = {}\n    local function _sc(start,\
    \ end_)\n        if start >= end_ then\n            return 0\n        end\n  \
    \      local left, right = arr[start], arr[end_]\n        local key = string.format(\"\
    %d,%d\", start, end_)\n        if mem[key] ~= nil then\n            return mem[key]\n\
    \        end\n        if left == right then\n            mem[key] = _sc(start\
    \ + 1, end_ - 1)\n        else\n            mem[key] = 1 + math.min(_sc(start\
    \ + 1, end_), _sc(start, end_ - 1))\n        end\n        return mem[key]\n  \
    \  end\n    return _sc(1, len)\nend", "  local i = 1\n  local j = #arr\n  local\
    \ s = 0\n  while i < j do\n    if arr[i] ~= arr[j] then\n      s = s + 1\n   \
    \ end\n    i = i + 1\n    j = j - 1\n  end\n  return s\nend", "    if #arr ==\
    \ 0 then\n        return 0\n    end\n    local start = 1\n    local endd = #arr\n\
    \    local count = 0\n    while start < endd do\n        if arr[start] ~= arr[endd]\
    \ then\n            count = count + 1\n        end\n        start = start + 1\n\
    \        endd = endd - 1\n    end\n    return count\nend", "\tlocal ln = #arr\n\
    \tlocal res = 0\n\tfor i = 1, ln / 2 do\n\t\tif arr[i] ~= arr[ln - i + 1] then\n\
    \t\t\tres = res + 1\n\t\tend\n\tend\n\treturn res\nend", "  local len = #arr\n\
    \  local mid = math.floor(len / 2)", "    local t = {}\n    local c = 0\n    for\
    \ i, v in ipairs(arr) do\n        t[i] = v\n    end\n    local front = 1\n   \
    \ local back = #t\n    while front < back do\n        if t[front] ~= t[back] then\n\
    \            t[back] = t[front]\n            c = c + 1\n        end\n        front\
    \ = front + 1\n        back = back - 1\n    end\n    return c\nend", "    local\
    \ size = #arr\n    local dp = {}\n    for i = 0, size do\n        dp[i] = {}\n\
    \        for j = 0, size do\n            dp[i][j] = 0\n        end\n    end\n\
    \    for i = 0, size - 1 do\n        dp[i][i] = 0\n        dp[i][i + 1] = arr[i\
    \ + 1] == arr[i + 1] and 0 or 1\n    end\n    dp[size][size] = 0\n    for gap\
    \ = 2, size do\n        for i = 0, size - gap do\n            j = i + gap\n  \
    \          if arr[i + 1] == arr[j + 1] then\n                dp[i][j] = dp[i +\
    \ 1][j - 1]\n            else\n                dp[i][j] = math.min(dp[i + 1][j],\
    \ dp[i][j - 1]) + 1\n            end\n        end\n    end\n    return dp[0][size\
    \ - 1]\nend", "  local len = #arr\n  local l, r = 1, len\n  local changes = 0\n\
    \  while l < r do\n    if arr[l] ~= arr[r] then\n      changes = changes + 1\n\
    \    end\n    l = l + 1\n    r = r - 1\n  end\n  return changes\nend", "    local\
    \ len = #arr\n    local pal = {}\n    for i = 1, len do\n        pal[i] = {}\n\
    \        for j = 1, len do\n            pal[i][j] = 0\n        end\n    end\n\
    \    local longest = 0\n    for l = 1, len do\n        for i = 1, len - l + 1\
    \ do\n            local j = i + l - 1\n            if arr[i] == arr[j] and (l\
    \ <= 2 or pal[i + 1][j - 1] == 1) then\n                pal[i][j] = 1\n      \
    \          longest = l\n            end\n        end\n    end\n    return len\
    \ - longest\nend", "  local mid = #arr / 2\n  local max = 0\n  local count = 0\n\
    \  for i = 1, mid do\n    count = count + 1\n    local beg = arr[i]\n    local\
    \ end = arr[#arr - i + 1]\n    if beg ~= end then\n      max = max + 1\n    end\n\
    \  end\n  return max\nend", "    local len = #arr\n    local func = function(i,\
    \ j)\n        if i > j then\n            return 0\n        end\n        if arr[i]\
    \ == arr[j] then\n            return func(i + 1, j - 1)\n        else\n      \
    \      return 1 + math.min(func(i + 1, j), func(i, j - 1))\n        end\n    end\n\
    \    return func(1, len)\nend", "    local len = #arr\n    local dp = {}\n   \
    \ for i = 1, len do\n        dp[i] = {}\n        for j = 1, len do\n         \
    \   dp[i][j] = 0\n        end\n    end\n    for i = 1, len do\n        dp[i][i]\
    \ = 0\n    end\n    for i = 1, len - 1 do\n        dp[i][i + 1] = arr[i] == arr[i\
    \ + 1] and 0 or 1\n    end\n    for l = 3, len do\n        for i = 1, len - l\
    \ + 1 do\n            j = i + l - 1\n            if arr[i] == arr[j] then\n  \
    \              dp[i][j] = dp[i + 1][j - 1]\n            else\n               \
    \ dp[i][j] = math.min(dp[i + 1][j], dp[i][j - 1]) + 1\n            end\n     \
    \   end\n    end\n    return dp[1][len]\nend", "  return 0\nend", "\t-- your code\
    \ goes here\n\treturn 0\nend", "    -- Implement this function\nend", "  local\
    \ count = 0\n  for i = 1, #arr / 2 do\n    if arr[i] ~= arr[#arr - i + 1] then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "\tlocal reversed\
    \ = {}\n\tfor i = #arr, 1, -1 do\n\t\treversed[#reversed + 1] = arr[i]\n\tend\n\
    \tlocal difference = 0\n\tfor i = 1, #arr do\n\t\tif arr[i] ~= reversed[i] then\n\
    \t\t\tdifference = difference + 1\n\t\tend\n\tend\n\treturn difference / 2\nend",
  "  local arr_size = #arr\n  local mem = {}\n  for i = 1, arr_size do\n    mem[i]\
    \ = {}\n    for j = 1, arr_size do\n      mem[i][j] = 0\n    end\n  end\n  return\
    \ changes(arr, 1, arr_size, mem)\nend", "    -- check a, b, c, d\n    -- a ==\
    \ d and b == c\n    -- or\n    -- a == d\n    -- and\n    -- b == c\n    -- or\n\
    \    -- a == d\n    -- and\n    -- b == c", "  local aux = {}\n  for _,v in ipairs(arr)\
    \ do\n    table.insert(aux,v)\n  end\n  table.sort(aux)\n  local arr_len = #arr\n\
    \  local i, j = 1, arr_len\n  local cnt = 0\n  while i <= j do\n    if aux[i]\
    \ ~= arr[i] then\n      cnt = cnt + 1\n    end\n    if aux[j] ~= arr[j] then\n\
    \      cnt = cnt + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return cnt\n\
    end", "    local n = #arr\n    local dp = {}\n    for i = 0, n - 1 do\n      \
    \  dp[i] = {}\n        for j = 0, n - 1 do\n            dp[i][j] = 0\n       \
    \ end\n    end\n    for i = n - 2, 0, -1 do\n        for j = n - 1, i, -1 do\n\
    \            if i == j - 1 then\n                dp[i][j] = math.min(math.abs(arr[i]\
    \ - arr[j]), dp[i + 1][j] + 1, dp[i][j - 1] + 1)\n            else\n         \
    \       dp[i][j] = math.min(math.abs(arr[i] - arr[j]) + dp[i + 1][j - 1], dp[i\
    \ + 1][j] + 1, dp[i][j - 1] + 1)\n            end\n        end\n    end\n    return\
    \ dp[1][n]\nend", "  return 0\nend", "  -- your code here\nend", "    -- TODO:\
    \ implement this function here\n    -- do not change the function signature\n\
    end", "    local i = 1\n    local j = #arr\n    local changes = 0\n    while i\
    \ < j do\n        if arr[i] ~= arr[j] then\n            changes = changes + 1\n\
    \        end\n        i = i + 1\n        j = j - 1\n    end\n    return changes\n\
    end", "  -- fill in code here\nend", "    local n = #arr\n    local left, right\
    \ = 1, n\n    local changes = 0\n    while left < right do\n        if arr[left]\
    \ ~= arr[right] then\n            local found = false\n            for j = right,\
    \ left + 1, -1 do\n                if arr[left] == arr[j] then\n             \
    \       local temp = arr[right]\n                    arr[right] = arr[j]\n   \
    \                 arr[j] = temp\n                    changes = changes + 1\n \
    \                   found = true\n                    break\n                end\n\
    \            end\n            if not found then\n                local temp =\
    \ arr[left]\n                arr[left] = arr[right]\n                arr[right]\
    \ = temp\n                changes = changes + 1\n            end\n        end\n\
    \        left = left + 1\n        right = right - 1\n    end\n    return changes\n\
    end", "    -- \nend", "  if palindrome(arr) then\n    return 0\n  end\n  local\
    \ n = #arr\n  local changes = {}\n  local mirror = {}\n  local diffs = {}\n  local\
    \ min = n\n  local mid = math.floor(n / 2)\n  for i = 1, mid do\n    changes[i]\
    \ = {}\n    mirror[i] = {}\n    diffs[i] = {}\n    changes[i][0] = i - 1\n   \
    \ mirror[i][0] = i - 1\n    diffs[i][0] = i - 1\n    for j = 1, n do\n      changes[i][j]\
    \ = math.huge\n      mirror[i][j] = math.huge\n      diffs[i][j] = math.huge\n\
    \    end\n  end\n  for i = 1, mid do\n    for j = i, n do\n      if i == j then\n\
    \        changes[i][j] = 0\n        mirror[i][j] = 0\n        diffs[i][j] = 0\n\
    \      else\n        local diff = math.abs(arr[i] - arr[j])\n        if arr[i]\
    \ == arr[j] then\n          changes[i][j] = changes[i + 1][j - 1]\n          mirror[i][j]\
    \ = mirror[i + 1][j - 1]\n          diffs[i][j] = diffs[i + 1][j - 1]\n      \
    \  else\n          changes[i][j] = 1 + changes[i + 1][j - 1]\n          mirror[i][j]\
    \ = 1 + mirror[i + 1][j - 1]\n          diffs[i][j] = diff + diffs[i + 1][j -\
    \ 1]\n        end\n        changes[i][j] = math.min(changes[i][j], mirror[i +\
    \ 1][j])\n        changes[i][j] = math.min(changes[i][j], mirror[i][j - 1])\n\
    \        mirror[i][j] = math.min(mirror[i][j], changes[i + 1][j])\n        mirror[i][j]\
    \ = math.min(mirror[i][j], changes[i][j", "  local len = #arr\n  local min = math.huge\n\
    \  for i = 1, len do\n    local changes = 0\n    for j = 1, len do\n      if arr[j]\
    \ ~= arr[len - j + 1] then\n        changes = changes + 1\n      end\n    end\n\
    \    min = math.min(min, changes)\n    table.insert(arr, table.remove(arr, 1))\n\
    \  end\n  return min\nend", "    -- your code here\nend", "  local half = #arr\
    \ // 2\n  local changes = 0\n  for i = 1, half do\n    if arr[i] ~= arr[#arr -\
    \ i + 1] then\n      changes = changes + 1\n    end\n  end\n  return changes\n\
    end", "  local changes = 0\n  local i, j = 1, #arr\n  while i < j do\n    if arr[i]\
    \ ~= arr[j] then\n      changes = changes + 1\n    end\n    i = i + 1\n    j =\
    \ j - 1\n  end\n  return changes\nend", end, "  local i, j = 1, #arr\n  local\
    \ count = 0\n  while i < j do\n    if arr[i] ~= arr[j] then\n      count = count\
    \ + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return count\nend", " \
    \   local function recurse(arr, i, j)\n        if i >= j then\n            return\
    \ 0\n        end\n        if arr[i] == arr[j] then\n            return recurse(arr,\
    \ i + 1, j - 1)\n        else\n            return 1 + math.min(recurse(arr, i\
    \ + 1, j), recurse(arr, i, j - 1))\n        end\n    end\n    return recurse(arr,\
    \ 1, #arr)\nend", "  local n = #arr\n  local dp = {}\n  for i = 1, n do\n    dp[i]\
    \ = {}\n    for j = 1, n do\n      dp[i][j] = math.huge\n    end\n  end\n  for\
    \ i = 1, n do\n    dp[i][i] = 0\n  end\n  for l = 2, n do\n    for i = 1, n -\
    \ l + 1 do\n      local j = i + l - 1\n      if arr[i] == arr[j] then\n      \
    \  dp[i][j] = dp[i + 1][j - 1]\n      else\n        dp[i][j] = math.min(dp[i +\
    \ 1][j], dp[i][j - 1]) + 1\n      end\n    end\n  end\n  return dp[1][n]\nend",
  "    -- make sure the table contains at least two elements\n    if #arr < 2 then\n\
    \        return 0\n    end", "    local n = #arr\n    local c = {}\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            c[i][j] = 0\n        end\n \
    \   end\n    for j = 1, n do\n        c[1][j] = j - 1\n    end\n    for i = 2,\
    \ n do\n        for j = i, n do\n            if arr[i] == arr[j] then\n      \
    \          c[i][j] = c[i - 1][j - 1]\n            else\n                c[i][j]\
    \ = math.min(c[i - 1][j], c[i][j - 1]) + 1\n            end\n        end\n   \
    \ end\n    return c[n][n]\nend", "  local i, j = 1, #arr\n  local n, same = 0,\
    \ true\n  while i <= j do\n    if not same then\n      n = n + 1\n    end\n  \
    \  if arr[i] ~= arr[j] then\n      same = false\n    end\n    i = i + 1\n    j\
    \ = j - 1\n  end\n  return n\nend", "\tlocal n = #arr\n\tlocal a,b = {},{}\n\t\
    for i=1,n do\n\t\ta[i],b[i] = i%2 == 1 and 1 or 2,i%2 == 1 and 2 or 1\n\tend\n\
    \tfor i=2,n do\n\t\ta[i] = math.min(a[i],a[i-1]+1)\n\t\tb[i] = math.min(b[i],b[i-1]+1)\n\
    \tend\n\tfor i=n-1,1,-1 do\n\t\ta[i] = math.min(a[i],a[i+1]+1)\n\t\tb[i] = math.min(b[i],b[i+1]+1)\n\
    \tend\n\tlocal c = n%2 == 1 and 1 or 2\n\tfor i=1,n//2 do\n\t\tlocal j = n-i+1\n\
    \t\tif arr[i] == arr[j] then\n\t\t\ta[i] = math.min(a[i],b[i-1])\n\t\t\tb[i] =\
    \ math.min(b[i],a[i-1])\n\t\telse\n\t\t\ta[i] = math.min(a[i],b[i-1]+c)\n\t\t\t\
    b[i] = math.min(b[i],a[i-1]+c)\n\t\tend\n\tend\n\treturn a[n//2]\nend", "    local\
    \ larr = #arr\n    local larr2 = larr / 2\n    local ans = 0\n    for i = 1, larr2\
    \ do\n        if arr[i] ~= arr[larr - i + 1] then\n            ans = ans + 1\n\
    \        end\n    end\n    return ans\nend", "    local n = #arr\n    local m\
    \ = {}\n    for i = 1, n do\n        m[i] = {}\n        for j = 1, n do\n    \
    \        m[i][j] = 0\n        end\n    end\n    for l = 2, n do\n        for i\
    \ = 1, n - l + 1 do\n            local j = i + l - 1\n            if l == 2 then\n\
    \                m[i][j] = int(arr[i] ~= arr[j])\n            else\n         \
    \       m[i][j] = min(m[i + 1][j] + int(arr[i] ~= arr[j]),\n                 \
    \             m[i][j - 1] + int(arr[i] ~= arr[j]))\n            end\n        end\n\
    \    end\n    return m[1][n]\nend", "    local n = table.getn(arr)\n    local\
    \ offset = n % 2\n    local i = 1\n    local k = n\n    local count = 0\n    while\
    \ i < k do\n        if arr[i] ~= arr[k] then\n            count = count + 1\n\
    \        end\n        i = i + 1\n        k = k - 1\n    end\n    return count\n\
    end", "\tlocal n = #arr\n\tlocal min_changes = 0\n\tlocal left, right = 1, n\n\
    \twhile left < right do\n\t\tif arr[left] ~= arr[right] then\n\t\t\tmin_changes\
    \ = min_changes + 1\n\t\tend\n\t\tleft = left + 1\n\t\tright = right - 1\n\tend\n\
    \treturn min_changes\nend", "  local reverse_arr = {}\n  for i, x in ipairs(arr)\
    \ do\n    reverse_arr[#arr - i + 1] = x\n  end\n  local n = #arr\n  local change\
    \ = {}\n  for i = 1, n do\n    change[i] = {}\n    for j = 1, n do\n      change[i][j]\
    \ = 0\n    end\n  end\n  for i = 2, n do\n    for j = 1, n - i + 1 do\n      if\
    \ arr[j] == reverse_arr[j + i - 1] then\n        change[j][j + i - 1] = change[j\
    \ + 1][j + i - 2]\n      else\n        change[j][j + i - 1] = math.min(change[j\
    \ + 1][j + i - 1], change[j][j + i - 2]) + 1\n      end\n    end\n  end\n  return\
    \ change[1][n]\nend", "\t-- define the start and ending index of the input arr\n\
    \tlocal start = 1\n\tlocal ending = #arr\n\t-- the number of changes needed\n\t\
    local changes = 0\n\t-- while starting index is smaller than ending index\n\t\
    while start < ending do\n\t\t-- if the left element and right element do not match\n\
    \t\tif arr[start] ~= arr[ending] then\n\t\t\t-- increase the number of changes\
    \ needed\n\t\t\tchanges = changes + 1\n\t\tend\n\t\t-- move both pointers toward\
    \ each other\n\t\tstart = start + 1\n\t\tending = ending - 1\n\tend\n\t-- return\
    \ the number of changes needed\n\treturn changes\nend", "  return 0\nend", " \
    \ local len = #arr\n  if len == 0 then return 0 end\n  local i, j = 1, len\n \
    \ local count = 0\n  while i < j do\n    if arr[i] ~= arr[j] then\n      count\
    \ = count + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return count\n\
    end", "  local n = #arr\n  local dp = {}\n  for i = 1, n do\n    dp[i] = {}\n\
    \    for j = 1, n do\n      dp[i][j] = 1\n    end\n  end\n  for diff = 1, n -\
    \ 1 do\n    for i = 1, n - diff do\n      j = i + diff\n      if arr[i] == arr[j]\
    \ then\n        dp[i][j] = dp[i + 1][j - 1]\n      else\n        dp[i][j] = 1\
    \ + math.min(dp[i + 1][j], dp[i][j - 1])\n      end\n    end\n  end\n  return\
    \ dp[1][n]\nend", "    local n = #arr\n    local dp = {}\n    for i = 1, n do\n\
    \        dp[i] = {}\n        for j = 1, n do\n            dp[i][j] = 0\n     \
    \   end\n    end\n    for i = n - 1, 1, -1 do\n        for j = i + 1, n do\n \
    \           if arr[i] == arr[j] then\n                dp[i][j] = dp[i + 1][j -\
    \ 1]\n            else\n                dp[i][j] = math.min(dp[i + 1][j], dp[i][j\
    \ - 1]) + 1\n            end\n        end\n    end\n    return dp[1][n]\nend",
  "    local len = #arr\n    local dp = {}\n    for i = 1, len do\n        dp[i] =\
    \ {}\n        for j = 1, len do\n            dp[i][j] = 0\n        end\n    end\n\
    \    for j = 2, len do\n        for i = j - 1, 1, -1 do\n            if arr[i]\
    \ == arr[j] then\n                dp[i][j] = dp[i + 1][j - 1]\n            else\n\
    \                dp[i][j] = math.min(dp[i + 1][j], dp[i][j - 1]) + 1\n       \
    \     end\n        end\n    end\n    return dp[1][len]\nend", "  local len = #arr\n\
    \  local l, r = 1, len\n  local count = 0\n  while l < r do\n    if arr[l] ~=\
    \ arr[r] then\n      count = count + 1\n    end\n    l = l + 1\n    r = r - 1\n\
    \  end\n  return count\nend", "  local n = #arr\n  local m = math.floor(n / 2)\n\
    \  local e = n % 2\n  local r = 0\n  for i = 1, m do\n    if arr[i] ~= arr[n -\
    \ i + 1 - e] then\n      r = r + 1\n    end\n  end\n  return r\nend", "    return\
    \ 0\nend", "    local n = #arr\n    local a, b = 0, n - 1\n    local counter =\
    \ 0\n    while a < b do\n        if arr[a] ~= arr[b] then\n            counter\
    \ = counter + 1\n        end\n        a = a + 1\n        b = b - 1\n    end\n\
    \    return counter\nend", "  local n = #arr\n  local dp = {}\n  for i = 1, n\
    \ do\n    dp[i] = {}\n    for j = 1, n do\n      dp[i][j] = 1000000000\n    end\n\
    \  end\n  for i = 1, n do\n    dp[i][i] = 0\n  end\n  for l = 2, n do\n    for\
    \ i = 1, n - l + 1 do\n      local j = i + l - 1\n      if arr[i] == arr[j] then\n\
    \        dp[i][j] = dp[i + 1][j - 1]\n      else\n        for k = i, j - 1 do\n\
    \          dp[i][j] = math.min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        end\n\
    \        dp[i][j] = dp[i][j] + 1\n      end\n    end\n  end\n  return dp[1][n]\n\
    end", "    local n = #arr\n    if n <= 1 then\n        return 0\n    end\n   \
    \ -- Return if palindrome.\n    local half = math.floor(n / 2)\n    for i = 1,\
    \ half do\n        if arr[i] ~= arr[n - i + 1] then\n            break\n     \
    \   end\n        if i == half then\n            return 0\n        end\n    end\n\
    \    -- Build table of changes (ragged table):\n    -- rows is number of elements\
    \ to change in first half of array.\n    -- first row is the empty changes.\n\
    \    -- columns is index of elements to change in array.\n    -- last column is\
    \ the empty changes.\n    local rows = half\n    local columns = half + 1\n  \
    \  local changes = { { 0 } }\n    for i = 1, rows do\n        changes[i] = { }\n\
    \        for j = 1, columns do\n            changes[i][j] = n\n        end\n \
    \   end\n    for j = 1, columns do\n        if arr[j] == arr[n - j + 1] then\n\
    \            changes[1][j] = 0\n        else\n            changes[1][j] = 1\n\
    \        end\n    end\n    for i = 2, rows do\n        for j = 1, columns do\n\
    \            if arr[i] == arr[n - j + 1] then\n                changes[i][j] =\
    \ changes[i - 1][j]\n            else\n                changes[i][j] = 1 + math.min(changes[i\
    \ - 1][j], changes[i][j - 1])\n            end\n        end\n    end\n    return\
    \ changes[rows][columns]\nend", "    -- see if the table is already palindromic\n\
    \    local is_palindromic = true\n    for i = 1, #arr do\n        if arr[i] ~=\
    \ arr[#arr - i + 1] then\n            is_palindromic = false\n            break\n\
    \        end\n    end\n    if is_palindromic then\n        return 0\n    end",
  "\tlocal arr_len = #arr\n\tlocal len = math.floor(arr_len / 2)\n\tlocal changes\
    \ = 0\n\tlocal pos = 1\n\twhile pos <= len do\n\t\tchanges = changes + math.abs(arr[pos]\
    \ - arr[arr_len - pos + 1])\n\t\tpos = pos + 1\n\tend\n\treturn changes\nend",
  "  -- Put your code here!\nend", "  -- Your code here\nend", "    local n = #arr\n\
    \    local m = math.floor(n / 2)\n    local diff = 0\n    for i = 1, m do\n  \
    \      if arr[i] ~= arr[n - i + 1] then\n            diff = diff + 1\n       \
    \ end\n    end\n    return diff\nend", "    -- your code here\nend", "  local\
    \ ans = 0\n  local len = #arr\n  for i = 1, math.floor(len / 2) do\n    ans =\
    \ ans + math.abs(arr[i] - arr[len + 1 - i])\n  end\n  return ans\nend", "    local\
    \ n = #arr\n    local min = 999999999\n    for i = 1, n do\n        local t =\
    \ 0\n        for j = 1, n do\n            local idx = (j + i - 1) % n + 1\n  \
    \          t = t + math.abs(arr[j] - arr[idx])\n        end\n        if t < min\
    \ then\n            min = t\n        end\n    end\n    return min\nend", "\tlocal\
    \ function reverse(arr)\n\t\tlocal len = #arr\n\t\tlocal new = {}\n\t\tfor i =\
    \ 1, len do\n\t\t\tnew[i] = arr[len - i + 1]\n\t\tend\n\t\treturn new\n\tend\n\
    \tlocal function changes(arr1, arr2)\n\t\tlocal len = #arr1\n\t\tlocal count =\
    \ 0\n\t\tfor i = 1, len do\n\t\t\tif arr1[i] ~= arr2[i] then\n\t\t\t\tcount =\
    \ count + 1\n\t\t\tend\n\t\tend\n\t\treturn count\n\tend\n\treturn changes(arr,\
    \ reverse(arr))\nend", "  local len = #arr\n  local changes = 0\n  for i = 1,\
    \ len / 2 do\n    if arr[i] ~= arr[len - i + 1] then\n      changes = changes\
    \ + 1\n    end\n  end\n  return changes\nend", "    local len = #arr\n    local\
    \ mid = math.floor(len / 2)\n    local change = 0\n    for i = 1, mid do\n   \
    \     if arr[i] ~= arr[len + 1 - i] then\n            change = change + 1\n  \
    \      end\n    end\n    return change\nend", "    -- TODO: your code here\nend",
  "    -- your code here\nend", "    local len = #arr\n    local memo = {}\n    local\
    \ arr_reverse = {}\n    for i = 1, len do\n        arr_reverse[i] = arr[len +\
    \ 1 - i]\n    end\n    local function foo(i, j)\n        local key = i .. '|'\
    \ .. j\n        if memo[key] ~= nil then\n            return memo[key]\n     \
    \   end\n        if i == j then\n            memo[key] = 0\n            return\
    \ 0\n        end\n        if i == j - 1 then\n            memo[key] = arr[i] ==\
    \ arr[j] and 0 or 1\n            return memo[key]\n        end\n        if arr[i]\
    \ == arr[j] then\n            memo[key] = foo(i + 1, j - 1)\n            return\
    \ memo[key]\n        end\n        memo[key] = math.min(foo(i + 1, j), foo(i, j\
    \ - 1)) + 1\n        return memo[key]\n    end\n    return foo(1, len)\nend",
  "    -- Loop through elements of arr, stoping when reach midpoint. Each iteration,\n\
    \    -- compare the corresponding elements on opposite sides of the table.\n \
    \   -- If the value is not equal, then set count to that value + 1.\n    local\
    \ count = 0\n    for i=1, math.floor(#arr/2) do\n        if arr[i] ~= arr[#arr\
    \ - i + 1] then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "  local count = 0\n  local reversed = table.reverse(arr)\n  for\
    \ i = 1, #arr do\n    if arr[i] ~= reversed[i] then\n      count = count + 1\n\
    \    end\n  end\n  return count\nend", "    local n = #arr\n    local cost = {}\n\
    \    for i = 1, n do\n        cost[i] = {}\n        for j = 1, n do\n        \
    \    cost[i][j] = 0\n        end\n    end\n    for i = 2, n do\n        cost[i\
    \ - 1][i] = arr[i - 1] ~= arr[i] and 1 or 0\n    end\n    for l = 3, n do\n  \
    \      for i = 1, n - l + 1 do\n            j = i + l - 1\n            if arr[i]\
    \ == arr[j] then\n                cost[i][j] = cost[i + 1][j - 1]\n          \
    \  else\n                cost[i][j] = math.min(cost[i + 1][j], cost[i][j - 1])\
    \ + 1\n            end\n        end\n    end\n    return cost[1][n]\nend", " \
    \   local n = #arr\n    local dp = tablex.deepcopy(arr)\n    for i = 2, n do\n\
    \        local nj = dp[i]\n        for j = i - 1, 1, -1 do\n            local\
    \ nk = dp[j]\n            local nl = dp[i - j + 1]\n            if nj == nl then\n\
    \                dp[j] = nk\n            else\n                dp[j] = math.min(nk,\
    \ nl) + 1\n            end\n        end\n    end\n    return dp[1]\nend", "  local\
    \ start, last = 1, #arr\n  local changes = 0\n  while start < last do\n    if\
    \ arr[start] ~= arr[last] then\n      changes = changes + 1\n    end\n    start\
    \ = start + 1\n    last = last - 1\n  end\n  return changes\nend", '  -- your
    code here', "    local n = #arr\n    if n == 0 then return -1 end\n    if n ==\
    \ 1 then return 0 end\n    if n == 2 then return 1 end\n    local max_len = 0\n\
    \    for i = 1, n do\n        if arr[i] == arr[n - i + 1] then\n            max_len\
    \ = max_len + 1\n        end\n    end\n    if max_len < 2 then return -1 end\n\
    \    return n - max_len\nend", "  local n = #arr\n  local arr2 = {}\n  for i =\
    \ n, 1, -1 do\n    arr2[n-i+1] = arr[i]\n  end\n  local dp = {}\n  for i = 0,\
    \ n do\n    dp[i] = {}\n    for j = 0, n do\n      dp[i][j] = 0\n    end\n  end\n\
    \  for i = 1, n do\n    for j = 1, n do\n      if arr[i] == arr2[j] then\n   \
    \     dp[i][j] = dp[i-1][j-1] + 1\n      else\n        dp[i][j] = math.max(dp[i-1][j],\
    \ dp[i][j-1])\n      end\n    end\n  end\n  return n - dp[n][n]\nend", "    local\
    \ n = #arr\n    local dp = {}\n    local i, j\n    for i = 1, n do\n        dp[i]\
    \ = {}\n        for j = 1, n do\n            dp[i][j] = 0\n        end\n    end\n\
    \    for i = 1, n do\n        for j = 1, n do\n            if (i == j) then\n\
    \                dp[i][j] = 0\n            elseif (i == j + 1) then\n        \
    \        dp[i][j] = arr[i] ~= arr[j] and 1 or 0\n            else\n          \
    \      dp[i][j] = math.min(dp[i][j - 1] + (arr[j] ~= arr[i] and 1 or 0), dp[i\
    \ + 1][j] + (arr[j] ~= arr[i] and 1 or 0))\n            end\n        end\n   \
    \ end\n    return dp[1][n]\nend", "    local reversed = reverse(arr)\n    local\
    \ cost = 0\n    for i, e in ipairs(arr) do\n        if e ~= reversed[i] then\n\
    \            cost = cost + 1\n        end\n    end\n    return cost\nend", " \
    \   -- Your code here\nend", "    local len = #arr\n    local i = 1\n    local\
    \ j = len\n    local ch = 0\n    while i < j do\n        if arr[i] ~= arr[j] then\n\
    \            ch = ch + 1\n        end\n        i = i + 1\n        j = j - 1\n\
    \    end\n    return ch\nend", "\tlocal n = #arr\n\tif n == 0 then return 0 end\n\
    \tlocal function aux(i, j)\n\t\tif i >= j then return 0 end\n\t\tif arr[i] ==\
    \ arr[j] then\n\t\t\treturn aux(i + 1, j - 1)\n\t\telse\n\t\t\treturn 1 + min(aux(i\
    \ + 1, j), aux(i, j - 1))\n\t\tend\n\tend\n\treturn aux(1, n)\nend", "  local\
    \ n = #arr\n  local m = table.concat(arr)\n  if m == strrev(m) then return 0 end",
  "\t-- your code here\nend", "    if #arr == 0 then\n        return 0\n    end\n\
    \    local i = 1\n    local j = #arr\n    local count = 0\n    while i < j do\n\
    \        if arr[i] ~= arr[j] then\n            count = count + 1\n        end\n\
    \        i = i + 1\n        j = j - 1\n    end\n    return count\nend", "    --\
    \ Write your code here\n    local l = #arr\n    local m = math.floor(l/2)\n  \
    \  local change = 0\n    local left, right = 1, l\n    while left <= right do\n\
    \        if arr[left] ~= arr[right] then\n            change = change + 1\n  \
    \      end\n        left = left + 1\n        right = right - 1\n    end\n    return\
    \ change\nend", "\tif not arr then return 0 end\n\tlocal N = #arr\n\tif N <= 1\
    \ then return 0 end\n\tlocal h = {}\n\tfor i = 1, N do\n\t\th[i] = {}\n\t\tfor\
    \ j = 1, N do\n\t\t\th[i][j] = 0\n\t\tend\n\tend\n\tfor i = 1, N - 1 do\n\t\t\
    if arr[i] ~= arr[N - i + 1] then\n\t\t\th[i][N - i + 1] = 1\n\t\tend\n\tend\n\t\
    for i = 1, N - 2 do\n\t\tfor j = i + 2, N do\n\t\t\tif arr[i] == arr[j] then\n\
    \t\t\t\th[i][j] = h[i + 1][j - 1]\n\t\t\telse\n\t\t\t\th[i][j] = math.min(h[i\
    \ + 1][j], h[i][j - 1]) + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn h[1][N]\nend",
  "    -- This solution is based on the observation that if we consider the table\
    \ as\n    -- two separate tables (the first N / 2 elements and the last N / 2\
    \ elements)\n    -- then the smallest number of elements that need to be changed\
    \ in order to\n    -- make the table palindromic is the number of elements that\
    \ are different\n    -- in the two tables.\n    local arr_len = #arr\n    local\
    \ half_len = arr_len / 2\n    local half_len_floor = math.floor(half_len)\n  \
    \  local result = 0\n    for i = 1, half_len_floor do\n        if arr[i] ~= arr[arr_len\
    \ - i + 1] then\n            result = result + 1\n        end\n    end\n    return\
    \ result\nend", "\tlocal result = 0\n\tlocal i = 1\n\tlocal j = #arr\n\twhile\
    \ i < j do\n\t\tif arr[i] ~= arr[j] then\n\t\t\tresult = result + 1\n\t\tend\n\
    \t\ti = i + 1\n\t\tj = j - 1\n\tend\n\treturn result\nend", '  local n = #arr',
  "    local i = 1\n    local j = #arr\n    local changes = 0\n    while i < j do\n\
    \        if arr[i] ~= arr[j] then\n            changes = changes + 1\n       \
    \ end\n        i = i + 1\n        j = j - 1\n    end\n    return changes\nend",
  "  -- TODO: Finish me!\nend", "  -- Your code here!\nend", "  local len = table.maxn(arr)\n\
    \  local left, right = 1, len\n  local changes = 0\n  while left < right do\n\
    \    if arr[left] ~= arr[right] then\n      changes = changes + 1\n    end\n \
    \   left = left + 1\n    right = right - 1\n  end\n  return changes\nend", " \
    \ local count = 0\n  for i = 1, #arr // 2 do\n    count = count + math.abs(arr[i]\
    \ - arr[#arr - i + 1])\n  end\n  return count\nend", "  local n = #arr\n  local\
    \ dp = {}\n  for i = 0, n-1 do\n    dp[i] = {}\n    for j = 0, n-1 do\n      dp[i][j]\
    \ = math.huge\n    end\n  end\n  for i = 0, n-1 do\n    dp[i][i] = 0\n  end\n\
    \  for len = 2, n do\n    for i = 0, n-len do\n      local j = i + len - 1\n \
    \     if arr[i+1] == arr[j+1] then\n        dp[i][j] = dp[i+1][j-1]\n      else\n\
    \        dp[i][j] = math.min(dp[i+1][j], dp[i][j-1]) + 1\n      end\n    end\n\
    \  end\n  return dp[0][n-1]\nend", "    -- your code goes here\nend", "  -- your\
    \ code here\nend", "  local n = #arr\n  local sum = 0\n  for i = 1, math.floor(n\
    \ / 2) do\n    sum = sum + math.abs(arr[i] - arr[n - i + 1])\n  end\n  return\
    \ sum\nend", "\t-- TODO\nend", "    if #arr < 2 then\n        return 0\n    end\n\
    \    local mid = math.floor(#arr / 2)\n    local count = 0\n    for i = 1, mid\
    \ do\n        local rev_idx = #arr - i + 1\n        if arr[i] ~= arr[rev_idx]\
    \ then\n            count = count + 1\n        end\n    end\n    return count\n\
    end", "    local min = math.huge\n    for i = 1, #arr do\n        local change\
    \ = 0\n        for j = 1, math.floor(#arr / 2) do\n            if arr[j] ~= arr[#arr\
    \ - j + 1] then\n                change = change + 1\n            end\n      \
    \  end\n        if change < min then\n            min = change\n        end\n\
    \        table.insert(arr, 1, table.remove(arr))\n    end\n    return min\nend",
  "  local N = #arr\n  local L = {}\n  for i = 1, N do\n    L[i] = {}\n    for j =\
    \ 1, N do\n      L[i][j] = 0\n    end\n  end\n  for c = 1, N - 1 do\n    for i\
    \ = 1, N - c do\n      local j = i + c\n      if arr[i] == arr[j] then\n     \
    \   L[i][j] = L[i + 1][j - 1]\n      else\n        L[i][j] = math.min(L[i + 1][j],\
    \ L[i][j - 1]) + 1\n      end\n    end\n  end\n  return L[1][N]\nend", "  local\
    \ i, j = 1, #arr\n  local n = 0\n  while i < j do\n    if arr[i] ~= arr[j] then\n\
    \      n = n + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return n\nend",
  "    -- write your solution here\n    -- return 0\nend", "  local len = #arr\n \
    \ local is_palindrome = true\n  for k = 1, math.floor(len / 2) do\n    if arr[k]\
    \ ~= arr[len - k + 1] then\n      is_palindrome = false\n      break\n    end\n\
    \  end\n  if is_palindrome then\n    return 0\n  end\n  local matrix = {}\n  for\
    \ i = 1, len do\n    matrix[i] = {}\n    for j = 1, len do\n      matrix[i][j]\
    \ = 0\n    end\n  end\n  for i = 1, len do\n    matrix[i][i] = 1\n  end\n  for\
    \ len = 2, len do\n    for i = 1, len - 1 do\n      local j = i + len - 1\n  \
    \    matrix[i][j] = 1 + matrix[i + 1][j]\n      if arr[i] == arr[j] then\n   \
    \     matrix[i][j] = math.min(matrix[i][j], matrix[i + 1][j - 1])\n      end\n\
    \      for k = i + 1, j - 1 do\n        matrix[i][j] = math.min(matrix[i][j],\
    \ 1 + matrix[i][k] + matrix[k + 1][j])\n      end\n    end\n  end\n  return matrix[1][len]\n\
    end", "    local i, j = 1, #arr\n    local count = 0\n    while i < j do\n   \
    \     if arr[i] ~= arr[j] then\n            if arr[i] < arr[j] then\n        \
    \        arr[i] = arr[j]\n            else\n                arr[j] = arr[i]\n\
    \            end\n            count = count + 1\n        end\n        i = i +\
    \ 1\n        j = j - 1\n    end\n    return count\nend", "  local len = #arr\n\
    \  local mid = math.floor(len / 2)\n  local sum = 0\n  for i = 1, mid do\n   \
    \ sum = sum + math.abs(arr[i] - arr[len - i + 1])\n  end\n  return sum\nend",
  "    local n = #arr\n    local dp = {}\n    for i = 1, n do\n        dp[i] = {}\n\
    \        for j = 1, n do\n            dp[i][j] = 0\n        end\n    end\n   \
    \ for i = n - 1, 1, -1 do\n        for j = i + 1, n do\n            if arr[i]\
    \ == arr[j] then\n                dp[i][j] = dp[i + 1][j - 1]\n            else\n\
    \                dp[i][j] = math.min(dp[i + 1][j - 1], dp[i + 1][j], dp[i][j -\
    \ 1]) + 1\n            end\n        end\n    end\n    return dp[1][n]\nend", " \
    \ -- your code here\nend", "  local n = #arr\n  local table.sub = table.sub or\
    \ function(t, i, j)\n    local res = {}\n    for k = i, j do\n      res[#res +\
    \ 1] = t[k]\n    end\n    return res\n  end\n  local function reverse(t)\n   \
    \ local res = {}\n    for i = #t, 1, -1 do\n      res[#res + 1] = t[i]\n    end\n\
    \    return res\n  end\n  local function solve(i, j)\n    if j - i <= 1 then\n\
    \      return 0\n    end\n    if arr[i] == arr[j] then\n      return solve(i +\
    \ 1, j - 1)\n    end\n    return 1 + min(solve(i + 1, j), solve(i, j - 1))\n \
    \ end\n  return solve(1, n)\nend", "    local n = #arr\n    local count = 0\n\
    \    for i = 1, n / 2 do\n        if arr[i] ~= arr[n - i + 1] then\n         \
    \   count = count + 1\n        end\n    end\n    return count\nend", "    local\
    \ n = #arr\n    local copy = { table.unpack(arr) }\n    for i = 1, n / 2 do\n\
    \        local j = n - i + 1\n        if arr[i] ~= arr[j] then\n            local\
    \ min = math.min(arr[i], arr[j])\n            local max = math.max(arr[i], arr[j])\n\
    \            arr[i] = min\n            arr[j] = min\n            if arr[i + 1]\
    \ == max then\n                arr[i + 1] = min\n            else\n          \
    \      arr[j - 1] = min\n            end\n        end\n    end\n    local changes\
    \ = 0\n    for i = 1, n do\n        if arr[i] ~= copy[i] then\n            changes\
    \ = changes + 1\n        end\n    end\n    return changes\nend", "\tassert(#arr\
    \ > 0)\n\tif #arr == 1 then return 0 end\n\tlocal n = #arr\n\tlocal m = math.floor(n\
    \ / 2)\n\tlocal i, j = 1, n\n\tlocal count = 0\n\twhile i <= m and j > m do\n\t\
    \tif arr[i] ~= arr[j] then\n\t\t\tcount = count + 1\n\t\tend\n\t\ti = i + 1\n\t\
    \tj = j - 1\n\tend\n\treturn count\nend", "  local len = #arr\n  local table_list\
    \ = {}\n  local num_list = {}\n  --lizard.print_r(arr)\n  for i=1, len do\n  \
    \  table_list[i] = arr[i]\n    num_list[i] = i\n  end\n  --lizard.print_r(table_list)\n\
    \  --lizard.print_r(num_list)\n  --lizard.print_r(table_add(table_list, num_list))\n\
    \  return table_add(table_list, num_list)\nend", "  -- TODO: Your code here.\n\
    end", "    local len = #arr\n    local dp = table.copy(arr)\n    for i = len -\
    \ 1, 1, -1 do\n        for j = i + 1, len do\n            if arr[i] == arr[j]\
    \ then\n                dp[j] = math.min(dp[j], dp[j - 1])\n            else\n\
    \                dp[j] = math.min(dp[j], dp[j - 1] + 1)\n            end\n   \
    \     end\n    end\n    return dp[len]\nend", "    local min_changes = 0\n   \
    \ local last_index = #arr\n    for i = 1, last_index / 2 do\n        if arr[i]\
    \ ~= arr[last_index - i + 1] then\n            min_changes = min_changes + 1\n\
    \        end\n    end\n    return min_changes\nend", "    local n = #arr\n   \
    \ local m = math.floor(n / 2)\n    local changes = 0\n    for i = 1, m do\n  \
    \      local j = n - i + 1\n        if arr[i] ~= arr[j] then\n            changes\
    \ = changes + 1\n        end\n    end\n    return changes\nend", "    local n\
    \ = #arr\n    local table_a = {}\n    local table_b = {}\n    local min_changes\
    \ = n\n    local a, b\n    for i=1,n,1 do\n        table_a[i] = arr[i]\n     \
    \   table_b[i] = arr[n - i + 1]\n    end\n    for i=1,n,1 do\n        if table_a[i]\
    \ ~= table_b[i] then\n            min_changes = min_changes + 1\n        end\n\
    \    end\n    return min_changes\nend", '    local length = #arr', "    -- YOUR\
    \ CODE HERE\n    local n = #arr\n    local l, r = 1, n\n    local changes = 0\n\
    \    while l < r do\n        if arr[l] ~= arr[r] then\n            changes = changes\
    \ + 1\n        end\n        l = l + 1\n        r = r - 1\n    end\n    return\
    \ changes\nend", "  local count = 0\n  local i = 1\n  local j = #arr\n  while\
    \ i < j do\n    if arr[i] ~= arr[j] then\n      count = count + 1\n    end\n \
    \   i = i + 1\n    j = j - 1\n  end\n  return count\nend", "    local l, r = 1,\
    \ #arr\n    local k = 0\n    while l < r do\n        if arr[l] ~= arr[r] then\n\
    \            k = k + 1\n        end\n        l = l + 1\n        r = r - 1\n  \
    \  end\n    return k\nend", "  local len = #arr\n  local reverse = {}\n  for i\
    \ = 1, len do\n    reverse[i] = arr[len - i + 1]\n  end\n  local memo = {}\n \
    \ local function dp(i, j)\n    if memo[i] == nil then\n      memo[i] = {}\n  \
    \  end\n    if memo[i][j] then\n      return memo[i][j]\n    end\n    if i > j\
    \ then\n      return 0\n    end\n    if i == j then\n      return 1\n    end\n\
    \    if arr[i] == reverse[j] then\n      return dp(i + 1, j - 1)\n    end\n  \
    \  local result = math.min(dp(i + 1, j), dp(i, j - 1)) + 1\n    memo[i][j] = result\n\
    \    return result\n  end\n  return dp(1, len)\nend", "\tlocal l = #arr\n\tlocal\
    \ c = 0\n\tlocal i = 1\n\tlocal j = l\n\twhile i < j do\n\t\tif arr[i] ~= arr[j]\
    \ then\n\t\t\tc = c + 1\n\t\tend\n\t\ti = i + 1\n\t\tj = j - 1\n\tend\n\treturn\
    \ c\nend", "    local sum_1, sum_2 = 0, 0\n    for i, v in ipairs(arr) do\n  \
    \      if i <= #arr / 2 then\n            sum_1 = sum_1 + v\n        else\n  \
    \          sum_2 = sum_2 + v\n        end\n    end\n    return sum_1 > sum_2 and\
    \ sum_1 - sum_2 or sum_2 - sum_1\nend", end, "  if #arr == 0 then return 0 end\n\
    \  local n = #arr\n  local change = 0\n  for i = 1, math.floor(n / 2) do\n   \
    \ if arr[i] ~= arr[n - i + 1] then\n      change = change + 1\n    end\n  end\n\
    \  return change\nend", "    local count = 0\n    for i = 1, #arr do\n       \
    \ if arr[i] ~= arr[#arr - i + 1] then\n            count = count + 1\n       \
    \ end\n    end\n    return count\nend", "    local len = #arr\n    local dp =\
    \ {}\n    for i = 0, len do\n        dp[i] = {}\n        for j = 0, len do\n \
    \           dp[i][j] = i == j and 0 or len\n        end\n    end\n    for step\
    \ = 1, len do\n        for i = 1, len - step + 1 do\n            local j = i +\
    \ step - 1\n            if arr[i] == arr[j] then\n                dp[i][j] = dp[i\
    \ + 1][j - 1]\n            else\n                dp[i][j] = math.min(dp[i + 1][j],\
    \ dp[i][j - 1]) + 1\n            end\n        end\n    end\n    return dp[1][len]\n\
    end", "    local n = #arr\n    local memo = {}\n    local function lcs(i, j)\n\
    \        if i == j then return 0 end\n        if i == j - 1 then return arr[i]\
    \ == arr[j] and 0 or 1 end\n        if memo[i] and memo[i][j] then return memo[i][j]\
    \ end\n        if not memo[i] then memo[i] = {} end\n        if arr[i] == arr[j]\
    \ then\n            memo[i][j] = lcs(i + 1, j - 1)\n        else\n           \
    \ memo[i][j] = math.min(lcs(i + 1, j), lcs(i, j - 1)) + 1\n        end\n     \
    \   return memo[i][j]\n    end\n    return lcs(1, n)\nend", "    local sum = 0\n\
    \    local i = 1\n    local j = #arr\n    while i < j do\n        sum = sum +\
    \ math.abs(arr[i] - arr[j])\n        i = i + 1\n        j = j - 1\n    end\n \
    \   return sum\nend", "    local len = #arr\n    local palindrome_matrix = {}\n\
    \    for i = 1, len do\n        palindrome_matrix[i] = {}\n        for j = 1,\
    \ len do\n            palindrome_matrix[i][j] = 0\n        end\n    end\n    for\
    \ i = 1, len do\n        palindrome_matrix[i][i] = 0\n    end\n    for i = 1,\
    \ len - 1 do\n        palindrome_matrix[i][i + 1] = arr[i] == arr[i + 1] and 0\
    \ or 1\n    end\n    for j = 2, len - 1 do\n        for i = 1, len - j do\n  \
    \          local e = arr[i] == arr[i + j] and 0 or 1\n            palindrome_matrix[i][i\
    \ + j] = math.min(palindrome_matrix[i + 1][i + j] + 1,\n                     \
    \                              palindrome_matrix[i][i + j - 1] + 1,\n        \
    \                                           palindrome_matrix[i + 1][i + j - 1]\
    \ + e)\n        end\n    end\n    return palindrome_matrix[1][len]\nend", "  \
    \  local n = #arr\n    local dp = Array.array(n, n)\n    for i = 1, n do\n   \
    \     dp[i][i] = 0\n    end\n    for l = 2, n do\n        for i = 1, n - l + 1\
    \ do\n            local j = i + l - 1\n            if arr[i] == arr[j] then\n\
    \                dp[i][j] = dp[i + 1][j - 1]\n            else\n             \
    \   dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n            end\n        end\n\
    \    end\n    return dp[1][n]\nend", "    local n = #arr\n    local dp = {}\n\
    \    for i = 1, n do\n        dp[i] = {}\n        for j = 1, n do\n          \
    \  dp[i][j] = -1\n        end\n    end\n    local function solve(i, j)\n     \
    \   if dp[i][j] == -1 then\n            if i >= j then\n                dp[i][j]\
    \ = 0\n            elseif arr[i] == arr[j] then\n                dp[i][j] = solve(i\
    \ + 1, j - 1)\n            else\n                dp[i][j] = 1 + math.min(solve(i\
    \ + 1, j), solve(i, j - 1))\n            end\n        end\n        return dp[i][j]\n\
    \    end\n    return solve(1, n)\nend", "  local count = 0\n  local i = 1\n  local\
    \ j = #arr\n  while i < j do\n    if arr[i] ~= arr[j] then\n      count = count\
    \ + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return count\nend", " \
    \ local n = #arr\n  local dp = {}\n  for i = 0, n do\n    dp[i] = {}\n    for\
    \ j = 0, n do\n      dp[i][j] = 0\n    end\n  end\n  for diff = 1, n - 1 do\n\
    \    for i = 1, n - diff do\n      j = i + diff\n      dp[i][j] = math.min(dp[i][j\
    \ - 1] + 1, dp[i + 1][j] + 1)\n      if arr[i] == arr[j] then\n        dp[i][j]\
    \ = math.min(dp[i][j], dp[i + 1][j - 1])\n      end\n    end\n  end\n  return\
    \ dp[1][n]\nend", "    -- TODO: implement this function\n    local n = #arr\n\
    \    local dp = {}\n    for i = 0, n do\n        dp[i] = {}\n        for j = 0,\
    \ n do\n            dp[i][j] = 0\n        end\n    end\n    for i = 1, n do\n\
    \        for j = 1, n - i + 1 do\n            local k = j + i - 1\n          \
    \  if j == k then\n                dp[j][k] = 0\n            elseif j + 1 == k\
    \ then\n                dp[j][k] = arr[j] == arr[k] and 0 or 1\n            else\n\
    \                dp[j][k] = math.min(dp[j + 1][k - 1] + (arr[j] == arr[k] and\
    \ 0 or 1),\n                                    dp[j + 1][k] + 1,\n          \
    \                          dp[j][k - 1] + 1)\n            end\n        end\n \
    \   end\n    return dp[1][n]\nend", "  local n = #arr\n  local table_count = {}\n\
    \  local table_keys = {}\n  for i = 1, n do\n    local key = arr[i]\n    if table_count[key]\
    \ == nil then\n      table_count[key] = 1\n      table_keys[#table_keys + 1] =\
    \ key\n    else\n      table_count[key] = table_count[key] + 1\n    end\n  end\n\
    \  local middle_numbers = {}\n  for _, key in ipairs(table_keys) do\n    if table_count[key]\
    \ % 2 == 1 then\n      middle_numbers[#middle_numbers + 1] = key\n    end\n  end\n\
    \  if n % 2 == 1 then\n    if #middle_numbers > 1 then\n      middle_numbers[#middle_numbers]\
    \ = nil\n    end\n  else\n    if #middle_numbers > 0 then\n      middle_numbers[#middle_numbers]\
    \ = nil\n    end\n  end\n  return #middle_numbers\nend", "    local count = 0\n\
    \    local len = #arr\n    local left = 1\n    local right = len\n    while left\
    \ < right do\n        if arr[left] ~= arr[right] then\n            count = count\
    \ + 1\n        end\n        left = left + 1\n        right = right - 1\n    end\n\
    \    return count\nend", "\tlocal size = #arr\n\tif arr[1] == arr[size] then\n\
    \t\ttable.remove(arr, 1)\n\t\ttable.remove(arr, size-1)\n\t\treturn smallest_change(arr)\n\
    \telse\n\t\treturn size-1\n\tend\nend", "    -- Find max palindrome and count\
    \ non-palindrome elements\n    local n = #arr\n    local count = 0\n    local\
    \ last = 1\n    for i = 1, math.floor(n / 2) do\n        if arr[i] ~= arr[n -\
    \ i + 1] then\n            count = count + 1\n            last = i\n        end\n\
    \    end\n    if count == 0 then\n        return 0\n    end\n    -- Change value\
    \ if necessary\n    if arr[last] ~= arr[n - last + 1] then\n        arr[last]\
    \ = arr[n - last + 1]\n        return count\n    end\n    return count - 1\nend",
  "    local len = #arr\n    local min_changes = 0\n    for i = 1, len do\n      \
    \  if arr[i] ~= arr[len + 1 - i] then\n            min_changes = min_changes +\
    \ 1\n        end\n    end\n    return min_changes\nend", "    local n = #arr\n\
    \    local max_len = 0\n    local dp = {}", "  if not arr then return nil end\n\
    \  local len = #arr\n  if len < 2 then return 0 end\n  local mid, m, n, count,\
    \ i = (len+1)/2, 1, len, 0, len\n  while m < n do\n    if arr[m] ~= arr[n] then\n\
    \      count = count + 1\n    end\n    m = m + 1\n    n = n - 1\n  end\n  return\
    \ count\nend", "  local n = #arr\n  local t = {}\n  for i = 1, n do\n    t[i]\
    \ = {}\n    for j = 1, n do\n      t[i][j] = 0\n    end\n  end\n  for i = 1, n\
    \ do\n    t[i][i] = 0\n  end\n  for i = 1, n - 1 do\n    if arr[i] ~= arr[i +\
    \ 1] then\n      t[i][i + 1] = 1\n    end\n  end\n  for i = 3, n do\n    for j\
    \ = 1, n - i + 1 do\n      if arr[j] == arr[j + i - 1] then\n        t[j][j +\
    \ i - 1] = t[j + 1][j + i - 2]\n      else\n        t[j][j + i - 1] = 1 + math.min(t[j\
    \ + 1][j + i - 1], t[j][j + i - 2])\n      end\n    end\n  end\n  return t[1][n]\n\
    end", "    return -1\nend", "    local l = #arr\n    local forward = {}\n    local\
    \ backward = {}\n    for i = 1, l do\n        forward[i] = arr[i]\n        backward[i]\
    \ = arr[l - i + 1]\n    end\n    for i = 1, l do\n        if forward[i] ~= backward[i]\
    \ then\n            forward[i] = nil\n            backward[i] = nil\n        end\n\
    \    end\n    return #forward + #backward\nend", "  local n = #arr\n  local min_diff\
    \ = math.huge\n  for mid in ipairs(arr) do\n    local i, j = mid - 1, mid + 1\n\
    \    local diff = 0\n    while i >= 1 and j <= n do\n      if arr[i] ~= arr[j]\
    \ then\n        diff = diff + 1\n      end\n      i, j = i - 1, j + 1\n    end\n\
    \    min_diff = math.min(min_diff, diff)\n  end\n  return min_diff\nend", "\t\
    local min_changes = 0\n\tlocal i, j = 1, #arr\n\twhile i < j do\n\t\tlocal a =\
    \ arr[i]\n\t\tlocal b = arr[j]\n\t\tif a == b then\n\t\t\ti = i + 1\n\t\t\tj =\
    \ j - 1\n\t\telse\n\t\t\tmin_changes = min_changes + 1\n\t\t\tif a > b then\n\t\
    \t\t\tj = j - 1\n\t\t\telse\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\tend\n\t\
    return min_changes\nend", "  if arr[1] == arr[#arr] then\n    table.remove(arr,\
    \ 1)\n    table.remove(arr, #arr)\n    return smallest_change(arr)\n  else\n \
    \   return #arr\n  end\nend", "    local endIndex = #arr\n    local startIndex\
    \ = 1\n    local change = 0\n    while endIndex > startIndex do\n        if arr[endIndex]\
    \ ~= arr[startIndex] then\n            change = change + 1\n        end\n    \
    \    endIndex = endIndex - 1\n        startIndex = startIndex + 1\n    end\n \
    \   return change\nend", "  local n = #arr\n  local dp = {}\n  for i = 0, n -\
    \ 1 do\n    dp[i] = {}\n    for j = 0, n - 1 do\n      dp[i][j] = 0\n    end\n\
    \  end\n  for l = 1, n do\n    for i = 0, n - l do\n      j = i + l - 1\n    \
    \  if i == j then\n        dp[i][j] = 0\n      elseif l == 2 then\n        dp[i][j]\
    \ = arr[i + 1] == arr[j + 1] and 0 or 1\n      else\n        dp[i][j] = arr[i\
    \ + 1] == arr[j + 1] and dp[i + 1][j - 1] or (1 + math.min(dp[i + 1][j], dp[i][j\
    \ - 1]))\n      end\n    end\n  end\n  return dp[0][n - 1]\nend", "  if #arr %\
    \ 2 == 0 then\n    local mid = #arr / 2\n    local elem_counts = {}\n    for idx\
    \ = 1, #arr do\n      if elem_counts[arr[idx]] == nil then\n        elem_counts[arr[idx]]\
    \ = 0\n      end\n      elem_counts[arr[idx]] = elem_counts[arr[idx]] + 1\n  \
    \  end\n    local min_count = math.huge\n    for k, v in pairs(elem_counts) do\n\
    \      min_count = math.min(min_count, v)\n    end\n    return #arr - min_count\n\
    \  else\n    return #arr\n  end\nend", "    local n = #arr\n    local dp = {}\n\
    \    for i = 1, n do\n        dp[i] = {}\n        for j = 1, n do\n          \
    \  dp[i][j] = j - i + 1\n        end\n    end\n    for i = n - 1, 1, -1 do\n \
    \       for j = i + 1, n do\n            if arr[i] == arr[j] then\n          \
    \      dp[i][j] = dp[i + 1][j - 1]\n            else\n                dp[i][j]\
    \ = math.min(dp[i + 1][j], dp[i][j - 1]) + 1\n            end\n        end\n \
    \   end\n    return dp[1][n]\nend", "    local pivot = math.floor(#arr / 2)\n\
    \    local l, r = pivot - 1, pivot + 1\n    local left_change, right_change =\
    \ 0, 0\n    if #arr % 2 == 0 then\n        r = r + 1\n    end\n    while l >=\
    \ 1 and r <= #arr do\n        if arr[l] ~= arr[r] then\n            if arr[l]\
    \ < arr[r] then\n                left_change = left_change + 1\n            else\n\
    \                right_change = right_change + 1\n            end\n        end\n\
    \        l = l - 1\n        r = r + 1\n    end\n    return math.max(left_change,\
    \ right_change)\nend", "    -- TODO: Complete this function\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
