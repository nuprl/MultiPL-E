{
  "language": "ts",
  "name": "HumanEval_1_separate_paren_groups",
  "results": [
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  let open_brace_group = \"\";\n  let closed_paren_group = \"\";\n  let open_brace_group_length = 0;\n  let closed_paren_group_length = 0;\n  let paren_group = \"\";\n  let paren_group_length = 0;\n  let paren_group_start = 0;\n  let paren_group_end = 0;\n  let paren_group_start_index = 0;\n  let paren_group_end_index = 0;\n  let paren_group_start_index2 = 0;\n  let paren_group_end_index2 = 0;\n  let paren_group_start_index3 = 0;\n  let paren_group_end_index3 = 0;\n  let paren_group_start_index4 = 0;\n  let paren_group_end_index4 = 0;\n  let paren_group_start_index5 = 0;\n  let paren_group_end_index5 = 0;\n  let paren_group_start_index6 = 0;\n  let paren_group_end_index6 = 0;\n  let paren_group_start_index7 = 0;\n  let paren_group_end_index7 = 0;\n  let paren_group_start_index8 = 0;\n  let paren_group_end_index8 = 0;\n  let paren_group_start_index9 = 0;\n  let paren_group_end_index9 = 0;\n  let paren_group_start_index10 = 0;\n  let paren_group_end_index10 = 0;\n  let paren_group_start_index11 = 0;\n  let paren_group_end_index11 = 0;\n  let paren_group_start_index12 = 0;\n  let paren_group_end_index12 = 0;\n  let paren_group_start_index13 = 0;\n  let paren_group_end_index13 = 0;\n  let paren_group_start_index14 = 0;\n  let paren_group_end_index14 = 0;\n  let paren_group_start_index15 = 0;\n  let paren_group_end_index15 = 0;\n  let paren_group_start_index16 = 0;\n  let paren_group_end_index16 = 0;\n  let paren_group_start_index17 = 0;\n  let paren_group_end_index17 = 0;\n  let paren_group_start_index18 = 0;\n  let paren_group_end_index18 = 0;\n  let paren_group_start_index19 = 0;\n  let paren_group_end_index19 = 0;\n  let paren_group_start_index20 = 0;\n  let paren_group_end_index20 = 0;\n  let paren_group_start_index21 = 0;\n  let paren_group_end_index21 = 0;\n  let paren_group_start_index22 = 0;\n  let paren_group_end_index22 = 0;\n  let paren_group_start_index23 = 0;\n  let paren_group_end_index23 = 0;\n  let paren_group_start_index24 = 0;\n  let paren_group_end_index24 = 0;\n  let paren_group_start_index25 = 0;\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcgf849mt.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333769
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n    const groups = [];\n    for (let i = 0; i < paren_groups.length; i++) {\n        const group = paren_groups[i];\n        const group_split = group.match(/\\(|\\)/g);\n        const group_length = group_split.length;\n        const group_string = group.substring(0, group_length - 1);\n        groups.push(group_string);\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()',\n  '(()',\n  '(',\n  '(()',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpwzvbdur6.js:22:12)\n    at Object.<anonymous> (/tmp/tmpwzvbdur6.js:27:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()', '(()', '(', '(()', '(', '(' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n    const groups = [];\n    for (let i = 0; i < paren_groups.length; i++) {\n        const group = paren_groups[i];\n        const group_split = group.split(/\\(|\\)/g);\n        for (let j = 0; j < group_split.length; j++) {\n            if (group_split[j].trim() !== \"\") {\n                groups.push(group_split[j]);\n            }\n        }\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpltvceazs.js:24:12)\n    at Object.<anonymous> (/tmp/tmpltvceazs.js:29:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let open_brace_index = 0;\n  let close_brace_count = 0;\n  let close_brace_index = 0;\n  let paren_char: string;\n  let paren_char_index = 0;\n  let paren_char_length = 0;\n  let paren_char_length_index = 0;\n  let paren_char_length_char: string;\n  let paren_char_length_char_index = 0;\n  let paren_char_length_char_length = 0;\n  let paren_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char: string;\n  let paren_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char: string;\n  let paren_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char: string;\n  let paren_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char: string;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char: string;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length_char: string;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length_char_length_char: string;\n  let paren_char_length_char_length_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphdvbbfcz.ts(59,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n\tconst paren_groups: string[] = [];\n\tlet paren_group = \"\";\n\tlet paren_group_open = false;\n\tlet paren_group_closed = false;\n\tfor (let i = 0; i < paren_string.length; i++) {\n\t\tconst char = paren_string[i];\n\t\tif (char === \"(\") {\n\t\t\tif (paren_group_open) {\n\t\t\t\tparen_groups.push(paren_group);\n\t\t\t\tparen_group = \"\";\n\t\t\t\tparen_group_open = false;\n\t\t\t\tparen_group_closed = false;\n\t\t\t}\n\t\t\tparen_group_open = true;\n\t\t} else if (char === \")\") {\n\t\t\tif (paren_group_closed) {\n\t\t\t\tparen_groups.push(paren_group);\n\t\t\t\tparen_group = \"\";\n\t\t\t\tparen_group_open = false;\n\t\t\t\tparen_group_closed = false;\n\t\t\t}\n\t\t\tparen_group_closed = true;\n\t\t} else if (char === \" \") {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tparen_group += char;\n\t\t}\n\t}\n\tif (paren_group.length > 0) {\n\t\tparen_groups.push(paren_group);\n\t}\n\treturn paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpa53vlzoh.js:47:12)\n    at Object.<anonymous> (/tmp/tmpa53vlzoh.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces: number = 0;\n  let closed_parens: number = 0;\n  let open_parens: number = 0;\n  let close_parens: number = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      open_braces += 1;\n    } else if (char === ')') {\n      closed_parens += 1;\n    } else if (char === ' ') {\n      continue;\n    } else if (char === '(') {\n      open_parens += 1;\n    } else if (char === ')') {\n      close_parens += 1;\n    }\n    if (open_braces === closed_parens) {\n      groups.push(paren_string.substring(i, i + 1));\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  ')',\n  ')',\n  ')',\n  ')'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpfrhmf_9v.js:39:12)\n    at Object.<anonymous> (/tmp/tmpfrhmf_9v.js:44:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ ')', ')', ')', ')' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let close_brace_count = 0;\n  let open_paren_count = 0;\n  let close_paren_count = 0;\n  let paren_char = '';\n  let paren_char_count = 0;\n  let paren_char_index = 0;\n  let paren_char_length = 0;\n  let paren_char_length_index = 0;\n  let paren_char_length_char = '';\n  let paren_char_length_char_index = 0;\n  let paren_char_length_char_length = 0;\n  let paren_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char = '';\n  let paren_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char = '';\n  let paren_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char = '';\n  let paren_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char = '';\n  let paren_char_length_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char = '';\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_length = 0;\n  let paren_char_length_char_length_char_length_char_length_char_length_char_length_char_index = 0;\n  let paren_char_length_char_length_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmph0cyt1y_.ts(61,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_string[i] === \"(\" && !paren_group_open) {\n      paren_group += paren_string[i];\n      paren_group_open = true;\n    } else if (paren_string[i] === \")\" && paren_group_open) {\n      paren_group += paren_string[i];\n      paren_group_open = false;\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n    } else if (paren_string[i] === \")\") {\n      paren_group += paren_string[i];\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  ')()',\n  '))()',\n  '()',\n  ')()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpyd77gm2i.js:31:12)\n    at Object.<anonymous> (/tmp/tmpyd77gm2i.js:36:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()',  '()',\n    ')()', '))()',\n    '()',  ')()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group.length > 0) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n      }\n      paren_group_open = false;\n    } else if (char === \"(\") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group_open = true;\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' (((',\n  ' (',\n  ' (((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp55ntf6tu.js:41:12)\n    at Object.<anonymous> (/tmp/tmp55ntf6tu.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',\n    ' (((', ' (',\n    ' (((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let open_brace_count = 1;\n    let close_brace_count = 1;\n    let open_paren_count = 0;\n    let close_paren_count = 0;\n    let paren_string_index = 0;\n    let paren_string = paren_string.replace(/\\s/g, '');\n    for (let i = 0; i < paren_string.length; i++) {\n        if (paren_string[i] === '(') {\n            paren_groups[paren_string_index] = paren_groups[paren_string_index] || '';\n            paren_groups[paren_string_index] += paren_string[i];\n            open_paren_count++;\n        } else if (paren_string[i] === ')') {\n            paren_groups[paren_string_index] += paren_string[i];\n            close_paren_count++;\n        } else if (paren_string[i] === '{') {\n            open_brace_count++;\n        } else if (paren_string[i] === '}') {\n            close_brace_count++;\n        } else if (paren_string[i] === ' ') {\n            if (open_paren_count === close_brace_count && open_paren_count === open_brace_count) {\n                paren_groups[paren_string_index] += paren_string[i];\n            }\n        }\n        paren_string_index++;\n    }\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphr8d3cby.ts(7,32): error TS2300: Duplicate identifier 'paren_string'.\n../../../../tmp/tmphr8d3cby.ts(14,9): error TS2300: Duplicate identifier 'paren_string'.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups ? paren_groups.map(x => x.replace(/\\s+/g, '')) : [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpx3ju3bx0.js:14:12)\n    at Object.<anonymous> (/tmp/tmpx3ju3bx0.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group.length > 0) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n      }\n      paren_group_open = false;\n    } else if (char === \"(\") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group_open = true;\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' (((',\n  ' (',\n  ' (((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp55ntf6tu.js:41:12)\n    at Object.<anonymous> (/tmp/tmp55ntf6tu.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',\n    ' (((', ' (',\n    ' (((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces = 0;\n  let close_braces = 0;\n  let open_parens = 0;\n  let close_parens = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_length = 0;\n  let paren_group_closing_char_length = 0;\n  let paren_group_opening_char_index2 = 0;\n  let paren_group_closing_char_index2 = 0;\n  let paren_group_opening_char_length2 = 0;\n  let paren_group_closing_char_length2 = 0;\n  let paren_group_opening_char_index3 = 0;\n  let paren_group_closing_char_index3 = 0;\n  let paren_group_opening_char_length3 = 0;\n  let paren_group_closing_char_length3 = 0;\n  let paren_group_opening_char_index4 = 0;\n  let paren_group_closing_char_index4 = 0;\n  let paren_group_opening_char_length4 = 0;\n  let paren_group_closing_char_length4 = 0;\n  let paren_group_opening_char_index5 = 0;\n  let paren_group_closing_char_index5 = 0;\n  let paren_group_opening_char_length5 = 0;\n  let paren_group_closing_char_length5 = 0;\n  let paren_group_opening_char_index6 = 0;\n  let paren_group_closing_char_index6 = 0;\n  let paren_group_opening_char_length6 = 0;\n  let paren_group_closing_char_length6 = 0;\n  let paren_group_opening_char_index7 = 0;\n  let paren_group_closing_char_index7 = 0;\n  let paren_group_opening_char_length7 = 0;\n  let paren_group_closing_char_length7 = 0;\n  let paren_group_opening_char_index8 = 0;\n  let paren_group_closing_char_index8 = 0;\n  let paren_group_opening_char_length8 = 0;\n  let paren_group_closing_char_length8 = 0;\n  let paren_group_opening_char_index9 = 0;\n  let paren_group_closing_char_index9 = 0;\n  let paren_group_opening_char_length9 = 0;\n  let paren_group_closing_char_length9 = 0;\n  let paren_group_opening_char_index10 = 0;\n  let paren_group_closing_char_index10 = 0;\n  let paren_group_opening_char_length10 = 0;\n  let paren_group_closing_char_length10 = 0;\n  let paren_group_opening_char_index11 = 0;\n  let paren_group_closing_char_index11 = 0;\n  let paren_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp79tm0esj.ts(73,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333769
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_opening_char_position = 0;\n  let paren_group_closing_char = \"\";\n  let paren_group_closing_char_position = 0;\n  let paren_group_opening_paren_group = \"\";\n  let paren_group_opening_paren_group_position = 0;\n  let paren_group_closing_paren_group = \"\";\n  let paren_group_closing_paren_group_position = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_opening_char_position = 0;\n        paren_group_closing_char = \"\";\n        paren_group_closing_char_position = 0;\n        paren_group_opening_paren_group = \"\";\n        paren_group_opening_paren_group_position = 0;\n        paren_group_closing_paren_group = \"\";\n        paren_group_closing_paren_group_position = 0;\n      }\n    } else if (char === \")\") {\n      paren_group_closed = true;\n      paren_group_opening_char = \"\";\n      paren_group_opening_char_position = 0;\n      paren_group_closing_char = \"\";\n      paren_group_closing_char_position = 0;\n      paren_group_opening_paren_group = \"\";\n      paren_group_opening_paren_group_position = 0;\n      paren_group_closing_paren_group = \"\";\n      paren_group_closing_paren_group_position = 0;\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group += char;\n        paren_group_opening_char += char;\n        paren_group_opening_char_position++;\n      } else {\n        paren_group += char;\n      }\n    } else if (char === \")\") {\n      paren_group_open = true;\n      paren_group_opening_char = \"\";\n      paren_group_opening_char_position = 0;\n      paren_group_closing_char = \"\";\n      paren_group_closing_char_position = 0;\n      paren_group_opening_paren_group = \"\";\n      paren_group_opening_paren_group_position = 0;\n      paren_group_closing_paren_group = \"\";\n      paren_group_closing_paren_group_position = 0;\n    } else if (char === \")\") {\n      paren_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpid2cupkk.ts(79,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 1;\n  let closed_paren_count = 0;\n  let open_paren_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      closed_paren_count--;\n    } else if (char === \"(\") {\n      open_brace_count++;\n    } else if (char === \" \") {\n      continue;\n    } else if (char === \")\" && open_brace_count === closed_paren_count) {\n      groups.push(paren_string.substring(open_paren_count, i));\n      open_paren_count = 0;\n    } else if (char === \"(\" && open_brace_count === closed_paren_count) {\n      groups.push(paren_string.substring(open_paren_count, i));\n      open_paren_count++;\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpn11a43g0.js:37:12)\n    at Object.<anonymous> (/tmp/tmpn11a43g0.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces: number = 0;\n  let closed_groups: number = 0;\n  let open_parens: number = 0;\n  let close_parens: number = 0;\n  let open_parens_stack: string[] = [];\n  let close_parens_stack: string[] = [];\n  let paren_group: string[] = [];\n  let paren_group_stack: string[] = [];\n  let paren_group_counter: number = 0;\n  let paren_group_counter_string: string = \"\";\n  let paren_group_counter_string_count: number = 0;\n  let paren_group_counter_string_count2: string = \"\";\n  let paren_group_counter_string_count3: string = \"\";\n  let paren_group_counter_string_count4: string = \"\";\n  let paren_group_counter_string_count5: string = \"\";\n  let paren_group_counter_string_count6: string = \"\";\n  let paren_group_counter_string_count7: string = \"\";\n  let paren_group_counter_string_count8: string = \"\";\n  let paren_group_counter_string_count9: string = \"\";\n  let paren_group_counter_string_count10: string = \"\";\n  let paren_group_counter_string_count11: string = \"\";\n  let paren_group_counter_string_count12: string = \"\";\n  let paren_group_counter_string_count13: string = \"\";\n  let paren_group_counter_string_count14: string = \"\";\n  let paren_group_counter_string_count15: string = \"\";\n  let paren_group_counter_string_count16: string = \"\";\n  let paren_group_counter_string_count17: string = \"\";\n  let paren_group_counter_string_count18: string = \"\";\n  let paren_group_counter_string_count19: string = \"\";\n  let paren_group_counter_string_count20: string = \"\";\n  let paren_group_counter_string_count21: string = \"\";\n  let paren_group_counter_string_count22: string = \"\";\n  let paren_group_counter_string_count23: string = \"\";\n  let paren_group_counter_string_count24: string = \"\";\n  let paren_group_counter_string_count25: string = \"\";\n  let paren_group_counter_string_count26: string = \"\";\n  let paren_group_counter_string_count27: string = \"\";\n  let paren_group_counter_string_count28: string = \"\";\n  let paren_group_counter_string_count29: string = \"\";\n  let paren_group_counter_string_count30: string = \"\";\n  let paren_group_counter_string_count31: string = \"\";\n  let paren_group_counter_string_count32: string = \"\";\n  let paren_group_counter_string_count33: string = \"\";\n  let paren_group_counter_string_count34: string = \"\";\n  let paren_group_counter_string_count35: string = \"\";\n  let paren_group_counter_string_count36: string = \"\";\n  let paren_group_counter_string_count37: string = \"\";\n  let paren_group_counter_string_count38: string = \"\";\n  let paren_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpr2blnmgw.ts(70,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_open_brace = false;\n  let paren_group_closed_brace = false;\n  let paren_group_open_brace_or_closed_brace = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpx9pqvc3h.ts(54,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n    } else {\n      if (paren_group_closed) {\n        paren_group += char;\n      } else {\n        paren_group += char;\n        paren_group_open = true;\n      }\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' ((( ( ((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmptaqliq7p.js:46:12)\n    at Object.<anonymous> (/tmp/tmptaqliq7p.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((', '(', ' ((( ( (((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpw510s3sz.ts(91,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let open_brace_count = 0;\n  let open_brace_group = \"\";\n  let closed_paren = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      open_brace_count++;\n      open_brace_group += char;\n    } else if (char === \")\") {\n      open_brace_count--;\n      if (open_brace_count === 0) {\n        paren_groups.push(open_brace_group);\n        open_brace_group = \"\";\n        closed_paren = true;\n      }\n    } else if (char === \" \") {\n      if (closed_paren) {\n        paren_groups.push(open_brace_group);\n        open_brace_group = \"\";\n        closed_paren = false;\n      }\n    } else {\n      open_brace_group += char;\n    }\n  }\n  if (open_brace_count !== 0) {\n    paren_groups.push(open_brace_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(((',\n  '',\n  '(((',\n  '',\n  '(',\n  '',\n  '((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpld4wvwvk.js:45:12)\n    at Object.<anonymous> (/tmp/tmpld4wvwvk.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(((', '', '(((', '', '(', '', '(((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(())',\n  '()',\n  '(())',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzgt0q5_p.js:14:12)\n    at Object.<anonymous> (/tmp/tmpzgt0q5_p.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(())', '()', '(())', '()', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group = \"\";\n    } else if (char === \")\") {\n      paren_group_closed = true;\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group += \" \";\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp5pmbt6jr.js:43:12)\n    at Object.<anonymous> (/tmp/tmp5pmbt6jr.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '',\n    '', '', '', '', '',\n    '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  let open_paren_count = 0;\n  let open_paren_group = \"\";\n  let closed_paren_group = \"\";\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_count = 0;\n  let paren_group_closing_char_count = 0;\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_length = 0;\n  let paren_group_closing_char_length = 0;\n  let paren_group_opening_char_last_index = 0;\n  let paren_group_closing_char_last_index = 0;\n  let paren_group_opening_char_last_char = \"\";\n  let paren_group_closing_char_last_char = \"\";\n  let paren_group_opening_char_last_char_count = 0;\n  let paren_group_closing_char_last_char_count = 0;\n  let paren_group_opening_char_last_char_index = 0;\n  let paren_group_closing_char_last_char_index = 0;\n  let paren_group_opening_char_last_char_length = 0;\n  let paren_group_closing_char_last_char_length = 0;\n  let paren_group_opening_char_last_char_last_index = 0;\n  let paren_group_closing_char_last_char_last_index = 0;\n  let paren_group_opening_char_last_char_last_char = \"\";\n  let paren_group_closing_char_last_char_last_char = \"\";\n  let paren_group_opening_char_last_char_last_char_count = 0;\n  let paren_group_closing_char_last_char_last_char_count = 0;\n  let paren_group_opening_char_last_char_last_char_index = 0;\n  let paren_group_closing_char_last_char_last_char_index = 0;\n  let paren_group_opening_char_last_char_last_char_length = 0;\n  let paren_group_closing_char_last_char_last_char_length = 0;\n  let paren_group_opening_char_last_char_last_char_last_index = 0;\n  let paren_group_closing_char_last_char_last_char_last_index = 0;\n  let paren_group_opening_char_last_char_last_char_last_char = \"\";\n  let paren_group_closing_char_last_char_last_char_last_char = \"\";\n  let paren_group_opening_char_last_char_last_char_last_char_count = 0;\n  let paren_group_closing_char_last_char_last_char_last_char_count = 0;\n  let paren_group_opening_char_last_char_last_char_last_char_index = 0;\n  let paren_group_closing_char_last_char_last_char_last_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4tlozffa.ts(65,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group = \"\";\n    } else if (char === \")\") {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n    } else if (char === \" \") {\n      continue;\n    } else {\n      paren_group += char;\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpr43ha63o.js:35:12)\n    at Object.<anonymous> (/tmp/tmpr43ha63o.js:40:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let current_group: string = \"\";\n  let paren_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      paren_count--;\n      if (paren_count === 0) {\n        groups.push(current_group);\n        current_group = \"\";\n      }\n    } else if (char === \"(\") {\n      paren_count++;\n    }\n    current_group += char;\n  }\n  if (current_group.length > 0) {\n    groups.push(current_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()',\n  ') ((())',\n  ') (',\n  ') ((())()()',\n  ')'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpo1ohfluq.js:33:12)\n    at Object.<anonymous> (/tmp/tmpo1ohfluq.js:38:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()', ') ((())', ') (', ') ((())()()', ')' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_count = 0;\n  let paren_group_closing_count = 0;\n  let paren_group_opening_char_count = 0;\n  let paren_group_closing_char_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_opening_char_count++;\n      paren_group_opening_char = char;\n      paren_group_opening_count++;\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closing_char_count++;\n      paren_group_closing_char = char;\n      paren_group_closing_count++;\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group_opening_char_count++;\n      } else {\n        paren_group_closing_char_count++;\n      }\n    } else {\n      if (paren_group_open) {\n        paren_group_opening_char_count++;\n      } else {\n        paren_group_closing_char_count++;\n      }\n    }\n    if (paren_group_opening_char_count === paren_group_opening_count &&\n      paren_group_closing_char_count === paren_group_closing_count) {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n      paren_group_opening_count = 0;\n      paren_group_closing_count = 0;\n      paren_group_opening_char_count = 0;\n      paren_group_closing_char_count = 0;\n    }\n    if (paren_group_open) {\n      paren_group += char;\n    } else {\n      paren_group += \" \";\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  ' ',\n  ' ',\n  ' ',\n  ' ',\n  ' ',\n  '  (((    (  (((  ( (  '\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp0y9biipi.js:76:12)\n    at Object.<anonymous> (/tmp/tmp0y9biipi.js:81:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', ' ', ' ', ' ', ' ', ' ', '  (((    (  (((  ( (  ' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else if (paren_group_closed) {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n      paren_group_closed = false;\n    } else if (paren_string[i] === \"(\") {\n      paren_group_open = true;\n    } else if (paren_string[i] === \")\") {\n      paren_group_closed = true;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmphju5pzp0.js:37:12)\n    at Object.<anonymous> (/tmp/tmphju5pzp0.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_closed) {\n        paren_group += char;\n        paren_group_open = true;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' ((( ( ((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpcjgs9pg7.js:46:12)\n    at Object.<anonymous> (/tmp/tmpcjgs9pg7.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((', '(', ' ((( ( (((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces = 0;\n  let closed_group = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      open_braces++;\n    } else if (char === ')') {\n      open_braces--;\n      if (open_braces === 0) {\n        closed_group = true;\n      }\n    } else if (char === ' ') {\n      if (closed_group) {\n        groups.push(paren_string.slice(i + 1, i + 1 + open_braces));\n      }\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpz0at183y.js:33:12)\n    at Object.<anonymous> (/tmp/tmpz0at183y.js:38:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '', '' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 0;\n    let close_brace_count = 0;\n    let open_paren_count = 0;\n    let close_paren_count = 0;\n    let open_paren_groups: string[] = [];\n    let close_paren_groups: string[] = [];\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === '(') {\n            open_paren_count++;\n            open_paren_groups.push(paren_string.substring(i, i + 1));\n        } else if (char === ')') {\n            close_paren_count++;\n            close_paren_groups.push(paren_string.substring(i, i + 1));\n        } else if (char === ' ') {\n            continue;\n        } else if (char === '(') {\n            open_brace_count++;\n        } else if (char === ')') {\n            close_brace_count++;\n        } else if (open_brace_count > close_brace_count) {\n            groups.push(open_paren_groups.join(''));\n            open_paren_groups = [];\n            open_paren_count = 0;\n        } else if (open_brace_count < close_brace_count) {\n            groups.push(close_paren_groups.join(''));\n            close_paren_groups = [];\n            close_paren_count = 0;\n        }\n    }\n    if (open_paren_groups.length > 0) {\n        groups.push(open_paren_groups.join(''));\n    }\n    if (close_paren_groups.length > 0) {\n        groups.push(close_paren_groups.join(''));\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((((((((((((',\n  '))))))))))))'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpook6i6ua.js:56:12)\n    at Object.<anonymous> (/tmp/tmpook6i6ua.js:61:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((((((((((((', '))))))))))))' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else if (paren_group_closed) {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n      paren_group_closed = false;\n    } else if (paren_string[i] === \"(\") {\n      paren_group_open = true;\n    } else if (paren_string[i] === \")\") {\n      paren_group_closed = true;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmphju5pzp0.js:37:12)\n    at Object.<anonymous> (/tmp/tmphju5pzp0.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let open_paren_count = 0;\n  let close_paren_count = 0;\n  let open_paren_group = false;\n  let close_paren_group = false;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_close = false;\n  let paren_group_open_string = \"\";\n  let paren_group_close_string = \"\";\n  let paren_group_open_string_count = 0;\n  let paren_group_close_string_count = 0;\n  let paren_group_open_string_group = \"\";\n  let paren_group_close_string_group = \"\";\n  let paren_group_open_string_group_count = 0;\n  let paren_group_close_string_group_count = 0;\n  let paren_group_open_string_group_string = \"\";\n  let paren_group_close_string_group_string = \"\";\n  let paren_group_open_string_group_string_count = 0;\n  let paren_group_close_string_group_string_count = 0;\n  let paren_group_open_string_group_string_index = 0;\n  let paren_group_close_string_group_string_index = 0;\n  let paren_group_open_string_group_string_index2 = 0;\n  let paren_group_close_string_group_string_index2 = 0;\n  let paren_group_open_string_group_string_index3 = 0;\n  let paren_group_close_string_group_string_index3 = 0;\n  let paren_group_open_string_group_string_index4 = 0;\n  let paren_group_close_string_group_string_index4 = 0;\n  let paren_group_open_string_group_string_index5 = 0;\n  let paren_group_close_string_group_string_index5 = 0;\n  let paren_group_open_string_group_string_index6 = 0;\n  let paren_group_close_string_group_string_index6 = 0;\n  let paren_group_open_string_group_string_index7 = 0;\n  let paren_group_close_string_group_string_index7 = 0;\n  let paren_group_open_string_group_string_index8 = 0;\n  let paren_group_close_string_group_string_index8 = 0;\n  let paren_group_open_string_group_string_index9 = 0;\n  let paren_group_close_string_group_string_index9 = 0;\n  let paren_group_open_string_group_string_index10 = 0;\n  let paren_group_close_string_group_string_index10 = 0;\n  let paren_group_open_string_group_string_index11 = 0;\n  let paren_group_close_string_group_string_index11 = 0;\n  let paren_group_open_string_group_string_index12 = 0;\n  let paren_group_close_string_group_string_index12 = 0;\n  let paren_group_open_string_group_string_index13 = 0;\n  let paren_group_close_string_group_string_index13 = 0;\n  let paren_group_open_string_group_string_index14 = 0;\n  let paren_group_close_string_group_string_index14 = 0;\n  let paren_group_open_string_group_string_index15 = 0;\n  let paren\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplf18a9i4.ts(71,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_group = \"\";\n        paren_group_open = true;\n        paren_group_closed = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpboc2jbdg.js:44:12)\n    at Object.<anonymous> (/tmp/tmpboc2jbdg.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '',\n    '', '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_braces = 0;\n    let closed_group = false;\n    let open_brace_group = \"\";\n    let closed_group_group = \"\";\n    let open_brace_group_group = \"\";\n    let closed_group_group_group = \"\";\n    let open_brace_group_group_group = \"\";\n    let closed_group_group_group_group = \"\";\n    let open_brace_group_group_group_group = \"\";\n    let closed_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let closed_group_group_group_group_group_group_group_group_group_group_group_group = \"\";\n    let open_brace_group_group_group_group_group_group_group_group_group_group_group_group_group = \"\";\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_ao2o47s.ts(58,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n\tlet paren_groups: string[] = [];\n\tlet paren_group = \"\";\n\tlet paren_group_open = false;\n\tlet paren_group_closed = false;\n\tfor (let i = 0; i < paren_string.length; i++) {\n\t\tlet c = paren_string[i];\n\t\tif (paren_group_open) {\n\t\t\tif (paren_group_closed) {\n\t\t\t\tparen_group += c;\n\t\t\t\tparen_group_open = false;\n\t\t\t\tparen_group_closed = false;\n\t\t\t} else if (c === \")\") {\n\t\t\t\tparen_group += c;\n\t\t\t\tparen_group_open = false;\n\t\t\t\tparen_group_closed = true;\n\t\t\t} else if (c === \"(\") {\n\t\t\t\tparen_group += c;\n\t\t\t\tparen_group_open = true;\n\t\t\t\tparen_group_closed = false;\n\t\t\t} else {\n\t\t\t\tparen_group += c;\n\t\t\t}\n\t\t} else if (paren_group_closed) {\n\t\t\tif (c === \")\") {\n\t\t\t\tparen_group += c;\n\t\t\t\tparen_group_open = false;\n\t\t\t\tparen_group_closed = false;\n\t\t\t} else if (c === \"(\") {\n\t\t\t\tparen_group += c;\n\t\t\t\tparen_group_open = true;\n\t\t\t\tparen_group_closed = false;\n\t\t\t} else {\n\t\t\t\tparen_group += c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (c === \")\") {\n\t\t\t\tparen_group += c;\n\t\t\t\tparen_group_open = false;\n\t\t\t\tparen_group_closed = false;\n\t\t\t} else if (c === \"(\") {\n\t\t\t\tparen_group += c;\n\t\t\t\tparen_group_open = true;\n\t\t\t\tparen_group_closed = false;\n\t\t\t} else {\n\t\t\t\tparen_group += c;\n\t\t\t}\n\t\t}\n\t}\n\tparen_groups.push(paren_group);\n\treturn paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpeiyevqkf.js:71:12)\n    at Object.<anonymous> (/tmp/tmpeiyevqkf.js:76:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group_open = true;\n        paren_group += char;\n      }\n    } else if (char === \")\") {\n      if (paren_group_closed) {\n        paren_group += char;\n      } else {\n        paren_group_closed = true;\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpntybfuwr.js:42:12)\n    at Object.<anonymous> (/tmp/tmpntybfuwr.js:47:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_count = 0;\n  let paren_group_closing_char_count = 0;\n  let paren_group_opening_char_count_index = 0;\n  let paren_group_closing_char_count_index = 0;\n  let paren_group_opening_char_count_index2 = 0;\n  let paren_group_closing_char_count_index2 = 0;\n  let paren_group_opening_char_count_index3 = 0;\n  let paren_group_closing_char_count_index3 = 0;\n  let paren_group_opening_char_count_index4 = 0;\n  let paren_group_closing_char_count_index4 = 0;\n  let paren_group_opening_char_count_index5 = 0;\n  let paren_group_closing_char_count_index5 = 0;\n  let paren_group_opening_char_count_index6 = 0;\n  let paren_group_closing_char_count_index6 = 0;\n  let paren_group_opening_char_count_index7 = 0;\n  let paren_group_closing_char_count_index7 = 0;\n  let paren_group_opening_char_count_index8 = 0;\n  let paren_group_closing_char_count_index8 = 0;\n  let paren_group_opening_char_count_index9 = 0;\n  let paren_group_closing_char_count_index9 = 0;\n  let paren_group_opening_char_count_index10 = 0;\n  let paren_group_closing_char_count_index10 = 0;\n  let paren_group_opening_char_count_index11 = 0;\n  let paren_group_closing_char_count_index11 = 0;\n  let paren_group_opening_char_count_index12 = 0;\n  let paren_group_closing_char_count_index12 = 0;\n  let paren_group_opening_char_count_index13 = 0;\n  let paren_group_closing_char_count_index13 = 0;\n  let paren_group_opening_char_count_index14 = 0;\n  let paren_group_closing_char_count_index14 = 0;\n  let paren_group_opening_char_count_index15 = 0;\n  let paren_group_closing_char_count_index15 = 0;\n  let paren_group_opening_char_count_index16 = 0;\n  let paren_group_closing_char_count_index16 = 0;\n  let paren_group_opening_char_count_index17 = 0;\n  let paren_group_closing_char_count_index17 = 0;\n  let paren_group_opening_char_count_index18 = 0;\n  let paren_group_closing_char_count_index18 = 0;\n  let paren_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpchsxrl67.ts(67,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333773
    },
    {
      "exit_code": -5,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces: number = 0;\n  let closed_parens: number = 0;\n  let open_parens: number = 0;\n  let close_parens: number = 0;\n  let paren_group: string = paren_string;\n  while (paren_group.length > 0) {\n    if (paren_group.startsWith(\"(\")) {\n      open_parens++;\n    } else if (paren_group.startsWith(\")\")) {\n      close_parens++;\n    } else if (paren_group.startsWith(\"{\")) {\n      open_braces++;\n    } else if (paren_group.startsWith(\"}\")) {\n      closed_parens++;\n    }\n    paren_group = paren_group.trim();\n    if (open_parens > close_parens) {\n      groups.push(paren_group);\n      open_parens = 0;\n      close_parens = 0;\n    } else if (open_parens < close_parens) {\n      open_parens++;\n    } else {\n      close_parens++;\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "Exception",
      "stderr": "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffc709e6330\n 1: 0x2b8b11c31727  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b8b127c628e V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 3: 0x2b8b12100f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 4: 0x2b8b122929f0  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 5: 0x2b8b1229a390  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 6: 0x2b8b124847db v8::internal::Runtime_GrowArrayElements(int, unsigned long*, v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 7: 0x2b8b11de37f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n",
      "stdout": "",
      "timestamp": 1660333779
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_open_index = 0;\n  let paren_group_closed_index = 0;\n  let paren_group_open_string = \"\";\n  let paren_group_closed_string = \"\";\n  let paren_group_open_string_length = 0;\n  let paren_group_closed_string_length = 0;\n  let paren_group_open_string_index = 0;\n  let paren_group_closed_string_index = 0;\n  let paren_group_open_string_char = \"\";\n  let paren_group_closed_string_char = \"\";\n  let paren_group_open_string_char_length = 0;\n  let paren_group_closed_string_char_length = 0;\n  let paren_group_open_string_char_index = 0;\n  let paren_group_closed_string_char_index = 0;\n  let paren_group_open_string_char_repeat = 0;\n  let paren_group_closed_string_char_repeat = 0;\n  let paren_group_open_string_char_repeat_length = 0;\n  let paren_group_closed_string_char_repeat_length = 0;\n  let paren_group_open_string_char_repeat_count = 0;\n  let paren_group_closed_string_char_repeat_count = 0;\n  let paren_group_open_string_char_repeat_count_length = 0;\n  let paren_group_closed_string_char_repeat_count_length = 0;\n  let paren_group_open_string_char_repeat_count_index = 0;\n  let paren_group_closed_string_char_repeat_count_index = 0;\n  let paren_group_open_string_char_repeat_count_repeat = 0;\n  let paren_group_closed_string_char_repeat_count_repeat = 0;\n  let paren_group_open_string_char_repeat_count_repeat_length = 0;\n  let paren_group_closed_string_char_repeat_count_repeat_length = 0;\n  let paren_group_open_string_char_repeat_count_repeat_count = 0;\n  let paren_group_closed_string_char_repeat_count_repeat_count = 0;\n  let paren_group_open_string_char_repeat_count_repeat_count_length = 0;\n  let paren_group_closed_string_char_repeat_count_repeat_count_length = 0;\n  let paren_group_open_string_char_repeat_count_repeat_count_index = 0;\n  let paren_group_closed_string_char_repeat_count_repeat_count_index = 0;\n  let paren_group_open_string_char_repeat_count_repeat_count_repeat = 0;\n  let paren_group_closed_string_char_repeat_count_repeat_count_repeat = 0;\n  let paren_group_open_string_char_repeat_count_repeat_count_repeat_length = 0;\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpx18g9frs.ts(62,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_group = \"\";\n        paren_group_open = true;\n        paren_group_closed = false;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '((',\n  ' (((',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp764wy75b.js:47:12)\n    at Object.<anonymous> (/tmp/tmp764wy75b.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((', '((', ' (((', '(' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333774
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_open_brace = false;\n  let paren_group_closed_brace = false;\n  let paren_group_open_brace_count = 1;\n  let paren_group_closed_brace_count = 1;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_open_brace = true;\n      paren_group_open_brace_count++;\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_open_brace = false;\n      paren_group_open_brace_count--;\n      if (paren_group_open_brace_count === 0) {\n        paren_group_open_brace = false;\n        paren_group_open_brace_count = 1;\n      }\n    } else if (char === \" \") {\n      paren_group_open = false;\n      paren_group_open_brace = false;\n      paren_group_open_brace_count--;\n      if (paren_group_open_brace_count === 0) {\n        paren_group_open_brace = false;\n        paren_group_open_brace_count = 1;\n      }\n    } else if (char === \")\") {\n      paren_group_closed = true;\n      paren_group_closed_brace = true;\n      paren_group_closed_brace_count++;\n    } else if (char === \")\") {\n      paren_group_closed = false;\n      paren_group_closed_brace = false;\n      paren_group_closed_brace_count--;\n      if (paren_group_closed_brace_count === 0) {\n        paren_group_closed_brace = false;\n        paren_group_closed_brace_count = 1;\n      }\n    }\n    if (paren_group_open) {\n      paren_group += char;\n    } else if (paren_group_closed) {\n      paren_group += char;\n    } else if (paren_group_open_brace) {\n      paren_group += char;\n    } else if (paren_group_closed_brace) {\n      paren_group += char;\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(((((((((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp9qfwqz58.js:74:12)\n    at Object.<anonymous> (/tmp/tmp9qfwqz58.js:79:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((((((((((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333774
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_open_brace_count = 0;\n    let paren_group_closed_brace_count = 0;\n    let paren_group_open_brace = false;\n    let paren_group_closed_brace = false;\n    let paren_group_open_brace_string = \"\";\n    let paren_group_closed_brace_string = \"\";\n    let paren_group_open_brace_string_index = 0;\n    let paren_group_closed_brace_string_index = 0;\n    let paren_group_open_brace_string_index2 = 0;\n    let paren_group_closed_brace_string_index2 = 0;\n    let paren_group_open_brace_string_index3 = 0;\n    let paren_group_closed_brace_string_index3 = 0;\n    let paren_group_open_brace_string_index4 = 0;\n    let paren_group_closed_brace_string_index4 = 0;\n    let paren_group_open_brace_string_index5 = 0;\n    let paren_group_closed_brace_string_index5 = 0;\n    let paren_group_open_brace_string_index6 = 0;\n    let paren_group_closed_brace_string_index6 = 0;\n    let paren_group_open_brace_string_index7 = 0;\n    let paren_group_closed_brace_string_index7 = 0;\n    let paren_group_open_brace_string_index8 = 0;\n    let paren_group_closed_brace_string_index8 = 0;\n    let paren_group_open_brace_string_index9 = 0;\n    let paren_group_closed_brace_string_index9 = 0;\n    let paren_group_open_brace_string_index10 = 0;\n    let paren_group_closed_brace_string_index10 = 0;\n    let paren_group_open_brace_string_index11 = 0;\n    let paren_group_closed_brace_string_index11 = 0;\n    let paren_group_open_brace_string_index12 = 0;\n    let paren_group_closed_brace_string_index12 = 0;\n    let paren_group_open_brace_string_index13 = 0;\n    let paren_group_closed_brace_string_index13 = 0;\n    let paren_group_open_brace_string_index14 = 0;\n    let paren_group_closed_brace_string_index14 = 0;\n    let paren_group_open_brace_string_index15 = 0;\n    let paren_group_closed_brace_string_index15 = 0;\n    let paren_group_open_brace_string_index16 = 0;\n    let paren_group_closed_brace_string_index16 = 0;\n    let paren_group_open_brace_string_index17 = 0;\n    let paren_group_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3q7v0ntr.ts(64,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      paren_open = true;\n      paren_level++;\n    } else if (char === ')') {\n      paren_open = false;\n      paren_level--;\n    }\n    if (paren_open) {\n      paren_groups.push(paren_string.substring(i, i + 1));\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(',\n  '(',\n  '(',\n  '(',\n  '(',\n  '(',\n  '(',\n  '(',\n  '(',\n  '(',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp1i3ixwdn.js:30:12)\n    at Object.<anonymous> (/tmp/tmp1i3ixwdn.js:35:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '(', '(', '(', '(',\n    '(', '(', '(', '(',\n    '(', '(', '(', '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \"(\") {\n            if (paren_group_open) {\n                paren_group += char;\n            } else {\n                paren_groups.push(paren_group);\n                paren_group = char;\n                paren_group_open = true;\n            }\n        } else if (char === \")\") {\n            if (paren_group_closed) {\n                paren_group += char;\n            } else {\n                paren_groups.push(paren_group);\n                paren_group = char;\n                paren_group_closed = true;\n            }\n        } else {\n            paren_group += char;\n        }\n    }\n    paren_groups.push(paren_group);\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '((',\n  ')()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpm_1rvw_h.js:44:12)\n    at Object.<anonymous> (/tmp/tmpm_1rvw_h.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '((', ')()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333774
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_opening_char_position = 0;\n  let paren_group_closing_char = \"\";\n  let paren_group_closing_char_position = 0;\n  let paren_group_opening_char_position_index = 0;\n  let paren_group_closing_char_position_index = 0;\n  let paren_group_opening_char_position_index_in_paren_group = 0;\n  let paren_group_closing_char_position_index_in_paren_group = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end = 0;\n  let paren_group_closing_char_position_index_in_paren_group_end = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group = 0;\n  let paren_group_closing_char_position_index_in_paren_group_end_in_paren_group = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end = 0;\n  let paren_group_closing_char_position_index_in_paren_group_end_in_paren_group = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end_in_paren_group = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end_in_paren_group = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end_in_paren_group_end = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group_end = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group_end = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group_end_in_paren_group = 0;\n  let paren_group_opening_char_position_index_in_paren_group_end_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsgm52tmo.ts(50,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else if (paren_group_closed) {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n      paren_group_closed = false;\n    } else {\n      if (paren_string[i] === \"(\") {\n        paren_group_open = true;\n      } else if (paren_string[i] === \")\") {\n        paren_group_closed = true;\n      }\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp71pwhqou.js:39:12)\n    at Object.<anonymous> (/tmp/tmp71pwhqou.js:44:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333774
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = true;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  ' ',\n  '',\n  ' ',\n  '',\n  ' ',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpngwp208i.js:48:12)\n    at Object.<anonymous> (/tmp/tmpngwp208i.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',  '', '',  '', ' ', '',\n    ' ', '', ' ', '', '',  '',\n    '',  ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.j",
      "stdout": "",
      "timestamp": 1660333774
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  let open_paren_count = 0;\n  let open_paren_groups: string[] = [];\n  let closed_paren_groups: string[] = [];\n  let paren_groups: string[] = [];\n  let paren_group_string: string;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      open_paren_count++;\n      open_paren_groups.push(paren_string.slice(i + 1, i + 1 + open_paren_count));\n    } else if (char === ')') {\n      closed_paren_count++;\n      closed_paren_groups.push(paren_string.slice(i + 1, i + 1 + closed_paren_count));\n    } else if (char === ' ') {\n      continue;\n    } else if (char === '(') {\n      open_brace_count++;\n      paren_groups.push(paren_string.slice(i + 1, i + 1 + open_brace_count));\n    } else if (char === ')') {\n      paren_group_string = paren_string.slice(i + 1, i + 1 + closed_paren_count);\n      if (open_paren_count === closed_paren_count) {\n        groups.push(paren_group_string);\n      } else {\n        groups.push(paren_group_string);\n      }\n    }\n  }\n\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp33y50aev.js:48:12)\n    at Object.<anonymous> (/tmp/tmp33y50aev.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333774
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 1;\n    let open_brace_level = 0;\n    let close_brace_level = 0;\n    let close_brace_count = 0;\n    let paren_count = 0;\n    let paren_level = 0;\n    let paren_string = paren_string.replace(/\\s+/g, \"\");\n    for (let i = 0; i < paren_string.length; i++) {\n        if (paren_string[i] === \"(\") {\n            paren_level++;\n            paren_count++;\n        } else if (paren_string[i] === \")\") {\n            paren_level--;\n            paren_count--;\n            if (paren_level === 0) {\n                close_brace_level++;\n                close_brace_count++;\n            }\n        }\n        if (paren_count === 0) {\n            open_brace_level++;\n            open_brace_count++;\n        }\n        if (open_brace_count === open_brace_level) {\n            groups.push(paren_string.substring(0, i + 1));\n            paren_string = paren_string.substring(i + 1);\n            open_brace_level = 0;\n            open_brace_count = 0;\n        }\n        if (close_brace_count === close_brace_level) {\n            groups.push(paren_string);\n            paren_string = \"\";\n            close_brace_level = 0;\n            close_brace_count = 0;\n        }\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp385sxzk2.ts(7,32): error TS2300: Duplicate identifier 'paren_string'.\n../../../../tmp/tmp385sxzk2.ts(15,9): error TS2300: Duplicate identifier 'paren_string'.\n",
      "timestamp": 1660333776
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group.length > 0) {\n        paren_groups.push(paren_group);\n      }\n      paren_group = \"\";\n      paren_group_open = false;\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_group += char;\n        paren_group_open = true;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' (((',\n  ' (',\n  ' (((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpeci9hgw7.js:41:12)\n    at Object.<anonymous> (/tmp/tmpeci9hgw7.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',\n    ' (((', ' (',\n    ' (((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \")\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_open = true;\n      }\n    } else {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group += char;\n      }\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((( ((( ( ((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpf9ma8uj1.js:53:12)\n    at Object.<anonymous> (/tmp/tmpf9ma8uj1.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((( ((( ( (((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333776
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(())',\n  '()',\n  '(())',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzgt0q5_p.js:14:12)\n    at Object.<anonymous> (/tmp/tmpzgt0q5_p.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(())', '()', '(())', '()', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces = 0;\n  let closed_group = false;\n  let open_brace_group = false;\n  let closed_brace_group = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      open_braces++;\n      open_brace_group = true;\n    } else if (char === ')') {\n      open_braces--;\n      closed_brace_group = true;\n    } else if (char === ' ') {\n      if (open_braces === 0 && closed_group === false && open_brace_group === false && closed_brace_group === false) {\n        groups.push(paren_string.substring(i, i + 1));\n      }\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpchbup7x9.js:34:12)\n    at Object.<anonymous> (/tmp/tmpchbup7x9.js:39:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n    } else if (char === \" \") {\n      continue;\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp4w7zjjih.js:38:12)\n    at Object.<anonymous> (/tmp/tmp4w7zjjih.js:43:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '',\n    '', '', '', '', '',\n    '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_open_index = 0;\n  let paren_group_closed_index = 0;\n  let paren_group_open_string = \"\";\n  let paren_group_closed_string = \"\";\n  let paren_group_open_string_length = paren_group_open_string.length;\n  let paren_group_closed_string_length = paren_group_closed_string.length;\n  let paren_group_open_string_char = paren_group_open_string.charAt(0);\n  let paren_group_closed_string_char = paren_group_closed_string.charAt(0);\n  let paren_group_open_string_char_length = paren_group_open_string_char.length;\n  let paren_group_closed_string_char_length = paren_group_closed_string_char.length;\n  let paren_group_open_string_char_char_length = paren_group_open_string_char_length;\n  let paren_group_closed_string_char_char_length = paren_group_closed_string_char_length;\n  let paren_group_open_string_char_char_char_length = paren_group_open_string_char_char_length;\n  let paren_group_closed_string_char_char_char_length = paren_group_closed_string_char_char_length;\n  let paren_group_open_string_char_char_char_char_length = paren_group_open_string_char_char_char_length;\n  let paren_group_closed_string_char_char_char_char_length = paren_group_closed_string_char_char_char_length;\n  let paren_group_open_string_char_char_char_char_char_length = paren_group_open_string_char_char_char_char_char_length;\n  let paren_group_closed_string_char_char_char_char_char_length = paren_group_closed_string_char_char_char_char_char_length;\n  let paren_group_open_string_char_char_char_char_char_char_length = paren_group_open_string_char_char_char_char_char_char_length;\n  let paren_group_closed_string_char_char_char_char_char_char_length = paren_group_closed_string_char_char_char_char_char_char_length;\n  let paren_group_open_string_char_char_char_char_char_char_char_char_length = paren_group_open_string_char_char_char_char_char_char_char_char_length;\n  let paren_group_closed_string_char_char_char_char_char_char_char_char_length = paren_group_closed_string_char_char_char_char_char_char_char_char_char_length;\n  let paren_group_open_string_char_char_char_char_char_char_char_char_char_char_length = paren_group_open_string_char_char_char_char_char_char_char_char_char_char_char_length;\n  let paren_group_closed_string_char_char_char_char_char_char_char_char_char_char_char_length = paren_group_closed_string_char_char_char_char_char_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpr1jl566v.ts(48,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333776
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_open = false;\n      } else {\n        paren_open = false;\n      }\n    } else if (char === \")\") {\n      paren_open = false;\n    } else {\n      if (paren_open) {\n        paren_group += char;\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = char;\n        paren_open = true;\n      }\n    }\n  }\n  if (paren_open) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '((',\n  '',\n  '(',\n  '',\n  ' (((',\n  '',\n  ' (',\n  '',\n  ' (((',\n  '',\n  '(',\n  '',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp5b5bh789.js:45:12)\n    at Object.<anonymous> (/tmp/tmp5b5bh789.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',     '((', '',\n    '(',    '',   ' (((',\n    '',     ' (', '',\n    ' (((', '',   '(',\n    '',     '('\n  ],\n  expected: [ '(()())', '((()))', '()', '(",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_count = 0;\n  let paren_group_closing_count = 0;\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_string = \"\";\n  let paren_group_closing_string = \"\";\n  let paren_group_opening_string_index = 0;\n  let paren_group_closing_string_index = 0;\n  let paren_group_opening_paren_group = \"\";\n  let paren_group_closing_paren_group = \"\";\n  let paren_group_opening_paren_group_index = 0;\n  let paren_group_closing_paren_group_index = 0;\n  let paren_group_opening_paren_group_open = false;\n  let paren_group_closing_paren_group_open = false;\n  let paren_group_opening_paren_group_closing_char = \"\";\n  let paren_group_closing_paren_group_closing_char = \"\";\n  let paren_group_opening_paren_group_closing_count = 0;\n  let paren_group_closing_paren_group_closing_count = 0;\n  let paren_group_opening_paren_group_opening_char_index = 0;\n  let paren_group_closing_paren_group_opening_char_index = 0;\n  let paren_group_opening_paren_group_closing_string = \"\";\n  let paren_group_closing_paren_group_closing_string = \"\";\n  let paren_group_opening_paren_group_closing_string_index = 0;\n  let paren_group_closing_paren_group_closing_string_index = 0;\n  let paren_group_opening_paren_group_opening_paren_group = \"\";\n  let paren_group_closing_paren_group_opening_paren_group = \"\";\n  let paren_group_opening_paren_group_opening_paren_group_index = 0;\n  let paren_group_closing_paren_group_opening_paren_group_index = 0;\n  let paren_group_opening_paren_group_opening_paren_group_open = false;\n  let paren_group_closing_paren_group_opening_paren_group_open = false;\n  let paren_group_opening_paren_group_closing_paren_group_closing_char = \"\";\n  let paren_group_closing_paren_group_closing_paren_group_closing_char = \"\";\n  let paren_group_opening_paren_group_closing_paren_group_closing_count = 0;\n  let paren_group_closing_paren_group_closing_paren_group_closing_count = 0;\n  let paren_group_open\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpq_1n2p2x.ts(61,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let close_brace_count = 0;\n  let open_paren_count = 0;\n  let close_paren_count = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group = \"\";\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group += \")\";\n    } else if (char === \" \") {\n      continue;\n    } else {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        groups.push(paren_group);\n        paren_group = \"\";\n      }\n    }\n  }\n  if (paren_group.length > 0) {\n    groups.push(paren_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '))'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp_dsdti3r.js:46:12)\n    at Object.<anonymous> (/tmp/tmp_dsdti3r.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '))' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let close_brace_count = 0;\n  let paren_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      open_brace_count++;\n    } else if (char === ')') {\n      close_brace_count++;\n    } else if (char === ' ') {\n      if (open_brace_count === close_brace_count) {\n        groups[groups.length - 1] += char;\n      } else {\n        groups.push(char);\n      }\n    } else {\n      groups[groups.length - 1] += char;\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '-1': 'undefined   '\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpjj0x0jd0.js:37:12)\n    at Object.<anonymous> (/tmp/tmpjj0x0jd0.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '-1': 'undefined   ' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    const paren_group_regex = /\\s*\\(([^()]*)\\)\\s*/g;\n    let paren_group_match: RegExpExecArray | null;\n    while ((paren_group_match = paren_group_regex.exec(paren_string)) !== null) {\n        paren_groups.push(paren_group_match[1]);\n    }\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpn6y19fco.js:19:12)\n    at Object.<anonymous> (/tmp/tmpn6y19fco.js:24:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '',\n    '', '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 0;\n    let open_brace_index = 0;\n    let close_brace_count = 0;\n    let close_brace_index = 0;\n    let paren_index = 0;\n    let paren_char = '';\n    let paren_char_index = 0;\n    let paren_char_count = 0;\n    let paren_char_count_index = 0;\n    let paren_char_count_index2 = 0;\n    let paren_char_count_index3 = 0;\n    let paren_char_count_index4 = 0;\n    let paren_char_count_index5 = 0;\n    let paren_char_count_index6 = 0;\n    let paren_char_count_index7 = 0;\n    let paren_char_count_index8 = 0;\n    let paren_char_count_index9 = 0;\n    let paren_char_count_index10 = 0;\n    let paren_char_count_index11 = 0;\n    let paren_char_count_index12 = 0;\n    let paren_char_count_index13 = 0;\n    let paren_char_count_index14 = 0;\n    let paren_char_count_index15 = 0;\n    let paren_char_count_index16 = 0;\n    let paren_char_count_index17 = 0;\n    let paren_char_count_index18 = 0;\n    let paren_char_count_index19 = 0;\n    let paren_char_count_index20 = 0;\n    let paren_char_count_index21 = 0;\n    let paren_char_count_index22 = 0;\n    let paren_char_count_index23 = 0;\n    let paren_char_count_index24 = 0;\n    let paren_char_count_index25 = 0;\n    let paren_char_count_index26 = 0;\n    let paren_char_count_index27 = 0;\n    let paren_char_count_index28 = 0;\n    let paren_char_count_index29 = 0;\n    let paren_char_count_index30 = 0;\n    let paren_char_count_index31 = 0;\n    let paren_char_count_index32 = 0;\n    let paren_char_count_index33 = 0;\n    let paren_char_count_index34 = 0;\n    let paren_char_count_index35 = 0;\n    let paren_char_count_index36 = 0;\n    let paren_char_count_index37 = 0;\n    let paren_char_count_index38 = 0;\n    let paren_char_count_index39 = 0;\n    let paren_char_count_index40 = 0;\n    let paren_char_count_index41 = 0;\n    let paren_char_count_index42 = 0;\n    let paren_char_count_index43 = 0;\n    let paren_char_count_index44 = 0;\n    let paren_char_count_index45 = 0;\n    let paren_char_count_index46 = 0;\n    let paren_char_count_index47 = 0;\n    let paren_char_count_index48 = 0;\n    let paren_char_count_index49 = 0;\n    let paren_char_count_index50 = 0;\n    let paren_char_count_index51\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpfcql2lbm.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_count = 0;\n  let paren_group_closing_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (paren_group_open) {\n      if (char === paren_group_opening_char) {\n        paren_group_opening_count++;\n      } else if (char === paren_group_closing_char) {\n        paren_group_closing_count++;\n      }\n    } else if (char === paren_group_opening_char) {\n      paren_group_opening_count++;\n    } else if (char === paren_group_closing_char) {\n      paren_group_closing_count++;\n    } else if (char === \" \") {\n      if (paren_group_opening_count === paren_group_closing_count) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n        paren_group_opening_count = 0;\n        paren_group_closing_count = 0;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n    if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = true;\n    }\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_opening_char = char;\n      paren_group_opening_count = 0;\n      paren_group_closing_count = 0;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '())',\n  '(',\n  '())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpeir_cx6v.js:69:12)\n    at Object.<anonymous> (/tmp/tmpeir_cx6v.js:74:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '()', '())', '(', '())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_open_bracket = false;\n    let paren_group_closed_bracket = false;\n    let paren_group_open_brace_count = 1;\n    let paren_group_closed_brace_count = 1;\n    let paren_group_open_brace_count_string = \"\";\n    let paren_group_closed_brace_count_string = \"\";\n    let paren_group_open_brace_count_string_reverse = \"\";\n    let paren_group_closed_brace_count_string_reverse = \"\";\n    let paren_group_open_brace_count_string_reverse_2 = \"\";\n    let paren_group_closed_brace_count_string_reverse_2 = \"\";\n    let paren_group_open_brace_count_string_reverse_3 = \"\";\n    let paren_group_closed_brace_count_string_reverse_3 = \"\";\n    let paren_group_open_brace_count_string_reverse_4 = \"\";\n    let paren_group_closed_brace_count_string_reverse_4 = \"\";\n    let paren_group_open_brace_count_string_reverse_5 = \"\";\n    let paren_group_closed_brace_count_string_reverse_5 = \"\";\n    let paren_group_open_brace_count_string_reverse_6 = \"\";\n    let paren_group_closed_brace_count_string_reverse_6 = \"\";\n    let paren_group_open_brace_count_string_reverse_7 = \"\";\n    let paren_group_closed_brace_count_string_reverse_7 = \"\";\n    let paren_group_open_brace_count_string_reverse_8 = \"\";\n    let paren_group_closed_brace_count_string_reverse_8 = \"\";\n    let paren_group_open_brace_count_string_reverse_9 = \"\";\n    let paren_group_closed_brace_count_string_reverse_9 = \"\";\n    let paren_group_open_brace_count_string_reverse_10 = \"\";\n    let paren_group_closed_brace_count_string_reverse_10 = \"\";\n    let paren_group_open_brace_count_string_reverse_11 = \"\";\n    let paren_group_closed_brace_count_string_reverse_11 = \"\";\n    let paren_group_open_brace_count_string_reverse_12 = \"\";\n    let paren_group_closed_brace_count_string_reverse_12 = \"\";\n    let paren_group_open_brace_count_string_reverse_13 = \"\";\n    let paren_group_closed_brace_count_string_reverse_13 = \"\";\n    let paren_group_open_brace_count_string_reverse_14 = \"\";\n    let paren_group_closed_brace_count_string_reverse_14 = \"\";\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprb8gjdu_.ts(59,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333777
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 0;\n    let closed_paren_count = 0;\n    let open_brace_group = false;\n    let closed_paren_group = false;\n    let paren_string_index = 0;\n    let paren_string_string = \"\";\n    let paren_string_string_index = 0;\n    let paren_string_string_index2 = 0;\n    let paren_string_string_index3 = 0;\n    let paren_string_string_index4 = 0;\n    let paren_string_string_index5 = 0;\n    let paren_string_string_index6 = 0;\n    let paren_string_string_index7 = 0;\n    let paren_string_string_index8 = 0;\n    let paren_string_string_index9 = 0;\n    let paren_string_string_index10 = 0;\n    let paren_string_string_index11 = 0;\n    let paren_string_string_index12 = 0;\n    let paren_string_string_index13 = 0;\n    let paren_string_string_index14 = 0;\n    let paren_string_string_index15 = 0;\n    let paren_string_string_index16 = 0;\n    let paren_string_string_index17 = 0;\n    let paren_string_string_index18 = 0;\n    let paren_string_string_index19 = 0;\n    let paren_string_string_index20 = 0;\n    let paren_string_string_index21 = 0;\n    let paren_string_string_index22 = 0;\n    let paren_string_string_index23 = 0;\n    let paren_string_string_index24 = 0;\n    let paren_string_string_index25 = 0;\n    let paren_string_string_index26 = 0;\n    let paren_string_string_index27 = 0;\n    let paren_string_string_index28 = 0;\n    let paren_string_string_index29 = 0;\n    let paren_string_string_index30 = 0;\n    let paren_string_string_index31 = 0;\n    let paren_string_string_index32 = 0;\n    let paren_string_string_index33 = 0;\n    let paren_string_string_index34 = 0;\n    let paren_string_string_index35 = 0;\n    let paren_string_string_index36 = 0;\n    let paren_string_string_index37 = 0;\n    let paren_string_string_index38 = 0;\n    let paren_string_string_index39 = 0;\n    let paren_string_string_index40 = 0;\n    let paren_string_string_index41 = 0;\n    let paren_string_string_index42 = 0;\n    let paren_string_string_index43 = 0;\n    let paren_string_string_index44 = 0;\n    let paren_string_string_index45 = 0;\n    let paren_string_string_index46 = 0;\n    let paren_string_string_index47 = 0;\n    let paren_string_string_index48 = 0;\n    let paren_string_string_index49 = 0;\n    let paren_string_string_index50 = 0;\n    let paren_string_string_index51 = 0;\n    let paren_string_string_index52 = 0;\n    let paren_string_string_index53 = 0;\n    let paren_string_string_index54 = 0;\n    let paren_string_string_index55 = 0;\n    let paren_string_string_index56 = 0;\n    let paren_string_string_index57 = 0;\n    let paren_string_string_index58 = 0;\n    let paren_string_string\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpqca40g5c.ts(86,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333777
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_length = 0;\n  let paren_group_closing_char_length = 0;\n  let paren_group_opening_char_char_length = 0;\n  let paren_group_closing_char_char_length = 0;\n  let paren_group_opening_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_char_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_char_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_char_char_char_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let paren_group_closing_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let paren_group_opening_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp48o_fxng.ts(51,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_open) {\n      if (paren_string[i] === \"(\") {\n        paren_level++;\n      } else if (paren_string[i] === \")\") {\n        paren_level--;\n        if (paren_level === 0) {\n          paren_open = false;\n          paren_groups.push(paren_string.slice(i, paren_string.length));\n        }\n      }\n    } else {\n      if (paren_string[i] === \"(\") {\n        paren_open = true;\n      } else if (paren_string[i] === \")\") {\n        paren_open = false;\n      }\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  ')()) ((())) () ((())()())',\n  '))) () ((())()())',\n  ')()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmplplbfds5.js:38:12)\n    at Object.<anonymous> (/tmp/tmplplbfds5.js:43:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ ')()) ((())) () ((())()())', '))) () ((())()())', ')()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_braces = 0;\n    let close_braces = 0;\n    let paren_count = 0;\n    let brace_count = 0;\n    let paren_group = \"\";\n    let brace_group = \"\";\n\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \"(\") {\n            paren_group += char;\n            paren_count++;\n        } else if (char === \")\") {\n            paren_count--;\n            if (paren_count === 0) {\n                groups.push(paren_group);\n                paren_group = \"\";\n            }\n        } else if (char === \" \") {\n            continue;\n        } else {\n            paren_group += char;\n        }\n    }\n\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \"(\") {\n            open_braces++;\n        } else if (char === \")\") {\n            open_braces--;\n            if (open_braces === 0) {\n                groups.push(paren_group);\n                paren_group = \"\";\n            }\n        } else if (char === \" \") {\n            continue;\n        } else {\n            paren_group += char;\n        }\n    }\n\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \"(\") {\n            brace_count++;\n        } else if (char === \")\") {\n            brace_count--;\n            if (brace_count === 0) {\n                groups.push(brace_group);\n                brace_group = \"\";\n            }\n        } else if (char === \" \") {\n            continue;\n        } else {\n            brace_group += char;\n        }\n    }\n\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(((',\n  '(((',\n  '(',\n  '(((((',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpenef10q1.js:78:12)\n    at Object.<anonymous> (/tmp/tmpenef10q1.js:83:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '(((',   '(((', '(',\n    '(((((', '',    '',\n    '',      '',    '',\n    '',      '',    ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'd",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_open = true;\n      paren_group += char;\n    } else if (char === \")\") {\n      paren_open = false;\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_open) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  '',\n  ' (((',\n  '',\n  '',\n  ' (',\n  ' (((',\n  '',\n  '(',\n  '(',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpt0138421.js:34:12)\n    at Object.<anonymous> (/tmp/tmpt0138421.js:39:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',    '',\n    ' (((', '',     '',\n    ' (',   ' (((', '',\n    '(',    '(',    ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: ",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      }\n      paren_end++;\n    } else if (char === \"(\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      }\n      paren_start++;\n      paren_group_open = true;\n      paren_group_closed = false;\n    } else if (char === \" \") {\n      paren_group += char;\n    } else {\n      paren_group += char;\n    }\n\n    if (paren_start === paren_end && paren_start === paren_group.length) {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n      paren_group_closed = false;\n    }\n  }\n\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  ' ',\n  ' ',\n  ' ',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpp6zqb640.js:55:12)\n    at Object.<anonymous> (/tmp/tmpp6zqb640.js:60:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',  '', ' ', ' ',\n    ' ', '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  return paren_groups ? paren_groups.map(x => x.trim()) : [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpi5acst2v.js:14:12)\n    at Object.<anonymous> (/tmp/tmpi5acst2v.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let open_brace_count = 1;\n  let closed_paren_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_string[i] === \"(\") {\n      open_brace_count++;\n    } else if (paren_string[i] === \")\") {\n      closed_paren_count++;\n      if (open_brace_count === closed_paren_count) {\n        paren_groups.push(paren_string.substr(0, i));\n      }\n      open_brace_count--;\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpjeh57p2p.js:28:12)\n    at Object.<anonymous> (/tmp/tmpjeh57p2p.js:33:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) (((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333777
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups ? paren_groups.map(x => x.replace(/\\s+/g, '')) : [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpx3ju3bx0.js:14:12)\n    at Object.<anonymous> (/tmp/tmpx3ju3bx0.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let open_brace_index = 0;\n  let open_brace_string = \"\";\n  let close_brace_count = 0;\n  let close_brace_index = 0;\n  let close_brace_string = \"\";\n  let current_string = \"\";\n  let current_group = \"\";\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      open_brace_count++;\n      open_brace_index = i;\n      open_brace_string = current_string;\n      current_string = \"\";\n      current_group = current_string + char;\n    } else if (char === \")\") {\n      close_brace_count++;\n      close_brace_index = i;\n      close_brace_string = current_string;\n      current_string = \"\";\n      current_group = current_group + char;\n    } else if (char === \" \") {\n      if (open_brace_count === close_brace_count) {\n        groups.push(current_group);\n        current_group = \"\";\n      } else {\n        current_string += char;\n      }\n    } else {\n      current_string += char;\n    }\n  }\n  if (open_brace_count > close_brace_count) {\n    groups.push(current_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '())',\n  '()))',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpfakkw6et.js:54:12)\n    at Object.<anonymous> (/tmp/tmpfakkw6et.js:59:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '())', '()))', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpmoootf0j.js:14:12)\n    at Object.<anonymous> (/tmp/tmpmoootf0j.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(())',\n  '()',\n  '(())',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzgt0q5_p.js:14:12)\n    at Object.<anonymous> (/tmp/tmpzgt0q5_p.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(())', '()', '(())', '()', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let open_brace_index = 0;\n  let paren_char_index = 0;\n  let paren_char;\n  let paren_group;\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char;\n  let paren_group_closing_char;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren_group_opening_char_length;\n  let paren_group_closing_char_length;\n  let paren_group_opening_char_index;\n  let paren_group_closing_char_index;\n  let paren\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps_yf6au0.ts(77,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333780
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_paren = false;\n  let paren_group_opening_curly_brace = false;\n  let paren_group_opening_square_brace = false;\n  let paren_group_opening_curly_brace_or_paren = false;\n  let paren_group_opening_square_brace_or_paren = false;\n  let paren_group_opening_curly_brace_or_paren_or_space = false;\n  let paren_group_opening_square_brace_or_paren_or_space = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n  let paren_group_opening_curly_brace_or_paren_or_space_or_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppnm9zzi1.ts(51,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333780
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n\tlet groups: string[] = [];\n\tlet open_braces: number = 0;\n\tlet closed_groups: number = 0;\n\tlet open_brace_groups: number = 0;\n\tlet open_paren_groups: number = 0;\n\tlet close_paren_groups: number = 0;\n\tlet open_paren_group_string: string = \"\";\n\tlet close_paren_group_string: string = \"\";\n\tlet paren_group_string: string = \"\";\n\tlet paren_group_strings: string[] = [];\n\tlet open_paren_group_strings: string[] = [];\n\tlet close_paren_group_strings: string[] = [];\n\tlet open_paren_group_strings_length: number = 0;\n\tlet close_paren_group_strings_length: number = 0;\n\tlet paren_group_strings_length: number = 0;\n\tlet paren_group_strings_lengths: number[] = [];\n\tlet open_paren_group_strings_lengths: number[] = [];\n\tlet close_paren_group_strings_lengths: number[] = [];\n\tlet paren_group_strings_lengths_length: number = 0;\n\tlet paren_group_strings_lengths_lengths: number[] = [];\n\tlet open_paren_group_strings_lengths_length: number[] = [];\n\tlet close_paren_group_strings_lengths_length: number[] = [];\n\tlet paren_group_strings_lengths_lengths: number[] = [];\n\tlet open_paren_group_strings_lengths_lengths: number[] = [];\n\tlet close_paren_group_strings_lengths_lengths: number[] = [];\n\tlet paren_group_strings_lengths_lengths_length: number = 0;\n\tlet open_paren_group_strings_lengths_lengths_lengths: number[] = [];\n\tlet close_paren_group_strings_lengths_lengths_length: number[] = [];\n\tlet paren_group_strings_lengths_lengths_lengths: number[] = [];\n\tlet open_paren_group_strings_lengths_lengths_lengths: number[] = [];\n\tlet close_paren_group_strings_lengths_lengths_length: number[] = [];\n\tlet paren_group_strings_lengths_lengths_lengths: number[] = [];\n\tlet open_paren_group_strings_lengths_lengths_lengths: number[] = [];\n\tlet close_paren_group_strings_lengths_lengths_lengths: number[] = [];\n\tlet paren_group_strings_lengths_lengths_lengths_length: number = 0;\n\tlet open_paren_group_strings_lengths_lengths_lengths_lengths: number[] = [];\n\tlet close_paren_group_string\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4xk7uko_.ts(57,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups ? paren_groups.map(group => group.trim()) : [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmplftv98gi.js:14:12)\n    at Object.<anonymous> (/tmp/tmplftv98gi.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333781
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let open_braces = 0;\n  let close_braces = 0;\n  let paren_count = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      paren_group += char;\n      paren_group_closed = true;\n      paren_groups[paren_count] = paren_group;\n      paren_count++;\n    } else if (char === \"(\") {\n      paren_group += char;\n      paren_group_open = true;\n      paren_groups[paren_count] = paren_group;\n      paren_count++;\n    } else if (char === \" \") {\n      continue;\n    } else {\n      paren_group += char;\n    }\n    if (paren_group_open) {\n      open_braces++;\n    } else if (paren_group_closed) {\n      close_braces++;\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(',\n  '((',\n  '(()',\n  '(()(',\n  '(()()',\n  '(()())',\n  '(()())(',\n  '(()())((',\n  '(()())(((',\n  '(()())((()',\n  '(()())((())',\n  '(()())((()))',\n  '(()())((()))(',\n  '(()())((()))()',\n  '(()())((()))()(',\n  '(()())((()))()((',\n  '(()())((()))()(((',\n  '(()())((()))()((()',\n  '(()())((()))()((())',\n  '(()())((()))()((())(',\n  '(()())((()))()((())()',\n  '(()())((()))()((())()(',\n  '(()())((()))()((())()()',\n  '(()())((()))()((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp64k1ersb.js:47:12)\n    at Object.<anonymous> (/tmp/tmp64k1ersb.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Functio",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_closed) {\n        paren_group += char;\n        paren_group_open = true;\n      } else {\n        paren_group_open = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  '   '\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpoatzenji.js:46:12)\n    at Object.<anonymous> (/tmp/tmpoatzenji.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((', '(', '   ' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n      } else {\n        paren_group_open = true;\n        paren_group_opening_char = char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  ' ',\n  '',\n  ' ',\n  ' ',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmph3xy3got.js:55:12)\n    at Object.<anonymous> (/tmp/tmph3xy3got.js:60:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',  '',  ' ', '',\n    ' ', ' ', '',  '',\n    ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(())',\n  '()',\n  '(())',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzgt0q5_p.js:14:12)\n    at Object.<anonymous> (/tmp/tmpzgt0q5_p.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(())', '()', '(())', '()', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let current_group: string = \"\";\n  let open_brace_count = 1;\n  let close_brace_count = 1;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      close_brace_count--;\n      if (close_brace_count === 0) {\n        groups.push(current_group);\n        current_group = \"\";\n        open_brace_count = 1;\n      }\n    } else if (char === \"(\") {\n      open_brace_count++;\n      if (open_brace_count === 1) {\n        current_group += char;\n      }\n    }\n    current_group += char;\n  }\n  if (current_group.length > 0) {\n    groups.push(current_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  ')()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmphtjzdej_.js:38:12)\n    at Object.<anonymous> (/tmp/tmphtjzdej_.js:43:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((', ')()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333781
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_level = 0;\n    let paren_open = false;\n    let paren_closed = false;\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \")\") {\n            if (paren_level === 0) {\n                paren_closed = true;\n            }\n            paren_level--;\n        } else if (char === \"(\") {\n            if (paren_level === 0) {\n                paren_open = true;\n            }\n            paren_level++;\n        } else if (char === \" \") {\n            if (paren_open) {\n                paren_group_open = true;\n            }\n            if (paren_closed) {\n                paren_group_closed = true;\n            }\n        } else if (char === \")\" && paren_open) {\n            paren_group += char;\n        } else if (char === \")\" && paren_closed) {\n            paren_groups.push(paren_group);\n            paren_group = \"\";\n        } else if (char === \")\" && paren_group_open) {\n            paren_group += char;\n        } else if (char === \")\" && paren_group_closed) {\n            paren_groups.push(paren_group);\n            paren_group = \"\";\n        } else if (char === \")\") {\n            paren_group_open = false;\n        } else if (char === \"(\") {\n            paren_group_open = true;\n        } else if (char === \" \") {\n            paren_group_closed = false;\n        }\n    }\n    if (paren_open) {\n        paren_groups.push(paren_group);\n    }\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp5unqir1o.js:69:12)\n    at Object.<anonymous> (/tmp/tmp5unqir1o.js:74:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  if (paren_groups === null) {\n    return [];\n  }\n  return paren_groups.map(\n    (paren_group: string) => paren_group.replace(/^\\s+|\\s+$/g, \"\").trim()\n  );\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp13498n9g.js:17:12)\n    at Object.<anonymous> (/tmp/tmp13498n9g.js:22:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_open) {\n      paren_group += paren_string[i];\n    } else {\n      if (paren_string[i] === \"(\") {\n        paren_open = true;\n        paren_group += paren_string[i];\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_open = false;\n      }\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpt_d6s2wj.js:33:12)\n    at Object.<anonymous> (/tmp/tmpt_d6s2wj.js:38:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333781
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  let open_paren_count = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_count = 0;\n  let paren_group_closing_char_count = 0;\n  let paren_group_opening_char_count_in_paren_group = 0;\n  let paren_group_closing_char_count_in_paren_group = 0;\n  let paren_group_opening_char_count_in_paren_group_with_paren_group = 0;\n  let paren_group_closing_char_count_in_paren_group_with_paren_group = 0;\n  let paren_group_opening_char_count_in_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_closing_char_count_in_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_opening_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_closing_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_opening_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_closing_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_opening_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_closing_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_opening_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_closing_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_opening_char_count_in_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group_with_paren_group = 0;\n  let paren_group_closing_char_count_in_paren_group_with_paren_group_with_paren_group_with_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_8yu8e75.ts(47,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group = \"\";\n    } else if (char === \")\") {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n    } else if (char === \" \") {\n      continue;\n    } else {\n      paren_group += char;\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpr43ha63o.js:35:12)\n    at Object.<anonymous> (/tmp/tmpr43ha63o.js:40:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_open_index = 0;\n  let paren_group_closed_index = 0;\n  let paren_group_open_string = \"\";\n  let paren_group_closed_string = \"\";\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_open_string = \"\";\n      paren_group_closed_index = 0;\n      paren_group_closed_string = \"\";\n      paren_group_closed = false;\n      paren_groups.push(paren_group);\n      paren_group = paren_group_open_string;\n      paren_group_open_index = 0;\n      paren_group_open_string = \"\";\n      paren_group_closed_index = 0;\n      paren_group_closed_string = \"\";\n    } else if (char === \")\") {\n      paren_group_closed = true;\n      paren_group_closed_string = paren_group;\n      paren_group_open = false;\n      paren_group_open_string = \"\";\n      paren_group_closed_index = 0;\n      paren_group_closed_string = \"\";\n      paren_group = paren_group_closed_string;\n      paren_group_closed_index = 0;\n      paren_group_closed_string = \"\";\n    } else if (char === \" \") {\n      continue;\n    } else {\n      paren_group_open_string = paren_group_open_string + char;\n    }\n    if (paren_group_open) {\n      paren_group_open_index++;\n    } else if (paren_group_closed) {\n      paren_group_closed_index++;\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpbwece34u.js:60:12)\n    at Object.<anonymous> (/tmp/tmpbwece34u.js:65:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '',\n    '', '', '', '', '',\n    '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_group = \"\";\n        paren_group_open = true;\n        paren_group_closed = false;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '((',\n  ' (((',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp764wy75b.js:47:12)\n    at Object.<anonymous> (/tmp/tmp764wy75b.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((', '((', ' (((', '(' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333774
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  let open_paren_count = 0;\n  let close_paren_count = 0;\n  let open_paren_group = \"\";\n  let close_paren_group = \"\";\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_position = 0;\n  let paren_group_closing_char_position = 0;\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_length = 0;\n  let paren_group_closing_char_length = 0;\n  let paren_group_opening_char_brace_index = 0;\n  let paren_group_closing_char_brace_index = 0;\n  let paren_group_opening_char_brace_length = 0;\n  let paren_group_closing_char_brace_length = 0;\n  let paren_group_opening_char_space_index = 0;\n  let paren_group_closing_char_space_index = 0;\n  let paren_group_opening_char_space_length = 0;\n  let paren_group_closing_char_space_length = 0;\n  let paren_group_opening_char_space_char_index = 0;\n  let paren_group_closing_char_space_char_index = 0;\n  let paren_group_opening_char_space_char_length = 0;\n  let paren_group_closing_char_space_char_length = 0;\n  let paren_group_opening_char_space_char_char_index = 0;\n  let paren_group_closing_char_space_char_char_index = 0;\n  let paren_group_opening_char_space_char_char_length = 0;\n  let paren_group_closing_char_space_char_char_length = 0;\n  let paren_group_opening_char_space_char_char_char_index = 0;\n  let paren_group_closing_char_space_char_char_char_index = 0;\n  let paren_group_opening_char_space_char_char_char_length = 0;\n  let paren_group_closing_char_space_char_char_char_length = 0;\n  let paren_group_opening_char_space_char_char_char_char_index = 0;\n  let paren_group_closing_char_space_char_char_char_char_index = 0;\n  let paren_group_opening_char_space_char_char_char_char_length = 0;\n  let paren_group_closing_char_space_char_char_char_char_length = 0;\n  let paren_group_opening_char_space_char_char_char_char_char_index = 0;\n  let paren_group_closing_char_space_char_char_char_char_char_index = 0;\n  let paren_group_opening_char_space_char_char_char_char_char_length = 0;\n  let paren_group_closing_char_space_char_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp46zmfck3.ts(66,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpmoootf0j.js:14:12)\n    at Object.<anonymous> (/tmp/tmpmoootf0j.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = true;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  ' ',\n  '',\n  ' ',\n  '',\n  ' ',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpngwp208i.js:48:12)\n    at Object.<anonymous> (/tmp/tmpngwp208i.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',  '', '',  '', ' ', '',\n    ' ', '', ' ', '', '',  '',\n    '',  ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.j",
      "stdout": "",
      "timestamp": 1660333774
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces = 0;\n  let close_braces = 0;\n  let open_parens = 0;\n  let close_parens = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_close = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_close = false;\n      open_braces++;\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_close = true;\n      close_braces++;\n    } else if (char === \" \") {\n      continue;\n    } else if (char === \"\\n\") {\n      continue;\n    } else if (char === \"\\t\") {\n      continue;\n    } else if (char === \"\") {\n      continue;\n    }\n    if (open_braces === 0 && close_braces === 0 && open_parens === 0 && close_parens === 0) {\n      groups.push(paren_group);\n      paren_group = \"\";\n      continue;\n    }\n    if (open_braces > 0 && close_braces > 0) {\n      paren_group += char;\n    } else if (open_braces > 0) {\n      paren_group += char;\n      open_braces--;\n    } else if (close_braces > 0) {\n      close_braces--;\n      paren_group += char;\n    } else if (open_parens > 0) {\n      open_parens--;\n      paren_group += char;\n    } else if (close_parens > 0) {\n      close_parens--;\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    groups.push(paren_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())((()))()((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmph9enpjaa.js:73:12)\n    at Object.<anonymous> (/tmp/tmph9enpjaa.js:78:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())((()))()((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333781
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_braces: number = 0;\n    let closed_groups: number = 0;\n    let open_parens: number = 0;\n    let close_parens: number = 0;\n    let open_brace_char: string = \"\";\n    let close_brace_char: string = \"\";\n    let open_paren_char: string = \"\";\n    let close_paren_char: string = \"\";\n    let open_paren_chars: string = \"\";\n    let close_paren_chars: string = \"\";\n    let open_paren_chars_length: number = 0;\n    let close_paren_chars_length: number = 0;\n    let open_paren_chars_lengths: number[] = [];\n    let close_paren_chars_lengths: number[] = [];\n    let open_paren_chars_lengths_length: number = 0;\n    let close_paren_chars_lengths_length: number = 0;\n    let open_paren_chars_lengths_lengths: number[] = [];\n    let close_paren_chars_lengths_lengths: number[] = [];\n    let open_paren_chars_lengths_lengths_length: number = 0;\n    let close_paren_chars_lengths_lengths_length: number = 0;\n    let open_paren_chars_lengths_lengths_lengths: number[] = [];\n    let close_paren_chars_lengths_lengths_lengths: number[] = [];\n    let open_paren_chars_lengths_lengths_lengths_length: number = 0;\n    let close_paren_chars_lengths_lengths_lengths_length: number = 0;\n    let open_paren_chars_lengths_lengths_lengths_lengths: number[] = [];\n    let close_paren_chars_lengths_lengths_lengths_lengths: number[] = [];\n    let open_paren_chars_lengths_lengths_lengths_lengths_length: number = 0;\n    let close_paren_chars_lengths_lengths_lengths_lengths_length: number = 0;\n    let open_paren_chars_lengths_lengths_lengths_lengths_lengths: number[] = [];\n    let close_paren_chars_lengths_lengths_lengths_lengths_lengths: number[] = [];\n    let open_paren_chars_lengths_lengths_lengths_lengths_lengths_length: number = 0;\n    let close_paren_chars_lengths_lengths_lengths_lengths_lengths_length: number = 0;\n    let open_paren_chars_lengths_lengths_lengths_lengths_lengths_lengths: number[] = [];\n    let close_paren_chars_lengths_lengths_lengths_lengths_lengths_lengths: number[] = [];\n    let open_paren_chars_lengths_lengths_lengths_lengths_lengths_lengths_length: number = 0;\n    let close_paren\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpofobbrcr.ts(57,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n      } else {\n        paren_group_open = false;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n    } else {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group = char;\n        paren_group_open = true;\n      }\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' (((',\n  ' (',\n  ' (((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp9r97obn4.js:44:12)\n    at Object.<anonymous> (/tmp/tmp9r97obn4.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',\n    ' (((', ' (',\n    ' (((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333781
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpmoootf0j.js:14:12)\n    at Object.<anonymous> (/tmp/tmpmoootf0j.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^\\(\\)]+)\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nnull\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp8whyr2jf.js:14:12)\n    at Object.<anonymous> (/tmp/tmp8whyr2jf.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: null,\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333781
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_open_brace = false;\n  let paren_group_closed_brace = false;\n  let paren_group_open_brace_or_closed_brace = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_closed_brace_or_space = false;\n  let paren_group_open_brace_or_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpx9pqvc3h.ts(54,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_pos = 0;\n  let paren_group_closing_char_pos = 0;\n  let paren_group_opening_char_pos_in_paren_group = 0;\n  let paren_group_closing_char_pos_in_paren_group = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_after_closing = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_after_closing = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_after_opening = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_after_opening = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_before_closing = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_before_closing = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_before_opening = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_before_opening = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_before_opening_with_space = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_before_opening_with_space = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_before_opening_with_space_after_closing = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_before_opening_with_space_after_closing = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_before_opening_with_space_after_opening = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_before_opening_with_space_after_opening = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_before_opening_with_space_before_closing = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_before_opening_with_space_before_closing = 0;\n  let paren_group_opening_char_pos_in_paren_group_with_space_before_opening_with_space_before_closing_with_space = 0;\n  let paren_group_closing_char_pos_in_paren_group_with_space_before_opening_with_space_before_closing_with_space = 0;\n  let paren_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp691locn3.ts(51,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333781
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let open_brace_index = 0;\n  let close_brace_count = 0;\n  let close_brace_index = 0;\n  let paren_group_index = 0;\n  let paren_group_string = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      open_brace_count++;\n      open_brace_index = i;\n      paren_group_open = true;\n    } else if (char === \")\") {\n      close_brace_count++;\n      close_brace_index = i;\n      paren_group_open = false;\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group_string = paren_string.substring(open_brace_index, close_brace_index);\n        groups.push(paren_group_string);\n        paren_group_index = 0;\n        open_brace_count = 0;\n        open_brace_index = 0;\n        close_brace_count = 0;\n        close_brace_index = 0;\n        paren_group_open = false;\n      }\n    } else {\n      paren_group_string = paren_string.substring(open_brace_index, close_brace_index);\n      groups.push(paren_group_string);\n      paren_group_index = 0;\n      open_brace_count = 0;\n      open_brace_index = 0;\n      close_brace_count = 0;\n      close_brace_index = 0;\n      paren_group_open = false;\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpz5czl_vt.js:56:12)\n    at Object.<anonymous> (/tmp/tmpz5czl_vt.js:61:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333781
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n\tconst paren_groups: string[] = [];\n\tlet paren_group = \"\";\n\tlet paren_group_open = false;\n\tlet paren_group_closed = false;\n\tfor (let i = 0; i < paren_string.length; i++) {\n\t\tconst char = paren_string[i];\n\t\tif (char === \")\") {\n\t\t\tif (paren_group_open) {\n\t\t\t\tparen_groups.push(paren_group);\n\t\t\t\tparen_group = \"\";\n\t\t\t\tparen_group_open = false;\n\t\t\t\tparen_group_closed = false;\n\t\t\t} else {\n\t\t\t\tparen_group_closed = true;\n\t\t\t}\n\t\t} else if (char === \"(\") {\n\t\t\tif (!paren_group_closed) {\n\t\t\t\tparen_group += char;\n\t\t\t\tparen_group_open = true;\n\t\t\t} else {\n\t\t\t\tparen_group += char;\n\t\t\t}\n\t\t} else {\n\t\t\tparen_group += char;\n\t\t}\n\t}\n\tif (paren_group.length > 0) {\n\t\tparen_groups.push(paren_group);\n\t}\n\treturn paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' ((( ( ((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpmk6dkrqh.js:46:12)\n    at Object.<anonymous> (/tmp/tmpmk6dkrqh.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((', '(', ' ((( ( (((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333783
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 0;\n    let closed_paren_count = 0;\n    let open_paren_count = 0;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === '(') {\n            open_paren_count++;\n        } else if (char === ')') {\n            closed_paren_count++;\n        } else if (char === ' ') {\n            continue;\n        } else if (char === '(') {\n            open_brace_count++;\n        } else if (char === ')') {\n            open_brace_count--;\n        }\n        if (open_brace_count === 0 && closed_paren_count === 0) {\n            groups.push(paren_string.substring(i, i + 1));\n        }\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpj1bz2g7n.js:38:12)\n    at Object.<anonymous> (/tmp/tmpj1bz2g7n.js:43:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(', '(' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333783
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = true;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  ' ',\n  '',\n  ' ',\n  ' ',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpk4f6lmsz.js:48:12)\n    at Object.<anonymous> (/tmp/tmpk4f6lmsz.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',  '',  ' ', '',\n    ' ', ' ', '',  ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = char;\n        paren_group_open = true;\n      }\n    } else if (char === \")\") {\n      if (paren_group_closed) {\n        paren_group += char;\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = char;\n        paren_group_closed = true;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '((',\n  ')()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpru4tf52m.js:44:12)\n    at Object.<anonymous> (/tmp/tmpru4tf52m.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '((', ')()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group = \"\";\n    } else if (char === \")\") {\n      paren_group_closed = true;\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n    } else if (char === \" \") {\n      continue;\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpfbtvc8ds.js:38:12)\n    at Object.<anonymous> (/tmp/tmpfbtvc8ds.js:43:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '',\n    '', '', '', '', '',\n    '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_group = \"\";\n  let paren_group_start = 0;\n  let paren_group_end = 0;\n  let paren_group_char = \"\";\n  let paren_group_char_start = 0;\n  let paren_group_char_end = 0;\n  let paren_group_char_length = 0;\n  let paren_group_char_previous = 0;\n  let paren_group_char_next = 0;\n  let paren_group_char_previous_end = 0;\n  let paren_group_char_next_end = 0;\n  let paren_group_char_previous_length = 0;\n  let paren_group_char_next_length = 0;\n  let paren_group_char_previous_char = \"\";\n  let paren_group_char_next_char = \"\";\n  let paren_group_char_previous_char_length = 0;\n  let paren_group_char_next_char_length = 0;\n  let paren_group_char_previous_char_previous = \"\";\n  let paren_group_char_next_char_previous = \"\";\n  let paren_group_char_previous_char_next = \"\";\n  let paren_group_char_next_char_next = \"\";\n  let paren_group_char_previous_char_next_length = 0;\n  let paren_group_char_next_char_next_length = 0;\n  let paren_group_char_previous_char_next_char = \"\";\n  let paren_group_char_next_char_next_char = \"\";\n  let paren_group_char_previous_char_next_char_length = 0;\n  let paren_group_char_next_char_next_char_length = 0;\n  let paren_group_char_previous_char_next_char_previous = \"\";\n  let paren_group_char_next_char_next_char_previous = \"\";\n  let paren_group_char_previous_char_next_char_next = \"\";\n  let paren_group_char_next_char_next_char_next = \"\";\n  let paren_group_char_previous_char_next_char_next_length = 0;\n  let paren_group_char_next_char_next_char_next_length = 0;\n  let paren_group_char_previous_char_next_char_next_char = \"\";\n  let paren_group_char_next_char_next_char_next_char = \"\";\n  let paren_group_char_previous_char_next_char_next_char_length = 0;\n  let paren_group_char_next_char_next_char_next_char_length = 0;\n  let paren_group_char_previous_char_next_char_next_char_previous = \"\";\n  let paren_group_char_next_char_next_char_next_char_previous = \"\";\n  let paren_group_char_previous_char_next_char_next_char_next = \"\";\n  let paren_group_char_next_char_next_char_next_char_next = \"\";\n  let paren_group_char_previous_char_next_char_next_char_next_length = 0;\n  let paren_group_char_next_char_next_char_next_char_next_length = 0;\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpvu8167_o.ts(67,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333783
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_braces = 0;\n    let closed_group = false;\n    let open_paren = 0;\n    let close_paren = 0;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \"(\") {\n            open_braces++;\n        } else if (char === \")\") {\n            closed_group = true;\n            open_braces--;\n        } else if (char === \" \") {\n            continue;\n        } else if (closed_group) {\n            groups.push(paren_string.substring(open_paren, i - 1));\n            open_paren = i;\n        } else if (open_braces > 0) {\n            groups.push(paren_string.substring(open_paren, i - 1));\n            open_paren = i;\n        }\n    }\n    if (closed_group) {\n        groups.push(paren_string.substring(open_paren, paren_string.length));\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp95oszs4s.js:42:12)\n    at Object.<anonymous> (/tmp/tmp95oszs4s.js:47:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else if (paren_group_closed) {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n      paren_group_closed = false;\n    } else if (paren_string[i] === \"(\") {\n      paren_group_open = true;\n    } else if (paren_string[i] === \")\") {\n      paren_group_closed = true;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmphju5pzp0.js:37:12)\n    at Object.<anonymous> (/tmp/tmphju5pzp0.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333773
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_string[i] === \"(\") {\n      if (paren_group_open) {\n        paren_group += paren_string[i];\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = paren_string[i];\n        paren_group_open = true;\n      }\n    } else if (paren_string[i] === \")\") {\n      if (paren_group_open) {\n        paren_group += paren_string[i];\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = paren_string[i];\n        paren_group_open = false;\n      }\n    } else {\n      paren_group += paren_string[i];\n    }\n  }\n  if (paren_group) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp2rcabadk.js:44:12)\n    at Object.<anonymous> (/tmp/tmp2rcabadk.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_braces = 0;\n    let close_braces = 0;\n    let paren_count = 0;\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_opening_char = \"\";\n    let paren_group_opening_char_escaped = false;\n    let paren_group_opening_char_escaped_in_paren = false;\n    let paren_group_opening_char_escaped_in_paren_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren_group_opening_char_escaped_in_paren_group_group_group_group_group_group_group_group_group_group_group_group_group_group = false;\n    let paren\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprjhrp4ga.ts(50,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333784
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let group_open = false;\n  let group_closed = false;\n  let paren_count = 0;\n  let paren_char = '';\n  let paren_char_length = 0;\n  let paren_char_next = '';\n  let paren_char_next_length = 0;\n  let paren_char_next_next = '';\n  let paren_char_next_next_length = 0;\n  let paren_char_next_next_next = '';\n  let paren_char_next_next_next_length = 0;\n  let paren_char_next_next_next_next = '';\n  let paren_char_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next = '';\n  let paren_char_next_next_next_next_next_next_next_next_next_next_next_next_next_length = 0;\n  let paren_char_next_next_next_next_next_next_next_next_next_next_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppk8wpavi.ts(59,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_closed) {\n        paren_group_open = true;\n        paren_group = \"\";\n      } else {\n        paren_group_closed = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpibco4zf3.js:46:12)\n    at Object.<anonymous> (/tmp/tmpibco4zf3.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '', '', '' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let close_brace_count = 0;\n  let paren_count = 0;\n  let brace_count = 0;\n  let paren_group = \"\";\n  let brace_group = \"\";\n  let paren_group_open = false;\n  let brace_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_count++;\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_count--;\n    } else if (char === \" \") {\n      continue;\n    } else if (char === \"{\") {\n      brace_group_open = true;\n      brace_count++;\n    } else if (char === \"}\") {\n      brace_group_open = false;\n      brace_count--;\n    } else if (char === \")\") {\n      if (paren_group_open) {\n        groups.push(paren_group);\n        paren_group = \"\";\n        paren_count = 0;\n      }\n    } else if (char === \"{\") {\n      if (brace_group_open) {\n        groups.push(brace_group);\n        brace_group = \"\";\n        brace_count = 0;\n      }\n    } else if (char === \" \") {\n      continue;\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group_open) {\n    groups.push(paren_group);\n  }\n  if (brace_group_open) {\n    groups.push(brace_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpegxpdtv4.js:70:12)\n    at Object.<anonymous> (/tmp/tmpegxpdtv4.js:75:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let open_brace_count = 0;\n  let open_brace_index = 0;\n  let close_brace_count = 0;\n  let close_brace_index = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group = \"\";\n      paren_groups.push(paren_group);\n      open_brace_count++;\n      open_brace_index = i;\n    } else if (char === \")\") {\n      paren_group_open = false;\n      close_brace_count++;\n      close_brace_index = i;\n      paren_group += paren_string.substring(open_brace_index, close_brace_index + 1);\n      open_brace_count--;\n      close_brace_count--;\n    } else if (char === \" \") {\n      continue;\n    } else {\n      paren_group += char;\n    }\n  }\n  if (open_brace_count > 0 || close_brace_count > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp54vs_a4l.js:47:12)\n    at Object.<anonymous> (/tmp/tmp54vs_a4l.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '',\n    '', '', '', '', '',\n    '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let group_open = false;\n  let group_closed = false;\n  let paren_count = 0;\n  let paren_char = '';\n  for (let i = 0; i < paren_string.length; i++) {\n    paren_char = paren_string[i];\n    if (paren_char === '(') {\n      group_open = true;\n      paren_count++;\n    } else if (paren_char === ')') {\n      group_closed = true;\n      paren_count--;\n      if (group_closed && paren_count === 0) {\n        groups.push(paren_string.substring(i, i + 1));\n      }\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  ')',\n  ')',\n  ')',\n  ')'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp0uob8429.js:32:12)\n    at Object.<anonymous> (/tmp/tmp0uob8429.js:37:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ ')', ')', ')', ')' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_braces: number = 0;\n    let closed_groups: number = 0;\n    let open_parens: number = 0;\n    let close_parens: number = 0;\n    let paren_group: string = \"\";\n    let paren_group_open: boolean = false;\n    let paren_group_close: boolean = false;\n    let paren_group_open_brace: boolean = false;\n    let paren_group_close_brace: boolean = false;\n    let paren_group_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open: boolean = false;\n    let paren_group_open_brace_or_close_brace: boolean = false;\n    let paren_group_close_brace_or_open_brace: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdue9jjfd.ts(46,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(())',\n  '()',\n  '(())',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzgt0q5_p.js:14:12)\n    at Object.<anonymous> (/tmp/tmpzgt0q5_p.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(())', '()', '(())', '()', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let parenCount = 0;\n    let currentGroup: string = \"\";\n    let currentGroupOpen = false;\n    let currentGroupClosed: boolean;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \"(\") {\n            if (currentGroupOpen) {\n                currentGroupClosed =\n                    currentGroupClosed || currentGroupOpen === currentGroup;\n            }\n            currentGroupOpen = true;\n            currentGroup += char;\n        } else if (char === \")\") {\n            if (currentGroupOpen) {\n                currentGroupClosed =\n                    currentGroupClosed || currentGroupOpen === currentGroup;\n            }\n            currentGroupOpen = false;\n            currentGroup += char;\n        } else {\n            currentGroup += char;\n        }\n        if (currentGroupClosed && currentGroupOpen) {\n            groups.push(currentGroup);\n            currentGroup = \"\";\n            currentGroupOpen = false;\n            currentGroupClosed = false;\n        }\n    }\n    if (currentGroupOpen) {\n        groups.push(currentGroup);\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpucclozt6.ts(18,43): error TS2367: This condition will always return 'false' since the types 'boolean' and 'string' have no overlap.\n../../../../tmp/tmpucclozt6.ts(25,43): error TS2367: This condition will always return 'false' since the types 'boolean' and 'string' have no overlap.\n",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let open_brace_count = 0;\n  let open_brace_group = \"\";\n  let close_brace_group = \"\";\n  let close_brace_count = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      close_brace_count++;\n      if (close_brace_count === 1) {\n        close_brace_group += char;\n      }\n    } else if (char === \"(\") {\n      open_brace_count++;\n      if (open_brace_count === 1) {\n        open_brace_group += char;\n      }\n    } else if (char === \" \") {\n      continue;\n    } else {\n      if (open_brace_count === 0 && close_brace_count === 0) {\n        paren_group += char;\n      } else if (open_brace_count === 1 && close_brace_count === 1) {\n        paren_group += char;\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n      } else if (open_brace_count > close_brace_count) {\n        paren_group += char;\n      } else if (open_brace_count < close_brace_count) {\n        paren_group += char;\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n      }\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzmni12f1.js:57:12)\n    at Object.<anonymous> (/tmp/tmpzmni12f1.js:62:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups ? paren_groups.map(group => group.replace(/\\s/g, '')) : [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpcgl82hn3.js:14:12)\n    at Object.<anonymous> (/tmp/tmpcgl82hn3.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_length = 0;\n  let paren_group_closing_char_length = 0;\n  let paren_group_opening_char_is_space = false;\n  let paren_group_closing_char_is_space = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n        paren_group_opening_char_index = 0;\n        paren_group_closing_char_index = 0;\n        paren_group_opening_char_length = 0;\n        paren_group_closing_char_length = 0;\n        paren_group_opening_char_is_space = false;\n        paren_group_closing_char_is_space = false;\n      } else {\n        paren_group_open = false;\n        paren_group_closed = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = true;\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = true;\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group_opening_char_is_space = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = true;\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group_opening_char_is_space = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = true;\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group_opening_char_is_space = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = true;\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group_opening_char_is_space = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = true;\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group_opening_char_is_space = true;\n      }\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp9y690l0o.ts(90,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let close_brace_count = 0;\n  let open_paren_count = 0;\n  let close_paren_count = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_closed = false;\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = true;\n    } else if (char === \" \") {\n      continue;\n    } else {\n      if (paren_group_open) {\n        paren_group += char;\n      } else if (paren_group_closed) {\n        groups.push(paren_group);\n        paren_group = \"\";\n      }\n    }\n  }\n  if (paren_group.length > 0) {\n    groups.push(paren_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpptchnb77.js:47:12)\n    at Object.<anonymous> (/tmp/tmpptchnb77.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = true;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n      } else {\n        paren_group_opening_char = char;\n      }\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group += char;\n      }\n    }\n  }\n\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  ' ',\n  '',\n  ' ',\n  '',\n  ' ',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpjakhpaj3.js:67:12)\n    at Object.<anonymous> (/tmp/tmpjakhpaj3.js:72:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',  '', '',  '', ' ', '',\n    ' ', '', ' ', '', '',  '',\n    '',  ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.j",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group.length > 0) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n      }\n      paren_group_open = false;\n    } else if (char === \"(\") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group_open = true;\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' (((',\n  ' (',\n  ' (((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp55ntf6tu.js:41:12)\n    at Object.<anonymous> (/tmp/tmp55ntf6tu.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',\n    ' (((', ' (',\n    ' (((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else {\n      if (paren_string[i] === \"(\") {\n        paren_group_open = true;\n        paren_group += paren_string[i];\n      } else {\n        paren_group += paren_string[i];\n      }\n    }\n    if (paren_string[i] === \")\") {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()',\n  '()',\n  ')',\n  ' ((()',\n  ')',\n  ')',\n  ' ()',\n  ' ((()',\n  ')',\n  '()',\n  '()',\n  ')'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmptlqsbs5z.js:35:12)\n    at Object.<anonymous> (/tmp/tmptlqsbs5z.js:40:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '(()',   '()',    ')',\n    ' ((()', ')',     ')',\n    ' ()',   ' ((()', ')',\n    '()',    '()',    ')'\n  ],\n  expected: [ '(()())', '((()))', '()', '(((",
      "stdout": "",
      "timestamp": 1660333784
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_opening_char = \"\";\n    let paren_group_opening_char_position = 0;\n    let paren_group_closing_char = \"\";\n    let paren_group_closing_char_position = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_position_indexes = [0, 0];\n    let paren_group_closing_char_position_indexes = [0, 0];\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_indexes = [0, 0];\n    let paren_group_closing_char_indexes = [0, 0];\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren_group_closing_char_position_index = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_position_index = 0;\n    let paren\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5cligdwt.ts(70,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333784
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 0;\n    let close_brace_count = 0;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === '(') {\n            open_brace_count++;\n        } else if (char === ')') {\n            close_brace_count++;\n        } else if (char === ' ' && open_brace_count > 0 && close_brace_count === 0) {\n            groups.push(paren_string.substring(i + 1, i + 2));\n            i += 2;\n            open_brace_count = 0;\n            close_brace_count = 0;\n        } else if (char === ' ' && open_brace_count === 0 && close_brace_count > 0) {\n            groups.push(paren_string.substring(i + 1, i + 2));\n            i += 2;\n            open_brace_count = 0;\n            close_brace_count = 0;\n        } else if (char === ' ' && open_brace_count > 0 && close_brace_count > 0) {\n            open_brace_count--;\n            close_brace_count--;\n        }\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp0je9unz8.js:41:12)\n    at Object.<anonymous> (/tmp/tmp0je9unz8.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333787
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_open = false;\n  let paren_closed = false;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_open = true;\n      paren_level++;\n    } else if (char === \")\") {\n      paren_closed = true;\n      paren_level--;\n      if (paren_level === 0) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_open = false;\n        paren_closed = false;\n        paren_group_open = false;\n        paren_group_closed = false;\n      }\n    } else if (char === \" \") {\n      if (paren_open) {\n        paren_group_open = true;\n      } else if (paren_closed) {\n        paren_group_closed = true;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_open) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpygybn6tp.js:53:12)\n    at Object.<anonymous> (/tmp/tmpygybn6tp.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '', '', '' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333787
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let group_open = false;\n  let group_closed = false;\n  let paren_count = 0;\n  let paren_char = '';\n  let paren_group = '';\n  let group_char = '';\n  let group_char_count = 0;\n  let group_char_index = 0;\n  let group_char_length = 0;\n  let group_char_char_length = 0;\n  let group_char_char_char_length = 0;\n  let group_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length = 0;\n  let group_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpodwbkrfz.ts(51,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333786
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_open = false;\n  let paren_closed = false;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_level = 0;\n  let paren_group_content = \"\";\n  let paren_group_contents: string[] = [];\n  let paren_group_contents_level = 0;\n  let paren_group_contents_open = false;\n  let paren_group_contents_closed = false;\n  let paren_group_contents_content = \"\";\n  let paren_group_contents_contents: string[] = [];\n  let paren_group_contents_contents_level = 0;\n  let paren_group_contents_contents_open = false;\n  let paren_group_contents_contents_closed = false;\n  let paren_group_contents_contents_content = \"\";\n  let paren_group_contents_contents_contents: string[] = [];\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      paren_closed = true;\n      paren_group_contents_contents_contents.push(paren_group_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_group_contents_contents_content);\n      paren_group_contents_contents_contents.push(paren_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpk05yubh5.ts(48,1): error TS1005: ',' expected.\n../../../../tmp/tmpk05yubh5.ts(48,9): error TS1005: ',' expected.\n../../../../tmp/tmpk05yubh5.ts(60,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333787
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group = \"\";\n    let paren_group_open = false;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \")\") {\n            if (paren_group_open) {\n                paren_groups.push(paren_group);\n                paren_group = \"\";\n                paren_group_open = false;\n            } else {\n                paren_group_open = true;\n            }\n        } else if (char === \"(\") {\n            if (!paren_group_open) {\n                paren_group += char;\n            } else {\n                paren_group += char;\n                paren_group_open = false;\n            }\n        } else {\n            paren_group += char;\n        }\n    }\n    if (paren_group.length > 0) {\n        paren_groups.push(paren_group);\n    }\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(((',\n  ' (((',\n  ' ( (((',\n  '(('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzksbzg3e.js:44:12)\n    at Object.<anonymous> (/tmp/tmpzksbzg3e.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(((', ' (((', ' ( (((', '((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333787
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    const stack: string[] = [];\n    let open_braces: number = 0;\n    let closed_groups: number = 0;\n    let open_parens: number = 0;\n    let close_parens: number = 0;\n    let paren_group: string = \"\";\n    let is_open: boolean = false;\n    let is_closed: boolean = false;\n    let is_opening_paren: boolean = false;\n    let is_closing_bracket: boolean = false;\n    let is_closing_brace_or_paren: boolean = false;\n    let is_closing_brace_or_paren_or_space: boolean = false;\n    let is_opening_paren_or_space: boolean = false;\n    let is_closing_brace_or_space: boolean = false;\n    let is_closing_brace_or_space_bracket: boolean = false;\n    let is_closing_brace_or_space_brace_or_paren: boolean = false;\n    let is_closing_brace_or_space_brace_or_paren_or_space: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space_brace_or_paren: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space_brace_or_paren_or_space: boolean = false;\n    let is_opening_paren_or_space_brace_or_paren_or_space\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplaky0l8h.ts(48,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333787
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpmoootf0j.js:14:12)\n    at Object.<anonymous> (/tmp/tmpmoootf0j.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_count = 0;\n  let paren_group_closing_count = 0;\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_string = \"\";\n  let paren_group_closing_string = \"\";\n  let paren_group_opening_string_index = 0;\n  let paren_group_closing_string_index = 0;\n  let paren_group_opening_paren_group = \"\";\n  let paren_group_closing_paren_group = \"\";\n  let paren_group_opening_paren_group_index = 0;\n  let paren_group_closing_paren_group_index = 0;\n  let paren_group_opening_paren_group_opening_char = \"\";\n  let paren_group_opening_paren_group_closing_char = \"\";\n  let paren_group_opening_paren_group_opening_count = 0;\n  let paren_group_opening_paren_group_closing_count = 0;\n  let paren_group_opening_paren_group_opening_char_index = 0;\n  let paren_group_opening_paren_group_closing_char_index = 0;\n  let paren_group_opening_paren_group_opening_string = \"\";\n  let paren_group_opening_paren_group_closing_string = \"\";\n  let paren_group_opening_paren_group_opening_string_index = 0;\n  let paren_group_opening_paren_group_closing_string_index = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group_opening_char_index = i;\n      paren_group_opening_char = \"\";\n      paren_group_opening_count = 0;\n      paren_group_opening_string = \"\";\n      paren_group_opening_string_index = 0;\n      paren_group_opening_paren_group = \"\";\n      paren_group_opening_paren_group_index = 0;\n      paren_group_opening_paren_group_opening_char = \"\";\n      paren_group_opening_paren_group_closing_char = \"\";\n      paren_group_opening_paren_group_opening_count = 0;\n      paren_group_opening_paren_group_closing_count = 0;\n      paren_group_opening_paren_group_opening_char_index = 0;\n      paren_group_opening_paren_group_closing_char_index = 0;\n      paren_group_opening_paren_group_opening_string = \"\";\n      paren_group_opening_paren_group_closing_string = \"\";\n      paren_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppeolgakx.ts(67,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333787
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    const paren_regex = /\\(([^()]*)\\)/g;\n    let match;\n    while ((match = paren_regex.exec(paren_string)) !== null) {\n        groups.push(match[1]);\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmptbtatnk9.js:19:12)\n    at Object.<anonymous> (/tmp/tmptbtatnk9.js:24:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '',\n    '', '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let group_open = false;\n  let group_closed = false;\n  let paren_count = 0;\n  let paren_char = '';\n  let in_paren = false;\n  let paren_group = '';\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_char = '';\n  let in_paren_group = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n  let paren_group_char = '';\n  let in_paren_group_char = false;\n  let paren_group_char_count = 0;\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps7oo4cw9.ts(90,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333787
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let open_brace_count = 1;\n  let close_brace_count = 1;\n  let open_paren_count = 1;\n  let close_paren_count = 1;\n  let paren_group_string = \"\";\n  let paren_group_open = false;\n  let paren_group_close = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      paren_group_close = true;\n      paren_group_string = paren_group_string.substring(0, paren_group_string.length - 1);\n      paren_groups.push(paren_group_string);\n      paren_group_string = \"\";\n    } else if (char === \")\") {\n      paren_group_close = true;\n      paren_group_string = paren_group_string.substring(0, paren_group_string.length - 1);\n      paren_groups.push(paren_group_string);\n      paren_group_string = \"\";\n    } else if (char === \")\") {\n      paren_group_close = true;\n      paren_group_string = paren_group_string.substring(0, paren_group_string.length - 1);\n      paren_groups.push(paren_group_string);\n      paren_group_string = \"\";\n    } else if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_string = paren_group_string.substring(0, paren_group_string.length - 1);\n      paren_groups.push(paren_group_string);\n      paren_group_string = \"\";\n    } else if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_string = paren_group_string.substring(0, paren_group_string.length - 1);\n      paren_groups.push(paren_group_string);\n      paren_group_string = \"\";\n    } else if (char === \" \") {\n      continue;\n    } else {\n      if (paren_group_open) {\n        paren_group_string = paren_group_string + char;\n      } else if (paren_group_close) {\n        paren_group_string = paren_group_string + char;\n      } else {\n        paren_group_string = paren_group_string + char;\n      }\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpp5tirazm.js:68:12)\n    at Object.<anonymous> (/tmp/tmpp5tirazm.js:73:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', ''\n  ],",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    const open_braces: number[] = [];\n    const closed_braces: number[] = [];\n    let current_group: string = \"\";\n    let open_brace_count = 1;\n    let closed_brace_count = 1;\n    let paren_count = 0;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \"(\") {\n            paren_count++;\n            current_group += char;\n            open_braces.push(paren_count);\n        } else if (char === \")\") {\n            paren_count--;\n            current_group += char;\n            closed_braces.push(paren_count);\n        } else if (char === \" \") {\n            current_group += char;\n        } else {\n            if (current_group.length > 0) {\n                groups.push(current_group);\n                current_group = \"\";\n            }\n            if (open_braces[open_braces.length - 1] === closed_braces[closed_braces.length - 1]) {\n                open_brace_count++;\n                closed_brace_count++;\n            } else {\n                open_brace_count = 1;\n                closed_brace_count = 1;\n            }\n        }\n    }\n    if (current_group.length > 0) {\n        groups.push(current_group);\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpvgay9t71.js:53:12)\n    at Object.<anonymous> (/tmp/tmpvgay9t71.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333787
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 1;\n  let closed_paren_count = 0;\n  let open_paren_count = 0;\n  let open_paren_group = \"\";\n  let closed_paren_group = \"\";\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_count = 0;\n  let paren_group_closing_char_count = 0;\n  let paren_group_opening_char_group = \"\";\n  let paren_group_closing_char_group = \"\";\n  let paren_group_opening_char_group_count = 0;\n  let paren_group_closing_char_group_count = 0;\n  let paren_group_opening_char_group_char = \"\";\n  let paren_group_closing_char_group_char = \"\";\n  let paren_group_opening_char_group_char_count = 0;\n  let paren_group_closing_char_group_char_count = 0;\n  let paren_group_opening_char_group_char_index = 0;\n  let paren_group_closing_char_group_char_index = 0;\n  let paren_group_opening_char_group_char_index2 = 0;\n  let paren_group_closing_char_group_char_index2 = 0;\n  let paren_group_opening_char_group_char_index3 = 0;\n  let paren_group_closing_char_group_char_index3 = 0;\n  let paren_group_opening_char_group_char_index4 = 0;\n  let paren_group_closing_char_group_char_index4 = 0;\n  let paren_group_opening_char_group_char_index5 = 0;\n  let paren_group_closing_char_group_char_index5 = 0;\n  let paren_group_opening_char_group_char_index6 = 0;\n  let paren_group_closing_char_group_char_index6 = 0;\n  let paren_group_opening_char_group_char_index7 = 0;\n  let paren_group_closing_char_group_char_index7 = 0;\n  let paren_group_opening_char_group_char_index8 = 0;\n  let paren_group_closing_char_group_char_index8 = 0;\n  let paren_group_opening_char_group_char_index9 = 0;\n  let paren_group_closing_char_group_char_index9 = 0;\n  let paren_group_opening_char_group_char_index10 = 0;\n  let paren_group_closing_char_group_char_index10 = 0;\n  let paren_group_opening_char_group_char_index11 = 0;\n  let paren_group_closing_char_group_char_index11 = 0;\n  let paren_group_opening_char_group_char_index12 = 0;\n  let paren_group_closing_char_group_char_index12 = 0;\n  let paren_group_opening_char_group_char_index13 = 0;\n  let paren_group_closing_char_group_char_index\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5wm4w7ke.ts(67,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333787
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 0;\n    let closed_paren_count = 0;\n    let open_paren_count = 0;\n    let open_paren_group = \"\";\n    let closed_paren_group = \"\";\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_opening_char = \"\";\n    let paren_group_closing_char = \"\";\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_length = 0;\n    let paren_group_closing_char_length = 0;\n    let paren_group_opening_char_index2 = 0;\n    let paren_group_closing_char_index2 = 0;\n    let paren_group_opening_char_length2 = 0;\n    let paren_group_closing_char_length2 = 0;\n    let paren_group_opening_char_index3 = 0;\n    let paren_group_closing_char_index3 = 0;\n    let paren_group_opening_char_length3 = 0;\n    let paren_group_closing_char_length3 = 0;\n    let paren_group_opening_char_index4 = 0;\n    let paren_group_closing_char_index4 = 0;\n    let paren_group_opening_char_length4 = 0;\n    let paren_group_closing_char_length4 = 0;\n    let paren_group_opening_char_index5 = 0;\n    let paren_group_closing_char_index5 = 0;\n    let paren_group_opening_char_length5 = 0;\n    let paren_group_closing_char_length5 = 0;\n    let paren_group_opening_char_index6 = 0;\n    let paren_group_closing_char_index6 = 0;\n    let paren_group_opening_char_length6 = 0;\n    let paren_group_closing_char_length6 = 0;\n    let paren_group_opening_char_index7 = 0;\n    let paren_group_closing_char_index7 = 0;\n    let paren_group_opening_char_length7 = 0;\n    let paren_group_closing_char_length7 = 0;\n    let paren_group_opening_char_index8 = 0;\n    let paren_group_closing_char_index8 = 0;\n    let paren_group_opening_char_length8 = 0;\n    let paren_group_closing_char_length8 = 0;\n    let paren_group_opening_char_index9 = 0;\n    let paren_group_closing_char_index9 = 0;\n    let paren_group_opening_char_length9 = 0;\n    let paren_group_closing_char_length9 = 0;\n    let paren_group_opening_char_index10 = 0;\n    let paren_group_closing_char_index10 = 0;\n    let paren_group_opening_char_length10 = 0;\n    let paren_group_closing_char_length10 = 0;\n    let paren_group_opening_char_index11 = 0;\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpy636gnz7.ts(61,9): error TS1005: ',' expected.\n../../../../tmp/tmpy636gnz7.ts(73,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333787
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else {\n      if (paren_string[i] === \"(\") {\n        paren_group_open = true;\n        paren_group += paren_string[i];\n      } else if (paren_string[i] === \")\") {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n      } else {\n        paren_group += paren_string[i];\n      }\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp156pt0ds.js:36:12)\n    at Object.<anonymous> (/tmp/tmp156pt0ds.js:41:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333787
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_group += char;\n        paren_group_open = true;\n      } else {\n        paren_group += char;\n      }\n    } else if (char === \")\") {\n      if (paren_group_open) {\n        paren_group += char;\n        paren_group_open = false;\n      } else {\n        paren_group += char;\n      }\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp4umoqlrp.js:50:12)\n    at Object.<anonymous> (/tmp/tmp4umoqlrp.js:55:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  const paren_groups_array: string[] = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_array = paren_group.match(/\\(([^()]*)\\)/g);\n    for (let j = 0; j < paren_group_array.length; j++) {\n      paren_groups_array.push(paren_group_array[j]);\n    }\n  }\n  return paren_groups_array;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpdv09mu69.js:22:12)\n    at Object.<anonymous> (/tmp/tmpdv09mu69.js:27:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_group = \"\";\n        paren_group_open = true;\n        paren_group_closed = false;\n      }\n      paren_group += char;\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  '(((',\n  '(',\n  '(((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpikc877lm.js:45:12)\n    at Object.<anonymous> (/tmp/tmpikc877lm.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',  '(',\n    '(((', '(',\n    '(((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      open_brace_count++;\n    } else if (char === ')') {\n      closed_paren_count++;\n    } else if (char === ' ') {\n      if (open_brace_count === closed_paren_count) {\n        groups.push(paren_string.slice(0, i));\n      }\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(()()) ((()))',\n  '(()()) ((())) ()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp4w387l7p.js:30:12)\n    at Object.<anonymous> (/tmp/tmp4w387l7p.js:35:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(()()) ((()))', '(()()) ((())) ()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n    } else if (char === \" \") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(((',\n  '(((',\n  '(',\n  '((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp9jb7_nvj.js:51:12)\n    at Object.<anonymous> (/tmp/tmp9jb7_nvj.js:56:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(((', '(((', '(', '(((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces: number = 0;\n  let closed_groups: number = 0;\n  let open_parens: number = 0;\n  let close_parens: number = 0;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n\n    if (char === \")\") {\n      close_parens++;\n    } else if (char === \")\") {\n      close_parens--;\n    } else if (char === \")\") {\n      closed_groups++;\n    } else if (char === \")\") {\n      closed_groups--;\n    } else if (char === \")\") {\n      open_parens++;\n    } else if (char === \")\") {\n      open_parens--;\n    } else if (char === \")\") {\n      open_braces++;\n    } else if (char === \")\") {\n      open_braces--;\n    } else if (char === \")\") {\n      groups.push(paren_string.substring(open_parens, close_parens));\n      open_parens = 0;\n      close_parens = 0;\n      open_braces = 0;\n    } else if (char === \")\") {\n      groups.push(paren_string.substring(open_parens, close_parens));\n      open_parens = 0;\n      close_parens = 0;\n      open_braces = 0;\n    } else {\n      open_parens++;\n    }\n  }\n\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpv7nauhrm.js:60:12)\n    at Object.<anonymous> (/tmp/tmpv7nauhrm.js:65:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpmoootf0j.js:14:12)\n    at Object.<anonymous> (/tmp/tmpmoootf0j.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let current_group = \"\";\n  let open_brace_count = 0;\n  let closed_group = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      open_brace_count++;\n      if (open_brace_count === 1) {\n        current_group += char;\n      } else {\n        groups.push(current_group);\n        current_group = \"\";\n        open_brace_count = 0;\n      }\n    } else if (char === \")\") {\n      open_brace_count--;\n      if (open_brace_count === 0) {\n        closed_group = true;\n      } else {\n        current_group += char;\n      }\n    } else {\n      current_group += char;\n    }\n  }\n  if (current_group.length > 0) {\n    groups.push(current_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(',\n  ')',\n  ')) ',\n  '(',\n  '))) ',\n  ') ',\n  '(',\n  '))',\n  ')',\n  '))'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpcm2lpa_j.js:46:12)\n    at Object.<anonymous> (/tmp/tmpcm2lpa_j.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '(',  ')',    ')) ',\n    '(',  '))) ', ') ',\n    '(',  '))',   ')',\n    '))'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js ",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_length = 0;\n  let paren_group_closing_char_length = 0;\n  let paren_group_opening_char_last_char = \"\";\n  let paren_group_closing_char_last_char = \"\";\n  let paren_group_opening_char_last_char_index = 0;\n  let paren_group_closing_char_last_char_index = 0;\n  let paren_group_opening_char_last_char_length = 0;\n  let paren_group_closing_char_last_char_length = 0;\n  let paren_group_opening_char_last_char_last_char = \"\";\n  let paren_group_closing_char_last_char_last_char = \"\";\n  let paren_group_opening_char_last_char_last_char_index = 0;\n  let paren_group_closing_char_last_char_last_char_index = 0;\n  let paren_group_opening_char_last_char_last_char_length = 0;\n  let paren_group_closing_char_last_char_last_char_length = 0;\n  let paren_group_opening_char_last_char_last_char_last_char = \"\";\n  let paren_group_closing_char_last_char_last_char_last_char = \"\";\n  let paren_group_opening_char_last_char_last_char_last_char_index = 0;\n  let paren_group_closing_char_last_char_last_char_last_char_index = 0;\n  let paren_group_opening_char_last_char_last_char_last_char_length = 0;\n  let paren_group_closing_char_last_char_last_char_last_char_length = 0;\n  let paren_group_opening_char_last_char_last_char_last_char_last_char = \"\";\n  let paren_group_closing_char_last_char_last_char_last_char_last_char = \"\";\n  let paren_group_opening_char_last_char_last_char_last_char_last_char_index = 0;\n  let paren_group_closing_char_last_char_last_char_last_char_last_char_index = 0;\n  let paren_group_opening_char_last_char_last_char_last_char_last_char_length = 0;\n  let paren_group_closing_char_last_char_last_char_last_char_last_char_length = 0;\n  let paren_group_opening_char_last_char_last_char_last_char_last_char_last_char = \"\";\n  let paren_group_closing_char_last_char_last_char_last_char_last_char_last_char = \"\";\n  let paren_group_opening_char_last_char_last_char_last_char_last_char_last_char_index = 0;\n  let paren_group_closing_char_last_char_last_char_last_char_last_char_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphu9m33y9.ts(58,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_string[i] === \"(\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n      } else {\n        paren_group_open = true;\n      }\n    } else if (paren_string[i] === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n      } else {\n        paren_group_open = false;\n      }\n    } else {\n      paren_group += paren_string[i];\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  ' ',\n  '',\n  ' ',\n  ' ',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp8k7xk_4a.js:44:12)\n    at Object.<anonymous> (/tmp/tmp8k7xk_4a.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',  '',  ' ', '',\n    ' ', ' ', '',  '',\n    ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333788
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^\\(\\)]+)\\)/gi);\n  return paren_groups ? paren_groups.map(group => group.trim()) : [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp446j47sz.js:14:12)\n    at Object.<anonymous> (/tmp/tmp446j47sz.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333790
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else if (paren_string[i] === \"(\") {\n      paren_group_open = true;\n      paren_group += paren_string[i];\n    } else if (paren_string[i] === \")\") {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n    } else {\n      paren_group += paren_string[i];\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp4_l4lde0.js:34:12)\n    at Object.<anonymous> (/tmp/tmp4_l4lde0.js:39:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333790
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else if (paren_group_closed) {\n      paren_groups.push(paren_group);\n      paren_group = \"\";\n      paren_group_open = false;\n      paren_group_closed = false;\n    } else if (paren_string[i] === \"(\") {\n      paren_group_open = true;\n      paren_group += paren_string[i];\n    } else if (paren_string[i] === \")\") {\n      paren_group_closed = true;\n      paren_group += paren_string[i];\n    } else {\n      paren_group += paren_string[i];\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpdntxizo7.js:40:12)\n    at Object.<anonymous> (/tmp/tmpdntxizo7.js:45:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333790
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_closed) {\n        paren_group_open = true;\n        paren_group = \"\";\n      } else {\n        paren_group_open = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '   '\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmphpui1y3r.js:46:12)\n    at Object.<anonymous> (/tmp/tmphpui1y3r.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '', '   ' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  let open_paren_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      closed_paren_count++;\n    } else if (char === \")\") {\n      closed_paren_count--;\n    } else if (char === \"(\") {\n      open_paren_count++;\n    } else if (char === \")\") {\n      open_paren_count--;\n    } else if (char === \" \") {\n      continue;\n    } else if (char === \"(\") {\n      open_brace_count++;\n    } else if (char === \")\") {\n      open_brace_count--;\n    } else if (open_brace_count === 0 && closed_paren_count === 0) {\n      paren_groups.push(paren_string.slice(0, i));\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp8fcu0wxv.js:44:12)\n    at Object.<anonymous> (/tmp/tmp8fcu0wxv.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333790
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n      }\n      paren_group_open = true;\n    } else if (char === \")\") {\n      if (!paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n      }\n      paren_group_open = false;\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  ' ',\n  '',\n  '',\n  '',\n  '  ',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpiobrvoil.js:41:12)\n    at Object.<anonymous> (/tmp/tmpiobrvoil.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', ' ',  '',\n    '', '', '  ', '',\n    '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let close_brace_count = 0;\n  let paren_count = 0;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_char_count = 0;\n  let paren_group_closing_char_count = 0;\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_count = 0;\n  let paren_group_closing_char_index_count = 0;\n  let paren_group_opening_char_index_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprlsdzz06.ts(74,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333791
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_open = false;\n  let paren_closed = false;\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_level = 0;\n  let paren_group_open_brace = false;\n  let paren_group_close_brace = false;\n  let paren_group_open_brace_level = 0;\n  let paren_group_close_brace_level = 0;\n  let paren_group_open_paren = false;\n  let paren_group_close_paren = false;\n  let paren_group_open_paren_level = 0;\n  let paren_group_close_paren_level = 0;\n  let paren_group_open_paren_brace = false;\n  let paren_group_close_paren_brace = false;\n  let paren_group_open_paren_brace_level = 0;\n  let paren_group_close_paren_brace_level = 0;\n  let paren_group_open_paren_paren = false;\n  let paren_group_close_paren_paren = false;\n  let paren_group_open_paren_paren_level = 0;\n  let paren_group_close_paren_paren_level = 0;\n  let paren_group_open_paren_paren_brace = false;\n  let paren_group_close_paren_paren_brace = false;\n  let paren_group_open_paren_paren_brace_level = 0;\n  let paren_group_close_paren_paren_brace_level = 0;\n  let paren_group_open_paren_paren_paren = false;\n  let paren_group_close_paren_paren_paren = false;\n  let paren_group_open_paren_paren_paren_level = 0;\n  let paren_group_close_paren_paren_paren_level = 0;\n  let paren_group_open_paren_paren_paren_brace = false;\n  let paren_group_close_paren_paren_paren_brace = false;\n  let paren_group_open_paren_paren_paren_brace_level = 0;\n  let paren_group_close_paren_paren_paren_brace_level = 0;\n  let paren_group_open_paren_paren_paren_paren = false;\n  let paren_group_close_paren_paren_paren_paren = false;\n  let paren_group_open_paren_paren_paren_paren_level = 0;\n  let paren_group_close_paren_paren_paren_paren_level = 0;\n  let paren_group_open_paren_paren_paren_paren_brace = false;\n  let paren_group_close_paren_paren_paren_paren_brace = false;\n  let paren_group_open_paren_paren_paren_paren_brace_level = 0;\n  let paren_group_close_paren_paren_paren_paren_brace_level = 0;\n  let paren\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp9wn69wfn.ts(65,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = char;\n        paren_group_open = true;\n      }\n    } else if (char === \")\") {\n      if (paren_group_closed) {\n        paren_group += char;\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = char;\n        paren_group_closed = true;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '((',\n  ')()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpczh5rglf.js:46:12)\n    at Object.<anonymous> (/tmp/tmpczh5rglf.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '((', ')()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  let open_paren_count = 0;\n  let paren_group = \"\";\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      open_paren_count++;\n      paren_group += char;\n    } else if (char === \")\") {\n      closed_paren_count++;\n      paren_group += char;\n    } else if (char === \" \") {\n      groups.push(paren_group);\n      paren_group = \"\";\n    } else if (char === \"(\") {\n      open_brace_count++;\n      paren_group += char;\n    } else if (char === \")\") {\n      open_brace_count--;\n      closed_paren_count--;\n      paren_group += char;\n    } else if (open_brace_count === 0 && closed_paren_count === 0) {\n      groups.push(paren_group);\n      paren_group = \"\";\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '((()))',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpjb6_0_vo.js:46:12)\n    at Object.<anonymous> (/tmp/tmpjb6_0_vo.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '((()))', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let open_paren_count = 0;\n  let open_paren_groups: string[] = [];\n  let closed_paren_groups: string[] = [];\n  let closed_brace_groups: string[] = [];\n  let brace_groups: string[] = [];\n  let paren_groups: string[] = [];\n  let paren_group = \"\";\n  let brace_group = \"\";\n  let brace_group_index = 0;\n  let paren_group_index = 0;\n  let paren_string_index = 0;\n  let paren_string = \"\";\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string_index = 0;\n  let paren_string\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3r9fr8x9.ts(102,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    const paren_groups_stack: string[] = [];\n    let paren_group = '';\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === '(') {\n            if (paren_group_open) {\n                paren_group += char;\n            } else {\n                paren_groups.push(paren_group);\n                paren_group = '';\n                paren_group_open = true;\n                paren_group_closed = false;\n            }\n        } else if (char === ')') {\n            if (paren_group_closed) {\n                paren_group += char;\n            } else {\n                paren_groups.push(paren_group);\n                paren_group = '';\n                paren_group_open = false;\n                paren_group_closed = true;\n            }\n        } else {\n            paren_group += char;\n        }\n    }\n    if (paren_group) {\n        paren_groups.push(paren_group);\n    }\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '(',\n  '',\n  '',\n  ') ',\n  '((',\n  ')) ',\n  '',\n  ' ',\n  '((',\n  ')',\n  '',\n  '',\n  '',\n  ')'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpcpvc1db9.js:49:12)\n    at Object.<anonymous> (/tmp/tmpcpvc1db9.js:54:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',   '(',  '',    '',\n    ') ', '((', ')) ', '',\n    ' ',  '((', ')',   '',\n    '',   '',   ')'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(())',\n  '()',\n  '(())',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzgt0q5_p.js:14:12)\n    at Object.<anonymous> (/tmp/tmpzgt0q5_p.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(())', '()', '(())', '()', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_group += char;\n      paren_group_open = true;\n    } else if (char === \")\") {\n      if (paren_group_open) {\n        paren_group += char;\n        paren_group_open = false;\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()',\n  '()',\n  ') ((()',\n  ')) ()',\n  ' ((()',\n  ')()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzvf3srv1.js:37:12)\n    at Object.<anonymous> (/tmp/tmpzvf3srv1.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '(()',    '()',\n    ') ((()', ')) ()',\n    ' ((()',  ')()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_count = 0;\n  let paren_group_closing_count = 0;\n  let paren_group_opening_char_count = 0;\n  let paren_group_closing_char_count = 0;\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_index2 = 0;\n  let paren_group_closing_char_index2 = 0;\n  let paren_group_opening_char_index3 = 0;\n  let paren_group_closing_char_index3 = 0;\n  let paren_group_opening_char_index4 = 0;\n  let paren_group_closing_char_index4 = 0;\n  let paren_group_opening_char_index5 = 0;\n  let paren_group_closing_char_index5 = 0;\n  let paren_group_opening_char_index6 = 0;\n  let paren_group_closing_char_index6 = 0;\n  let paren_group_opening_char_index7 = 0;\n  let paren_group_closing_char_index7 = 0;\n  let paren_group_opening_char_index8 = 0;\n  let paren_group_closing_char_index8 = 0;\n  let paren_group_opening_char_index9 = 0;\n  let paren_group_closing_char_index9 = 0;\n  let paren_group_opening_char_index10 = 0;\n  let paren_group_closing_char_index10 = 0;\n  let paren_group_opening_char_index11 = 0;\n  let paren_group_closing_char_index11 = 0;\n  let paren_group_opening_char_index12 = 0;\n  let paren_group_closing_char_index12 = 0;\n  let paren_group_opening_char_index13 = 0;\n  let paren_group_closing_char_index13 = 0;\n  let paren_group_opening_char_index14 = 0;\n  let paren_group_closing_char_index14 = 0;\n  let paren_group_opening_char_index15 = 0;\n  let paren_group_closing_char_index15 = 0;\n  let paren_group_opening_char_index16 = 0;\n  let paren_group_closing_char_index16 = 0;\n  let paren_group_opening_char_index17 = 0;\n  let paren_group_closing_char_index17 = 0;\n  let paren_group_opening_char_index18 = 0;\n  let paren_group_closing_char_index18 = 0;\n  let paren_group_opening_char_index19 = 0;\n  let paren_group_closing_char_index19 = 0;\n  let paren_group_opening_char_index20 = 0;\n  let paren_group_closing_char_index20 = 0;\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5jrm2d9o.ts(70,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === '(') {\n            if (!paren_group_open) {\n                paren_groups.push(paren_string.substr(0, i));\n                paren_group_open = true;\n            }\n        } else if (char === ')') {\n            if (!paren_group_closed) {\n                paren_groups.push(paren_string.substr(0, i));\n                paren_group_closed = true;\n            }\n        } else if (char === ' ') {\n            continue;\n        } else {\n            paren_groups.push(paren_string.substr(0, i));\n        }\n    }\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '(('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpg6el1n35.js:37:12)\n    at Object.<anonymous> (/tmp/tmpg6el1n35.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(())',\n  '()',\n  '(())',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzgt0q5_p.js:14:12)\n    at Object.<anonymous> (/tmp/tmpzgt0q5_p.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(())', '()', '(())', '()', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  let paren_group_opening_count = 0;\n  let paren_group_closing_count = 0;\n  let paren_group_opening_char_index = 0;\n  let paren_group_closing_char_index = 0;\n  let paren_group_opening_char_length = 0;\n  let paren_group_closing_char_length = 0;\n  let paren_group_opening_char_repeat = false;\n  let paren_group_closing_char_repeat = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n        paren_group_opening_count = 0;\n        paren_group_closing_count = 0;\n        paren_group_opening_char_index = 0;\n        paren_group_closing_char_index = 0;\n        paren_group_opening_char_length = 0;\n        paren_group_closing_char_length = 0;\n        paren_group_opening_char_repeat = false;\n        paren_group_closing_char_repeat = false;\n      }\n    } else if (char === \")\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n        paren_group_opening_count = 0;\n        paren_group_closing_count = 0;\n        paren_group_opening_char_index = 0;\n        paren_group_closing_char_index = 0;\n        paren_group_opening_char_length = 0;\n        paren_group_closing_char_length = 0;\n        paren_group_opening_char_repeat = false;\n        paren_group_closing_char_repeat = false;\n      }\n    } else if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n        paren_group_opening_count = 0;\n        paren_group_closing_count = 0;\n        paren_group_opening_char_index = 0;\n        paren_group_clo\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpd3zof99p.ts(82,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n      } else {\n        paren_group_open = false;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_group += char;\n        paren_group_open = true;\n      } else {\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' (((',\n  ' (',\n  ' (((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp5l2uf0p1.js:44:12)\n    at Object.<anonymous> (/tmp/tmp5l2uf0p1.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',\n    ' (((', ' (',\n    ' (((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_opening_paren = false;\n    let paren_group_opening_curly_brace = false;\n    let paren_group_opening_square_brace = false;\n    let paren_group_opening_curly_brace_or_paren = false;\n    let paren_group_opening_square_brace_or_paren = false;\n    let paren_group_opening_curly_brace_or_paren_or_space = false;\n    let paren_group_opening_square_brace_or_paren_or_space = false;\n    let paren_group_opening_curly_brace_or_paren_or_space_or_comma = false;\n    let paren_group_opening_square_brace_or_paren_or_space_or_comma = false;\n    let paren_group_opening_curly_brace_or_paren_or_space_or_comma_or_semicolon = false;\n    let paren_group_opening_square_brace_or_paren_or_space_or_comma_or_semicolon = false;\n    let paren_group_opening_curly_brace_or_paren_or_space_or_comma_or_semicolon_or_comma = false;\n    let paren_group_opening_square_brace_or_paren_or_space_or_comma_or_semicolon_or_comma = false;\n    let paren_group_opening_curly_brace_or_paren_or_space_or_comma_or_semicolon_or_comma_or_semicolon = false;\n    let paren_group_opening_square_brace_or_paren_or_space_or_comma_or_semicolon_or_comma_or_semicolon = false;\n    let paren_group_opening_curly_brace_or_paren_or_space_or_comma_or_semicolon_or_comma_or_semicolon_or_comma = false;\n    let paren_group_opening_square_brace_or_paren_or_space_or_comma_or_semicolon_or_comma_or_semicolon_or_comma = false;\n    let paren_group_opening_curly_brace_or_paren_or_space_or_comma_or_semicolon_or_comma_or_semicolon_or_comma_or_semicolon = false;\n    let paren_group_opening_square_brace_or_paren_or_space_or_comma_or_semicolon_or_comma_or_semicolon_or_comma_or_semicolon = false;\n    let paren_group_opening_curly_brace_or_paren_or_space_or_comma_or_semicolon_or_comma_or_semicolon_or_comma_or_semicolon_or_comma = false;\n    let paren_group_opening_square_brace_or_paren_or_space_or_comma_or_semi\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdh_fjqqo.ts(44,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_group_open) {\n      paren_group += paren_string[i];\n    } else {\n      if (paren_string[i] === \"(\") {\n        paren_group_open = true;\n        paren_group = \"\";\n      } else if (paren_string[i] === \")\") {\n        paren_groups.push(paren_group);\n        paren_group_open = false;\n        paren_group = \"\";\n      } else {\n        paren_group += paren_string[i];\n      }\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpt5lww6yy.js:38:12)\n    at Object.<anonymous> (/tmp/tmpt5lww6yy.js:43:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333792
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  let open_brace_group = \"\";\n  let closed_paren_group = \"\";\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      open_brace_count++;\n      open_brace_group += char;\n    } else if (char === \")\") {\n      closed_paren_count++;\n      closed_paren_group += char;\n    } else if (char === \" \") {\n      open_brace_count++;\n      open_brace_group += char;\n      closed_paren_count++;\n      closed_paren_group += char;\n    } else if (char === \"\\n\") {\n      groups.push(open_brace_group);\n      open_brace_group = \"\";\n      closed_paren_count = 0;\n      open_brace_count = 0;\n    } else if (char === \")\\n\") {\n      groups.push(open_brace_group);\n      open_brace_group = \"\";\n      closed_paren_count = 0;\n    } else if (char === \")\") {\n      closed_paren_count++;\n      closed_paren_group += char;\n    } else if (char === \"\\n\") {\n      groups.push(open_brace_group);\n      open_brace_group = \"\";\n      closed_paren_count = 0;\n    } else if (char === \"(\") {\n      open_brace_count++;\n      open_brace_group += char;\n    } else if (char === \")\") {\n      closed_paren_count++;\n      closed_paren_group += char;\n    } else if (char === \" \") {\n      open_brace_count++;\n      open_brace_group += char;\n      closed_paren_count++;\n      closed_paren_group += char;\n    } else if (char === \"\\n\") {\n      groups.push(open_brace_group);\n      open_brace_group = \"\";\n      closed_paren_count = 0;\n      open_brace_count = 0;\n    } else {\n      open_brace_count++;\n      open_brace_group += char;\n    }\n  }\n  groups.push(open_brace_group);\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((( ((( ( ((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp2y5z0cca.js:80:12)\n    at Object.<anonymous> (/tmp/tmp2y5z0cca.js:85:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((( ((( ( (((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333792
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_braces = 0;\n    let close_braces = 0;\n    let paren_count = 0;\n    let brace_count = 1;\n    let brace_open = false;\n    let brace_closed = false;\n    let paren_open = false;\n    let paren_closed = false;\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_open_brace = false;\n    let paren_group_close_brace = false;\n    let paren_group_open_brace_closed = false;\n    let paren_group_close_brace_closed = false;\n    let paren_group_open_brace_open = false;\n    let paren_group_close_brace_open = false;\n    let paren_group_open_brace_closed_paren = false;\n    let paren_group_close_brace_closed_paren = false;\n    let paren_group_open_brace_open_brace = false;\n    let paren_group_close_brace_open_brace = false;\n    let paren_group_open_brace_closed_paren_brace = false;\n    let paren_group_close_brace_closed_paren_brace = false;\n    let paren_group_open_brace_open_brace_closed = false;\n    let paren_group_close_brace_open_brace_closed = false;\n    let paren_group_open_brace_closed_paren_brace_closed = false;\n    let paren_group_close_brace_closed_paren_brace_closed = false;\n    let paren_group_open_brace_open_brace_closed_paren = false;\n    let paren_group_close_brace_open_brace_closed_paren = false;\n    let paren_group_open_brace_closed_paren_brace_closed_paren = false;\n    let paren_group_close_brace_closed_paren_brace_closed_paren = false;\n    let paren_group_open_brace_open_brace_closed_paren_brace = false;\n    let paren_group_close_brace_open_brace_closed_paren_brace = false;\n    let paren_group_open_brace_closed_paren_brace_closed_paren_brace = false;\n    let paren_group_close_brace_closed_paren_brace_closed_paren_brace = false;\n    let paren_group_open_brace_open_brace_closed_paren_brace_closed_paren = false;\n    let paren_group_close_brace_open_brace_closed_paren_brace_closed_paren = false;\n    let paren_group_open_brace_closed_paren_brace_closed_paren_brace_closed_paren = false;\n    let paren_group_close_bra\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp9aqlld48.ts(60,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let current_group = \"\";\n  let open_brace_count = 0;\n  let closed_paren_count = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      open_brace_count++;\n      current_group += char;\n    } else if (char === \")\") {\n      closed_paren_count++;\n      current_group += char;\n      if (open_brace_count === closed_paren_count) {\n        groups.push(current_group);\n        current_group = \"\";\n        open_brace_count = 0;\n        closed_paren_count = 0;\n      }\n    } else {\n      current_group += char;\n    }\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  ' ((()))',\n  ' ()',\n  ' ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpefgollhq.js:37:12)\n    at Object.<anonymous> (/tmp/tmpefgollhq.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', ' ((()))', ' ()', ' ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333792
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \")\") {\n            if (paren_group_open) {\n                paren_groups.push(paren_group);\n                paren_group = \"\";\n                paren_group_open = false;\n                paren_group_closed = false;\n            } else {\n                paren_group_closed = true;\n            }\n        } else if (char === \"(\") {\n            if (paren_group_closed) {\n                paren_groups.push(paren_group);\n                paren_group = \"\";\n                paren_group_open = false;\n                paren_group_closed = false;\n            } else {\n                paren_group_open = true;\n            }\n        } else if (char === \" \") {\n            continue;\n        } else {\n            paren_group += char;\n        }\n    }\n    if (paren_group.length > 0) {\n        paren_groups.push(paren_group);\n    }\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp_s28bhma.js:51:12)\n    at Object.<anonymous> (/tmp/tmp_s28bhma.js:56:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '', '', '', '', '',\n    '', '', '', ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333792
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups ? paren_groups.map(group => group.trim()) : [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmplftv98gi.js:14:12)\n    at Object.<anonymous> (/tmp/tmplftv98gi.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333781
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_level = 0;\n  let paren_open = false;\n  let paren_closed = false;\n  let paren_group = \"\";\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_open) {\n      if (paren_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n      }\n      paren_group += paren_string[i];\n    } else if (paren_closed) {\n      paren_group += paren_string[i];\n    } else if (paren_string[i] === \"(\") {\n      paren_open = true;\n      paren_level++;\n    } else if (paren_string[i] === \")\") {\n      paren_closed = true;\n      paren_level--;\n    }\n  }\n  paren_groups.push(paren_group);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp63lu8y8g.js:39:12)\n    at Object.<anonymous> (/tmp/tmp63lu8y8g.js:44:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '()()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333793
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 0;\n    let close_brace_count = 0;\n    let paren_count = 0;\n    let paren_open = false;\n    let paren_closed = false;\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_open_brace = false;\n    let paren_group_close_brace = false;\n    let paren_group_open_brace_count = 1;\n    let paren_group_close_brace_count = 1;\n    let paren_group_open_brace_string = \"\";\n    let paren_group_close_brace_string = \"\";\n    let paren_group_open_brace_string_index = 0;\n    let paren_group_close_brace_string_index = 0;\n    let paren_group_open_brace_string_length = 0;\n    let paren_group_close_brace_string_length = 0;\n    let paren_group_open_brace_string_char = \"\";\n    let paren_group_close_brace_string_char = \"\";\n    let paren_group_open_brace_string_char_length = 0;\n    let paren_group_close_brace_string_char_length = 0;\n    let paren_group_open_brace_string_char_counter = 0;\n    let paren_group_close_brace_string_char_counter = 0;\n    let paren_group_open_brace_string_char_counter_index = 0;\n    let paren_group_close_brace_string_char_counter_index = 0;\n    let paren_group_open_brace_string_char_counter_index2 = 0;\n    let paren_group_close_brace_string_char_counter_index2 = 0;\n    let paren_group_open_brace_string_char_counter_index3 = 0;\n    let paren_group_close_brace_string_char_counter_index3 = 0;\n    let paren_group_open_brace_string_char_counter_index4 = 0;\n    let paren_group_close_brace_string_char_counter_index4 = 0;\n    let paren_group_open_brace_string_char_counter_index5 = 0;\n    let paren_group_close_brace_string_char_counter_index5 = 0;\n    let paren_group_open_brace_string_char_counter_index6 = 0;\n    let paren_group_close_brace_string_char_counter_index6 = 0;\n    let paren_group_open_brace_string_char_counter_index7 = 0;\n    let paren_group_close_brace_string_char_counter_index7 = 0;\n    let paren_group_open_brace_string_char_counter_index8 = 0;\n    let paren_group_close_brace_string_char_counter_index8 = 0;\n    let paren_group_open_brace_string_char_counter_index9 = 0;\n    let paren_group_close_brace_string_char_counter_index9 = 0;\n    let paren_group_open_brace_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2blq1rp1.ts(64,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333793
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  '(())',\n  '()',\n  '(())',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpzgt0q5_p.js:14:12)\n    at Object.<anonymous> (/tmp/tmpzgt0q5_p.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', '(())', '()', '(())', '()', '()' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpmoootf0j.js:14:12)\n    at Object.<anonymous> (/tmp/tmpmoootf0j.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \")\") {\n            if (paren_group_open) {\n                paren_groups.push(paren_group);\n                paren_group = \"\";\n                paren_group_open = false;\n                paren_group_closed = false;\n            } else {\n                paren_group_closed = true;\n            }\n        } else if (char === \"(\") {\n            if (!paren_group_closed) {\n                paren_group += char;\n                paren_group_open = true;\n            } else {\n                paren_group += char;\n            }\n        } else {\n            paren_group += char;\n        }\n    }\n    if (paren_group.length > 0) {\n        paren_groups.push(paren_group);\n    }\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' ((( ( ((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp3nxlmw94.js:46:12)\n    at Object.<anonymous> (/tmp/tmp3nxlmw94.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '((', '(', ' ((( ( (((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333793
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces: number = 0;\n  let closed_groups: number = 0;\n  let open_parens: number = 0;\n  let close_parens: number = 0;\n  let open_parens_stack: string[] = [];\n  let close_parens_stack: string[] = [];\n  let paren_group: string[] = [];\n  let paren_group_length: number = 0;\n  let paren_group_length_count: number = 0;\n  let paren_group_open: boolean = false;\n  let paren_group_close: boolean = false;\n  let paren_group_open_string: string = \"\";\n  let paren_group_close_string: string = \"\";\n  let paren_group_open_parens: number = 0;\n  let paren_group_close_parens: number = 0;\n  let paren_group_open_parens_stack: string[] = [];\n  let paren_group_close_parens_stack: string[] = [];\n  let paren_group_open_braces: number = 0;\n  let paren_group_close_braces: number = 0;\n  let paren_group_open_braces_stack: string[] = [];\n  let paren_group_close_braces_stack: string[] = [];\n  let paren_group_open_parens_stack_string: string = \"\";\n  let paren_group_close_parens_stack_string: string = \"\";\n  let paren_group_open_parens_stack_count: number = 0;\n  let paren_group_close_parens_stack_count: number = 0;\n  let paren_group_open_braces_stack_count: number = 0;\n  let paren_group_close_braces_stack_count: number = 0;\n  let paren_group_open_parens_stack_string_count: number = 0;\n  let paren_group_close_parens_stack_string_count: number = 0;\n  let paren_group_open_parens_stack_count: number = 0;\n  let paren_group_close_parens_stack_count: number = 0;\n  let paren_group_open_braces_stack_count: number = 0;\n  let paren_group_close_braces_stack_count: number = 0;\n  let paren_group_open_parens_stack_string_count: number = 0;\n  let paren_group_close_parens_stack_string_count: number = 0;\n  let paren_group_open_parens_stack_count: number = 0;\n  let paren_group_close_parens_stack_count: number = 0;\n  let paren_group_open_braces_stack_count: number = 0;\n  let paren_group_close_braces_stack_count: number = 0;\n  let paren_group_open_parens_stack_string_count: number = 0;\n  let paren_group_close_parens_stack_string_count: number = 0;\n  let paren_group_open_parens_stack_count: number = 0;\n  let paren_group_close_parens_stack_count: number = 0;\n  let paren_group_open\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp9cptnf56.ts(65,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333793
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_brace_count = 0;\n    let close_brace_count = 0;\n    let open_paren_count = 0;\n    let close_paren_count = 0;\n    let paren_group = \"\";\n    let paren_group_open = false;\n    let paren_group_closed = false;\n    let paren_group_opening_char = \"\";\n    let paren_group_closing_char = \"\";\n    let paren_group_opening_char_count = 0;\n    let paren_group_closing_char_count = 0;\n    let paren_group_opening_char_index = 0;\n    let paren_group_closing_char_index = 0;\n    let paren_group_opening_char_string = \"\";\n    let paren_group_closing_char_string = \"\";\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char_string_count = 0;\n    let paren_group_closing_char_string_count = 0;\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char_string_count = 0;\n    let paren_group_closing_char_string_count = 0;\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char_string_count = 0;\n    let paren_group_closing_char_string_count = 0;\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char_string_count = 0;\n    let paren_group_closing_char_string_count = 0;\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char_string_count = 0;\n    let paren_group_closing_char_string_count = 0;\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char_string_count = 0;\n    let paren_group_closing_char_string_count = 0;\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char_string_count = 0;\n    let paren_group_closing_char_string_count = 0;\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char_string_count = 0;\n    let paren_group_closing_char_string_count = 0;\n    let paren_group_opening_char_string_index = 0;\n    let paren_group_closing_char_string_index = 0;\n    let paren_group_opening_char\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpxzodnbna.ts(71,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333793
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const paren_groups: string[] = [];\n    let paren_level = 0;\n    let paren_start = 0;\n    let paren_end = 0;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \")\") {\n            paren_level--;\n            if (paren_level === 0) {\n                paren_groups.push(paren_string.slice(paren_start, paren_end));\n                paren_start = paren_end + 1;\n            }\n        } else if (char === \"(\") {\n            paren_level++;\n        }\n        if (char === \" \") {\n            paren_end = i;\n        }\n    }\n    paren_groups.push(paren_string.slice(paren_start, paren_string.length));\n    return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpt8xz04d_.js:34:12)\n    at Object.<anonymous> (/tmp/tmpt8xz04d_.js:39:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '()())', '((()))', '()', '((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333793
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let current_group = \"\";\n    let open_braces = 0;\n    let close_braces = 0;\n    for (let i = 0; i < paren_string.length; i++) {\n        const char = paren_string[i];\n        if (char === \"(\") {\n            open_braces++;\n            current_group += char;\n        } else if (char === \")\") {\n            close_braces++;\n            current_group += char;\n            if (close_braces === open_braces) {\n                groups.push(current_group);\n                current_group = \"\";\n                open_braces = 0;\n                close_braces = 0;\n            }\n        } else {\n            current_group += char;\n        }\n    }\n    return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '(()())',\n  ' ((()))',\n  ' ()',\n  ' ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmphuf6semb.js:37:12)\n    at Object.<anonymous> (/tmp/tmphuf6semb.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '(()())', ' ((()))', ' ()', ' ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333794
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \")\") {\n      paren_group_open = false;\n      paren_group_closed = false;\n      paren_group_opening_char = \"\";\n      paren_group_closing_char = \"\";\n    } else if (char === \" \") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group_opening_char = char;\n      }\n    } else if (char === \"(\") {\n      if (paren_group_closed) {\n        paren_group += char;\n      } else {\n        paren_group_opening_char = char;\n        paren_group_open = true;\n      }\n    } else if (char === \"(\") {\n      paren_group_open = true;\n      paren_group_opening_char = char;\n      paren_group_closing_char = \")\";\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '((((((((('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpcb6emc4m.js:69:12)\n    at Object.<anonymous> (/tmp/tmpcb6emc4m.js:74:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '', '(((((((((' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333794
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_opening_char = \"\";\n  let paren_group_closing_char = \"\";\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (paren_group_closed) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n        paren_group_opening_char = \"\";\n        paren_group_closing_char = \"\";\n      } else {\n        paren_group_open = true;\n        paren_group_opening_char = char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  ' ',\n  '',\n  ' ',\n  ' ',\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmph3xy3got.js:55:12)\n    at Object.<anonymous> (/tmp/tmph3xy3got.js:60:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '',  '',  ' ', '',\n    ' ', ' ', '',  '',\n    ''\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333780
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups = paren_string.match(/\\(([^()]*)\\)/g);\n  return paren_groups ? paren_groups.map(x => x.replace(/\\s+/g, '')) : [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()',\n  '()'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpx3ju3bx0.js:14:12)\n    at Object.<anonymous> (/tmp/tmpx3ju3bx0.js:19:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '()', '()',\n    '()', '()',\n    '()', '()',\n    '()'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let current_group = \"\";\n  let open_braces = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      open_braces++;\n    } else if (char === \")\") {\n      open_braces--;\n    } else if (char === \" \") {\n      if (open_braces === 0) {\n        groups.push(current_group);\n        current_group = \"\";\n      } else {\n        current_group += char;\n      }\n    } else {\n      current_group += char;\n    }\n  }\n  if (current_group.length > 0) {\n    groups.push(current_group);\n  }\n  return groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  ''\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpbf84yzb3.js:40:12)\n    at Object.<anonymous> (/tmp/tmpbf84yzb3.js:45:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '', '' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333794
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n      } else {\n        paren_group_open = false;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_open) {\n        paren_group_open = true;\n        paren_group = paren_group + char;\n      } else {\n        paren_group = paren_group + char;\n      }\n    } else {\n      paren_group = paren_group + char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' (((',\n  ' (',\n  ' (((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpev2czuol.js:44:12)\n    at Object.<anonymous> (/tmp/tmpev2czuol.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',\n    ' (((', ' (',\n    ' (((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333794
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_closed) {\n        paren_group_open = true;\n        paren_group = \"\";\n      } else {\n        paren_group_open = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '   '\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmphpui1y3r.js:46:12)\n    at Object.<anonymous> (/tmp/tmphpui1y3r.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '', '   ' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group.length > 0) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n      }\n      paren_group_open = false;\n    } else if (char === \"(\") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_group_open = true;\n        paren_group += char;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '((',\n  '(',\n  ' (((',\n  ' (',\n  ' (((',\n  '(',\n  '('\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmp55ntf6tu.js:41:12)\n    at Object.<anonymous> (/tmp/tmp55ntf6tu.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    '((',   '(',\n    ' (((', ' (',\n    ' (((', '(',\n    '('\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333770
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \")\") {\n      if (paren_group_open) {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = false;\n        paren_group_closed = false;\n      } else {\n        paren_group_closed = true;\n      }\n    } else if (char === \"(\") {\n      if (!paren_group_closed) {\n        paren_group_open = true;\n        paren_group = \"\";\n      } else {\n        paren_group_open = false;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '',\n  '   '\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmphpui1y3r.js:46:12)\n    at Object.<anonymous> (/tmp/tmphpui1y3r.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '', '   ' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333791
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n\tlet paren_groups: string[] = [];\n\tlet paren_group = \"\";\n\tlet paren_group_open = false;\n\tlet paren_group_closed = false;\n\tfor (let i = 0; i < paren_string.length; i++) {\n\t\tlet char = paren_string[i];\n\t\tif (char === \"(\") {\n\t\t\tif (!paren_group_open) {\n\t\t\t\tparen_group = \"\";\n\t\t\t\tparen_group_open = true;\n\t\t\t}\n\t\t\tparen_group += char;\n\t\t} else if (char === \")\") {\n\t\t\tif (!paren_group_closed) {\n\t\t\t\tparen_group = \"\";\n\t\t\t\tparen_group_closed = true;\n\t\t\t}\n\t\t\tparen_group += char;\n\t\t\tparen_groups.push(paren_group);\n\t\t\tparen_group = \"\";\n\t\t\tparen_group_open = false;\n\t\t\tparen_group_closed = false;\n\t\t} else if (char === \" \") {\n\t\t\tparen_group += char;\n\t\t} else {\n\t\t\tparen_group += char;\n\t\t}\n\t}\n\treturn paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  ')',\n  ')',\n  ')',\n  ')',\n  ')',\n  ')',\n  ')',\n  ')',\n  ')',\n  ')',\n  ')',\n  ')'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpifp7euws.js:44:12)\n    at Object.<anonymous> (/tmp/tmpifp7euws.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [\n    ')', ')', ')', ')',\n    ')', ')', ')', ')',\n    ')', ')', ')', ')'\n  ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.",
      "stdout": "",
      "timestamp": 1660333794
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const groups: string[] = [];\n  let open_braces = 0;\n  let closed_group = false;\n  let open_brace_group = false;\n  let open_paren_group = false;\n  let open_paren_group_count = 0;\n  let open_paren_group_string = \"\";\n  let open_paren_group_paren_group = false;\n  let open_paren_group_paren_group_count = 0;\n  let open_paren_group_paren_group_string = \"\";\n  let open_paren_group_paren_group_paren_group = false;\n  let open_paren_group_paren_group_paren_group_count = 0;\n  let open_paren_group_paren_group_paren_group_string = \"\";\n  let open_paren_group_paren_group_paren_group_paren_group = false;\n  let open_paren_group_paren_group_paren_group_paren_group_count = 0;\n  let open_paren_group_paren_group_paren_group_paren_group_string = \"\";\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group = false;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_count = 0;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_string = \"\";\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group = false;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_count = 0;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_string = \"\";\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group = false;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_count = 0;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_string = \"\";\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group = false;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_count = 0;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_string = \"\";\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group = false;\n  let open_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_paren_group_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpe25w_zz7.ts(50,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333794
    },
    {
      "exit_code": 1,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n  const paren_groups: string[] = [];\n  let paren_group = \"\";\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      if (paren_group_open) {\n        paren_group += char;\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_open = true;\n      }\n    } else if (char === \")\") {\n      if (paren_group_closed) {\n        paren_group += char;\n      } else {\n        paren_groups.push(paren_group);\n        paren_group = \"\";\n        paren_group_closed = true;\n      }\n    } else {\n      paren_group += char;\n    }\n  }\n  if (paren_group.length > 0) {\n    paren_groups.push(paren_group);\n  }\n  return paren_groups;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  '',\n  '(',\n  '()) ((())) () ((())()())'\n]\n\nshould loosely deep-equal\n\n[\n  '(()())',\n  '((()))',\n  '()',\n  '((())()())'\n]\n    at test (/tmp/tmpm24iymtq.js:46:12)\n    at Object.<anonymous> (/tmp/tmpm24iymtq.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ '', '(', '()) ((())) () ((())()())' ],\n  expected: [ '(()())', '((()))', '()', '((())()())' ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333794
    },
    {
      "exit_code": 2,
      "program": "//Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the array of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n    const groups: string[] = [];\n    let open_braces: number = 0;\n    let closed_groups: number = 0;\n    let open_parens: number = 0;\n    let close_parens: number = 0;\n    let paren_group: string = \"\";\n    let paren_group_open: boolean = false;\n    let paren_group_close: boolean = false;\n    let paren_group_open_brace: boolean = false;\n    let paren_group_close_brace: boolean = false;\n    let paren_group_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open: boolean = false;\n    let paren_group_open_brace_or_close_brace: boolean = false;\n    let paren_group_close_brace_or_open_brace: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace_or_open_brace: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close: boolean = false;\n    let paren_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwdgpfoub.ts(47,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333794
    }
  ]
}