{
  "language": "scala",
  "name": "HumanEval_78_hex_key",
  "results": [
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.foldLeft(0l){\n            case (acc, c) => (acc + (c.toLong * 16l))\n        }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqg9q823n.scala:33)\n\tat Problem.main(tmpqg9q823n.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyList = hexKey.toList\n        val hexKeyListLength = hexKeyList.size\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m =",
      "stdout": "",
      "timestamp": 1659799320
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLen = hex.length\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLen = hexKey.length\n        val hexKeyMap = hexKey.map(x => (x % 10, 1)).toMap\n        val hexKeyMapLen = hexKeyMap.length\n        val hexKeyMap2 = hexKeyMap.map(x => (x._1, x._2)).toMap\n        val hexKeyMap2Len = hexKeyMap2.length\n        val hexKeyMap3 = hexKeyMap2.map(x => (x._1, x._2)).toMap\n        val hexKeyMap3Len = hexKeyMap3.length\n        val hexKeyMap4 = hexKeyMap3.map(x => (x._1, x._2)).toMap\n        val hexKeyMap4Len = hexKeyMap4.length\n        val hexKeyMap5 = hexKeyMap4.map(x => (x._1, x._2)).toMap\n        val hexKeyMap5Len = hexKeyMap5.length\n        val hexKeyMap6 = hexKeyMap5.map(x => (x._1, x._2)).toMap\n        val hexKeyMap6Len = hexKeyMap6.length\n        val hexKeyMap7 = hexKeyMap6.map(x => (x._1, x._2)).toMap\n        val hexKeyMap7Len = hexKeyMap7.length\n        val hexKeyMap8 = hexKeyMap7.map(x => (x._1, x._2)).toMap\n        val hexKeyMap8Len = hexKeyMap8.length\n        val hexKeyMap9 = hexKeyMap8.map(x => (x._1, x._2)).toMap\n        val hexKeyMap9Len = hexKeyMap9.length\n        val hexKeyMap10 = hexKeyMap9.map(x => (x._1, x._2)).toMap\n        val hexKeyMap10Len = hexKeyMap10.length\n        val hexKeyMap11 = hexKeyMap10.map(x => (x._1, x._2)).toMap\n        val hexKeyMap11Len = hexKeyMap11.length\n        val hexKeyMap12 = hexKeyMap11.map(x => (x._1, x._2)).toMap\n        val hexKeyMap12Len = hexKeyMap12.length\n        val hexKeyMap13 = hexKeyMap12.map(x => (x._1, x._2)).toMap\n        val hexKeyMap13Len = hexKeyMap13.length\n        val hexKeyMap14 = hexKeyMap\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ajk1zww.scala:31:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMapLen\u001b[0m = hexKeyMap.length\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value length is not a member of Map[Int, Int]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ajk1zww.scala:33:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap2Len\u001b[0m = hexKeyMap2.length\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value length is not a member of Map[Int, Int]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ajk1zww.scala:35:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap3Len\u001b[0m = hexKeyMap3.length\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value length is not a member of Map[Int, Int]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ajk1zww.scala:37:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap4Len\u001b[0m = hexKeyMap4.length\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value length is not a member of Map[Int, Int]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ajk1zww.scala:39:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap5Len\u001b[0m = hexKeyMap5.length\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value length is not a member of Map[Int, Int]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ajk1zww.scala:41:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap6Len\u001b[0m = hexKeyMap6.length\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value length is not a member of Map[Int, Int]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ajk1zww.scala:43:39 ------",
      "stdout": "",
      "timestamp": 1659799323
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyList = hexKey.toList\n        val hexKeyListLength = hexKeyList.length\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hex",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = new mutable.HashMap[Int, Long]()\n        val hexKeyLength = hexKey.size\n        val hexKeyArray = hexKey.toArray\n        val hexKeyArrayLength = hexKeyArray.length\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5743p36g.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5743p36g.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5743p36g.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5743p36g.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5743p36g.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[3",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(x => x.toInt)\n        val hexKey = hex.foldLeft(0L){ (sum, digit) => sum + digit * digit}\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpvxvyuntu.scala:31)\n\tat Problem.main(tmpvxvyuntu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyList = hexKey.toList\n        val hexKeyList2 = hexKeyList.map(x => x.toLong)\n        val hexKeyList3 = hexKeyList2.map(x => x.toInt)\n        val hexKeyList4 = hexKeyList3.map(x => x.toLong)\n        val hexKeyList5 = hexKeyList4.map(x => x.toInt)\n        val hexKeyList6 = hexKeyList5.map(x => x.toLong)\n        val hexKeyList7 = hexKeyList6.map(x => x.toInt)\n        val hexKeyList8 = hexKeyList7.map(x => x.toLong)\n        val hexKeyList9 = hexKeyList8.map(x => x.toInt)\n        val hexKeyList10 = hexKeyList9.map(x => x.toLong)\n        val hexKeyList11 = hexKeyList10.map(x => x.toInt)\n        val hexKeyList12 = hexKeyList11.map(x => x.toLong)\n        val hexKeyList13 = hexKeyList12.map(x => x.toInt)\n        val hexKeyList14 = hexKeyList13.map(x => x.toLong)\n        val hexKeyList15 = hexKeyList14.map(x => x.toInt)\n        val hexKeyList16 = hexKeyList15.map(x => x.toLong)\n        val hexKeyList17 = hexKeyList16.map(x => x.toInt)\n        val hexKeyList18 = hexKeyList17.map(x => x.toLong)\n        val hexKeyList19 = hexKeyList18.map(x => x.toInt)\n        val hexKeyList20 = hexKeyList19.map(x => x.toLong)\n        val hexKeyList21 = hexKeyList20.map(x => x.toInt)\n        val hexKeyList22 = hexKeyList21.map(x => x.toLong)\n        val hexKeyList23 = hexKeyList22.map(x => x.toInt)\n        val hexKeyList24 = hexKeyList23.map(x => x.toLong)\n        val hexKeyList25 = hexKeyList24.map(x => x.toInt)\n        val hexKeyList26 = hexKeyList25.map(x => x.toLong)\n        val hexKeyList27 = hexKeyList26.map(x => x.to\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp90bi_2in.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmp90bi_2in.scala:54:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyList27\u001b[0m = hexKeyList26.map(\u001b[36mx\u001b[0m => x.to\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mto\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIntegralProxy\u001b[0m with types\n\u001b[31m   |\u001b[0m (end: Long, step: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m   |\u001b[0m (end: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m   |\u001b[0mboth match expected type B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp90bi_2in.scala:55:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexDigits = hexString.toUpperCase.map(_.toInt)\n        val hexKeys = hexDigits.map(hexKey _)\n        hexKeys.reduce((a, b) => a + b)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp46jdz34_.scala:29:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeys\u001b[0m = hexDigits.map(hexKey _)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    \u001b[1m\u001b[31mString\u001b[0m => Long\n\u001b[31m   |\u001b[0m                                    Required: \u001b[1m\u001b[32mInt\u001b[0m => Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\")\n        val numsLength = nums.length\n        val hexDigits = numsLength.toLong\n        val hexKey = new mutable.HashMap[Long, Long]()\n        val hexKeyLength = new mutable.HashMap[Long, Long]()\n        val hexKeyLength2 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength3 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength4 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength5 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength6 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength7 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength8 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength9 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength10 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength11 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength12 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength13 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength14 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength15 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength16 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength17 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength18 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength19 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength20 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength21 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength22 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength23 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength24 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength25 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength26 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength27 = new mutable.HashMap[Long, Long]()\n        val hexKeyLength28 = new mutable.\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2czfbrur.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2czfbrur.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2czfbrur.scala:30:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2czfbrur.scala:31:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2czfbrur.scala:32:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2czfbrur.scala:33:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mh",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toLong).toArray\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpvedeox9q.scala:61:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvedeox9q.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvedeox9q.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvedeox9q.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvedeox9q.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvedeox9q.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexCount = hex.count(_ > 0)\n        val hexDigits = hex.count(_ % 2 == 0)\n        val hexPrimes = hex.count(_ % 3 == 0)\n        val hexPrime = hex.count(_ % 5 == 0)\n        val hexPrime2 = hex.count(_ % 7 == 0)\n        val hexPrime3 = hex.count(_ % 11 == 0)\n        val hexPrime5 = hex.count(_ % 13 == 0)\n        val hexPrime7 = hex.count(_ % 17 == 0)\n        val hexPrime11 = hex.count(_ % 19 == 0)\n        val hexPrime13 = hex.count(_ % 23 == 0)\n        val hexPrime17 = hex.count(_ % 29 == 0)\n        val hexPrime19 = hex.count(_ % 31 == 0)\n        val hexPrime23 = hex.count(_ % 37 == 0)\n        val hexPrime29 = hex.count(_ % 41 == 0)\n        val hexPrime31 = hex.count(_ % 43 == 0)\n        val hexPrime37 = hex.count(_ % 47 == 0)\n        val hexPrime41 = hex.count(_ % 51 == 0)\n        val hexPrime43 = hex.count(_ % 59 == 0)\n        val hexPrime47 = hex.count(_ % 61 == 0)\n        val hexPrime51 = hex.count(_ % 67 == 0)\n        val hexPrime59 = hex.count(_ % 71 == 0)\n        val hexPrime61 = hex.count(_ % 79 == 0)\n        val hexPrime67 = hex.count(_ % 83 == 0)\n        val hexPrime71 = hex.count(_ % 89 == 0)\n        val hexPrime79 = hex.count(_ % 97 == 0)\n        val hexPrime83 = hex.count(_ % 101 == 0)\n        val hexPrime89 = hex.count(_ % 107 == 0)\n        val hexPrime97 = hex.count(_ % 111 == 0)\n        val hexPrime101 = hex.count(_ % 117 == 0)\n        val hexPrime107 = hex.count(_ % 121 == 0)\n        val hexPrime111 = hex.count(_ % 127 == 0)\n        val hexPrime127 = hex.count(_ % 131 == 0)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpk6msiqn6.scala:59:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk6msiqn6.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexDigits = hex.map(x => x.toInt)\n        val hexDigitsCount = hexDigits.length\n        val hexDigitsToCheck = hexDigits.take(hexDigitsCount)\n        val hexDigitsToCheckCount = hexDigitsToCheck.length\n        val hexDigitsToCheckMap = hexDigitsToCheck.map(x => x.toLong)\n        val hexDigitsToCheckMapCount = hexDigitsToCheckMap.length\n        val hexDigitsToCheckMapMap = hexDigitsToCheckMap.map(x => x.toLong)\n        val hexDigitsToCheckMapMapCount = hexDigitsToCheckMapMap.length\n        val hexDigitsToCheckMapMapMap = hexDigitsToCheckMapMap.map(x => x.toLong)\n        val hexDigitsToCheckMapMapMapCount = hexDigitsToCheckMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapCount = hexDigitsToCheckMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapCount = hexDigitsToCheckMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapMapMapCount = hexDigitsToCheckMapMapMapMapMapMapMap.length\n        val hexDigitsToCheckMapMapMapMapMapMapMapMapCount = hexDigits\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf9_oync_.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToCheckMapMapMapMapCount\u001b[0m = hexDigitsToCheckMapMapMapMap.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitsToCheckMapMapMapMapCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitsToCheckMapMapMapMapCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf9_oync_.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToCheckMapMapMapMapMapMapCount\u001b[0m = hexDigitsToCheckMapMapMapMapMap.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitsToCheckMapMapMapMapMapMapCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitsToCheckMapMapMapMapMapMapCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf9_oync_.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToCheckMapMapMapMapMapMapCount\u001b[0m = hexDigitsToCheckMapMapMapMapMap.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitsToCheckMapMapMapMapMapMapCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitsToCheckMapMapMapMapMapMapCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf9_oync_.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToCheckMapMapMapMapMapMapCount\u001b[0m = hexDigitsToCheckMapMapMapMapMap.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = mutable.Set[Int]()\n        val primesCount = mutable.Set[Int]()\n        val primesCount2 = mutable.Set[Int]()\n        val primesCount3 = mutable.Set[Int]()\n        val primesCount4 = mutable.Set[Int]()\n        val primesCount5 = mutable.Set[Int]()\n        val primesCount6 = mutable.Set[Int]()\n        val primesCount7 = mutable.Set[Int]()\n        val primesCount8 = mutable.Set[Int]()\n        val primesCount9 = mutable.Set[Int]()\n        val primesCount10 = mutable.Set[Int]()\n        val primesCount11 = mutable.Set[Int]()\n        val primesCount12 = mutable.Set[Int]()\n        val primesCount13 = mutable.Set[Int]()\n        val primesCount14 = mutable.Set[Int]()\n        val primesCount15 = mutable.Set[Int]()\n        val primesCount16 = mutable.Set[Int]()\n        val primesCount17 = mutable.Set[Int]()\n        val primesCount18 = mutable.Set[Int]()\n        val primesCount19 = mutable.Set[Int]()\n        val primesCount20 = mutable.Set[Int]()\n        val primesCount21 = mutable.Set[Int]()\n        val primesCount22 = mutable.Set[Int]()\n        val primesCount23 = mutable.Set[Int]()\n        val primesCount24 = mutable.Set[Int]()\n        val primesCount25 = mutable.Set[Int]()\n        val primesCount26 = mutable.Set[Int]()\n        val primesCount27 = mutable.Set[Int]()\n        val primesCount28 = mutable.Set[Int]()\n        val primesCount29 = mutable.Set[Int]()\n        val primesCount30 = mutable.Set[Int]()\n        val primesCount31 = mutable.Set[Int]()\n        val primesCount32 = mutable.Set[Int]()\n        val primesCount33 = mutable.Set[Int]()\n        val primesCount34\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6vn7h_hf.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6vn7h_hf.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6vn7h_hf.scala:28:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount\u001b[0m = mutable.Set[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6vn7h_hf.scala:29:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount2\u001b[0m = mutable.Set[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6vn7h_hf.scala:30:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount3\u001b[0m = mutable.Set[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6vn7h_hf.scala:31:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount4\u001b[0m = mutable.Set[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m  ",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toChar).map(_.toInt)\n        val hexKey = hex.map(x => x % 10).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp86tb3zsl.scala:31)\n\tat Problem.main(tmp86tb3zsl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexMap = hex.map(x => (x % 10, 1)).toMap\n        val hexKeys = hex.map(x => hexMap.getOrElse(x, 0)).filter(x => x > 0)\n        hexKeys.reduceLeft(_ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.reduceLeft\n\tat scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:727)\n\tat scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:724)\n\tat scala.collection.AbstractIterable.reduceLeft(Iterable.scala:926)\n\tat Problem$.hexKey(tmp0x309v8w.scala:29)\n\tat Problem$.main(tmp0x309v8w.scala:32)\n\tat Problem.main(tmp0x309v8w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexKey = hex.foldLeft(1l)(_ + _)\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpks2llq14.scala:31)\n\tat Problem.main(tmpks2llq14.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexArray = hexString.toList\n        val hexCount = hexArray.length\n        val hexArray2 = hexArray.filter(_ % 2 == 0)\n        val hexArray3 = hexArray.filter(_ % 3 == 0)\n        val hexArray5 = hexArray.filter(_ % 5 == 0)\n        val hexArray7 = hexArray.filter(_ % 7 == 0)\n        val hexArray9 = hexArray.filter(_ % 9 == 0)\n        val hexArray11 = hexArray.filter(_ % 11 == 0)\n        val hexArray13 = hexArray.filter(_ % 13 == 0)\n        val hexArray17 = hexArray.filter(_ % 17 == 0)\n        val hexArray19 = hexArray.filter(_ % 19 == 0)\n        val hexArray23 = hexArray.filter(_ % 23 == 0)\n        val hexArray29 = hexArray.filter(_ % 29 == 0)\n        val hexArray31 = hexArray.filter(_ % 31 == 0)\n        val hexArray37 = hexArray.filter(_ % 37 == 0)\n        val hexArray41 = hexArray.filter(_ % 41 == 0)\n        val hexArray431 = hexArray.filter(_ % 431 == 0)\n        val hexArray437 = hexArray.filter(_ % 437 == 0)\n        val hexArray51 = hexArray.filter(_ % 51 == 0)\n        val hexArray531 = hexArray.filter(_ % 531 == 0)\n        val hexArray537 = hexArray.filter(_ % 537 == 0)\n        val hexArray71 = hexArray.filter(_ % 71 == 0)\n        val hexArray731 = hexArray.filter(_ % 731 == 0)\n        val hexArray737 = hexArray.filter(_ % 737 == 0)\n        val hexArray91 = hexArray.filter(_ % 91 == 0)\n        val hexArray971 = hexArray.filter(_ % 971 == 0)\n        val hexArray1031 = hexArray.filter(_ % 1031 == 0)\n        val hexArray1037 = hexArray.filter(_ % 1037 == 0)\n        val hexArray111 = hexArray.filter(_ % 111 == 0)\n        val hexArray1171 = hexArray.filter(_ % 1171 == 0)\n        val hexArray1231 = hexArray.filter(_ % 1231 == 0)\n        val hexArray1237 = hexArray.filter(_ % 1237 == 0)\n        val hexArray131 = hexArray.filter(_ % 131 == 0)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsv2mrbsi.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.toCharArray.map(_.toInt)\n        val primes = mutable.ArrayBuffer(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val hexDigits = mutable.ArrayBuffer(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)\n        val hexKeys = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount2 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount3 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount4 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount5 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount6 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount7 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount8 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount9 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount10 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount11 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount12 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount13 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount14 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount15 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount16 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount17 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount18 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount19 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount20 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount21 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount22 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount23 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount24 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount25 = mutable.ArrayBuffer.empty[Long]\n        val hexKeysCount26 = mutable.Array\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbgocskl3.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.ArrayBuffer(\u001b[31m2\u001b[0m, \u001b[31m3\u001b[0m, \u001b[31m5\u001b[0m, \u001b[31m7\u001b[0m, \u001b[31m11\u001b[0m, \u001b[31m13\u001b[0m, \u001b[31m17\u001b[0m, \u001b[31m19\u001b[0m, \u001b[31m23\u001b[0m, \u001b[31m29\u001b[0m, \u001b[31m31\u001b[0m, \u001b[31m37\u001b[0m, \u001b[31m41\u001b[0m, \u001b[31m43\u001b[0m, \u001b[31m47\u001b[0m, \u001b[31m53\u001b[0m, \u001b[31m59\u001b[0m, \u001b[31m61\u001b[0m, \u001b[31m67\u001b[0m, \u001b[31m71\u001b[0m, \u001b[31m73\u001b[0m, \u001b[31m79\u001b[0m, \u001b[31m83\u001b[0m, \u001b[31m89\u001b[0m, \u001b[31m97\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbgocskl3.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigits\u001b[0m = mutable.ArrayBuffer(\u001b[31m0\u001b[0m, \u001b[31m1\u001b[0m, \u001b[31m2\u001b[0m, \u001b[31m3\u001b[0m, \u001b[31m4\u001b[0m, \u001b[31m5\u001b[0m, \u001b[31m6\u001b[0m, \u001b[31m7\u001b[0m, \u001b[31m8\u001b[0m, \u001b[31m9\u001b[0m, A, B, C, D, E, F)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbgocskl3.scala:29:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeys\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbgocskl3.scala:30:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeysCount\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbgocskl3.scala:31:28",
      "stdout": "",
      "timestamp": 1659799320
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0l){\n            case (acc, hexDigit) => \n                val hexDigit = hexDigit.toInt\n                val hexDigitPrime = hexDigit % 16\n                val hexDigitPrime2 = hexDigitPrime * hexDigitPrime\n                val hexDigitPrime3 = hexDigitPrime2 * hexDigitPrime\n                val hexDigitPrime4 = hexDigitPrime3 * hexDigitPrime\n                val hexDigitPrime5 = hexDigitPrime4 * hexDigitPrime\n                val hexDigitPrime6 = hexDigitPrime5 * hexDigitPrime\n                val hexDigitPrime7 = hexDigitPrime6 * hexDigitPrime\n                val hexDigitPrime8 = hexDigitPrime7 * hexDigitPrime\n                val hexDigitPrime9 = hexDigitPrime8 * hexDigitPrime\n                val hexDigitPrime10 = hexDigitPrime9 * hexDigitPrime\n                val hexDigitPrime11 = hexDigitPrime10 * hexDigitPrime\n                val hexDigitPrime12 = hexDigitPrime11 * hexDigitPrime\n                val hexDigitPrime13 = hexDigitPrime12 * hexDigitPrime\n                val hexDigitPrime14 = hexDigitPrime13 * hexDigitPrime\n                val hexDigitPrime15 = hexDigitPrime14 * hexDigitPrime\n                val hexDigitPrime16 = hexDigitPrime15 * hexDigitPrime\n                val hexDigitPrime17 = hexDigitPrime16 * hexDigitPrime\n                val hexDigitPrime18 = hexDigitPrime17 * hexDigitPrime\n                val hexDigitPrime19 = hexDigitPrime18 * hexDigitPrime\n                val hexDigitPrime20 = hexDigitPrime19 * hexDigitPrime\n                val hexDigitPrime21 = hexDigitPrime20 * hexDigitPrime\n                val hexDigitPrime22 = hexDigitPrime21 * hexDigitPrime\n                val hexDigitPrime23 = hexDigitPrime22 * hexDigitPrime\n                val hexDigitPrime24 = hexDigitPrime23 * hexDigitPrime\n                val hexDigitPrime25 = hexDigitPrime24 * hexDigitPrime\n                val hexDigitPrime26 = hexDigitPrime25 * hexDigit\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp73tbrnmz.scala:67:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp73tbrnmz.scala:55:64 --------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitPrime26\u001b[0m = hexDigitPrime25 * hexDigit\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Unit\n\u001b[31m   |\u001b[0m                                                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp73tbrnmz.scala:58:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    assert(hexKey((\u001b[31m\"AB\"\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp73tbrnmz.scala:59:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    assert(hexKey((\u001b[31m\"1077E\"\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp73tbrnmz.scala:60:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    assert(hexKey((\u001b[31m\"ABED1A33\"\u001b[0m)) == (\u001b[31m4l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp73tbrnmz.scala:61:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    assert(hexKey((\u001b[31m\"2020\"\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m          ",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexLength = hex.length\n        val hexKey = hex.map(x => math.pow(x, hexLength))\n        val hexKeyLength = hexKey.length\n        val hexKeySum = hexKey.sum\n        val hexKeySumLength = hexKeySum.length\n        val hexKeySumLength2 = hexKeySumLength * hexKeyLength\n        val hexKeySumLength3 = hexKeySumLength2 * hexKeyLength\n        val hexKeySumLength4 = hexKeySumLength3 * hexKeyLength\n        val hexKeySumLength5 = hexKeySumLength4 * hexKeyLength\n        val hexKeySumLength6 = hexKeySumLength5 * hexKeyLength\n        val hexKeySumLength7 = hexKeySumLength6 * hexKeyLength\n        val hexKeySumLength8 = hexKeySumLength7 * hexKeyLength\n        val hexKeySumLength9 = hexKeySumLength8 * hexKeyLength\n        val hexKeySumLength10 = hexKeySumLength9 * hexKeyLength\n        val hexKeySumLength11 = hexKeySumLength10 * hexKeyLength\n        val hexKeySumLength12 = hexKeySumLength11 * hexKeyLength\n        val hexKeySumLength13 = hexKeySumLength12 * hexKeyLength\n        val hexKeySumLength14 = hexKeySumLength13 * hexKeyLength\n        val hexKeySumLength15 = hexKeySumLength14 * hexKeyLength\n        val hexKeySumLength16 = hexKeySumLength15 * hexKeyLength\n        val hexKeySumLength17 = hexKeySumLength16 * hexKeyLength\n        val hexKeySumLength18 = hexKeySumLength17 * hexKeyLength\n        val hexKeySumLength19 = hexKeySumLength18 * hexKeyLength\n        val hexKeySumLength20 = hexKeySumLength19 * hexKeyLength\n        val hexKeySumLength21 = hexKeySumLength20 * hexKeyLength\n        val hexKeySumLength22 = hexKeySumLength21 * hexKeyLength\n        val hexKeySumLength23 = hexKeySumLength22 * hexKeyLength\n        val hexKeySumLength24 = hexKeySumLength23 * hexKeyLength\n        val hexKeySumLength25 = hexKeySumLength24 * hexKeyLength\n        val hexKeySumLength26 = hexKeySumLength25 * hexKeyLength\n        val hexKeySumLength27 = hexKeySumLength26\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphectjwe1.scala:31:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumLength\u001b[0m = hexKeySum.length\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value length is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphectjwe1.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0l){ (sum, digit) => sum + digit * digit}\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpepn70mi5.scala:31)\n\tat Problem.main(tmpepn70mi5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\")\n        val numsLength = nums.length\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.toLong\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength.to\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp94f3br4h.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp94f3br4h.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp94f3br4h.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp94f3br4h.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp94f3br4h.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35m",
      "stdout": "",
      "timestamp": 1659799320
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => if (x == 'A') 1L else if (x == 'B') 2L else if (x == 'C') 3L else if (x == 'D') 4L else if (x == 'E') 5L else if (x == 'F') 6L else 0L)\n        hexKey.sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjyqnjrfd.scala:31)\n\tat Problem.main(tmpjyqnjrfd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLength = hexKey.length\n        val hexKeyArray = hexKey.toArray\n        val hexKeyArrayLength = hexKeyArray.length\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hexKeyArrayLength\n        val hexKeyArrayLength = hex\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1kd4y3nx.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1kd4y3nx.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1kd4y3nx.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1kd4y3nx.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1kd4y3nx.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength\n\u001b[31m\u001b[3",
      "stdout": "",
      "timestamp": 1659799331
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\")\n        val numsCount = nums.length\n        val numsSum = nums.map(_.toInt).sum\n        val numsSum2 = numsSum * numsSum\n        val numsSum3 = numsSum2 * numsSum\n        val numsSum4 = numsSum3 * numsSum\n        val numsSum5 = numsSum4 * numsSum\n        val numsSum6 = numsSum5 * numsSum\n        val numsSum7 = numsSum6 * numsSum\n        val numsSum8 = numsSum7 * numsSum\n        val numsSum9 = numsSum8 * numsSum\n        val numsSum10 = numsSum9 * numsSum\n        val numsSum11 = numsSum10 * numsSum\n        val numsSum12 = numsSum11 * numsSum\n        val numsSum13 = numsSum12 * numsSum\n        val numsSum14 = numsSum13 * numsSum\n        val numsSum15 = numsSum14 * numsSum\n        val numsSum16 = numsSum15 * numsSum\n        val numsSum17 = numsSum16 * numsSum\n        val numsSum18 = numsSum17 * numsSum\n        val numsSum19 = numsSum18 * numsSum\n        val numsSum20 = numsSum19 * numsSum\n        val numsSum21 = numsSum20 * numsSum\n        val numsSum22 = numsSum21 * numsSum\n        val numsSum23 = numsSum22 * numsSum\n        val numsSum24 = numsSum23 * numsSum\n        val numsSum25 = numsSum24 * numsSum\n        val numsSum26 = numsSum25 * numsSum\n        val numsSum27 = numsSum26 * numsSum\n        val numsSum28 = numsSum27 * numsSum\n        val numsSum29 = numsSum28 * numsSum\n        val numsSum30 = numsSum29 * numsSum\n        val numsSum31 = numsSum30 * numsSum\n        val numsSum32 = numsSum31 * numsSum\n        \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzifp8er4.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799332
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexLen = hex.length\n        val hexKey = hex.foldLeft(0)((sum, digit) => sum + digit * Math.pow(16, hexLen - 1 - digit))\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8415eu3f.scala:28:53 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36msum\u001b[0m, \u001b[36mdigit\u001b[0m) => sum + digit * Math.pow(\u001b[31m16\u001b[0m, hexLen - \u001b[31m1\u001b[0m - digit))\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     Found:    Double\n\u001b[31m   |\u001b[0m                                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799331
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\")\n        val hex = nums.map(_.toInt)\n        val primes = hex.filter(_.isPrime)\n        primes.length\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpovdtt2e_.scala:28:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = hex.filter(_.isPrime)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isPrime is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799331
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.filter(_ >= '0' && _ <='9').length\n        val hexDigits = hex.filter(_ >= '0' && _ <='9').toList\n        val hexDigitCount = hexDigits.length\n        val hexDigitPrimes = hexDigits.filter(_ % 2 == 0).filter(_ > 1).filter(_ % 3 == 0).length\n        val hexDigitPrimeCount = hexDigitPrimes.length\n        val hexDigitPrimePrimes = hexDigitPrimes.filter(_ % 2 == 0).filter(_ > 1).filter(_ % 5 == 0).length\n        val hexDigitPrimePrimeCount = hexDigitPrimePrimes.length\n        val hexDigitPrimePrimePrimes = hexDigitPrimePrimes.filter(_ % 2 == 0).filter(_ > 1).filter(_ % 7 == 0).length\n        val hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter(_ % 2 == 0).filter(_ > 1).filter(_ % 11 == 0).length\n        val hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter(_ % 2 == 0).filter(_ > 1).filter(_ % 13 == 0).length\n        val hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimes.filter(_ % 2 == 0).filter(_ > 1).filter(_ % 17 == 0).length\n        val hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.filter(_ % 2 == 0).filter(_ > 1).filter(_ % 19 == 0).length\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePri\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp7pkrets2.scala:27:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <=\u001b[31m'9'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp7pkrets2.scala:28:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigits\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <=\u001b[31m'9'\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7pkrets2.scala:31:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimeCount\u001b[0m = hexDigitPrimes.length\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value length is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7pkrets2.scala:32:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimes\u001b[0m = hexDigitPrimes.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).filter(_ > \u001b[31m1\u001b[0m).filter(_ % \u001b[31m5\u001b[0m == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value filter is not a member of Int\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7pkrets2.scala:40:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimes.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).filter(_ > \u001b[31m1\u001b[0m).filter(_ % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m      Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimes\u001b[0m needs type\n\u001b[31m   ",
      "stdout": "",
      "timestamp": 1659799333
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = hex.filter(_ % 2 == 0).filter(_ % 3 == 0).filter(_ % 5 == 0).filter(_ % 7 == 0).filter(_ % 11 == 0).filter(_ % 13 == 0).filter(_ % 17 == 0).filter(_ % 19 == 0).filter(_ % 23 == 0).filter(_ % 29 == 0).filter(_ % 31 == 0).filter(_ % 37 == 0).filter(_ % 41 == 0).filter(_ % 43 == 0).filter(_ % 47 == 0).filter(_ % 53 == 0).filter(_ % 59 == 0).filter(_ % 61 == 0).filter(_ % 67 == 0).filter(_ % 71 == 0).filter(_ % 73 == 0).filter(_ % 79 == 0).filter(_ % 83 == 0).filter(_ % 89 == 0).filter(_ % 97 == 0).filter(_ % 101 == 0).filter(_ % 103 == 0).filter(_ % 107 == 0).filter(_ % 113 == 0).filter(_ % 127 == 0).filter(_ % 131 == 0).filter(_ % 137 == 0).filter(_ % 139 == 0).filter(_ % 143 == 0).filter(_ % 149 == 0).filter(_ % 151 == 0).filter(_ % 157 == 0).filter(_ % 163 == 0).filter(_ % 167 == 0).filter(_ % 173 == 0).filter(_ % 179 == 0).filter(_ % 181 == 0).filter(_ % 191 == 0).filter(_ % 193 == 0).filter(_ % 197 == 0).filter(_ % 199 == 0).filter(_ % 201 == 0).filter(_ % 207 == 0).filter(_ % 211 == 0).filter(_ % 213 == 0).filter(_ % 217 == 0).filter(_ % 221 == 0).filter(_ % 227 == 0).filter(_ % 229 == 0).filter(_ % 233 == 0).filter(_ % 239 == 0).filter(_ % 241 == 0).filter(_ % 247 == 0).filter(_ % 251 == 0).filter(_ % 257 == 0).filter(_ % 263 == 0).filter(_ % 269 == 0).filter(_ % 271 == 0).filter(_ % 277 == 0).filter(_ % 281 == 0).filter(_ % 283 == 0).filter(_ % 293 == 0).filter(_ % 307 == 0).filter(_ % 311 == 0).filter(_ % 313 == 0).filter(_ % 317 == 0).filter(_ % 321 == 0).filter(_ % 323 == 0).filter(_ % 327 == 0).filter(_ % 331 == 0).filter(_ % 337 == 0).filter(_ % 341 == 0).filter(_ % 347 == 0).filter(_ % 351 == 0).filter(_ % 357 == 0).filter(_ % 363 == 0).filter(_ % 369 == 0).filter(_ % 37\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmph_y4cb7w.scala:28:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph_y4cb7w.scala:27:1725 ------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = hex.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m3\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m5\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m7\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m11\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m13\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m19\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m23\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m29\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m31\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m37\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m41\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m43\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m47\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m53\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m59\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m61\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m67\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m71\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m73\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m79\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m83\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m89\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m97\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m101\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m103\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m107\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m113\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m127\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m131\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m137\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m139\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m143\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m149\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m151\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m157\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m163\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m167\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m173\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m179\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m181\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m191\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m193\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31",
      "stdout": "",
      "timestamp": 1659799333
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\").map(_.toInt)\n        val primes = nums.filter(_ % 2 == 0).filter(_ % 3 == 0).filter(_ % 5 == 0)\n        val primesCount = primes.length\n        val hexDigits = nums.filter(_ % 2 == 0).filter(_ % 3 == 0).filter(_ % 5 == 0).filter(_ % 7 == 0).filter(_ % 11 == 0).filter(_ % 13 == 0).filter(_ % 17 == 0).filter(_ % 19 == 0).filter(_ % 23 == 0).filter(_ % 29 == 0).filter(_ % 31 == 0).filter(_ % 37 == 0).filter(_ % 41 == 0).filter(_ % 43 == 0).filter(_ % 47 == 0).filter(_ % 53 == 0).filter(_ % 59 == 0).filter(_ % 61 == 0).filter(_ % 67 == 0).filter(_ % 71 == 0).filter(_ % 73 == 0).filter(_ % 79 == 0).filter(_ % 83 == 0).filter(_ % 89 == 0).filter(_ % 97 == 0).filter(_ % 101 == 0).filter(_ % 103 == 0).filter(_ % 107 == 0).filter(_ % 113 == 0).filter(_ % 127 == 0).filter(_ % 131 == 0).filter(_ % 137 == 0).filter(_ % 143 == 0).filter(_ % 149 == 0).filter(_ % 151 == 0).filter(_ % 157 == 0).filter(_ % 163 == 0).filter(_ % 169 == 0).filter(_ % 173 == 0).filter(_ % 179 == 0).filter(_ % 181 == 0).filter(_ % 191 == 0).filter(_ % 193 == 0).filter(_ % 197 == 0).filter(_ % 199 == 0).filter(_ % 211 == 0).filter(_ % 213 == 0).filter(_ % 217 == 0).filter(_ % 221 == 0).filter(_ % 227 == 0).filter(_ % 229 == 0).filter(_ % 233 == 0).filter(_ % 239 == 0).filter(_ % 241 == 0).filter(_ % 251 == 0).filter(_ % 257 == 0).filter(_ % 263 == 0).filter(_ % 269 == 0).filter(_ % 271 == 0).filter(_ % 277 == 0).filter(_ % 281 == 0).filter(_ % 283 == 0).filter(_ % 293 == 0).filter(_ % 307 == 0).filter(_ % 311 == 0).filter(_ % 313 == 0).filter(_ % 317 == 0).filter(_ % 321 == 0).filter(_ % 323 == 0).filter(_ % 327 == 0).filter(_ % 331 == 0).filter(_ % 337 == 0).filter(_ % 341 == 0).filter(_ % 347 == 0).filter(_ % 351 == 0).filter(_ % 357 == 0).filter(_ % \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpfrd1dag5.scala:29:1606 -------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigits\u001b[0m = nums.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m3\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m5\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m7\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m11\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m13\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m19\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m23\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m29\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m31\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m37\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m41\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m43\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m47\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m53\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m59\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m61\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m67\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m71\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m73\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m79\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m83\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m89\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m97\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m101\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m103\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m107\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m113\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m127\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m131\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m137\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m143\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m149\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m151\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m157\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m163\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m169\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m173\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m179\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m181\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m191\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m193\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m197\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m199\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m211\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m213\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m217\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m221\u001b[0m == \u001b[31m0\u001b[0m).filter(",
      "stdout": "",
      "timestamp": 1659799334
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.foldLeft(0l) { (sum, digit) => sum + digit * digit(0) }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_7iirkj6.scala:27:70 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.foldLeft(\u001b[31m0l\u001b[0m) { (\u001b[36msum\u001b[0m, \u001b[36mdigit\u001b[0m) => sum + digit * digit(\u001b[31m0\u001b[0m) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                \u001b[33mparameter\u001b[0m \u001b[35mdigit\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799328
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyList = hexKey.toList\n        val hexKeyListLength = hexKeyList.size\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m =",
      "stdout": "",
      "timestamp": 1659799320
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.filter(_ >= '0' && _ <= '9').length\n        val hexKey2 = hex.filter(_ >= 'A' && _ <= 'F').length\n        val hexKey3 = hex.filter(_ >= 'a' && _ <= 'f').length\n        hexKey + (hexKey2 * 2) + (hexKey3 * 3)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp998e2rpr.scala:27:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <= \u001b[31m'9'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp998e2rpr.scala:28:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey2\u001b[0m = hex.filter(_ >= \u001b[31m'A'\u001b[0m && _ <= \u001b[31m'F'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp998e2rpr.scala:29:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey3\u001b[0m = hex.filter(_ >= \u001b[31m'a'\u001b[0m && _ <= \u001b[31m'f'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659799329
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => if (x == 'A') 1 else if (x == 'B') 2 else if (x == 'C') 3 else if (x == 'D') 4 else if (x == 'E') 5 else if (x == 'F') 6 else 0).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0jsovlvy.scala:31)\n\tat Problem.main(tmp0jsovlvy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\")\n        val numsLen = nums.length\n        val numsLen2 = numsLen * numsLen\n        val numsLen3 = numsLen2 * numsLen\n        val numsLen4 = numsLen3 * numsLen\n        val numsLen5 = numsLen4 * numsLen\n        val numsLen6 = numsLen5 * numsLen\n        val numsLen7 = numsLen6 * numsLen\n        val numsLen8 = numsLen7 * numsLen\n        val numsLen9 = numsLen8 * numsLen\n        val numsLen10 = numsLen9 * numsLen\n        val numsLen11 = numsLen10 * numsLen\n        val numsLen12 = numsLen11 * numsLen\n        val numsLen13 = numsLen12 * numsLen\n        val numsLen14 = numsLen13 * numsLen\n        val numsLen15 = numsLen14 * numsLen\n        val numsLen16 = numsLen15 * numsLen\n        val numsLen17 = numsLen16 * numsLen\n        val numsLen18 = numsLen17 * numsLen\n        val numsLen19 = numsLen18 * numsLen\n        val numsLen20 = numsLen19 * numsLen\n        val numsLen21 = numsLen20 * numsLen\n        val numsLen22 = numsLen21 * numsLen\n        val numsLen23 = numsLen22 * numsLen\n        val numsLen24 = numsLen23 * numsLen\n        val numsLen25 = numsLen24 * numsLen\n        val numsLen26 = numsLen25 * numsLen\n        val numsLen27 = numsLen26 * numsLen\n        val numsLen28 = numsLen27 * numsLen\n        val numsLen29 = numsLen28 * numsLen\n        val numsLen30 = numsLen29 * numsLen\n        val numsLen31 = numsLen30 * numsLen\n        val numsLen32 = numsLen31 * numsLen\n        val numsLen33 = numsLen32 * numsLen\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt3txrp5f.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799333
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.map(x => math.pow(16, x))\n        val hexKeySum = hexKey.sum\n        val hexKeySumInt = math.pow(16, hexKeySum)\n        val hexKeySumIntInt = math.pow(16, hexKeySumInt)\n        val hexKeySumIntIntInt = math.pow(16, hexKeySumIntInt)\n        val hexKeySumIntIntIntInt = math.pow(16, hexKeySumIntIntInt)\n        val hexKeySumIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntInt)\n        val hexKeySumIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntIntIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.pow(16, hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntInt\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplti3dfao.scala:45:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplti3dfao.scala:36:61 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumIntIntIntIntIntIntIntInt\u001b[0m = math.pow(\u001b[31m16\u001b[0m, hexKeySumIntIntIntIntIntIntIntInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m            Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKeySumIntIntIntIntIntIntIntInt\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplti3dfao.scala:42:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntInt\u001b[0m = math.pow(\u001b[31m16\u001b[0m, hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m Not found: hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplti3dfao.scala:41:76 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumIntIntIntIntIntIntIntIntIntIntIntIntInt\u001b[0m = math.pow(\u001b[31m16\u001b[0m, hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    Not found: hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplti3dfao.scala:43:82 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33m",
      "stdout": "",
      "timestamp": 1659799333
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexKey = hex.filter(_ % 2 == 0).filter(_ % 3 == 0).filter(_ % 5 == 0).filter(_ % 7 == 0).filter(_ % 11 == 0).filter(_ % 13 == 0).filter(_ % 17 == 0).filter(_ % 19 == 0).filter(_ % 23 == 0).filter(_ % 29 == 0).filter(_ % 31 == 0).filter(_ % 37 == 0).filter(_ % 41 == 0).filter(_ % 43 == 0).filter(_ % 47 == 0).filter(_ % 53 == 0).filter(_ % 59 == 0).filter(_ % 61 == 0).filter(_ % 67 == 0).filter(_ % 71 == 0).filter(_ % 73 == 0).filter(_ % 79 == 0).filter(_ % 83 == 0).filter(_ % 89 == 0).filter(_ % 97 == 0).filter(_ % 101 == 0).filter(_ % 103 == 0).filter(_ % 107 == 0).filter(_ % 113 == 0).filter(_ % 127 == 0).filter(_ % 131 == 0).filter(_ % 137 == 0).filter(_ % 143 == 0).filter(_ % 149 == 0).filter(_ % 151 == 0).filter(_ % 157 == 0).filter(_ % 163 == 0).filter(_ % 169 == 0).filter(_ % 171 == 0).filter(_ % 177 == 0).filter(_ % 183 == 0).filter(_ % 191 == 0).filter(_ % 197 == 0).filter(_ % 203 == 0).filter(_ % 209 == 0).filter(_ % 211 == 0).filter(_ % 217 == 0).filter(_ % 223 == 0).filter(_ % 229 == 0).filter(_ % 233 == 0).filter(_ % 239 == 0).filter(_ % 241 == 0).filter(_ % 247 == 0).filter(_ % 253 == 0).filter(_ % 259 == 0).filter(_ % 261 == 0).filter(_ % 267 == 0).filter(_ % 273 == 0).filter(_ % 279 == 0).filter(_ % 281 == 0).filter(_ % 283 == 0).filter(_ % 293 == 0).filter(_ % 307 == 0).filter(_ % 311 == 0).filter(_ % 317 == 0).filter(_ % 323 == 0).filter(_ % 329 == 0).filter(_ % 331 == 0).filter(_ % 337 == 0).filter(_ % 343 == 0).filter(_ % 349 == 0).filter(_ % 351 == 0).filter(_ % 357 == 0).filter(_ % 363 == 0).filter(_ % 369 == 0).filter(_ % 371 == 0).filter(_ % 377 == 0).filter(_ % 383 == 0).filter(_ % 389 == 0).filter(_ % 391 == 0).filter(_ % 397 == 0).filter(_ % 403 == 0).filter(_ % 409\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjoyr_pts.scala:28:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjoyr_pts.scala:27:1725 ------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m3\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m5\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m7\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m11\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m13\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m19\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m23\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m29\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m31\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m37\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m41\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m43\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m47\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m53\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m59\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m61\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m67\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m71\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m73\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m79\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m83\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m89\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m97\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m101\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m103\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m107\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m113\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m127\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m131\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m137\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m143\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m149\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m151\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m157\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m163\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m169\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m171\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m177\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m183\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m191\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m197\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m203\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.foldLeft(0L){\n            (acc, c) =>\n                val hexDigit = c.toLong\n                val hexDigitCount = hexDigit / 16\n                val hexDigitRemainder = hexDigit % 16\n                val hexDigitCount = hexDigitCount * 16\n                val hexDigitRemainder = hexDigitRemainder * 16\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toInt\n                val hexDigitRemainder = hexDigitRemainder.toInt\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toLong\n                val hexDigitRemainder = hexDigitRemainder.toLong\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toInt\n                val hexDigitRemainder = hexDigitRemainder.toInt\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toLong\n                val hexDigitRemainder = hexDigitRemainder.toLong\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toInt\n                val hexDigitRemainder = hexDigitRemainder.toInt\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toLong\n                val hexDigitRemainder = hexDigitRemainder.toLong\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toInt\n                val hexDigitRemainder = hexDigitRemainder.toInt\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toLong\n                val hexDigitRemainder = hexDigitRemainder.toLong\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toInt\n                val hexDigitRemainder = hexDigitRemainder.toInt\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toLong\n                val hexDigitRemainder = hexDigitRemainder.toLong\n                val hexDigitCount = hexDigitCount + hexDigitRemainder\n                val hexDigitCount = hexDigitCount.toInt\n                val hexDigitRemainder = hexDigitRemainder.to\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqzwvcabf.scala:78:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqzwvcabf.scala:32:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigitCount * \u001b[31m16\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqzwvcabf.scala:33:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitRemainder\u001b[0m = hexDigitRemainder * \u001b[31m16\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitRemainder is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitRemainder\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqzwvcabf.scala:34:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigitCount + hexDigitRemainder\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqzwvcabf.scala:35:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigitCount.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloade",
      "stdout": "",
      "timestamp": 1659799334
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyList = hexKey.toList\n        val hexKeyList2 = hexKeyList.map(x => x.toLong)\n        val hexKeyList3 = hexKeyList2.map(x => x.toLong)\n        val hexKeyList4 = hexKeyList3.map(x => x.toLong)\n        val hexKeyList5 = hexKeyList4.map(x => x.toLong)\n        val hexKeyList6 = hexKeyList5.map(x => x.toLong)\n        val hexKeyList7 = hexKeyList6.map(x => x.toLong)\n        val hexKeyList8 = hexKeyList7.map(x => x.toLong)\n        val hexKeyList9 = hexKeyList8.map(x => x.toLong)\n        val hexKeyList10 = hexKeyList9.map(x => x.toLong)\n        val hexKeyList11 = hexKeyList10.map(x => x.toLong)\n        val hexKeyList12 = hexKeyList11.map(x => x.toLong)\n        val hexKeyList13 = hexKeyList12.map(x => x.toLong)\n        val hexKeyList14 = hexKeyList13.map(x => x.toLong)\n        val hexKeyList15 = hexKeyList14.map(x => x.toLong)\n        val hexKeyList16 = hexKeyList15.map(x => x.toLong)\n        val hexKeyList17 = hexKeyList16.map(x => x.toLong)\n        val hexKeyList18 = hexKeyList17.map(x => x.toLong)\n        val hexKeyList19 = hexKeyList18.map(x => x.toLong)\n        val hexKeyList20 = hexKeyList19.map(x => x.toLong)\n        val hexKeyList21 = hexKeyList20.map(x => x.toLong)\n        val hexKeyList22 = hexKeyList21.map(x => x.toLong)\n        val hexKeyList23 = hexKeyList22.map(x => x.toLong)\n        val hexKeyList24 = hexKeyList23.map(x => x.toLong)\n        val hexKeyList25 = hexKeyList24.map(x => x.toLong)\n        val hexKeyList26 = hexKeyList25.map(x => x.toLong)\n        val hexKeyList27 = hexKeyList26.map(x => x.to\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxdgjqjdm.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpxdgjqjdm.scala:54:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyList27\u001b[0m = hexKeyList26.map(\u001b[36mx\u001b[0m => x.to\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mto\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIntegralProxy\u001b[0m with types\n\u001b[31m   |\u001b[0m (end: Long, step: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m   |\u001b[0m (end: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m   |\u001b[0mboth match expected type B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxdgjqjdm.scala:55:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659799334
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexKey = hexCount.toLong\n        val hexKeyList = hexKey.toList\n        val hexKeyList2 = hexKeyList.map(x => x.toLong)\n        val hexKeyList3 = hexKeyList2.map(x => x.toLong)\n        val hexKeyList4 = hexKeyList3.map(x => x.toLong)\n        val hexKeyList5 = hexKeyList4.map(x => x.toLong)\n        val hexKeyList6 = hexKeyList5.map(x => x.toLong)\n        val hexKeyList7 = hexKeyList6.map(x => x.toLong)\n        val hexKeyList8 = hexKeyList7.map(x => x.toLong)\n        val hexKeyList9 = hexKeyList8.map(x => x.toLong)\n        val hexKeyList10 = hexKeyList9.map(x => x.toLong)\n        val hexKeyList11 = hexKeyList10.map(x => x.toLong)\n        val hexKeyList12 = hexKeyList11.map(x => x.toLong)\n        val hexKeyList13 = hexKeyList12.map(x => x.toLong)\n        val hexKeyList14 = hexKeyList13.map(x => x.toLong)\n        val hexKeyList15 = hexKeyList14.map(x => x.toLong)\n        val hexKeyList16 = hexKeyList15.map(x => x.toLong)\n        val hexKeyList17 = hexKeyList16.map(x => x.toLong)\n        val hexKeyList18 = hexKeyList17.map(x => x.toLong)\n        val hexKeyList19 = hexKeyList18.map(x => x.toLong)\n        val hexKeyList20 = hexKeyList19.map(x => x.toLong)\n        val hexKeyList21 = hexKeyList20.map(x => x.toLong)\n        val hexKeyList22 = hexKeyList21.map(x => x.toLong)\n        val hexKeyList23 = hexKeyList22.map(x => x.toLong)\n        val hexKeyList24 = hexKeyList23.map(x => x.toLong)\n        val hexKeyList25 = hexKeyList24.map(x => x.toLong)\n        val hexKeyList26 = hexKeyList25.map(x => x.toLong)\n        val hexKeyList27 = hexKeyList26.map(x \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpr1mlmibx.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr1mlmibx.scala:29:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyList\u001b[0m = hexKey.toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value toList is not a member of Long - did you mean hexKey.toInt?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr1mlmibx.scala:56:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.map(x => x % 16).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"A\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$1(tmpcqjsxs12.scala:26)\n\tat Problem$.$anonfun$adapted$1(tmpcqjsxs12.scala:26)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:934)\n\tat Problem$.hexKey(tmpcqjsxs12.scala:26)\n\tat Problem$.main(tmpcqjsxs12.scala:31)\n\tat Problem.main(tmpcqjsxs12.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799336
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexLen = hex.length\n        val hexKey = new mutable.HashMap[Int, Long]()\n        val primes = mutable.ArrayBuffer(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val primesLen = primes.length\n        val primesSet = primes.toSet\n        val primesSetLen = primesSet.length\n        val primesSetSet = primesSet.toSet\n        val primesSetSetLen = primesSetSet.length\n        val primesSetSetSet = primesSetSet.toSet\n        val primesSetSetSetLen = primesSetSetSet.length\n        val primesSetSetSetSet = primesSetSetSet.toSet\n        val primesSetSetSetSetLen = primesSetSetSetSet.length\n        val primesSetSetSetSetSet = primesSetSetSetSet.toSet\n        val primesSetSetSetSetSetLen = primesSetSetSetSetSet.length\n        val primesSetSetSetSetSetSet = primesSetSetSetSetSet.toSet\n        val primesSetSetSetSetSetSetLen = primesSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSet = primesSetSetSetSetSetSet.toSet\n        val primesSetSetSetSetSetSetSetLen = primesSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSet = primesSetSetSetSetSetSetSet.toSet\n        val primesSetSetSetSetSetSetSetSetLen = primesSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSet = primesSetSetSetSetSetSetSetSetSet.toSet\n        val primesSetSetSetSetSetSetSetSetSetLen = primesSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSet = primesSetSetSetSetSetSetSetSetSetSet.toSet\n        val primesSetSetSetSetSetSetSetSetSetSetLen = primesSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSet\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk6f57vjb.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk6f57vjb.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk6f57vjb.scala:29:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.ArrayBuffer(\u001b[31m2\u001b[0m, \u001b[31m3\u001b[0m, \u001b[31m5\u001b[0m, \u001b[31m7\u001b[0m, \u001b[31m11\u001b[0m, \u001b[31m13\u001b[0m, \u001b[31m17\u001b[0m, \u001b[31m19\u001b[0m, \u001b[31m23\u001b[0m, \u001b[31m29\u001b[0m, \u001b[31m31\u001b[0m, \u001b[31m37\u001b[0m, \u001b[31m41\u001b[0m, \u001b[31m43\u001b[0m, \u001b[31m47\u001b[0m, \u001b[31m53\u001b[0m, \u001b[31m59\u001b[0m, \u001b[31m61\u001b[0m, \u001b[31m67\u001b[0m, \u001b[31m71\u001b[0m, \u001b[31m73\u001b[0m, \u001b[31m79\u001b[0m, \u001b[31m83\u001b[0m, \u001b[31m89\u001b[0m, \u001b[31m97\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpk6f57vjb.scala:47:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetSet\u001b[0m = primesSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m            Recursive \u001b[33mvalue\u001b[0m \u001b[35mprimesSetSetSetSetSetSetSetSetSet\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpk6f57vjb.scala:49:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetSetSet\u001b[0m = primesSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                      ",
      "stdout": "",
      "timestamp": 1659799333
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexDigits = hexString.toList\n        val hexDigitCount = hexDigits.size\n        val hexDigitMap = hexDigits.groupBy(x => x)\n        val hexDigitMapCount = hexDigitMap.size\n        val hexDigitMapKeys = hexDigitMap.keys.toList\n        val hexDigitMapValues = hexDigitMap.toList\n        val hexDigitMapValuesCount = hexDigitMapValues.size\n        val hexDigitMapValuesKeys = hexDigitMapValues.keys.toList\n        val hexDigitMapValuesValues = hexDigitMapValues.toList\n        val hexDigitMapValuesValuesCount = hexDigitMapValuesValues.size\n        val hexDigitMapValuesValuesKeys = hexDigitMapValuesValues.keys.toList\n        val hexDigitMapValuesValuesValues = hexDigitMapValuesValues.toList\n        val hexDigitMapValuesValuesValuesCount = hexDigitMapValuesValuesValues.size\n        val hexDigitMapValuesValuesValuesKeys = hexDigitMapValuesValuesValues.keys.toList\n        val hexDigitMapValuesValuesValuesValues = hexDigitMapValuesValuesValues.toList\n        val hexDigitMapValuesValuesValuesValuesCount = hexDigitMapValuesValuesValuesValues.size\n        val hexDigitMapValuesValuesValuesValuesKeys = hexDigitMapValuesValuesValuesValues.keys.toList\n        val hexDigitMapValuesValuesValuesValuesValues = hexDigitMapValuesValuesValuesValues.toList\n        val hexDigitMapValuesValuesValuesValuesValuesCount = hexDigitMapValuesValuesValuesValuesValues.size\n        val hexDigitMapValuesValuesValuesValuesValuesKeys = hexDigitMapValuesValuesValuesValuesValues.keys.toList\n        val hexDigitMapValuesValuesValuesValuesValuesValues = hexDigitMapValuesValuesValuesValuesValues.toList\n        val hexDigitMapValuesValuesValuesValuesValuesValuesCount = hexDigitMapValuesValuesValuesValuesValuesValuesValues.size\n        val hexDigitMapValuesValuesValuesValuesValuesValuesKeys = hexDigitMapValuesValuesValuesValuesValuesValuesValues.keys.toList\n        val hexDigitMapValuesValuesValuesValuesValuesValuesValues = hexDigitMapValuesValuesValuesValuesValuesValuesValuesValues.toList\n        val hexDigitMapValuesValuesValuesValuesValuesValuesValuesCount = hexDigitMapValuesValuesValuesValuesValuesValuesValuesValuesValues.size\n        val hexDigitMapValuesValuesValuesValuesValuesValuesValuesKeys = hexDigitMapValuesValuesValues\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsmdv021y.scala:35:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMapValuesKeys\u001b[0m = hexDigitMapValues.keys.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue keys is not a member of List[(Char, List[Char])] - did you mean hexDigitMapValues.head?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsmdv021y.scala:38:66 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMapValuesValuesKeys\u001b[0m = hexDigitMapValuesValues.keys.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue keys is not a member of List[(Char, List[Char])] - did you mean hexDigitMapValuesValues.head?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsmdv021y.scala:41:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMapValuesValuesValuesKeys\u001b[0m = hexDigitMapValuesValuesValues.keys.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue keys is not a member of List[(Char, List[Char])] - did you mean hexDigitMapValuesValuesValues.head?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsmdv021y.scala:44:90 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMapValuesValuesValuesValuesKeys\u001b[0m = hexDigitMapValuesValuesValuesValues.keys.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue keys is not a member of List[(Char, List[Char])] - did you mean hexDigitMapValuesValuesValuesValues.head?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsmdv021y.scala:47:102 -----------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMapValuesValuesValuesValuesValuesKeys\u001b[0m = hexDigitMapValuesValuesValuesValuesValues.keys.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexDigits = hexCount / 2\n        val hexDigitPrimes = hexDigits.toSet\n        val hexDigitPrimeCount = hexDigitPrimes.size\n        val hexDigitPrimePrimes = hexDigitPrimes.toSet\n        val hexDigitPrimePrimeCount = hexDigitPrimePrimes.size\n        val hexDigitPrimePrimePrimes = hexDigitPrimePrimes.toSet\n        val hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.size\n        val hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.toSet\n        val hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.size\n        val hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.toSet\n        val hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.size\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimes.toSet\n        val hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimes.size\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.toSet\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.size\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.toSet\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.size\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePri\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4fmf97xg.scala:29:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimes\u001b[0m = hexDigits.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value toSet is not a member of Int - did you mean hexDigits.toInt?\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4fmf97xg.scala:39:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimes.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m      Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4fmf97xg.scala:41:59 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimes.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4fmf97xg.scala:43:64 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       Not found: hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4fmf97xg.scala:45:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[",
      "stdout": "",
      "timestamp": 1659799334
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\").toList\n        val hex = nums.map(_.toInt)\n        val hexList = hex.toList\n        val hexKey = hexList.count(_ % 2 == 0)\n        val hexKey2 = hexList.count(_ % 3 == 0)\n        val hexKey3 = hexList.count(_ % 5 == 0)\n        val hexKey4 = hexList.count(_ % 7 == 0)\n        val hexKey5 = hexList.count(_ % 11 == 0)\n        val hexKey6 = hexList.count(_ % 13 == 0)\n        val hexKey7 = hexList.count(_ % 17 == 0)\n        val hexKey8 = hexList.count(_ % 19 == 0)\n        val hexKey9 = hexList.count(_ % 23 == 0)\n        val hexKey10 = hexList.count(_ % 29 == 0)\n        val hexKey11 = hexList.count(_ % 31 == 0)\n        val hexKey12 = hexList.count(_ % 37 == 0)\n        val hexKey13 = hexList.count(_ % 41 == 0)\n        val hexKey14 = hexList.count(_ % 43 == 0)\n        val hexKey15 = hexList.count(_ % 47 == 0)\n        val hexKey16 = hexList.count(_ % 53 == 0)\n        val hexKey17 = hexList.count(_ % 59 == 0)\n        val hexKey18 = hexList.count(_ % 61 == 0)\n        val hexKey19 = hexList.count(_ % 67 == 0)\n        val hexKey20 = hexList.count(_ % 71 == 0)\n        val hexKey21 = hexList.count(_ % 79 == 0)\n        val hexKey22 = hexList.count(_ % 83 == 0)\n        val hexKey23 = hexList.count(_ % 89 == 0)\n        val hexKey24 = hexList.count(_ % 97 == 0)\n        val hexKey25 = hexList.count(_ % 101 == 0)\n        val hexKey26 = hexList.count(_ % 103 == 0)\n        val hexKey27 = hexList.count(_ % 107 == 0)\n        val hexKey28 = hexList.count(_ % 111 == 0)\n        val hexKey29 = hexList.count(_ % 113 == 0)\n        val hexKey30 = hexList.count(_ % 117 == 0)\n        val hexKey31 = hexList.count(_ % 121 == 0)\n        val hexKey32 = hexList.count(_ % 123 == 0)\n        val hexKey33 = hexList.count(_ % 127 == 0)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5bjdurkx.scala:63:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799334
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => if (x == 'A') 1 else 0)\n        val hexKey2 = hexKey.map(x => if (x == 2) 1 else 0)\n        val hexKey3 = hexKey2.map(x => if (x == 3) 1 else 0)\n        val hexKey4 = hexKey3.map(x => if (x == 5) 1 else 0)\n        val hexKey5 = hexKey4.map(x => if (x == 7) 1 else 0)\n        val hexKey6 = hexKey5.map(x => if (x == 11) 1 else 0)\n        val hexKey7 = hexKey6.map(x => if (x == 13) 1 else 0)\n        val hexKey8 = hexKey7.map(x => if (x == 17) 1 else 0)\n        val hexKey9 = hexKey8.map(x => if (x == 19) 1 else 0)\n        val hexKey10 = hexKey9.map(x => if (x == 23) 1 else 0)\n        val hexKey11 = hexKey10.map(x => if (x == 29) 1 else 0)\n        val hexKey12 = hexKey11.map(x => if (x == 31) 1 else 0)\n        val hexKey13 = hexKey12.map(x => if (x == 33) 1 else 0)\n        val hexKey14 = hexKey13.map(x => if (x == 35) 1 else 0)\n        val hexKey15 = hexKey14.map(x => if (x == 37) 1 else 0)\n        val hexKey16 = hexKey15.map(x => if (x == 39) 1 else 0)\n        val hexKey17 = hexKey16.map(x => if (x == 43) 1 else 0)\n        val hexKey18 = hexKey17.map(x => if (x == 47) 1 else 0)\n        val hexKey19 = hexKey18.map(x => if (x == 51) 1 else 0)\n        val hexKey20 = hexKey19.map(x => if (x == 59) 1 else 0)\n        val hexKey21 = hexKey20.map(x => if (x == 71) 1 else 0)\n        val hexKey22 = hexKey21.map(x => if (x == 79) 1 else 0)\n        val hexKey23 = hexKey22.map(x => if (x == 91) 1 else 0)\n        val hexKey24 = hexKey23.map(x => if (x == 97) 1 else 0)\n        val hexKey25 = hexKey24.map(x => if (x == 101) 1 else 0)\n        val hexKey26 = hexKey25.map(x => if (x == 103) 1 else 0)\n        val hexKey27 = hexKey26.map(x => if (x == 105) 1 else 0)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9690e9hd.scala:55:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\")\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet34\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa_h9vlln.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_h9vlln.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_h9vlln.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_h9vlln.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_h9vlln.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_h9vlln.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799340
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(x => x.toInt)\n        val hexMap = hex.map(x => (x % 16).toChar).map(x => (x -> 1)).toMap\n        val hexKeys = hex.map(x => hexMap.getOrElse(x, 0)).sum\n        hexKeys\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfbgtsqrd.scala:28:52 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeys\u001b[0m = hex.map(\u001b[36mx\u001b[0m => hexMap.getOrElse(x, \u001b[31m0\u001b[0m)).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Int)\n\u001b[31m   |\u001b[0m                                                    Required: Char\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799341
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLen = hexKey.length\n        val hexKeyList = hexKey.toList\n        val hexKeyListLen = hexKeyList.length\n        val hexKeyList2 = hexKeyList.zipWithIndex.filter(_._1 == 0).map(_._2)\n        val hexKeyListLen2 = hexKeyList2.length\n        val hexKeyList3 = hexKeyList2.zipWithIndex.filter(_._1 == 1).map(_._2)\n        val hexKeyListLen3 = hexKeyList3.length\n        val hexKeyList4 = hexKeyList3.zipWithIndex.filter(_._1 == 2).map(_._2)\n        val hexKeyListLen4 = hexKeyList4.length\n        val hexKeyList5 = hexKeyList4.zipWithIndex.filter(_._1 == 3).map(_._2)\n        val hexKeyListLen5 = hexKeyList5.length\n        val hexKeyList6 = hexKeyList5.zipWithIndex.filter(_._1 == 4).map(_._2)\n        val hexKeyListLen6 = hexKeyList6.length\n        val hexKeyList7 = hexKeyList6.zipWithIndex.filter(_._1 == 5).map(_._2)\n        val hexKeyListLen7 = hexKeyList7.length\n        val hexKeyList8 = hexKeyList7.zipWithIndex.filter(_._1 == 6).map(_._2)\n        val hexKeyListLen8 = hexKeyList8.length\n        val hexKeyList9 = hexKeyList8.zipWithIndex.filter(_._1 == 7).map(_._2)\n        val hexKeyListLen9 = hexKeyList9.length\n        val hexKeyList10 = hexKeyList9.zipWithIndex.filter(_._1 == 8).map(_._2)\n        val hexKeyListLen10 = hexKeyList10.length\n        val hexKeyList11 = hexKeyList10.zipWithIndex.filter(_._1 == 9).map(_._2)\n        val hexKeyListLen11 = hexKeyList11.length\n        val hexKeyList12 = hexKeyList11.zipWithIndex.filter(_._1 == 10).map(_._2)\n        val hexKeyListLen12 = hexKeyList12.length\n        val hexKeyList13 = hexKeyList12.zipWithIndex.filter(_._1 == 11).map(_._2)\n        val hexKeyListLen13 = hexKeyList13.length\n        val hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6h50seqn.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6h50seqn.scala:56:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799342
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKeyCount = new mutable.HashMap[Int, Int]()\n        val hexKeyCount2 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount3 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount4 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount5 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount6 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount7 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount8 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount9 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount10 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount11 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount12 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount13 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount14 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount15 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount16 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount17 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount18 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount19 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount20 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount21 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount22 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount23 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount24 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount25 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount26 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount27 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount28 = new mutable.HashMap[Int, Int]()\n        val hexKeyCount\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfxu3ysw2.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfxu3ysw2.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfxu3ysw2.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyCount\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfxu3ysw2.scala:30:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyCount2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfxu3ysw2.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyCount3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfxu3ysw2.scala:32:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyCount4\u001b[0m = \u001b[33mnew\u001b",
      "stdout": "",
      "timestamp": 1659799343
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val prime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpviixudjt.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799343
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.map(x => x % 16).filter(_ > 0).count(_ == 2)\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"A\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$1(tmpvp84qt_w.scala:26)\n\tat Problem$.$anonfun$adapted$1(tmpvp84qt_w.scala:26)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:934)\n\tat Problem$.hexKey(tmpvp84qt_w.scala:26)\n\tat Problem$.main(tmpvp84qt_w.scala:31)\n\tat Problem.main(tmpvp84qt_w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799345
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = new mutable.HashMap[Int, Int]()\n        hex.foreach(x => {\n            val hexDigit = x.toInt\n            if (hexKey.contains(hexDigit)) {\n                hexKey.update(hexDigit, hexKey.get(hexDigit) + 1)\n            } else {\n                hexKey.put(hexDigit, 1)\n            }\n        })\n        hexKey.values.sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymv71gwf.scala:27:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799341
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0l) { (sum, digit) => sum + digit * digit }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3doqkvqj.scala:31)\n\tat Problem.main(tmp3doqkvqj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexDigits = hex.map(x => x.toInt)\n        val hexDigitCount = hexDigits.length\n        val hexDigitPrimes = hexDigits.filter(x => x % 2 == 0)\n        val hexDigitPrimeCount = hexDigitPrimes.length\n        val hexDigitPrimePrimes = hexDigitPrimes.filter(x => x % 3 == 0)\n        val hexDigitPrimePrimeCount = hexDigitPrimePrimes.length\n        val hexDigitPrimePrimePrimes = hexDigitPrimePrimes.filter(x => x % 5 == 0)\n        val hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter(x => x % 7 == 0)\n        val hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter(x => x % 11 == 0)\n        val hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter(x => x % 13 == 0)\n        val hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimes.filter(x => x % 17 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter(x => x % 19 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.length\n        val hexDigit\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9zf3pnjr.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9zf3pnjr.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimeCount\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimes.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitPrimePrimePrimePrimePrimeCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimeCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9zf3pnjr.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimes.filter(\u001b[36mx\u001b[0m => x % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitPrimePrimePrimePrimePrimePrimes is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimes\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9zf3pnjr.scala:44:59 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter(\u001b[36mx\u001b[0m => x % \u001b[31m19\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E",
      "stdout": "",
      "timestamp": 1659799345
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexKey = hex.foldLeft(0l){ (sum, digit) => sum + digit * digit }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm362wo1a.scala:31)\n\tat Problem.main(tmpm362wo1a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexList = hex.toList\n        val hexListLength = hexList.length\n        val hexListLength = hexListLength.toLong\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n        val hexListLength = hexListLength.toInt\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt1r7i1_w.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexListLength\u001b[0m = hexListLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt1r7i1_w.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexListLength\u001b[0m = hexListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt1r7i1_w.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexListLength\u001b[0m = hexListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt1r7i1_w.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexListLength\u001b[0m = hexListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt1r7i1_w.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexListLength\u001b[0m = hexListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659799344
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKey.length\n        val hex\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp651vigye.scala:83:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp651vigye.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKey.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp651vigye.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKey.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp651vigye.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKey.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp651vigye.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKey.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp651vigye.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b",
      "stdout": "",
      "timestamp": 1659799345
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexCount = hex.count(_ % 2 == 0)\n        val hexDigits = hex.count(_ % 2 == 0)\n        val hexDigitPrimes = hexDigits.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimes = hexDigitPrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimes = hexDigitPrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter(_ % 2 == 0).count(_ % 2 == 0)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes = hex\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvcnbkqk.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).count(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitPrimePrimePrimePrimePrimePrimePrimePrimes is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmvcnbkqk.scala:29:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimes\u001b[0m = hexDigits.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).count(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value filter is not a member of Int\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmvcnbkqk.scala:38:69 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).count(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmvcnbkqk.scala:39:74 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter(_",
      "stdout": "",
      "timestamp": 1659799346
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = hex.filter(_ % 2 == 0).filter(_ % 3 == 0).filter(_ % 5 == 0).filter(_ % 7 == 0).filter(_ % 11 == 0).filter(_ % 13 == 0).filter(_ % 17 == 0).filter(_ % 19 == 0).filter(_ % 23 == 0).filter(_ % 29 == 0).filter(_ % 31 == 0).filter(_ % 37 == 0).filter(_ % 41 == 0).filter(_ % 43 == 0).filter(_ % 47 == 0).filter(_ % 53 == 0).filter(_ % 59 == 0).filter(_ % 61 == 0).filter(_ % 67 == 0).filter(_ % 71 == 0).filter(_ % 73 == 0).filter(_ % 79 == 0).filter(_ % 83 == 0).filter(_ % 89 == 0).filter(_ % 97 == 0).filter(_ % 101 == 0).filter(_ % 103 == 0).filter(_ % 107 == 0).filter(_ % 113 == 0).filter(_ % 127 == 0).filter(_ % 131 == 0).filter(_ % 137 == 0).filter(_ % 139 == 0).filter(_ % 143 == 0).filter(_ % 147 == 0).filter(_ % 151 == 0).filter(_ % 157 == 0).filter(_ % 163 == 0).filter(_ % 167 == 0).filter(_ % 173 == 0).filter(_ % 179 == 0).filter(_ % 181 == 0).filter(_ % 191 == 0).filter(_ % 193 == 0).filter(_ % 197 == 0).filter(_ % 199 == 0).filter(_ % 201 == 0).filter(_ % 207 == 0).filter(_ % 211 == 0).filter(_ % 213 == 0).filter(_ % 217 == 0).filter(_ % 221 == 0).filter(_ % 227 == 0).filter(_ % 229 == 0).filter(_ % 233 == 0).filter(_ % 239 == 0).filter(_ % 241 == 0).filter(_ % 247 == 0).filter(_ % 251 == 0).filter(_ % 257 == 0).filter(_ % 263 == 0).filter(_ % 269 == 0).filter(_ % 271 == 0).filter(_ % 277 == 0).filter(_ % 281 == 0).filter(_ % 283 == 0).filter(_ % 293 == 0).filter(_ % 307 == 0).filter(_ % 311 == 0).filter(_ % 313 == 0).filter(_ % 317 == 0).filter(_ % 321 == 0).filter(_ % 323 == 0).filter(_ % 327 == 0).filter(_ % 331 == 0).filter(_ % 337 == 0).filter(_ % 341 == 0).filter(_ % 347 == 0).filter(_ % 351 == 0).filter(_ % 357 == 0).filter(_ % 361 == 0).filter(_ % 367 == 0).filter(_ % 37\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptagqmt9m.scala:28:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptagqmt9m.scala:27:1725 ------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = hex.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m3\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m5\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m7\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m11\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m13\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m19\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m23\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m29\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m31\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m37\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m41\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m43\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m47\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m53\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m59\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m61\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m67\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m71\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m73\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m79\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m83\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m89\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m97\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m101\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m103\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m107\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m113\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m127\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m131\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m137\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m139\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m143\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m147\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m151\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m157\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m163\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m167\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m173\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m179\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m181\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m191\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m193\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31",
      "stdout": "",
      "timestamp": 1659799347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(x => x.toInt)\n        val hexLength = hex.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        var hexKeyCount = 0\n        var hexKeyPrime = 0\n        var hexKeyPrimeCount = 0\n        var hexKeyPrimePrime = 0\n        var hexKeyPrimePrimeCount = 0\n        var hexKeyPrimePrimePrime = 0\n        var hexKeyPrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrime = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        var hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfgnftqkl.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfgnftqkl.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mhexKeyPrimePrimePrimePrimePrimePrimePrimeCount\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyPrimePrimePrimePrimePrimePrimePrimeCount is already defined as \u001b[33mvariable\u001b[0m \u001b[35mhexKeyPrimePrimePrimePrimePrimePrimePrimeCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfgnftqkl.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mhexKeyPrimePrimePrimePrimePrimePrimePrimePrime\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyPrimePrimePrimePrimePrimePrimePrimePrime is already defined as \u001b[33mvariable\u001b[0m \u001b[35mhexKeyPrimePrimePrimePrimePrimePrimePrimePrime\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfgnftqkl.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mhexKeyPrimePrimePrimePrimePrimePrimePrimePrime\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyPrimePrimePrimePrimePrimePrimePrimePrime is already defined as \u001b[33mvariable\u001b[0m \u001b[35mhexKeyPrimePrimePrimePrimePrimePrimePrimePrime\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfgnftqkl.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mhexKeyPrimePrimePrimePrimePrimePrime",
      "stdout": "",
      "timestamp": 1659799345
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.map(x => (x % 16).asInstanceOf[Int])\n        val hexKey = hexKey.filter(_ > 0)\n        val hexKey = hexKey.filter(_ % 2 == 0)\n        val hexKey = hexKey.filter(_ % 3 == 0)\n        val hexKey = hexKey.filter(_ % 5 == 0)\n        val hexKey = hexKey.filter(_ % 7 == 0)\n        val hexKey = hexKey.filter(_ % 11 == 0)\n        val hexKey = hexKey.filter(_ % 13 == 0)\n        val hexKey = hexKey.filter(_ % 17 == 0)\n        val hexKey = hexKey.filter(_ % 19 == 0)\n        val hexKey = hexKey.filter(_ % 23 == 0)\n        val hexKey = hexKey.filter(_ % 29 == 0)\n        val hexKey = hexKey.filter(_ % 31 == 0)\n        val hexKey = hexKey.filter(_ % 37 == 0)\n        val hexKey = hexKey.filter(_ % 41 == 0)\n        val hexKey = hexKey.filter(_ % 43 == 0)\n        val hexKey = hexKey.filter(_ % 47 == 0)\n        val hexKey = hexKey.filter(_ % 51 == 0)\n        val hexKey = hexKey.filter(_ % 53 == 0)\n        val hexKey = hexKey.filter(_ % 57 == 0)\n        val hexKey = hexKey.filter(_ % 59 == 0)\n        val hexKey = hexKey.filter(_ % 61 == 0)\n        val hexKey = hexKey.filter(_ % 67 == 0)\n        val hexKey = hexKey.filter(_ % 71 == 0)\n        val hexKey = hexKey.filter(_ % 73 == 0)\n        val hexKey = hexKey.filter(_ % 79 == 0)\n        val hexKey = hexKey.filter(_ % 83 == 0)\n        val hexKey = hexKey.filter(_ % 89 == 0)\n        val hexKey = hexKey.filter(_ % 97 == 0)\n        val hexKey = hexKey.filter(_ % 101 == 0)\n        val hexKey = hexKey.filter(_ % 103 == 0)\n        val hexKey = hexKey.filter(_ % 107 == 0)\n        val hexKey = hexKey.filter(_ % 109 == 0)\n        val hexKey = hexKey.filter(_ % 113 == 0)\n        val hexKey = hexKey.filter(_ % 117 == 0)\n        val hexKey = hexKey.filter(_ % 121 == 0)\n        val hexKey = hexKey.filter(_ % 123 == 0)\n        val hexKey = hexKey.filter(_ % 127 == 0)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt5e2bslx.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hexKey.filter(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKey is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt5e2bslx.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hexKey.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKey is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt5e2bslx.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hexKey.filter(_ % \u001b[31m3\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKey is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt5e2bslx.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hexKey.filter(_ % \u001b[31m5\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKey is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt5e2bslx.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hexKey.filter(_ % \u001b[31m7\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659799347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexLength = hex.length\n        val hexKey = new mutable.HashMap[Int, Long]()\n        val hexKey2 = new mutable.HashMap[Int, Long]()\n        val hexKey3 = new mutable.HashMap[Int, Long]()\n        val hexKey4 = new mutable.HashMap[Int, Long]()\n        val hexKey5 = new mutable.HashMap[Int, Long]()\n        val hexKey6 = new mutable.HashMap[Int, Long]()\n        val hexKey7 = new mutable.HashMap[Int, Long]()\n        val hexKey8 = new mutable.HashMap[Int, Long]()\n        val hexKey9 = new mutable.HashMap[Int, Long]()\n        val hexKey10 = new mutable.HashMap[Int, Long]()\n        val hexKey11 = new mutable.HashMap[Int, Long]()\n        val hexKey12 = new mutable.HashMap[Int, Long]()\n        val hexKey13 = new mutable.HashMap[Int, Long]()\n        val hexKey14 = new mutable.HashMap[Int, Long]()\n        val hexKey15 = new mutable.HashMap[Int, Long]()\n        val hexKey16 = new mutable.HashMap[Int, Long]()\n        val hexKey17 = new mutable.HashMap[Int, Long]()\n        val hexKey18 = new mutable.HashMap[Int, Long]()\n        val hexKey19 = new mutable.HashMap[Int, Long]()\n        val hexKey20 = new mutable.HashMap[Int, Long]()\n        val hexKey21 = new mutable.HashMap[Int, Long]()\n        val hexKey22 = new mutable.HashMap[Int, Long]()\n        val hexKey23 = new mutable.HashMap[Int, Long]()\n        val hexKey24 = new mutable.HashMap[Int, Long]()\n        val hexKey25 = new mutable.HashMap[Int, Long]()\n        val hexKey26 = new mutable.HashMap[Int, Long]()\n        val hexKey27 = new mutable.HashMap[Int, Long]()\n        val hexKey28 = new mutable.HashMap[Int, Long]()\n        val hexKey29 = new mutable.HashMap[Int, Long]()\n        val hexKey30 = new mutable.HashMap[Int, Long]()\n        val hexKey31 = new mutable.HashMap[\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf_2_3gjy.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf_2_3gjy.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf_2_3gjy.scala:29:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf_2_3gjy.scala:30:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf_2_3gjy.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey4\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf_2_3gjy.scala:32:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey5\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m,",
      "stdout": "",
      "timestamp": 1659799346
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.count(_ == '0')\n        val hexDigits = hexCount / 2\n        val hexPrimes = hex.take(hexDigits).count(_ == '2')\n        val hexPrime = hexPrimes.toLong\n        val hexHex = hexCount - hexDigits - hexPrimes - hexPrime\n        val hexHexPrime = hexHex / 2\n        val hexHexPrimes = hexHexPrime / 2\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n        val hexHexPrimes = hexHexPrimes.toLong\n        val hexHexPrime = hexHexPrimes.toLong\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5un12o6r.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexHexPrime\u001b[0m = hexHexPrimes.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexHexPrime is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexHexPrime\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5un12o6r.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexHexPrimes\u001b[0m = hexHexPrimes.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexHexPrimes is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexHexPrimes\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5un12o6r.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexHexPrime\u001b[0m = hexHexPrimes.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexHexPrime is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexHexPrime\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5un12o6r.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexHexPrimes\u001b[0m = hexHexPrimes.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexHexPrimes is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexHexPrimes\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5un12o6r.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexHexPrime\u001b[0m = hexHexPrimes.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhex",
      "stdout": "",
      "timestamp": 1659799346
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexDigits = hex.map(x => x.toInt)\n        val hexDigitsCount = hexDigits.length\n        val hexDigitsToCheck = hexDigits.take(hexDigitsCount/3)\n        val hexDigitsToCheckCount = hexDigitsToCheck.length\n        val hexDigitsToCheckSet = hexDigitsToCheck.toSet\n        val hexDigitsToCheckSetCount = hexDigitsToCheckSet.size\n        val hexDigitsToCheckSetIsPrime = hexDigitsToCheckSet.forall(x => \n            x % 2 == 0 && x != 1 && x != 3 && x != 5 && x != 7 && x != 11 && x != 13 && x != 17 && x != 19 && x != 21)\n        val hexDigitsToCheckSetIsPrimeCount = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetCount : 0\n        val hexDigitsToCheckSetIsPrimeIsPrime = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeCount : 0\n        val hexDigitsToCheckSetIsPrimeIsPrimeIsPrime = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeIsPrimeCount : 0\n        val hexDigitsToCheckSetIsPrimeIsPrimeIsPrimeIsPrime = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeIsPrimeIsPrimeCount : 0\n        val hexDigitsToCheckSetIsPrimeIsPrimeIsPrimeIsPrimeIsPrime = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeIsPrimeIsPrimeIsPrimeCount : 0\n        val hexDigitsToCheckSetIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrime = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeIsPrimeIsPrimeIsPrimeCount : 0\n        val hexDigitsToCheckSetIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrime = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeIsPrimeIsPrimeIsPrimeCount : 0\n        val hexDigits\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgmktbbd2.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgmktbbd2.scala:36:73 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToCheckSetIsPrimeCount\u001b[0m = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetCount : \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgmktbbd2.scala:37:75 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToCheckSetIsPrimeIsPrime\u001b[0m = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeCount : \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgmktbbd2.scala:38:82 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToCheckSetIsPrimeIsPrimeIsPrime\u001b[0m = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeIsPrimeCount : \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgmktbbd2.scala:38:84 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToCheckSetIsPrimeIsPrimeIsPrime\u001b[0m = hexDigitsToCheckSetIsPrime ? hexDigitsToCheckSetIsPrimeIsPrimeCount : \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: hexDigitsToCheckSetIsPrimeIsPrimeCount\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expl",
      "stdout": "",
      "timestamp": 1659799348
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.map(x => x % 16).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"A\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$1(tmpcqjsxs12.scala:26)\n\tat Problem$.$anonfun$adapted$1(tmpcqjsxs12.scala:26)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:934)\n\tat Problem$.hexKey(tmpcqjsxs12.scala:26)\n\tat Problem$.main(tmpcqjsxs12.scala:31)\n\tat Problem.main(tmpcqjsxs12.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799336
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKeyLength = hexKey.size\n        val hexKeyLength2 = hexKeyLength * hexKeyLength\n        val hexKeyLength3 = hexKeyLength2 * hexKeyLength\n        val hexKeyLength4 = hexKeyLength3 * hexKeyLength\n        val hexKeyLength5 = hexKeyLength4 * hexKeyLength\n        val hexKeyLength6 = hexKeyLength5 * hexKeyLength\n        val hexKeyLength7 = hexKeyLength6 * hexKeyLength\n        val hexKeyLength8 = hexKeyLength7 * hexKeyLength\n        val hexKeyLength9 = hexKeyLength8 * hexKeyLength\n        val hexKeyLength10 = hexKeyLength9 * hexKeyLength\n        val hexKeyLength11 = hexKeyLength10 * hexKeyLength\n        val hexKeyLength12 = hexKeyLength11 * hexKeyLength\n        val hexKeyLength13 = hexKeyLength12 * hexKeyLength\n        val hexKeyLength14 = hexKeyLength13 * hexKeyLength\n        val hexKeyLength15 = hexKeyLength14 * hexKeyLength\n        val hexKeyLength16 = hexKeyLength15 * hexKeyLength\n        val hexKeyLength17 = hexKeyLength16 * hexKeyLength\n        val hexKeyLength18 = hexKeyLength17 * hexKeyLength\n        val hexKeyLength19 = hexKeyLength18 * hexKeyLength\n        val hexKeyLength20 = hexKeyLength19 * hexKeyLength\n        val hexKeyLength21 = hexKeyLength20 * hexKeyLength\n        val hexKeyLength22 = hexKeyLength21 * hexKeyLength\n        val hexKeyLength23 = hexKeyLength22 * hexKeyLength\n        val hexKeyLength24 = hexKeyLength23 * hexKeyLength\n        val hexKeyLength25 = hexKeyLength24 * hexKeyLength\n        val hexKeyLength26 = hexKeyLength25 * hexKeyLength\n        val hexKeyLength27 = hexKeyLength26 * hexKeyLength\n        val hexKeyLength28 = hexKeyLength27 * hexKeyLength\n        val hexKeyLength29 = hexKeyLength28 * hexKeyLength\n        val hexKeyLength30 = hexKeyLength29 * hexKeyLength\n        val hexKeyLength31 = hexKeyLength30 * hexKeyLength\n        val hexKeyLength32 = hexKeyLength\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc6dsyugg.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc6dsyugg.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toHexString)\n        val hexMap = hex.map(x => (x.toInt, 1)).toMap\n        val hexKeys = hex.map(x => hexMap.getOrElse(x, 0l))\n        hexKeys.sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmp2vq1cx.scala:26:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value toHexString is not a member of Char.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          longWrapper(_$1)\n\u001b[31m\u001b[31m-- Error: /tmp/tmpmp2vq1cx.scala:26:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyList = hexKey.toList\n        val hexKeyListLength = hexKeyList.size\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toLong\n        val hexKeyListLength = hexKeyListLength.toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpux6027_g.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m =",
      "stdout": "",
      "timestamp": 1659799320
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexArray = hexString.toList\n        val hexCount = hexArray.length\n        val hexArray2 = hexArray.filter(x => x % 2 == 0)\n        val hexArray3 = hexArray.filter(x => x % 3 == 0)\n        val hexArray4 = hexArray.filter(x => x % 4 == 0)\n        val hexArray5 = hexArray.filter(x => x % 5 == 0)\n        val hexArray6 = hexArray.filter(x => x % 6 == 0)\n        val hexArray7 = hexArray.filter(x => x % 7 == 0)\n        val hexArray8 = hexArray.filter(x => x % 8 == 0)\n        val hexArray9 = hexArray.filter(x => x % 9 == 0)\n        val hexArray10 = hexArray.filter(x => x % 10 == 0)\n        val hexArray11 = hexArray.filter(x => x % 11 == 0)\n        val hexArray12 = hexArray.filter(x => x % 12 == 0)\n        val hexArray13 = hexArray.filter(x => x % 13 == 0)\n        val hexArray14 = hexArray.filter(x => x % 14 == 0)\n        val hexArray15 = hexArray.filter(x => x % 15 == 0)\n        val hexArray16 = hexArray.filter(x => x % 16 == 0)\n        val hexArray17 = hexArray.filter(x => x % 17 == 0)\n        val hexArray18 = hexArray.filter(x => x % 18 == 0)\n        val hexArray19 = hexArray.filter(x => x % 19 == 0)\n        val hexArray20 = hexArray.filter(x => x % 20 == 0)\n        val hexArray21 = hexArray.filter(x => x % 21 == 0)\n        val hexArray22 = hexArray.filter(x => x % 22 == 0)\n        val hexArray23 = hexArray.filter(x => x % 23 == 0)\n        val hexArray24 = hexArray.filter(x => x % 24 == 0)\n        val hexArray25 = hexArray.filter(x => x % 25 == 0)\n        val hexArray26 = hexArray.filter(x => x % 26 == 0)\n        val hexArray27 = hexArray.filter(x => x % 27 == 0)\n        val hexArray28 = hexArray.filter(x => x % 28 == 0)\n        val hexArray29 = hexArray.filter(x => x % 29 == 0)\n        val hexArray30 = hex\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphc54riuj.scala:59:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.filter(_ >= '0' && _ <='9').length\n        val hexPrime = hex.filter(_ >= '0' && _ <='9' && _ != 'A' && _ != 'B' && _ != 'C' && _ != 'D' && _ != 'E' && _ != 'F').length\n        hexKey * hexPrime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpivj2a1at.scala:27:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <=\u001b[31m'9'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpivj2a1at.scala:28:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPrime\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <=\u001b[31m'9'\u001b[0m && _ != \u001b[31m'A'\u001b[0m && _ != \u001b[31m'B'\u001b[0m && _ != \u001b[31m'C'\u001b[0m && _ != \u001b[31m'D'\u001b[0m && _ != \u001b[31m'E'\u001b[0m && _ != \u001b[31m'F'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799345
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = new mutable.HashMap[Int, Long]()\n        for (i <- 0 until hex.length) {\n            val hexDigit = hex(i)\n            if (hexKey.contains(hexDigit)) {\n                hexKey.put(hexDigit, hexKey.get(hexDigit) + 1)\n            } else {\n                hexKey.put(hexDigit, 1L)\n            }\n        }\n        hexKey.values.toList.max\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpllycj0oc.scala:27:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799348
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexLen = hex.length\n        val hexKey = hex.foldLeft(1l) {\n            case (acc, hexDigit) => \n                val hexDigitInt = hexDigit.toInt\n                val hexDigitPrime = hexDigitInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrime ? hexDigitInt + 1 : hexDigitInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrimeInt ? hexDigitPrimeInt + 1 : hexDigitPrimeInt\n                val hexDigitPrimeInt = hexDigitPrimeInt % 2 == 0\n                val hexDigitPrimeInt = hexDigitPrime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplkd_6wer.scala:64:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplkd_6wer.scala:32:73 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimeInt\u001b[0m = hexDigitPrime ? hexDigitInt + \u001b[31m1\u001b[0m : \u001b[35mhexDigitInt\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Not found: type hexDigitInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplkd_6wer.scala:32:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimeInt\u001b[0m = hexDigitPrime ? hexDigitInt + \u001b[31m1\u001b[0m : \u001b[35mhexDigitInt\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplkd_6wer.scala:34:81 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimeInt\u001b[0m = hexDigitPrimeInt ? hexDigitPrimeInt + \u001b[31m1\u001b[0m : \u001b[35mhexDigitPrimeInt\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                 ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: type hexDigitPrimeInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplkd_6wer.scala:36:81 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimeInt\u001b[0m = hexDigitPrimeInt ? hexDigitPrimeInt + \u001b[31m1\u001b[0m : \u001b[35mhexDigitPrimeInt\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                 ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        N",
      "stdout": "",
      "timestamp": 1659799355
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.map(x => x % 16).filter(_ > 0).size\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpepfkkwtv.scala:31)\n\tat Problem.main(tmpepfkkwtv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799355
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKeyCount = hexKey.size\n        val hexKeyPrime = new mutable.HashMap[Int, Int]()\n        val hexKeyPrimeCount = hexKeyPrime.size\n        val hexKeyPrimePrime = new mutable.HashMap[Int, Int]()\n        val hexKeyPrimePrimeCount = hexKeyPrimePrime.size\n        val hexKeyPrimePrimePrimeCount = hexKeyPrimePrimeCount\n        val hexKeyPrimePrimePrimePrimeCount = hexKeyPrimePrimePrimeCount\n        val hexKeyPrimePrimePrimePrimePrimeCount = hexKeyPrimePrimePrimePrimeCount\n        val hexKeyPrimePrimePrimePrimePrimePrimeCount = hexKeyPrimePrimePrimePrimePrimePrimeCount\n        val hexKeyPrimePrimePrimePrimePrimePrimePrimeCount = hexKeyPrimePrimePrimePrimePrimePrimePrimePrimeCount\n        val hexKeyPrimePrimePrimePrimePrimePrimePrimePrimeCount = hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\n        val hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\n        val hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\n        val hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\n        val hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexKeyPrimePrimePrimePrimePrimePrimePrimePrime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi7fphull.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi7fphull.scala:30:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyPrime\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi7fphull.scala:32:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyPrimePrime\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpi7fphull.scala:37:56 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyPrimePrimePrimePrimePrimePrimeCount\u001b[0m = hexKeyPrimePrimePrimePrimePrimePrimeCount\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m    Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKeyPrimePrimePrimePrimePrimePrimeCount\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi7fphull.scala:39:66 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyPrimePrimePrimePrimePrimePrimePrimePrimeCount\u001b[0m = hexKeyPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\n\u001b[31m\u001b[31m   |\u001b[0m  ",
      "stdout": "",
      "timestamp": 1659799353
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexLen = hex.length\n        val hexKey = hex.foldLeft(0l) { (sum, digit) => \n            val hexDigit = digit.toHexString\n            val hexDigitLen = hexDigit.length\n            val hexDigitKey = hexDigit.foldLeft(0l) { (sum, digit) => \n                val hexDigitDigit = digit.toHexString\n                val hexDigitDigitLen = hexDigitDigit.length\n                val hexDigitDigitKey = hexDigitDigit.foldLeft(0l) { (sum, digit) => \n                    val hexDigitDigitDigit = digit.toHexString\n                    val hexDigitDigitDigitLen = hexDigitDigitDigit.length\n                    val hexDigitDigitDigitKey = hexDigitDigitDigit.foldLeft(0l) { (sum, digit) => \n                        val hexDigitDigitDigitDigit = digit.toHexString\n                        val hexDigitDigitDigitDigitLen = hexDigitDigitDigitDigit.length\n                        val hexDigitDigitDigitDigitKey = hexDigitDigitDigitDigit.foldLeft(0l) { (sum, digit) => \n                            val hexDigitDigitDigitDigitDigit = digit.toHexString\n                            val hexDigitDigitDigitDigitDigitLen = hexDigitDigitDigitDigitDigit.length\n                            val hexDigitDigitDigitDigitDigitKey = hexDigitDigitDigitDigitDigit.foldLeft(0l) { (sum, digit) => \n                                val hexDigitDigitDigitDigitDigitDigit = digit.toHexString\n                                val hexDigitDigitDigitDigitDigitDigitLen = hexDigitDigitDigitDigitDigitDigit.length\n                                val hexDigitDigitDigitDigitDigitDigitKey = hexDigitDigitDigitDigitDigitDigitDigit.foldLeft(0l) { (sum, digit) => \n                                    val hexDigitDigitDigitDigitDigitDigitDigit = digit.toHexString\n                                    val hexDigitDigitDigitDigitDigitDigitLen = hexDigitDigitDigitDigitDigitDigit.length\n                                    val hexDigitDigitDigitDigitDigitDigitDigitKey = hexDigitDigitDigitDigitDigitDigitDigitDigit.foldLeft(0l) { (sum, digit) => \n                                        val hexDigitDigitDigitDigitDigitDigitDigit = digit.toHexString\n                                        val hexDigitDigitDigitDigitDigitDigitDigitLen = hexDigitDigitDigitDigitDigitDigitDigit.length\n                                        val hexDigitDigitDigitDigitDigitDigitDigitKey = hexDigitDigitDigitDigitDigitDigitDigitDigit.foldLeft(0l) { (sum, digit) => \n                                            val hexDigitDigitDigitDigitDigitDigitDigit\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpccbgpngy.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpccbgpngy.scala:65:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpccbgpngy.scala:32:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitDigit\u001b[0m = digit.toHexString\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value toHexString is not a member of Char.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          intWrapper(digit)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpccbgpngy.scala:64:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpccbgpngy.scala:55:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m55 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659799354
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.filter(_ >= '0' && _ <='9').length\n        val hexKeyPrime = hex.filter(_ >= '0' && _ <='9' && _ != 'A' && _ != 'B' && _ != 'C' && _ != 'D' && _ != 'E' && _ != 'F').length\n        hexKey + hexKeyPrime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpo9ccf5cz.scala:27:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <=\u001b[31m'9'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpo9ccf5cz.scala:28:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyPrime\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <=\u001b[31m'9'\u001b[0m && _ != \u001b[31m'A'\u001b[0m && _ != \u001b[31m'B'\u001b[0m && _ != \u001b[31m'C'\u001b[0m && _ != \u001b[31m'D'\u001b[0m && _ != \u001b[31m'E'\u001b[0m && _ != \u001b[31m'F'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799351
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLen = hex.length\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLen = hexKey.length\n        val hexKeyLen2 = hexKeyLen / 2\n        val hexKeyLen3 = hexKeyLen / 3\n        val hexKeyLen4 = hexKeyLen / 4\n        val hexKeyLen5 = hexKeyLen / 5\n        val hexKeyLen6 = hexKeyLen / 6\n        val hexKeyLen7 = hexKeyLen / 7\n        val hexKeyLen8 = hexKeyLen / 8\n        val hexKeyLen9 = hexKeyLen / 9\n        val hexKeyLen10 = hexKeyLen / 10\n        val hexKeyLen11 = hexKeyLen / 11\n        val hexKeyLen12 = hexKeyLen / 12\n        val hexKeyLen13 = hexKeyLen / 13\n        val hexKeyLen14 = hexKeyLen / 14\n        val hexKeyLen15 = hexKeyLen / 15\n        val hexKeyLen16 = hexKeyLen / 16\n        val hexKeyLen17 = hexKeyLen / 17\n        val hexKeyLen18 = hexKeyLen / 18\n        val hexKeyLen19 = hexKeyLen / 19\n        val hexKeyLen20 = hexKeyLen / 20\n        val hexKeyLen21 = hexKeyLen / 21\n        val hexKeyLen22 = hexKeyLen / 22\n        val hexKeyLen23 = hexKeyLen / 23\n        val hexKeyLen24 = hexKeyLen / 24\n        val hexKeyLen25 = hexKeyLen / 25\n        val hexKeyLen26 = hexKeyLen / 26\n        val hexKeyLen27 = hexKeyLen / 27\n        val hexKeyLen28 = hexKeyLen / 28\n        val hexKeyLen29 = hexKeyLen / 29\n        val hexKeyLen30 = hexKeyLen / 30\n        val hexKeyLen31 = hexKeyLen / 31\n        val hexKeyLen32 = hexKeyLen / 32\n        val hexKeyLen33 = hexKeyLen / 33\n        val hexKeyLen34 = hexKeyLen / 34\n        val hexKeyLen35 = hexKeyLen / 35\n        val hexKeyLen36 = hexKeyLen / 36\n        val hexKeyLen37 = hexKeyLen / 37\n        val hexKeyLen38 = hexKeyLen / 38\n        \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsrmgyb0r.scala:68:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799355
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.foldLeft(0l) { (sum, digit) =>\n            val hexDigit = digit.toLong\n            val hexDigitSum = sum + hexDigit\n            val hexDigitSumDivisor = hexDigitSum / hexDigit\n            val hexDigitSumDivisor2 = hexDigitSumDivisor / hexDigit\n            val hexDigitSumDivisor3 = hexDigitSumDivisor2 / hexDigit\n            val hexDigitSumDivisor4 = hexDigitSumDivisor3 / hexDigit\n            val hexDigitSumDivisor5 = hexDigitSumDivisor4 / hexDigit\n            val hexDigitSumDivisor6 = hexDigitSumDivisor5 / hexDigit\n            val hexDigitSumDivisor7 = hexDigitSumDivisor6 / hexDigit\n            val hexDigitSumDivisor8 = hexDigitSumDivisor7 / hexDigit\n            val hexDigitSumDivisor9 = hexDigitSumDivisor8 / hexDigit\n            val hexDigitSumDivisor10 = hexDigitSumDivisor9 / hexDigit\n            val hexDigitSumDivisor11 = hexDigitSumDivisor10 / hexDigit\n            val hexDigitSumDivisor12 = hexDigitSumDivisor11 / hexDigit\n            val hexDigitSumDivisor13 = hexDigitSumDivisor12 / hexDigit\n            val hexDigitSumDivisor14 = hexDigitSumDivisor13 / hexDigit\n            val hexDigitSumDivisor15 = hexDigitSumDivisor14 / hexDigit\n            val hexDigitSumDivisor16 = hexDigitSumDivisor15 / hexDigit\n            val hexDigitSumDivisor17 = hexDigitSumDivisor16 / hexDigit\n            val hexDigitSumDivisor18 = hexDigitSumDivisor17 / hexDigit\n            val hexDigitSumDivisor19 = hexDigitSumDivisor18 / hexDigit\n            val hexDigitSumDivisor20 = hexDigitSumDivisor19 / hexDigit\n            val hexDigitSumDivisor21 = hexDigitSumDivisor20 / hexDigit\n            val hexDigitSumDivisor22 = hexDigitSumDivisor21 / hexDigit\n            val hexDigitSumDivisor23 = hexDigitSumDivisor22 / hexDigit\n            val hexDigitSumDivisor24 = hexDigitSumDivisor23 / hexDigit\n            val hexDigitSumDivisor25 = hexDigitSumDivisor24 / hexDigit\n            val hexDigitSum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7bn3s_ym.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7bn3s_ym.scala:67:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7bn3s_ym.scala:58:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    assert(hexKey((\u001b[31m\"AB\"\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7bn3s_ym.scala:59:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    assert(hexKey((\u001b[31m\"1077E\"\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7bn3s_ym.scala:60:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    assert(hexKey((\u001b[31m\"ABED1A33\"\u001b[0m)) == (\u001b[31m4l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7bn3s_ym.scala:61:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    assert(hexKey((\u001b[31m\"2020\"\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7bn3s_ym.scala:62:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    assert(hexKey((\u001b[31m\"123456789ABCDEF0\"\u001b[0m)) == (\u001b[31m6l",
      "stdout": "",
      "timestamp": 1659799358
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexDigits = hex.map(x => x.toInt)\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.toList.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigitMap.values.to\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppuwzbxdu.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigitMap.values.toList.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppuwzbxdu.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMap\u001b[0m = hexDigits.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppuwzbxdu.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigitMap.values.toList.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppuwzbxdu.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMap\u001b[0m = hexDigits.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppuwzbxdu.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigitMap.values.toList.length\n\u001b[31m\u001b[31m   |\u001b[0m       ",
      "stdout": "",
      "timestamp": 1659799358
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.count\n        val hexDigits = hex.map(x => x.toInt)\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n        val hexDigitCount = hexDigits.length\n        val hexDigitMap = hexDigits.toMap\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0iyfsuqf.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigits.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0iyfsuqf.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMap\u001b[0m = hexDigits.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0iyfsuqf.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigits.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0iyfsuqf.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitMap\u001b[0m = hexDigits.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0iyfsuqf.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitCount\u001b[0m = hexDigits.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitCount is already ",
      "stdout": "",
      "timestamp": 1659799358
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.count\n        val hexDigits = hex.map(_.toInt)\n        val hexDigitCount = hexDigits.length\n        val hexDigitPrimes = hexDigits.filter(x => x % 2 == 0).length\n        val hexDigitPrimeCount = hexDigitPrimes + 1\n        val hexDigitPrimePrimes = hexDigitPrimes.filter(x => x % 3 == 0).length\n        val hexDigitPrimePrimeCount = hexDigitPrimePrimes + 1\n        val hexDigitPrimePrimePrimes = hexDigitPrimePrimes.filter(x => x % 5 == 0).length\n        val hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes + 1\n        val hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter(x => x % 7 == 0).length\n        val hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes + 1\n        val hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter(x => x % 11 == 0).length\n        val hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes + 1\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter(x => x % 13 == 0).length\n        val hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes + 1\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter(x => x % 17 == 0).length\n        val hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimes + 1\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.filter(x => x % 19 == 0).length\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp13ddubh1.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimeCount\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimes + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitPrimePrimePrimePrimePrimeCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimeCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp13ddubh1.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter(\u001b[36mx\u001b[0m => x % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitPrimePrimePrimePrimePrimePrimes is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimes\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp13ddubh1.scala:32:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimes\u001b[0m = hexDigitPrimes.filter(\u001b[36mx\u001b[0m => x % \u001b[31m3\u001b[0m == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value filter is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp13ddubh1.scala:44:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.filter(\u001b[36mx\u001b[0m => x % \u001b[31m19\u001b[0m == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                          ",
      "stdout": "",
      "timestamp": 1659799357
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toHexString).mkString\n        val hexDigits = hex.split(\"\").map(_.toInt)\n        val hexDigitCount = hexDigits.length\n        val hexDigitPrimes = hexDigits.filter(hexDigitPrime(_))\n        val hexDigitPrimeCount = hexDigitPrimes.length\n        val hexDigitPrimePrimes = hexDigitPrimes.filter(hexDigitPrimePrime(_))\n        val hexDigitPrimePrimeCount = hexDigitPrimePrimes.length\n        val hexDigitPrimePrimePrimes = hexDigitPrimePrimes.filter(hexDigitPrimePrimePrime(_))\n        val hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter(hexDigitPrimePrimePrimePrime(_))\n        val hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter(hexDigitPrimePrimePrimePrimePrime(_))\n        val hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter(hexDigitPrimePrimePrimePrimePrimePrime(_))\n        val hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter(hexDigitPrimePrimePrimePrimePrimePrimePrimePrime(_))\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.length\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvmzfbz34.scala:26:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value toHexString is not a member of Char.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          intWrapper(_$1)\n\u001b[31m\u001b[31m-- Error: /tmp/tmpvmzfbz34.scala:26:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpvmzfbz34.scala:41:59 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter(hexDigitPrimePrimePrimePrimePrimePrimePrimePrime(_))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimePrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvmzfbz34.scala:43:64 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimePrimePrimePrime\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: hexDigitPrimePrimePrimePrimePrimePrimePrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007]",
      "stdout": "",
      "timestamp": 1659799359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toHexString)\n        val hexKey = hex.map(_.toInt)\n        val hexKeyMap = hexKey.toMap\n        val hexKeyMap2 = hexKeyMap.toSeq.sortBy(_._1).reverse\n        val hexKeyMap3 = hexKeyMap2.filter(_._2 % 2 == 0).map(_._1)\n        val hexKeyMap4 = hexKeyMap3.filter(_._2 % 3 == 0).map(_._1)\n        val hexKeyMap5 = hexKeyMap4.filter(_._2 % 5 == 0).map(_._1)\n        val hexKeyMap6 = hexKeyMap5.filter(_._2 % 7 == 0).map(_._1)\n        val hexKeyMap7 = hexKeyMap6.filter(_._2 % 11 == 0).map(_._1)\n        val hexKeyMap8 = hexKeyMap7.filter(_._2 % 13 == 0).map(_._1)\n        val hexKeyMap9 = hexKeyMap8.filter(_._2 % 17 == 0).map(_._1)\n        val hexKeyMap10 = hexKeyMap9.filter(_._2 % 19 == 0).map(_._1)\n        val hexKeyMap11 = hexKeyMap10.filter(_._2 % 23 == 0).map(_._1)\n        val hexKeyMap12 = hexKeyMap11.filter(_._2 % 29 == 0).map(_._1)\n        val hexKeyMap13 = hexKeyMap12.filter(_._2 % 31 == 0).map(_._1)\n        val hexKeyMap14 = hexKeyMap13.filter(_._2 % 37 == 0).map(_._1)\n        val hexKeyMap15 = hexKeyMap14.filter(_._2 % 41 == 0).map(_._1)\n        val hexKeyMap16 = hexKeyMap15.filter(_._2 % 43 == 0).map(_._1)\n        val hexKeyMap17 = hexKeyMap16.filter(_._2 % 47 == 0).map(_._1)\n        val hexKeyMap18 = hexKeyMap17.filter(_._2 % 51 == 0).map(_._1)\n        val hexKeyMap19 = hexKeyMap18.filter(_._2 % 53 == 0).map(_._1)\n        val hexKeyMap20 = hexKeyMap19.filter(_._2 % 59 == 0).map(_._1)\n        val hexKeyMap21 = hexKeyMap20.filter(_._2 % 61 == 0).map(_._1)\n        val hexKeyMap22 = hexKeyMap21.filter(_\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyn9l9qmf.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyn9l9qmf.scala:26:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value toHexString is not a member of Char.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          longWrapper(_$1)\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyn9l9qmf.scala:26:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpyn9l9qmf.scala:49:45 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap22\u001b[0m = hexKeyMap21.filter(_\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m  Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  I could not infer the type of the parameter _$42 of expanded function:\n\u001b[31m   |\u001b[0m  _$42 => hexKeyMap21.filter(_$42).\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyn9l9qmf.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659799359
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => if (x == 'A') 1 else 0).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphn3dv98x.scala:32)\n\tat Problem.main(tmphn3dv98x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKey2 = new mutable.HashMap[Int, Int]()\n        val hexKey3 = new mutable.HashMap[Int, Int]()\n        val hexKey4 = new mutable.HashMap[Int, Int]()\n        val hexKey5 = new mutable.HashMap[Int, Int]()\n        val hexKey6 = new mutable.HashMap[Int, Int]()\n        val hexKey7 = new mutable.HashMap[Int, Int]()\n        val hexKey8 = new mutable.HashMap[Int, Int]()\n        val hexKey9 = new mutable.HashMap[Int, Int]()\n        val hexKey10 = new mutable.HashMap[Int, Int]()\n        val hexKey11 = new mutable.HashMap[Int, Int]()\n        val hexKey12 = new mutable.HashMap[Int, Int]()\n        val hexKey13 = new mutable.HashMap[Int, Int]()\n        val hexKey14 = new mutable.HashMap[Int, Int]()\n        val hexKey15 = new mutable.HashMap[Int, Int]()\n        val hexKey16 = new mutable.HashMap[Int, Int]()\n        val hexKey17 = new mutable.HashMap[Int, Int]()\n        val hexKey18 = new mutable.HashMap[Int, Int]()\n        val hexKey19 = new mutable.HashMap[Int, Int]()\n        val hexKey20 = new mutable.HashMap[Int, Int]()\n        val hexKey21 = new mutable.HashMap[Int, Int]()\n        val hexKey22 = new mutable.HashMap[Int, Int]()\n        val hexKey23 = new mutable.HashMap[Int, Int]()\n        val hexKey24 = new mutable.HashMap[Int, Int]()\n        val hexKey25 = new mutable.HashMap[Int, Int]()\n        val hexKey26 = new mutable.HashMap[Int, Int]()\n        val hexKey27 = new mutable.HashMap[Int, Int]()\n        val hexKey28 = new mutable.HashMap[Int, Int]()\n        val hexKey29 = new mutable.HashMap[Int, Int]()\n        val hexKey30 = new mutable.HashMap[Int, Int]()\n        val hexKey31 = new mutable.HashMap[Int, Int]()\n        val hexKey32 = new \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp186ybvmf.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp186ybvmf.scala:27:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp186ybvmf.scala:28:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp186ybvmf.scala:29:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp186ybvmf.scala:30:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey4\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp186ybvmf.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey5\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[3",
      "stdout": "",
      "timestamp": 1659799358
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.map(x => (x % 16).asInstanceOf[Int]).toList.map(x => x.toLong)\n        hexKey.count(x => x == 2)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8zdfpeay.scala:32)\n\tat Problem.main(tmp8zdfpeay.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = hexLength.toLong\n        val hexKeyArray = hexKey.toArray\n        val hexKeyArrayLength = hexKeyArray.length\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m",
      "stdout": "",
      "timestamp": 1659799359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey.map(x => x % 10)\n        val hexKey4 = hexKey.map(x => x % 10)\n        val hexKey5 = hexKey.map(x => x % 10)\n        val hexKey6 = hexKey.map(x => x % 10)\n        val hexKey7 = hexKey.map(x => x % 10)\n        val hexKey8 = hexKey.map(x => x % 10)\n        val hexKey9 = hexKey.map(x => x % 10)\n        val hexKey10 = hexKey.map(x => x % 10)\n        val hexKey11 = hexKey.map(x => x % 10)\n        val hexKey12 = hexKey.map(x => x % 10)\n        val hexKey13 = hexKey.map(x => x % 10)\n        val hexKey14 = hexKey.map(x => x % 10)\n        val hexKey15 = hexKey.map(x => x % 10)\n        val hexKey16 = hexKey.map(x => x % 10)\n        val hexKey17 = hexKey.map(x => x % 10)\n        val hexKey18 = hexKey.map(x => x % 10)\n        val hexKey19 = hexKey.map(x => x % 10)\n        val hexKey20 = hexKey.map(x => x % 10)\n        val hexKey21 = hexKey.map(x => x % 10)\n        val hexKey22 = hexKey.map(x => x % 10)\n        val hexKey23 = hexKey.map(x => x % 10)\n        val hexKey24 = hexKey.map(x => x % 10)\n        val hexKey25 = hexKey.map(x => x % 10)\n        val hexKey26 = hexKey.map(x => x % 10)\n        val hexKey27 = hexKey.map(x => x % 10)\n        val hexKey28 = hexKey.map(x => x % 10)\n        val hexKey29 = hexKey.map(x => x % 10)\n        val hexKey30 = hexKey.map(x => x % 10)\n        val hexKey31 = hexKey.map(x => x % 10)\n        val hexKey32 = hexKey.map(x => x % 10)\n        val hexKey33 = hexKey.map(x => x % 10)\n        val hexKey34 = hexKey.map(x => x % 10)\n        val hexKey35\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmabttmxu.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmabttmxu.scala:62:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLen = hex.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKeyLen = hexKey.size\n        val hexKeyMap = new mutable.HashMap[Int, Int]()\n        val hexKeyMapLen = hexKeyMap.size\n        val hexKeyMap2 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap2Len = hexKeyMap2.size\n        val hexKeyMap3 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap3Len = hexKeyMap3.size\n        val hexKeyMap4 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap4Len = hexKeyMap4.size\n        val hexKeyMap5 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap5Len = hexKeyMap5.size\n        val hexKeyMap6 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap6Len = hexKeyMap6.size\n        val hexKeyMap7 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap7Len = hexKeyMap7.size\n        val hexKeyMap8 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap8Len = hexKeyMap8.size\n        val hexKeyMap9 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap9Len = hexKeyMap9.size\n        val hexKeyMap10 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap10Len = hexKeyMap10.size\n        val hexKeyMap11 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap11Len = hexKeyMap11.size\n        val hexKeyMap12 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap12Len = hexKeyMap12.size\n        val hexKeyMap13 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap13Len = hexKeyMap13.size\n        val hexKeyMap14 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap14Len = hexKeyMap14.size\n        val hexKeyMap15 = new mutable.HashMap[Int, Int]()\n        val hexKeyMap15Len = hexKeyMap15.size\n        val hexKeyMap16 = new mut\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp43j1jtb7.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp43j1jtb7.scala:30:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp43j1jtb7.scala:32:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp43j1jtb7.scala:34:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp43j1jtb7.scala:36:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap4\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explan",
      "stdout": "",
      "timestamp": 1659799359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\")\n        val numsCount = nums.length\n        val hexNums = nums.map(_.toInt)\n        val hexNumsCount = hexNums.length\n        val hexNumsSum = hexNums.sum\n        val hexNumsSumCount = hexNumsSum.toInt\n        val hexNumsSumCount2 = hexNumsSumCount.toInt\n        val hexNumsSumCount3 = hexNumsSumCount2.toInt\n        val hexNumsSumCount4 = hexNumsSumCount3.toInt\n        val hexNumsSumCount5 = hexNumsSumCount4.toInt\n        val hexNumsSumCount6 = hexNumsSumCount5.toInt\n        val hexNumsSumCount7 = hexNumsSumCount6.toInt\n        val hexNumsSumCount8 = hexNumsSumCount7.toInt\n        val hexNumsSumCount9 = hexNumsSumCount8.toInt\n        val hexNumsSumCount10 = hexNumsSumCount9.toInt\n        val hexNumsSumCount11 = hexNumsSumCount10.toInt\n        val hexNumsSumCount12 = hexNumsSumCount11.toInt\n        val hexNumsSumCount13 = hexNumsSumCount12.toInt\n        val hexNumsSumCount14 = hexNumsSumCount13.toInt\n        val hexNumsSumCount15 = hexNumsSumCount14.toInt\n        val hexNumsSumCount16 = hexNumsSumCount15.toInt\n        val hexNumsSumCount17 = hexNumsSumCount16.toInt\n        val hexNumsSumCount18 = hexNumsSumCount17.toInt\n        val hexNumsSumCount19 = hexNumsSumCount18.toInt\n        val hexNumsSumCount20 = hexNumsSumCount19.toInt\n        val hexNumsSumCount21 = hexNumsSumCount20.toInt\n        val hexNumsSumCount22 = hexNumsSumCount21.toInt\n        val hexNumsSumCount23 = hexNumsSumCount22.toInt\n        val hexNumsSumCount24 = hexNumsSumCount23.toInt\n        val hexNumsSumCount25 = hexNumsSumCount24.toInt\n        val hexNumsSumCount26 = hexNumsSumCount25.toInt\n        val hexNumsSum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw6ivnkm_.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw6ivnkm_.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toChar).map(_.toInt)\n        val primes = hex.filter(_ % 2 == 0).filter(_ % 3 == 0).filter(_ % 5 == 0).filter(_ % 7 == 0).filter(_ % 11 == 0).filter(_ % 13 == 0).filter(_ % 17 == 0).filter(_ % 19 == 0).filter(_ % 23 == 0).filter(_ % 29 == 0).filter(_ % 31 == 0).filter(_ % 37 == 0).filter(_ % 41 == 0).filter(_ % 43 == 0).filter(_ % 47 == 0).filter(_ % 53 == 0).filter(_ % 59 == 0).filter(_ % 61 == 0).filter(_ % 67 == 0).filter(_ % 71 == 0).filter(_ % 73 == 0).filter(_ % 79 == 0).filter(_ % 83 == 0).filter(_ % 89 == 0).filter(_ % 97 == 0).filter(_ % 101 == 0).filter(_ % 103 == 0).filter(_ % 107 == 0).filter(_ % 109 == 0).filter(_ % 113 == 0).filter(_ % 127 == 0).filter(_ % 131 == 0).filter(_ % 137 == 0).filter(_ % 139 == 0).filter(_ % 143 == 0).filter(_ % 147 == 0).filter(_ % 151 == 0).filter(_ % 157 == 0).filter(_ % 159 == 0).filter(_ % 163 == 0).filter(_ % 167 == 0).filter(_ % 173 == 0).filter(_ % 177 == 0).filter(_ % 181 == 0).filter(_ % 191 == 0).filter(_ % 193 == 0).filter(_ % 197 == 0).filter(_ % 199 == 0).filter(_ % 201 == 0).filter(_ % 207 == 0).filter(_ % 209 == 0).filter(_ % 211 == 0).filter(_ % 213 == 0).filter(_ % 217 == 0).filter(_ % 221 == 0).filter(_ % 227 == 0).filter(_ % 229 == 0).filter(_ % 233 == 0).filter(_ % 239 == 0).filter(_ % 241 == 0).filter(_ % 243 == 0).filter(_ % 247 == 0).filter(_ % 251 == 0).filter(_ % 257 == 0).filter(_ % 259 == 0).filter(_ % 263 == 0).filter(_ % 267 == 0).filter(_ % 269 == 0).filter(_ % 271 == 0).filter(_ % 277 == 0).filter(_ % 281 == 0).filter(_ % 283 == 0).filter(_ % 293 == 0).filter(_ % 307 == 0).filter(_ % 311 == 0).filter(_ % 313 == 0).filter(_ % 317 == 0).filter(_ % 319 == 0).filter(_ % 323 == 0).filter(_ % 327 == 0).filter(_ % 331 == 0).filter(_ % 337 == \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp1y2ferl_.scala:27:1714 -------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = hex.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m3\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m5\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m7\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m11\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m13\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m19\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m23\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m29\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m31\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m37\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m41\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m43\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m47\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m53\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m59\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m61\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m67\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m71\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m73\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m79\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m83\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m89\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m97\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m101\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m103\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m107\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m109\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m113\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m127\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m131\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m137\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m139\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m143\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m147\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m151\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m157\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m159\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m163\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m167\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m173\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m177\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m181\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m191\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m193\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m197\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m199\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m201\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % ",
      "stdout": "",
      "timestamp": 1659799359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt_4qywzl.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.toCharArray\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet34 = mut\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:32:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprime",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0l){ (sum, digit) => sum + digit * digit }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptalan4td.scala:31)\n\tat Problem.main(tmptalan4td.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799361
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val prime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpviixudjt.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799343
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexArray = hex.toArray\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = hexArrayLength.toInt\n        val hexArrayLength = \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpj6frl28q.scala:72:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj6frl28q.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArrayLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj6frl28q.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArrayLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj6frl28q.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArrayLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj6frl28q.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArrayLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexArrayLength is alre",
      "stdout": "",
      "timestamp": 1659799363
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexLength = hexString.length\n        val hexKey = hexString.toList.map(x => (x % 16).toInt).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"A\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$1(tmpo77gxw77.scala:26)\n\tat Problem$.$anonfun$adapted$1(tmpo77gxw77.scala:26)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:934)\n\tat Problem$.hexKey(tmpo77gxw77.scala:26)\n\tat Problem$.main(tmpo77gxw77.scala:33)\n\tat Problem.main(tmpo77gxw77.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.foldLeft(0l) { (sum, digit) =>\n            val hexDigit = digit.toLong\n            val hexDigitCount = hexDigit match {\n                case 0 => 0\n                case 1 => 1\n                case 2 => 2\n                case 3 => 3\n                case 4 => 4\n                case 5 => 5\n                case 6 => 6\n                case 7 => 7\n                case 8 => 8\n                case 9 => 9\n                case 10 => 10\n                case 11 => 11\n                case 12 => 12\n                case 13 => 13\n                case 14 => 14\n                case 15 => 15\n                case 16 => 16\n                case 17 => 17\n                case 18 => 18\n                case 19 => 19\n                case 20 => 20\n                case 21 => 21\n                case 22 => 22\n                case 23 => 23\n                case 24 => 24\n                case 25 => 25\n                case 26 => 26\n                case 27 => 27\n                case 28 => 28\n                case 29 => 29\n                case 30 => 30\n                case 31 => 31\n                case 32 => 32\n                case 33 => 33\n                case 34 => 34\n                case 35 => 35\n                case 36 => 36\n                case 37 => 37\n                case 38 => 38\n                case 39 => 39\n                case 40 => 40\n                case 41 => 41\n                case 42 => 42\n                case 43 => 43\n                case 44 => 44\n                case 45 => 45\n                case 46 => 46\n                case 47 => 47\n                case 48 => 48\n                case 49 => 49\n                case 50 => 50\n                case 51 => 51\n                case 52 => 52\n                case 53 => 53\n                case 54 => 54\n                case 55 => 55\n                case 56 => 56\n                case 57 => 57\n                case 58 => 58\n                case 59 => 59\n                case 60 => 60\n                case 61 => 61\n                case 62 => 62\n                case 63 => 63\n                case 64 => 64\n                case 65 => 65\n                case 66 => 66\n                case 67 => 67\n                case 68 => 68\n                case 69 => 69\n                case 70 => 70\n                case 71 => 71\n                case 72 => 72\n                case 73 => 73\n                case 74 => 74\n                case 75 => 75\n                case 76 => 76\n                case 77 => 77\n                case 78 => 78\n                case 79 => 79\n                case 80 => 80\n                case 81 => 81\n                case 82 => 82\n                case 83 => 83\n                case 84 => 84\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjfmqahze.scala:126:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m126 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjfmqahze.scala:117:11 --------------------------\u001b[0m\u001b[0m\n\u001b[31m117 |\u001b[0m    assert(hexKey((\u001b[31m\"AB\"\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^\u001b[0m\n\u001b[31m    |\u001b[0m           Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m needs type\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjfmqahze.scala:118:11 --------------------------\u001b[0m\u001b[0m\n\u001b[31m118 |\u001b[0m    assert(hexKey((\u001b[31m\"1077E\"\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^\u001b[0m\n\u001b[31m    |\u001b[0m           Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m needs type\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjfmqahze.scala:119:11 --------------------------\u001b[0m\u001b[0m\n\u001b[31m119 |\u001b[0m    assert(hexKey((\u001b[31m\"ABED1A33\"\u001b[0m)) == (\u001b[31m4l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^\u001b[0m\n\u001b[31m    |\u001b[0m           Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m needs type\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjfmqahze.scala:120:11 --------------------------\u001b[0m\u001b[0m\n\u001b[31m120 |\u001b[0m    assert(hexKey((\u001b[31m\"2020\"\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^\u001b[0m\n\u001b[31m    |\u001b[0m           Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m needs type\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjfmqahze.scala:121:11 --------------------------\u001b[0m\u001b[0m\n\u001b[31m121 |\u001b[0m    assert(hexKey((\u001b[31m\"123456789ABCDEF0\"\u001b[0m)) == (\u001b[31m6l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^\u001b[0m\n\u001b[31m    |\u001b[0m           Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m needs type\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-e",
      "stdout": "",
      "timestamp": 1659799368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyCount = hexKey.length\n        val hexKeySum = hexKey.sum\n        val hexKeySumCount = hexKeySum.toInt\n        val hexKeySumCount2 = hexKeySumCount.toInt\n        val hexKeySumCount3 = hexKeySumCount2.toInt\n        val hexKeySumCount4 = hexKeySumCount3.toInt\n        val hexKeySumCount5 = hexKeySumCount4.toInt\n        val hexKeySumCount6 = hexKeySumCount5.toInt\n        val hexKeySumCount7 = hexKeySumCount6.toInt\n        val hexKeySumCount8 = hexKeySumCount7.toInt\n        val hexKeySumCount9 = hexKeySumCount8.toInt\n        val hexKeySumCount10 = hexKeySumCount9.toInt\n        val hexKeySumCount11 = hexKeySumCount10.toInt\n        val hexKeySumCount12 = hexKeySumCount11.toInt\n        val hexKeySumCount13 = hexKeySumCount12.toInt\n        val hexKeySumCount14 = hexKeySumCount13.toInt\n        val hexKeySumCount15 = hexKeySumCount14.toInt\n        val hexKeySumCount16 = hexKeySumCount15.toInt\n        val hexKeySumCount17 = hexKeySumCount16.toInt\n        val hexKeySumCount18 = hexKeySumCount17.toInt\n        val hexKeySumCount19 = hexKeySumCount18.toInt\n        val hexKeySumCount20 = hexKeySumCount19.toInt\n        val hexKeySumCount21 = hexKeySumCount20.toInt\n        val hexKeySumCount22 = hexKeySumCount21.toInt\n        val hexKeySumCount23 = hexKeySumCount22.toInt\n        val hexKeySumCount24 = hexKeySumCount23.toInt\n        val hexKeySumCount25 = hexKeySumCount24.toInt\n        val hexKeySumCount26 = hexKeySumCount25.toInt\n        val hexKeySumCount27 = hexKeySumCount26.toInt\n        val hexKeySumCount28 = hexKeySumCount27.toInt\n        val hexKeySumCount29 = hexKeySumCount28.toInt\n        val hexKeySumCount30 = hexKeySumCount29.to\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpw3avlkl3.scala:60:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumCount30\u001b[0m = hexKeySumCount29.to\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mto\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (end: Int, step: Int): scala.collection.immutable.Range.Inclusive\n\u001b[31m   |\u001b[0m (end: Int): scala.collection.immutable.Range.Inclusive\n\u001b[31m   |\u001b[0mboth match expected type <?>\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw3avlkl3.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799366
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = mutable.ArrayBuffer(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val primesSet = primes.toSet\n        val hexSet = hex.toSet\n        val primesCount = primes.count(_ == hexSet.last)\n        val hexCount = hex.count(_ == primesSet.last)\n        val hexKey = (hexCount + primesCount).toLong\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8u7fy24r.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.ArrayBuffer(\u001b[31m2\u001b[0m, \u001b[31m3\u001b[0m, \u001b[31m5\u001b[0m, \u001b[31m7\u001b[0m, \u001b[31m11\u001b[0m, \u001b[31m13\u001b[0m, \u001b[31m17\u001b[0m, \u001b[31m19\u001b[0m, \u001b[31m23\u001b[0m, \u001b[31m29\u001b[0m, \u001b[31m31\u001b[0m, \u001b[31m37\u001b[0m, \u001b[31m41\u001b[0m, \u001b[31m43\u001b[0m, \u001b[31m47\u001b[0m, \u001b[31m53\u001b[0m, \u001b[31m59\u001b[0m, \u001b[31m61\u001b[0m, \u001b[31m67\u001b[0m, \u001b[31m71\u001b[0m, \u001b[31m73\u001b[0m, \u001b[31m79\u001b[0m, \u001b[31m83\u001b[0m, \u001b[31m89\u001b[0m, \u001b[31m97\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799363
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyCount = hexKey.length\n        val hexKeySum = hexKey.sum\n        val hexKeySum2 = hexKeySum * hexKeySum\n        val hexKeySum3 = hexKeySum2 * hexKeySum\n        val hexKeySum4 = hexKeySum3 * hexKeySum\n        val hexKeySum5 = hexKeySum4 * hexKeySum\n        val hexKeySum6 = hexKeySum5 * hexKeySum\n        val hexKeySum7 = hexKeySum6 * hexKeySum\n        val hexKeySum8 = hexKeySum7 * hexKeySum\n        val hexKeySum9 = hexKeySum8 * hexKeySum\n        val hexKeySum10 = hexKeySum9 * hexKeySum\n        val hexKeySum11 = hexKeySum10 * hexKeySum\n        val hexKeySum12 = hexKeySum11 * hexKeySum\n        val hexKeySum13 = hexKeySum12 * hexKeySum\n        val hexKeySum14 = hexKeySum13 * hexKeySum\n        val hexKeySum15 = hexKeySum14 * hexKeySum\n        val hexKeySum16 = hexKeySum15 * hexKeySum\n        val hexKeySum17 = hexKeySum16 * hexKeySum\n        val hexKeySum18 = hexKeySum17 * hexKeySum\n        val hexKeySum19 = hexKeySum18 * hexKeySum\n        val hexKeySum20 = hexKeySum19 * hexKeySum\n        val hexKeySum21 = hexKeySum20 * hexKeySum\n        val hexKeySum22 = hexKeySum21 * hexKeySum\n        val hexKeySum23 = hexKeySum22 * hexKeySum\n        val hexKeySum24 = hexKeySum23 * hexKeySum\n        val hexKeySum25 = hexKeySum24 * hexKeySum\n        val hexKeySum26 = hexKeySum25 * hexKeySum\n        val hexKeySum27 = hexKeySum26 * hexKeySum\n        val hexKeySum28 = hexKeySum27 * hexKeySum\n        val hexKeySum29 = hexKeySum28 * hexKeySum\n        val hexKeySum30 = hexKeySum29 * hexKeySum\n        val hexKeySum31 = hexKeySum30 * hexKeySum\n        \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa66mecfj.scala:62:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799366
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLen = hex.length\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLen = hexKey.length\n        val hexKeyLen2 = hexKeyLen * hexKeyLen\n        val hexKeyLen3 = hexKeyLen2 * hexKeyLen\n        val hexKeyLen4 = hexKeyLen3 * hexKeyLen\n        val hexKeyLen5 = hexKeyLen4 * hexKeyLen\n        val hexKeyLen6 = hexKeyLen5 * hexKeyLen\n        val hexKeyLen7 = hexKeyLen6 * hexKeyLen\n        val hexKeyLen8 = hexKeyLen7 * hexKeyLen\n        val hexKeyLen9 = hexKeyLen8 * hexKeyLen\n        val hexKeyLen10 = hexKeyLen9 * hexKeyLen\n        val hexKeyLen11 = hexKeyLen10 * hexKeyLen\n        val hexKeyLen12 = hexKeyLen11 * hexKeyLen\n        val hexKeyLen13 = hexKeyLen12 * hexKeyLen\n        val hexKeyLen14 = hexKeyLen13 * hexKeyLen\n        val hexKeyLen15 = hexKeyLen14 * hexKeyLen\n        val hexKeyLen16 = hexKeyLen15 * hexKeyLen\n        val hexKeyLen17 = hexKeyLen16 * hexKeyLen\n        val hexKeyLen18 = hexKeyLen17 * hexKeyLen\n        val hexKeyLen19 = hexKeyLen18 * hexKeyLen\n        val hexKeyLen20 = hexKeyLen19 * hexKeyLen\n        val hexKeyLen21 = hexKeyLen20 * hexKeyLen\n        val hexKeyLen22 = hexKeyLen21 * hexKeyLen\n        val hexKeyLen23 = hexKeyLen22 * hexKeyLen\n        val hexKeyLen24 = hexKeyLen23 * hexKeyLen\n        val hexKeyLen25 = hexKeyLen24 * hexKeyLen\n        val hexKeyLen26 = hexKeyLen25 * hexKeyLen\n        val hexKeyLen27 = hexKeyLen26 * hexKeyLen\n        val hexKeyLen28 = hexKeyLen27 * hexKeyLen\n        val hexKeyLen29 = hexKeyLen28 * hexKeyLen\n        val hexKeyLen30 = hexKeyLen29 * hexKeyLen\n        val hexKeyLen31 = hexKeyLen30 * hexKeyLen\n        val hexKeyLen32 = hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdpzspgjf.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => if (x.toInt <= 9) x.toInt else x.toInt + 10).toArray\n        val hexKeySet = hexKey.toSet\n        val hexKeySetSize = hexKeySet.size\n        val hexKeySetIterator = hexKeySet.iterator\n        val hexKeySetIteratorSize = hexKeySetIterator.size\n        val hexKeySetIteratorIterator = hexKeySetIterator.iterator\n        val hexKeySetIteratorIteratorSize = hexKeySetIteratorIterator.size\n        val hexKeySetIteratorIteratorIterator = hexKeySetIteratorIterator.iterator\n        val hexKeySetIteratorIteratorIteratorSize = hexKeySetIteratorIteratorIterator.size\n        val hexKeySetIteratorIteratorIteratorIterator = hexKeySetIteratorIteratorIterator.iterator\n        val hexKeySetIteratorIteratorIteratorIteratorSize = hexKeySetIteratorIteratorIteratorIterator.size\n        val hexKeySetIteratorIteratorIteratorIteratorIterator = hexKeySetIteratorIteratorIteratorIterator.iterator\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorSize = hexKeySetIteratorIteratorIteratorIteratorIterator.size\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIterator = hexKeySetIteratorIteratorIteratorIteratorIterator.iterator\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorSize = hexKeySetIteratorIteratorIteratorIteratorIteratorIterator.size\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIterator = hexKeySetIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = hexKeySetIteratorIteratorIteratorIteratorIteratorIterator.size\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n        val hexKeySet\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvi7kd4ft.scala:51:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvi7kd4ft.scala:48:112 -----------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\u001b[0m = hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNot found: hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvi7kd4ft.scala:49:116 -----------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\u001b[0m = hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNot found: hexKeySetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvi7kd4ft.scala:51:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659799369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = new mutable.HashMap[Char, Long]()\n        val hexKeyLength = new mutable.HashMap[Char, Long]()\n        var hexKeyLengthLength = 0\n        var hexKeyLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n        var hexKeyLengthLengthLengthLengthLengthLengthLengthLengthLengthLength\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzaj5baj5.scala:66:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzaj5baj5.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mhexKeyLengthLengthLengthLength\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLengthLengthLengthLength is already defined as \u001b[33mvariable\u001b[0m \u001b[35mhexKeyLengthLengthLengthLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzaj5baj5.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mhexKeyLengthLengthLengthLengthLength\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLengthLengthLengthLengthLength is already defined as \u001b[33mvariable\u001b[0m \u001b[35mhexKeyLengthLengthLengthLengthLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzaj5baj5.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mhexKeyLengthLengthLengthLengthLengthLength\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLengthLengthLengthLengthLengthLength is already defined as \u001b[33mvariable\u001b[0m \u001b[35mhexKeyLengthLengthLengthLengthLengthLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzaj5baj5.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mhexKeyLengthLengthLengthLengthLengthLengthLength\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[3",
      "stdout": "",
      "timestamp": 1659799368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey.map(x => x % 10)\n        val hexKey4 = hexKey.map(x => x % 10)\n        val hexKey5 = hexKey.map(x => x % 10)\n        val hexKey6 = hexKey.map(x => x % 10)\n        val hexKey7 = hexKey.map(x => x % 10)\n        val hexKey8 = hexKey.map(x => x % 10)\n        val hexKey9 = hexKey.map(x => x % 10)\n        val hexKey10 = hexKey.map(x => x % 10)\n        val hexKey11 = hexKey.map(x => x % 10)\n        val hexKey12 = hexKey.map(x => x % 10)\n        val hexKey13 = hexKey.map(x => x % 10)\n        val hexKey14 = hexKey.map(x => x % 10)\n        val hexKey15 = hexKey.map(x => x % 10)\n        val hexKey16 = hexKey.map(x => x % 10)\n        val hexKey17 = hexKey.map(x => x % 10)\n        val hexKey18 = hexKey.map(x => x % 10)\n        val hexKey19 = hexKey.map(x => x % 10)\n        val hexKey20 = hexKey.map(x => x % 10)\n        val hexKey21 = hexKey.map(x => x % 10)\n        val hexKey22 = hexKey.map(x => x % 10)\n        val hexKey23 = hexKey.map(x => x % 10)\n        val hexKey24 = hexKey.map(x => x % 10)\n        val hexKey25 = hexKey.map(x => x % 10)\n        val hexKey26 = hexKey.map(x => x % 10)\n        val hexKey27 = hexKey.map(x => x % 10)\n        val hexKey28 = hexKey.map(x => x % 10)\n        val hexKey29 = hexKey.map(x => x % 10)\n        val hexKey30 = hexKey.map(x => x % 10)\n        val hexKey31 = hexKey.map(x => x % 10)\n        val hexKey32 = hexKey.map(x => x % 10)\n        val hexKey33 = hexKey.map(x => x % 10)\n        val hexKey34 = hexKey.map(x => x % 10)\n        val hexKey35\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmabttmxu.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmabttmxu.scala:62:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toChar).map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwtyds1u8.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwtyds1u8.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwtyds1u8.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwtyds1u8.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwtyds1u8.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwtyds1u8.scala:32:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprime",
      "stdout": "",
      "timestamp": 1659799369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey.map(x => x % 10)\n        val hexKey4 = hexKey.map(x => x % 10)\n        val hexKey5 = hexKey.map(x => x % 10)\n        val hexKey6 = hexKey.map(x => x % 10)\n        val hexKey7 = hexKey.map(x => x % 10)\n        val hexKey8 = hexKey.map(x => x % 10)\n        val hexKey9 = hexKey.map(x => x % 10)\n        val hexKey10 = hexKey.map(x => x % 10)\n        val hexKey11 = hexKey.map(x => x % 10)\n        val hexKey12 = hexKey.map(x => x % 10)\n        val hexKey13 = hexKey.map(x => x % 10)\n        val hexKey14 = hexKey.map(x => x % 10)\n        val hexKey15 = hexKey.map(x => x % 10)\n        val hexKey16 = hexKey.map(x => x % 10)\n        val hexKey17 = hexKey.map(x => x % 10)\n        val hexKey18 = hexKey.map(x => x % 10)\n        val hexKey19 = hexKey.map(x => x % 10)\n        val hexKey20 = hexKey.map(x => x % 10)\n        val hexKey21 = hexKey.map(x => x % 10)\n        val hexKey22 = hexKey.map(x => x % 10)\n        val hexKey23 = hexKey.map(x => x % 10)\n        val hexKey24 = hexKey.map(x => x % 10)\n        val hexKey25 = hexKey.map(x => x % 10)\n        val hexKey26 = hexKey.map(x => x % 10)\n        val hexKey27 = hexKey.map(x => x % 10)\n        val hexKey28 = hexKey.map(x => x % 10)\n        val hexKey29 = hexKey.map(x => x % 10)\n        val hexKey30 = hexKey.map(x => x % 10)\n        val hexKey31 = hexKey.map(x => x % 10)\n        val hexKey32 = hexKey.map(x => x % 10)\n        val hexKey33 = hexKey.map(x => x % 10)\n        val hexKey34 = hexKey.map(x => x % 10)\n        val hexKey35\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmabttmxu.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmabttmxu.scala:62:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toHexString)\n        val hexCount = hex.count(hex.contains)\n        val hexDigits = hex.count(hex.contains)\n        val hexDigitPrimes = hexDigits.filter(_ % 2 == 0).count(hexDigits % 2 == 0)\n        val hexDigitPrimes2 = hexDigits.filter(_ % 2 == 0).count(hexDigits % 2 != 0)\n        val hexDigitPrimes3 = hexDigits.filter(_ % 3 == 0).count(hexDigits % 3 != 0)\n        val hexDigitPrimes4 = hexDigits.filter(_ % 4 == 0).count(hexDigits % 4 != 0)\n        val hexDigitPrimes5 = hexDigits.filter(_ % 5 == 0).count(hexDigits % 5 != 0)\n        val hexDigitPrimes6 = hexDigits.filter(_ % 6 == 0).count(hexDigits % 6 != 0)\n        val hexDigitPrimes7 = hexDigits.filter(_ % 7 == 0).count(hexDigits % 7 != 0)\n        val hexDigitPrimes8 = hexDigits.filter(_ % 8 == 0).count(hexDigits % 8 != 0)\n        val hexDigitPrimes9 = hexDigits.filter(_ % 9 == 0).count(hexDigits % 9 != 0)\n        val hexDigitPrimes10 = hexDigits.filter(_ % 10 == 0).count(hexDigits % 10 != 0)\n        val hexDigitPrimes11 = hexDigits.filter(_ % 11 == 0).count(hexDigits % 11 != 0)\n        val hexDigitPrimes12 = hexDigits.filter(_ % 12 == 0).count(hexDigits % 12 != 0)\n        val hexDigitPrimes13 = hexDigits.filter(_ % 13 == 0).count(hexDigits % 13 != 0)\n        val hexDigitPrimes14 = hexDigits.filter(_ % 14 == 0).count(hexDigits % 14 != 0)\n        val hexDigitPrimes15 = hexDigits.filter(_ % 15 == 0).count(hexDigits % 15 != 0)\n        val hexDigitPrimes16 = hexDigits.filter(_ % 16 == 0).count(hexDigits % 16 != 0)\n        val hexDigitPrimes17 = hexDigits.filter(_ % 17 == 0).count(hexDigits % 17 != 0)\n        val hexDigitPrimes18 = hexDigits.filter(_ % 18 == 0).count(hexDigits % 18 != 0)\n        val hexDigitPrimes19 = hexDigits.filter(_ % 19 == 0).count(hexDigits \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0nu9ynix.scala:48:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0nu9ynix.scala:26:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value toHexString is not a member of Char.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          longWrapper(_$1)\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0nu9ynix.scala:26:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0nu9ynix.scala:48:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659799371
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\").toList\n        val numsCount = nums.length\n        val hexDigits = nums.map(_.toInt)\n        val hexDigitsCount = hexDigits.length\n        val hexDigitsToInt = hexDigits.map(_.toInt)\n        val hexDigitsToIntCount = hexDigitsToInt.length\n        val hexDigitsToIntToInt = hexDigitsToInt.map(_.toInt)\n        val hexDigitsToIntToIntCount = hexDigitsToIntToInt.length\n        val hexDigitsToIntToIntToInt = hexDigitsToIntToInt.map(_.toInt)\n        val hexDigitsToIntToIntToIntCount = hexDigitsToIntToIntToInt.length\n        val hexDigitsToIntToIntToIntToInt = hexDigitsToIntToIntToInt.map(_.toInt)\n        val hexDigitsToIntToIntToIntToIntCount = hexDigitsToIntToIntToIntToInt.length\n        val hexDigitsToIntToIntToIntToIntToIntCount = hexDigitsToIntToIntToIntToIntToInt.length\n        val hexDigitsToIntToIntToIntToIntToIntCount = hexDigitsToIntToIntToIntToIntToIntToInt.length\n        val hexDigitsToIntToIntToIntToIntToIntToIntCount = hexDigitsToIntToIntToIntToIntToIntToIntToInt.length\n        val hexDigitsToIntToIntToIntToIntToIntToIntToIntCount = hexDigitsToIntToIntToIntToIntToIntToIntToIntToIntCount.toLong\n        val hexDigitsToIntToIntToIntToIntToIntToIntToIntToIntCount = hexDigitsToIntToIntToIntToIntToIntToIntToIntToIntToIntCount.toLong\n        val hexDigitsToIntToIntToIntToIntToIntToIntToIntToIntToIntCount = hexDigitsToIntToIntToIntToIntToIntToIntToIntToIntToIntToIntCount.toLong\n        val hexDigitsToIntToIntToIntToIntToIntToIntToIntToIntToIntToIntCount = hexDigitsToIntToIntToIntToIntTo\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaea96lfp.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToIntToIntToIntToIntToIntCount\u001b[0m = hexDigitsToIntToIntToIntToIntToIntToInt.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexDigitsToIntToIntToIntToIntToIntCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexDigitsToIntToIntToIntToIntToIntCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaea96lfp.scala:38:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToIntToIntToIntToIntToIntCount\u001b[0m = hexDigitsToIntToIntToIntToIntToInt.length\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: hexDigitsToIntToIntToIntToIntToInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaea96lfp.scala:40:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToIntToIntToIntToIntToIntToIntCount\u001b[0m = hexDigitsToIntToIntToIntToIntToIntToIntToInt.length\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: hexDigitsToIntToIntToIntToIntToIntToIntToInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaea96lfp.scala:44:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitsToIntToIntToIntToIntToIntToIntToIntToIntToIntToIntCount\u001b[0m = hexDigitsToIntToIntToIntToIntTo\n\u001b[31m\u001b[31m   |\u001b[0m                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[",
      "stdout": "",
      "timestamp": 1659799370
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexKey = hexCount.toLong\n        val hexDigits = hexKey.toInt\n        val hexDigitCount = hexDigits.toInt\n        val hexDigitPrimes = hexDigitPrimes(hexDigitCount)\n        val hexDigitPrimeCount = hexDigitPrimes.toInt\n        val hexDigitPrimePrimes = hexDigitPrimePrimes(hexDigitPrimeCount)\n        val hexDigitPrimePrimeCount = hexDigitPrimePrimes.toInt\n        val hexDigitPrimePrimePrimes = hexDigitPrimePrimePrimes(hexDigitPrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes(hexDigitPrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes(hexDigitPrimePrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimes(hexDigitPrimePrimePrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes(hexDigitPrimePrimePrimePrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes(hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes(hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePri\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpajt6jx0p.scala:31:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimes\u001b[0m = hexDigitPrimes(hexDigitCount)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpajt6jx0p.scala:33:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimes\u001b[0m = hexDigitPrimePrimes(hexDigitPrimeCount)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpajt6jx0p.scala:35:39 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimes(hexDigitPrimePrimeCount)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpajt6jx0p.scala:36:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimes(hexDigitPrimePrimePrimeCount)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajt6jx0p.scala:36:74 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePr",
      "stdout": "",
      "timestamp": 1659799370
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\")\n        val numsLength = nums.length\n        val primes = mutable.Set[Long]()\n        val primesLength = primes.size\n        val primesSet = primes.toSet\n        val primesSetLength = primesSet.length\n        val primesSetSet = primesSet.toSet\n        val primesSetSetLength = primesSetSet.length\n        val primesSetSetSet = primesSetSet.toSet\n        val primesSetSetSetLength = primesSetSetSet.length\n        val primesSetSetSetSet = primesSetSetSet.toSet\n        val primesSetSetSetSetLength = primesSetSetSetSet.length\n        val primesSetSetSetSetSet = primesSetSetSetSet.toSet\n        val primesSetSetSetSetSetLength = primesSetSetSetSetSet.length\n        val primesSetSetSetSetSetSet = primesSetSetSetSetSet.toSet\n        val primesSetSetSetSetSetSetLength = primesSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSet = primesSetSetSetSetSetSet.toSet\n        val primesSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSet = primesSetSetSetSetSetSetSetSet.toSet\n        val primesSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSetSetSet.length\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp69hwm6ci.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetLength\u001b[0m = primesSetSetSetSetSetSetSetSetSet.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetSetSetSetSetSetSetSetLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetSetSetSetSetSetSetSetLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp69hwm6ci.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetSetSetLength\u001b[0m = primesSetSetSetSetSetSetSetSetSetSetSetSet.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetSetSetSetSetSetSetSetSetSetLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetSetSetSetSetSetSetSetSetSetLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp69hwm6ci.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetSetSetSetLength\u001b[0m = primesSetSetSetSetSetSetSetSetSetSetSetSetSet.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetSetSetSetSetSetSetSetSetSetSetLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetSetSetSetSetSetSetSetSetSetSetLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp69hwm6ci.scala:28:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m",
      "stdout": "",
      "timestamp": 1659799369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLen = hexKey.length\n        val hexKeyLen2 = hexKeyLen / 2\n        val hexKeyLen3 = hexKeyLen / 3\n        val hexKeyLen4 = hexKeyLen / 4\n        val hexKeyLen5 = hexKeyLen / 5\n        val hexKeyLen6 = hexKeyLen / 6\n        val hexKeyLen7 = hexKeyLen / 7\n        val hexKeyLen8 = hexKeyLen / 8\n        val hexKeyLen9 = hexKeyLen / 9\n        val hexKeyLen10 = hexKeyLen / 10\n        val hexKeyLen11 = hexKeyLen / 11\n        val hexKeyLen12 = hexKeyLen / 12\n        val hexKeyLen13 = hexKeyLen / 13\n        val hexKeyLen14 = hexKeyLen / 14\n        val hexKeyLen15 = hexKeyLen / 15\n        val hexKeyLen16 = hexKeyLen / 16\n        val hexKeyLen17 = hexKeyLen / 17\n        val hexKeyLen18 = hexKeyLen / 18\n        val hexKeyLen19 = hexKeyLen / 19\n        val hexKeyLen20 = hexKeyLen / 20\n        val hexKeyLen21 = hexKeyLen / 21\n        val hexKeyLen22 = hexKeyLen / 22\n        val hexKeyLen23 = hexKeyLen / 23\n        val hexKeyLen24 = hexKeyLen / 24\n        val hexKeyLen25 = hexKeyLen / 25\n        val hexKeyLen26 = hexKeyLen / 26\n        val hexKeyLen27 = hexKeyLen / 27\n        val hexKeyLen28 = hexKeyLen / 28\n        val hexKeyLen29 = hexKeyLen / 29\n        val hexKeyLen30 = hexKeyLen / 30\n        val hexKeyLen31 = hexKeyLen / 31\n        val hexKeyLen32 = hexKeyLen / 32\n        val hexKeyLen33 = hexKeyLen / 33\n        val hexKeyLen34 = hexKeyLen / 34\n        val hexKeyLen35 = hexKeyLen / 35\n        val hexKeyLen36 = hexKeyLen / 36\n        val hexKeyLen37 = hexKeyLen / 37\n        val hexKeyLen38 = hexKeyLen / 38\n        val hexKeyLen39 = hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9tu1k_dr.scala:67:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799371
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0)((acc, x) => acc * 16 + x)\n        hexKey % 10\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8boyj_k8.scala:31)\n\tat Problem.main(tmp8boyj_k8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799372
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val numArray = num.toCharArray.map(_.toInt)\n        val primes = mutable.Set[Int]()\n        val primesSet = mutable.Set[Int]()\n        val primesArray = mutable.Array[Int]()\n        val primesArraySet = mutable.Array[Int]()\n        val primesArraySet2 = mutable.Array[Int]()\n        val primesArraySet3 = mutable.Array[Int]()\n        val primesArraySet4 = mutable.Array[Int]()\n        val primesArraySet5 = mutable.Array[Int]()\n        val primesArraySet6 = mutable.Array[Int]()\n        val primesArraySet7 = mutable.Array[Int]()\n        val primesArraySet8 = mutable.Array[Int]()\n        val primesArraySet9 = mutable.Array[Int]()\n        val primesArraySet10 = mutable.Array[Int]()\n        val primesArraySet11 = mutable.Array[Int]()\n        val primesArraySet12 = mutable.Array[Int]()\n        val primesArraySet13 = mutable.Array[Int]()\n        val primesArraySet14 = mutable.Array[Int]()\n        val primesArraySet15 = mutable.Array[Int]()\n        val primesArraySet16 = mutable.Array[Int]()\n        val primesArraySet17 = mutable.Array[Int]()\n        val primesArraySet18 = mutable.Array[Int]()\n        val primesArraySet19 = mutable.Array[Int]()\n        val primesArraySet20 = mutable.Array[Int]()\n        val primesArraySet21 = mutable.Array[Int]()\n        val primesArraySet22 = mutable.Array[Int]()\n        val primesArraySet23 = mutable.Array[Int]()\n        val primesArraySet24 = mutable.Array[Int]()\n        val primesArraySet25 = mutable.Array[Int]()\n        val primesArraySet26 = mutable.Array[Int]()\n        val primesArraySet27 = mutable.Array[Int]()\n        val primesArraySet28 = mutable.Array[Int]()\n        val primesArraySet29 = mutable.Array[Int]()\n        val primesArray\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_dmv4br2.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dmv4br2.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dmv4br2.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dmv4br2.scala:29:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesArray\u001b[0m = mutable.Array[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dmv4br2.scala:30:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesArraySet\u001b[0m = mutable.Array[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dmv4br2.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesArraySet2\u001b[0m = mutable.Array[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |",
      "stdout": "",
      "timestamp": 1659799371
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.map(x => x % 16).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpeayndqw2.scala:31)\n\tat Problem.main(tmpeayndqw2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799373
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.filter(_ >= '0' && _ <= '9').length\n        val hexDigits = hex.filter(_ >= 'A' && _ <= 'F').length\n        val hexPrimes = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime2 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime3 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime4 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime5 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime6 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime7 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime8 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime9 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime10 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime11 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime12 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime13 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime14 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime15 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime16 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime17 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime18 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime19 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime20 = hex.filter(_ >= '2' && _ <= '7').length\n        val hexPrime21 = hex.filter(_ >= '2' && \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpuyhc18ve.scala:50:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPrime21\u001b[0m = hex.filter(_ >= \u001b[31m'2'\u001b[0m && \n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpuyhc18ve.scala:27:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <= \u001b[31m'9'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpuyhc18ve.scala:28:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigits\u001b[0m = hex.filter(_ >= \u001b[31m'A'\u001b[0m && _ <= \u001b[31m'F'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpuyhc18ve.scala:29:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPrimes\u001b[0m = hex.filter(_ >= \u001b[31m'2'\u001b[0m && _ <= \u001b[31m'7'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpuyhc18ve.scala:30:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPrime\u001b[0m = hex.filter(_ >= \u001b[31m'2'\u001b[0m && _ <= \u001b[31m'7'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpuyhc18ve.scala:31:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0",
      "stdout": "",
      "timestamp": 1659799372
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.toCharArray\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet34 = mut\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3t8w8_2l.scala:32:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprime",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexStr = hex.mkString(\"\")\n        val hexLen = hexStr.length\n        val hexKey = hexLen / 2\n        val hexKey2 = hexLen - hexKey\n        val hexKey3 = hexKey2 * hexKey2\n        val hexKey4 = hexKey3 * hexKey3\n        val hexKey5 = hexKey4 * hexKey4\n        val hexKey6 = hexKey5 * hexKey5\n        val hexKey7 = hexKey6 * hexKey6\n        val hexKey8 = hexKey7 * hexKey7\n        val hexKey9 = hexKey8 * hexKey8\n        val hexKey10 = hexKey9 * hexKey9\n        val hexKey11 = hexKey10 * hexKey10\n        val hexKey12 = hexKey11 * hexKey11\n        val hexKey13 = hexKey12 * hexKey12\n        val hexKey14 = hexKey13 * hexKey13\n        val hexKey15 = hexKey14 * hexKey14\n        val hexKey16 = hexKey15 * hexKey15\n        val hexKey17 = hexKey16 * hexKey16\n        val hexKey18 = hexKey17 * hexKey17\n        val hexKey19 = hexKey18 * hexKey18\n        val hexKey20 = hexKey19 * hexKey19\n        val hexKey21 = hexKey20 * hexKey20\n        val hexKey22 = hexKey21 * hexKey21\n        val hexKey23 = hexKey22 * hexKey22\n        val hexKey24 = hexKey23 * hexKey23\n        val hexKey25 = hexKey24 * hexKey24\n        val hexKey26 = hexKey25 * hexKey25\n        val hexKey27 = hexKey26 * hexKey26\n        val hexKey28 = hexKey27 * hexKey27\n        val hexKey29 = hexKey28 * hexKey28\n        val hexKey30 = hexKey29 * hexKey29\n        val hexKey31 = hexKey30 * hexKey30\n        val hexKey32 = hexKey31 * hexKey31\n        val hexKey33 = hexKey32 * hexKey32\n        val hexKey34 = hexKey33 * hexKey33\n        val hexKey35 = hexKey34 * hexKey34\n        val hexKey36 = hexKey35 * hexKey35\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuyrf50l1.scala:65:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799372
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexDigits = hexString.length\n        val hexDigitCount = hexDigits.toInt\n        val hexDigitPrimes = hexDigitPrimes(hexDigitCount)\n        val hexDigitPrimeCount = hexDigitPrimes.toInt\n        val hexDigitPrimePrimes = hexDigitPrimePrimes(hexDigitPrimeCount)\n        val hexDigitPrimePrimeCount = hexDigitPrimePrimes.toInt\n        val hexDigitPrimePrimePrimes = hexDigitPrimePrimePrimes(hexDigitPrimePrimeCount)\n        val hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.toInt\n        val hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes(hexDigitPrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.toInt\n        val hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes(hexDigitPrimePrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.toInt\n        val hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimes(hexDigitPrimePrimePrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.toInt\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes(hexDigitPrimePrimePrimePrimePrimePrimePrimeCount)\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.toInt\n        val hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPri\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1c_xb6a7.scala:30:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimes\u001b[0m = hexDigitPrimes(hexDigitCount)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1c_xb6a7.scala:32:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimes\u001b[0m = hexDigitPrimePrimes(hexDigitPrimeCount)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1c_xb6a7.scala:34:39 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimes(hexDigitPrimePrimeCount)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1c_xb6a7.scala:36:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimes\u001b[0m = hexDigitPrimePrimePrimePrimes(hexDigitPrimePrimePrimeCount)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexDigitPrimePrimePrimePrimes\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1c_xb6a7.scala:38:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigitPrimePrimePrimePrimePrimes\u001b[0m = hexDigitPrimePr",
      "stdout": "",
      "timestamp": 1659799371
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.foldLeft(0L){\n            case (acc, c) => acc + (c match {\n                case 'A' => 10\n                case 'B' => 11\n                case 'C' => 12\n                case 'D' => 13\n                case 'E' => 14\n                case 'F' => 15\n                case _ => c.toInt\n            })\n        }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpq8asom54.scala:41)\n\tat Problem.main(tmpq8asom54.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799372
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\")\n        val primes = mutable.ArrayBuffer(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val primesCount = primes.toList.length\n        val hexDigits = mutable.ArrayBuffer(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40)\n        val hexDigitsCount = hexDigits.length\n        val hexKey = 0\n        for(i <- 0 until hexDigitsCount) {\n            val hexDigit = hexDigits(i)\n            val hexDigitCount = nums.length\n            for(j <- 0 until hexDigitCount) {\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(i)\n                val hexDigitValue = hexDigits(j)\n                val hexDigitValue = hexDigits(\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpcqw8m68w.scala:70:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mhexDigitValue\u001b[0m = hexDigits(\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcqw8m68w.scala:82:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcqw8m68w.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.ArrayBuffer(\u001b[31m2\u001b[0m, \u001b[31m3\u001b[0m, \u001b[31m5\u001b[0m, \u001b[31m7\u001b[0m, \u001b[31m11\u001b[0m, \u001b[31m13\u001b[0m, \u001b[31m17\u001b[0m, \u001b[31m19\u001b[0m, \u001b[31m23\u001b[0m, \u001b[31m29\u001b[0m, \u001b[31m31\u001b[0m, \u001b[31m37\u001b[0m, \u001b[31m41\u001b[0m, \u001b[31m43\u001b[0m, \u001b[31m47\u001b[0m, \u001b[31m53\u001b[0m, \u001b[31m59\u001b[0m, \u001b[31m61\u001b[0m, \u001b[31m67\u001b[0m, \u001b[31m71\u001b[0m, \u001b[31m73\u001b[0m, \u001b[31m79\u001b[0m, \u001b[31m83\u001b[0m, \u001b[31m89\u001b[0m, \u001b[31m97\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcqw8m68w.scala:29:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexDigits\u001b[0m = mutable.ArrayBuffer(\u001b[31m0\u001b[0m, \u001b[31m1\u001b[0m, \u001b[31m2\u001b[0m, \u001b[31m3\u001b[0m, \u001b[31m4\u001b[0m, \u001b[31m5\u001b[0m, \u001b[31m6\u001b[0m, \u001b[31m7\u001b[0m, \u001b[31m8\u001b[0m, \u001b[31m9\u001b[0m, \u001b[31m10\u001b[0m, \u001b[31m11\u001b[0m, \u001b[31m12\u001b[0m, \u001b[31m13\u001b[0m, \u001b[31m14\u001b[0m, \u001b[31m15\u001b[0m, \u001b[31m16\u001b[0m, \u001b[31m17\u001b[0m, \u001b[31m18\u001b[0m, \u001b[31m19\u001b[0m, \u001b[31m20\u001b[0m, \u001b[31m21\u001b[0m, \u001b[31m22\u001b[0m, \u001b[31m23\u001b[0m, \u001b[31m24\u001b[0m, \u001b[31m25\u001b[0m, \u001b[31m26\u001b[0m, \u001b[31m27\u001b[0m, \u001b[31m28\u001b[0m, \u001b[31m29\u001b[0m, \u001b[31m30\u001b[0m, \u001b[31m31\u001b[0m, \u001b[31m32\u001b[0m, \u001b[31m33\u001b[0m, \u001b[31m34\u001b[0m, \u001b[31m35\u001b[0m, \u001b[31m36\u001b[0m, \u001b[31m37\u001b[0m, \u001b[31m38\u001b[0m, \u001b[31m39\u001b[0m, \u001b[31m40\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m",
      "stdout": "",
      "timestamp": 1659799371
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.foldLeft(0l){\n            (acc, c) => acc + (if (c.toInt >= 'A' && c.toInt <= 'F') c.toInt - 'A' + 10 else c.toInt - '0')\n        }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqxs44zyy.scala:33)\n\tat Problem.main(tmpqxs44zyy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799376
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexMap = new mutable.HashMap[Int, Int]()\n        val hexMap2 = new mutable.HashMap[Int, Int]()\n        val hexMap3 = new mutable.HashMap[Int, Int]()\n        val hexMap4 = new mutable.HashMap[Int, Int]()\n        val hexMap5 = new mutable.HashMap[Int, Int]()\n        val hexMap6 = new mutable.HashMap[Int, Int]()\n        val hexMap7 = new mutable.HashMap[Int, Int]()\n        val hexMap8 = new mutable.HashMap[Int, Int]()\n        val hexMap9 = new mutable.HashMap[Int, Int]()\n        val hexMap10 = new mutable.HashMap[Int, Int]()\n        val hexMap11 = new mutable.HashMap[Int, Int]()\n        val hexMap12 = new mutable.HashMap[Int, Int]()\n        val hexMap13 = new mutable.HashMap[Int, Int]()\n        val hexMap14 = new mutable.HashMap[Int, Int]()\n        val hexMap15 = new mutable.HashMap[Int, Int]()\n        val hexMap16 = new mutable.HashMap[Int, Int]()\n        val hexMap17 = new mutable.HashMap[Int, Int]()\n        val hexMap18 = new mutable.HashMap[Int, Int]()\n        val hexMap19 = new mutable.HashMap[Int, Int]()\n        val hexMap20 = new mutable.HashMap[Int, Int]()\n        val hexMap21 = new mutable.HashMap[Int, Int]()\n        val hexMap22 = new mutable.HashMap[Int, Int]()\n        val hexMap23 = new mutable.HashMap[Int, Int]()\n        val hexMap24 = new mutable.HashMap[Int, Int]()\n        val hexMap25 = new mutable.HashMap[Int, Int]()\n        val hexMap26 = new mutable.HashMap[Int, Int]()\n        val hexMap27 = new mutable.HashMap[Int, Int]()\n        val hexMap28 = new mutable.HashMap[Int, Int]()\n        val hexMap29 = new mutable.HashMap[Int, Int]()\n        val hexMap30 = new mutable.HashMap[Int, Int]()\n        val hexMap31 = new mutable.HashMap[Int, Int]()\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_8rfyd_i.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_8rfyd_i.scala:29:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_8rfyd_i.scala:30:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexMap3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_8rfyd_i.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexMap4\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_8rfyd_i.scala:32:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexMap5\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling wi",
      "stdout": "",
      "timestamp": 1659799375
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyMap = hexKey.toMap\n        val hexKeyMap2 = hexKeyMap.filter(_._2 % 2 == 0)\n        val hexKeyMap3 = hexKeyMap2.filter(_._2 % 3 == 0)\n        val hexKeyMap4 = hexKeyMap3.filter(_._2 % 5 == 0)\n        val hexKeyMap5 = hexKeyMap4.filter(_._2 % 7 == 0)\n        val hexKeyMap6 = hexKeyMap5.filter(_._2 % 11 == 0)\n        val hexKeyMap7 = hexKeyMap6.filter(_._2 % 13 == 0)\n        val hexKeyMap8 = hexKeyMap7.filter(_._2 % 17 == 0)\n        val hexKeyMap9 = hexKeyMap8.filter(_._2 % 19 == 0)\n        val hexKeyMap10 = hexKeyMap9.filter(_._2 % 23 == 0)\n        val hexKeyMap11 = hexKeyMap10.filter(_._2 % 29 == 0)\n        val hexKeyMap12 = hexKeyMap11.filter(_._2 % 31 == 0)\n        val hexKeyMap13 = hexKeyMap12.filter(_._2 % 37 == 0)\n        val hexKeyMap14 = hexKeyMap13.filter(_._2 % 41 == 0)\n        val hexKeyMap15 = hexKeyMap14.filter(_._2 % 43 == 0)\n        val hexKeyMap16 = hexKeyMap15.filter(_._2 % 47 == 0)\n        val hexKeyMap17 = hexKeyMap16.filter(_._2 % 51 == 0)\n        val hexKeyMap18 = hexKeyMap17.filter(_._2 % 53 == 0)\n        val hexKeyMap19 = hexKeyMap18.filter(_._2 % 57 == 0)\n        val hexKeyMap20 = hexKeyMap19.filter(_._2 % 61 == 0)\n        val hexKeyMap21 = hexKeyMap20.filter(_._2 % 67 == 0)\n        val hexKeyMap22 = hexKeyMap21.filter(_._2 % 71 == 0)\n        val hexKeyMap23 = hexKeyMap22.filter(_._2 % 73 == 0)\n        val hexKeyMap24 = hexKeyMap23.filter(_._2 % 79 == 0)\n        val hexKeyMap25 = hexKeyMap24.filter(_._2 % 83 == 0)\n        val hexKeyMap26 = hexKeyMap25.filter(_\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpco5lga3d.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpco5lga3d.scala:28:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap\u001b[0m = hexKey.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Cannot prove that Int <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                    where:    K is a type variable\n\u001b[31m   |\u001b[0m                                              V is a type variable\n\u001b[31m   |\u001b[0m                                    .\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpco5lga3d.scala:53:45 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap26\u001b[0m = hexKeyMap25.filter(_\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m  Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  I could not infer the type of the parameter _$25 of expanded function:\n\u001b[31m   |\u001b[0m  _$25 => hexKeyMap25.filter(_$25).\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpco5lga3d.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659799379
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexKey = (hexString.toLong / (hexString.toLong / 16)).toLong\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpah2iuztz.scala:32)\n\tat Problem.main(tmpah2iuztz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799380
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toChar).map(_.toInt)\n        val hexKey = hex.map(x => (x % 16))\n        val hexKeyList = hexKey.toList\n        val hexKeyList2 = hexKey.toList\n        val hexKeyList3 = hexKey.toList\n        val hexKeyList4 = hexKey.toList\n        val hexKeyList5 = hexKey.toList\n        val hexKeyList6 = hexKey.toList\n        val hexKeyList7 = hexKey.toList\n        val hexKeyList8 = hexKey.toList\n        val hexKeyList9 = hexKey.toList\n        val hexKeyList10 = hexKey.toList\n        val hexKeyList11 = hexKey.toList\n        val hexKeyList12 = hexKey.toList\n        val hexKeyList13 = hexKey.toList\n        val hexKeyList14 = hexKey.toList\n        val hexKeyList15 = hexKey.toList\n        val hexKeyList16 = hexKey.toList\n        val hexKeyList17 = hexKey.toList\n        val hexKeyList18 = hexKey.toList\n        val hexKeyList19 = hexKey.toList\n        val hexKeyList20 = hexKey.toList\n        val hexKeyList21 = hexKey.toList\n        val hexKeyList22 = hexKey.toList\n        val hexKeyList23 = hexKey.toList\n        val hexKeyList24 = hexKey.toList\n        val hexKeyList25 = hexKey.toList\n        val hexKeyList26 = hexKey.toList\n        val hexKeyList27 = hexKey.toList\n        val hexKeyList28 = hexKey.toList\n        val hexKeyList29 = hexKey.toList\n        val hexKeyList30 = hexKey.toList\n        val hexKeyList31 = hexKey.toList\n        val hexKeyList32 = hexKey.toList\n        val hexKeyList33 = hexKey.toList\n        val hexKeyList34 = hexKey.toList\n        val hexKeyList35 = hexKey.toList\n        val hexKeyList36 = hexKey.toList\n        val hexKeyList37 = hexKey.toList\n        val hexKeyList38 = hexKey.toList\n        val hexKeyList39 = hexKey.toList\n        val hexKeyList40 = hexKey.toList\n        val hexKeyList41 = hexKey.toList\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbeg3nt64.scala:69:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbeg3nt64.scala:70:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799379
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\").toList\n        val hexNum = nums.map(_.toInt)\n        val hexNums = hexNum.map(x => hexToBinary(x))\n        val primes = hexNums.filter(x => isPrime(x)).map(x => x.toInt)\n        val primesCount = primes.count\n        val hexNumsCount = hexNums.count\n        val hexNumsCount2 = hexNumsCount.toInt\n        val hexNumsCount3 = hexNumsCount2.toInt\n        val hexNumsCount4 = hexNumsCount3.toInt\n        val hexNumsCount5 = hexNumsCount4.toInt\n        val hexNumsCount6 = hexNumsCount5.toInt\n        val hexNumsCount7 = hexNumsCount6.toInt\n        val hexNumsCount8 = hexNumsCount7.toInt\n        val hexNumsCount9 = hexNumsCount8.toInt\n        val hexNumsCount10 = hexNumsCount9.toInt\n        val hexNumsCount11 = hexNumsCount10.toInt\n        val hexNumsCount12 = hexNumsCount11.toInt\n        val hexNumsCount13 = hexNumsCount12.toInt\n        val hexNumsCount14 = hexNumsCount13.toInt\n        val hexNumsCount15 = hexNumsCount14.toInt\n        val hexNumsCount16 = hexNumsCount15.toInt\n        val hexNumsCount17 = hexNumsCount16.toInt\n        val hexNumsCount18 = hexNumsCount17.toInt\n        val hexNumsCount19 = hexNumsCount18.toInt\n        val hexNumsCount20 = hexNumsCount19.toInt\n        val hexNumsCount21 = hexNumsCount20.toInt\n        val hexNumsCount22 = hexNumsCount21.toInt\n        val hexNumsCount23 = hexNumsCount22.toInt\n        val hexNumsCount24 = hexNumsCount23.toInt\n        val hexNumsCount25 = hexNumsCount24.toInt\n        val hexNumsCount26 = hexNumsCount25.toInt\n        val hexNumsCount27 = hexNumsCount26.toInt\n        val hexNumsCount28 = hexNumsCount27.toInt\n        val hexNumsCount\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4ltilbmy.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4ltilbmy.scala:28:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexNums\u001b[0m = hexNum.map(\u001b[36mx\u001b[0m => hexToBinary(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: hexToBinary\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4ltilbmy.scala:29:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = hexNums.filter(\u001b[36mx\u001b[0m => isPrime(x)).map(\u001b[36mx\u001b[0m => x.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4ltilbmy.scala:29:64 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = hexNums.filter(\u001b[36mx\u001b[0m => isPrime(x)).map(\u001b[36mx\u001b[0m => x.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4ltilbmy.",
      "stdout": "",
      "timestamp": 1659799381
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.toCharArray.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val prime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpac19xj6k.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac19xj6k.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac19xj6k.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac19xj6k.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac19xj6k.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac19xj6k.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799381
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyMap = hexKey.toMap\n        val hexKeyMap2 = hexKeyMap.map(x => (x._1, x._2))\n        val hexKeyMap3 = hexKeyMap2.map(x => (x._1, x._2))\n        val hexKeyMap4 = hexKeyMap3.map(x => (x._1, x._2))\n        val hexKeyMap5 = hexKeyMap4.map(x => (x._1, x._2))\n        val hexKeyMap6 = hexKeyMap5.map(x => (x._1, x._2))\n        val hexKeyMap7 = hexKeyMap6.map(x => (x._1, x._2))\n        val hexKeyMap8 = hexKeyMap7.map(x => (x._1, x._2))\n        val hexKeyMap9 = hexKeyMap8.map(x => (x._1, x._2))\n        val hexKeyMap10 = hexKeyMap9.map(x => (x._1, x._2))\n        val hexKeyMap11 = hexKeyMap10.map(x => (x._1, x._2))\n        val hexKeyMap12 = hexKeyMap11.map(x => (x._1, x._2))\n        val hexKeyMap13 = hexKeyMap12.map(x => (x._1, x._2))\n        val hexKeyMap14 = hexKeyMap13.map(x => (x._1, x._2))\n        val hexKeyMap15 = hexKeyMap14.map(x => (x._1, x._2))\n        val hexKeyMap16 = hexKeyMap15.map(x => (x._1, x._2))\n        val hexKeyMap17 = hexKeyMap16.map(x => (x._1, x._2))\n        val hexKeyMap18 = hexKeyMap17.map(x => (x._1, x._2))\n        val hexKeyMap19 = hexKeyMap18.map(x => (x._1, x._2))\n        val hexKeyMap20 = hexKeyMap19.map(x => (x._1, x._2))\n        val hexKeyMap21 = hexKeyMap20.map(x => (x._1, x._2))\n        val hexKeyMap22 = hexKeyMap21.map(x => (x._1, x._2))\n        val hexKeyMap23 = hexKeyMap22.map(x => (x._1, x._2))\n        val hexKeyMap24 = hexKeyMap23.map(x => (x._1, x._2))\n        val hexKeyMap25 = hex\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp17yrv6yq.scala:28:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap\u001b[0m = hexKey.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Cannot prove that Int <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                    where:    K is a type variable\n\u001b[31m   |\u001b[0m                                              V is a type variable\n\u001b[31m   |\u001b[0m                                    .\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp17yrv6yq.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799380
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\").toList\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet34\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjp823s52.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjp823s52.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjp823s52.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjp823s52.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjp823s52.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjp823s52.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799380
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = new mutable.HashMap[Int, Long]()\n        val primes = mutable.ArrayBuffer(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val primesSet = primes.toSet\n        val primesSetIterator = primes.iterator\n        val primesSetIteratorNext = primesSetIterator.next\n        val primesSetIteratorNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n        val primesSetIteratorNextNextNextNextNextNextNextNextNextNextNextNextNext = primesSetIterator.next\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1rvqq49r.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetIteratorNextNextNextNextNextNextNextNext\u001b[0m = primesSetIterator.next\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetIteratorNextNextNextNextNextNextNextNext is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetIteratorNextNextNextNextNextNextNextNext\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1rvqq49r.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetIteratorNextNextNextNextNextNextNextNextNext\u001b[0m = primesSetIterator.next\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetIteratorNextNextNextNextNextNextNextNextNext is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetIteratorNextNextNextNextNextNextNextNextNext\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1rvqq49r.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetIteratorNextNextNextNextNextNextNextNextNextNextNext\u001b[0m = primesSetIterator.next\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetIteratorNextNextNextNextNextNextNextNextNextNextNext is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetIteratorNextNextNextNextNextNextNextNextNextNextNext\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1rvqq49r.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetIteratorNextNextNextNextNext",
      "stdout": "",
      "timestamp": 1659799380
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyArray = hexKey.toArray\n        val hexKeyArrayLength = hexKeyArray.length\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7462iznx.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7462iznx.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7462iznx.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7462iznx.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7462iznx.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        ",
      "stdout": "",
      "timestamp": 1659799382
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLen = hex.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKeyLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLenLenLenLenLenLenLenLen\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppid4f3rd.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppid4f3rd.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLenLenLenLenLenLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppid4f3rd.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLenLenLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLenLenLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLenLenLenLenLenLenLenLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppid4f3rd.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLenLenLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLenLenLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLenLenLenLenLenLenLenLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppid4f3rd.scala:42:12 ---------------------------\u001b[0",
      "stdout": "",
      "timestamp": 1659799382
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.foldLeft(0l){ (sum, digit) =>\n            val hexDigit = digit % 16\n            val hexDigit2 = hexDigit % 16\n            val hexDigit3 = hexDigit2 % 16\n            val hexDigit4 = hexDigit3 % 16\n            val hexDigit5 = hexDigit4 % 16\n            val hexDigit6 = hexDigit5 % 16\n            val hexDigit7 = hexDigit6 % 16\n            val hexDigit8 = hexDigit7 % 16\n            val hexDigit9 = hexDigit8 % 16\n            val hexDigit10 = hexDigit9 % 16\n            val hexDigit11 = hexDigit10 % 16\n            val hexDigit12 = hexDigit11 % 16\n            val hexDigit13 = hexDigit12 % 16\n            val hexDigit14 = hexDigit13 % 16\n            val hexDigit15 = hexDigit14 % 16\n            val hexDigit16 = hexDigit15 % 16\n            val hexDigit17 = hexDigit16 % 16\n            val hexDigit18 = hexDigit17 % 16\n            val hexDigit19 = hexDigit18 % 16\n            val hexDigit20 = hexDigit19 % 16\n            val hexDigit21 = hexDigit20 % 16\n            val hexDigit22 = hexDigit21 % 16\n            val hexDigit23 = hexDigit22 % 16\n            val hexDigit24 = hexDigit23 % 16\n            val hexDigit25 = hexDigit24 % 16\n            val hexDigit26 = hexDigit25 % 16\n            val hexDigit27 = hexDigit26 % 16\n            val hexDigit28 = hexDigit27 % 16\n            val hexDigit29 = hexDigit28 % 16\n            val hexDigit30 = hexDigit29 % 16\n            val hexDigit31 = hexDigit30 % 16\n            val hexDigit32 = hexDigit31 % 16\n            val hexDigit33 = hexDigit32 % 16\n            val hexDigit34 = hexDigit33 % 16\n            val hexDigit35 = hexDigit34 % 16\n            val hexDigit36 = hexDigit35 % 16\n            val hexDigit37 = hexDigit36 % 16\n            val hexDigit38 = hexDigit37 % 16\n            val hexDigit39 = hexDigit38 % 16\n            val hexDigit40 = hexDigit39 % 16\n            val hexDigit41 = hexDigit40 % \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpkzech0ni.scala:68:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mhexDigit41\u001b[0m = hexDigit40 % \n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkzech0ni.scala:80:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkzech0ni.scala:69:4 ---------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    Found:    Unit\n\u001b[31m   |\u001b[0m    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpkzech0ni.scala:71:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    assert(hexKey((\u001b[31m\"AB\"\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpkzech0ni.scala:72:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    assert(hexKey((\u001b[31m\"1077E\"\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpkzech0ni.scala:73:11 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    assert(hexKey((\u001b[31m\"ABED1A33\"\u001b[0m)) == (\u001b[31m4l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mvalue\u001b[0m \u001b[35mhexKey\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] ",
      "stdout": "",
      "timestamp": 1659799383
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.foldLeft(0L) {\n            (acc, x) => acc + (if (x == 0) 1 else (x % 10) * Math.pow(10, (hex.length - 1 - x)))\n        }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpikyv5ief.scala:28:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            (\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc + (\u001b[33mif\u001b[0m (x == \u001b[31m0\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m (x % \u001b[31m10\u001b[0m) * Math.pow(\u001b[31m10\u001b[0m, (hex.length - \u001b[31m1\u001b[0m - x)))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    Double\n\u001b[31m   |\u001b[0m                        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799382
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt_4qywzl.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexKey = hex.map(x => x % 16).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6751qi7a.scala:31)\n\tat Problem.main(tmp6751qi7a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799383
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexLen = hex.length\n        val hexKey = hex.map(x => (x % 16).toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(x => x.toChar).map(x => x.toInt).map(x => x % 16).map(\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpy7_2632d.scala:28:1278 -------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.map(\u001b[36mx\u001b[0m => (x % \u001b[31m16\u001b[0m).toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % \u001b[31m16\u001b[0m).map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt).map(\u001b[36mx\u001b[0m => x % ",
      "stdout": "",
      "timestamp": 1659799382
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt_4qywzl.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toUpperCase)\n        val hexMap = hex.map(x => (x.toInt, 1)).toMap\n        val hexKeys = hex.map(x => hexMap.getOrElse(x, 0l))\n        hexKeys.reduceLeft(_ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc4_en1rb.scala:28:52 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeys\u001b[0m = hex.map(\u001b[36mx\u001b[0m => hexMap.getOrElse(x, \u001b[31m0l\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (x : String)\n\u001b[31m   |\u001b[0m                                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc4_en1rb.scala:29:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        hexKeys.reduceLeft(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of AnyVal, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799384
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexLength = hexString.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKeyList = hexString.toList.map(_.toInt)\n        val hexKeyListLength = hexKeyList.length\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyListLength = hexKeyListLength - 1\n        val hexKeyList\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp77__gu3e.scala:69:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp77__gu3e.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp77__gu3e.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp77__gu3e.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp77__gu3e.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be def",
      "stdout": "",
      "timestamp": 1659799384
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.map(x => (x % 16).toLong)\n        val hexKeyMap = hexKey.toMap\n        val hexKeyMap2 = hexKeyMap.filter(_._2 % 2 == 0)\n        val hexKeyMap3 = hexKeyMap2.filter(_._2 % 3 == 0)\n        val hexKeyMap4 = hexKeyMap3.filter(_._2 % 5 == 0)\n        val hexKeyMap5 = hexKeyMap4.filter(_._2 % 7 == 0)\n        val hexKeyMap6 = hexKeyMap5.filter(_._2 % 11 == 0)\n        val hexKeyMap7 = hexKeyMap6.filter(_._2 % 13 == 0)\n        val hexKeyMap8 = hexKeyMap7.filter(_._2 % 17 == 0)\n        val hexKeyMap9 = hexKeyMap8.filter(_._2 % 19 == 0)\n        val hexKeyMap10 = hexKeyMap9.filter(_._2 % 23 == 0)\n        val hexKeyMap11 = hexKeyMap10.filter(_._2 % 29 == 0)\n        val hexKeyMap12 = hexKeyMap11.filter(_._2 % 31 == 0)\n        val hexKeyMap13 = hexKeyMap12.filter(_._2 % 37 == 0)\n        val hexKeyMap14 = hexKeyMap13.filter(_._2 % 41 == 0)\n        val hexKeyMap15 = hexKeyMap14.filter(_._2 % 43 == 0)\n        val hexKeyMap16 = hexKeyMap15.filter(_._2 % 47 == 0)\n        val hexKeyMap17 = hexKeyMap16.filter(_._2 % 51 == 0)\n        val hexKeyMap18 = hexKeyMap17.filter(_._2 % 53 == 0)\n        val hexKeyMap19 = hexKeyMap18.filter(_._2 % 57 == 0)\n        val hexKeyMap20 = hexKeyMap19.filter(_._2 % 61 == 0)\n        val hexKeyMap21 = hexKeyMap20.filter(_._2 % 67 == 0)\n        val hexKeyMap22 = hexKeyMap21.filter(_._2 % 71 == 0)\n        val hexKeyMap23 = hexKeyMap22.filter(_._2 % 73 == 0)\n        val hexKeyMap24 = hexKeyMap23.filter(_._2 % 79 == 0)\n        val hexKeyMap25 = hexKeyMap24.filter(_._2 % 83 == 0)\n        val hexKeyMap26\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphs61nfv9.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmphs61nfv9.scala:28:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyMap\u001b[0m = hexKey.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                    where:    K is a type variable\n\u001b[31m   |\u001b[0m                                              V is a type variable\n\u001b[31m   |\u001b[0m                                    .\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphs61nfv9.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659799384
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.map(x => (x % 16).toLong)\n        val hexKeySet = hexKey.toSet\n        val hexKeySet2 = hexKey.toSet\n        val hexKeySet3 = hexKey.toSet\n        val hexKeySet4 = hexKey.toSet\n        val hexKeySet5 = hexKey.toSet\n        val hexKeySet6 = hexKey.toSet\n        val hexKeySet7 = hexKey.toSet\n        val hexKeySet8 = hexKey.toSet\n        val hexKeySet9 = hexKey.toSet\n        val hexKeySet10 = hexKey.toSet\n        val hexKeySet11 = hexKey.toSet\n        val hexKeySet12 = hexKey.toSet\n        val hexKeySet13 = hexKey.toSet\n        val hexKeySet14 = hexKey.toSet\n        val hexKeySet15 = hexKey.toSet\n        val hexKeySet16 = hexKey.toSet\n        val hexKeySet17 = hexKey.toSet\n        val hexKeySet18 = hexKey.toSet\n        val hexKeySet19 = hexKey.toSet\n        val hexKeySet20 = hexKey.toSet\n        val hexKeySet21 = hexKey.toSet\n        val hexKeySet22 = hexKey.toSet\n        val hexKeySet23 = hexKey.toSet\n        val hexKeySet24 = hexKey.toSet\n        val hexKeySet25 = hexKey.toSet\n        val hexKeySet26 = hexKey.toSet\n        val hexKeySet27 = hexKey.toSet\n        val hexKeySet28 = hexKey.toSet\n        val hexKeySet29 = hexKey.toSet\n        val hexKeySet30 = hexKey.toSet\n        val hexKeySet31 = hexKey.toSet\n        val hexKeySet32 = hexKey.toSet\n        val hexKeySet33 = hexKey.toSet\n        val hexKeySet34 = hexKey.toSet\n        val hexKeySet35 = hexKey.toSet\n        val hexKeySet36 = hexKey.toSet\n        val hexKeySet37 = hexKey.toSet\n        val hexKeySet38 = hexKey.toSet\n        val hexKeySet39 = hexKey.toSet\n        val hexKeySet40 = hexKey.toSet\n        val hexKeySet41 = hexKey.toSet\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpq37a8v06.scala:69:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq37a8v06.scala:70:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799384
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\").toList\n        val numsLen = nums.length\n        val numsLen2 = numsLen / 2\n        val numsLen3 = numsLen / 3\n        val numsLen4 = numsLen / 4\n        val numsLen5 = numsLen / 5\n        val numsLen6 = numsLen / 6\n        val numsLen7 = numsLen / 7\n        val numsLen8 = numsLen / 8\n        val numsLen9 = numsLen / 9\n        val numsLen10 = numsLen / 10\n        val numsLen11 = numsLen / 11\n        val numsLen12 = numsLen / 12\n        val numsLen13 = numsLen / 13\n        val numsLen14 = numsLen / 14\n        val numsLen15 = numsLen / 15\n        val numsLen16 = numsLen / 16\n        val numsLen17 = numsLen / 17\n        val numsLen18 = numsLen / 18\n        val numsLen19 = numsLen / 19\n        val numsLen20 = numsLen / 20\n        val numsLen21 = numsLen / 21\n        val numsLen22 = numsLen / 22\n        val numsLen23 = numsLen / 23\n        val numsLen24 = numsLen / 24\n        val numsLen25 = numsLen / 25\n        val numsLen26 = numsLen / 26\n        val numsLen27 = numsLen / 27\n        val numsLen28 = numsLen / 28\n        val numsLen29 = numsLen / 29\n        val numsLen30 = numsLen / 30\n        val numsLen31 = numsLen / 31\n        val numsLen32 = numsLen / 32\n        val numsLen33 = numsLen / 33\n        val numsLen34 = numsLen / 34\n        val numsLen35 = numsLen / 35\n        val numsLen36 = numsLen / 36\n        val numsLen37 = numsLen / 37\n        val numsLen38 = numsLen / 38\n        val numsLen39 = numsLen / 39\n        val numsLen40 = num\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxlufvsuu.scala:67:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799383
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toHexString)\n        val hexKey = hex.map(_.toInt)\n        val hexKeyMap = hexKey.toMap\n        val hexKeyMap2 = hexKeyMap.filter(_._2 % 2 == 0)\n        val hexKeyMap3 = hexKeyMap2.filter(_._2 % 3 == 0)\n        val hexKeyMap4 = hexKeyMap3.filter(_._2 % 5 == 0)\n        val hexKeyMap5 = hexKeyMap4.filter(_._2 % 7 == 0)\n        val hexKeyMap6 = hexKeyMap5.filter(_._2 % 11 == 0)\n        val hexKeyMap7 = hexKeyMap6.filter(_._2 % 13 == 0)\n        val hexKeyMap8 = hexKeyMap7.filter(_._2 % 17 == 0)\n        val hexKeyMap9 = hexKeyMap8.filter(_._2 % 19 == 0)\n        val hexKeyMap10 = hexKeyMap9.filter(_._2 % 23 == 0)\n        val hexKeyMap11 = hexKeyMap10.filter(_._2 % 29 == 0)\n        val hexKeyMap12 = hexKeyMap11.filter(_._2 % 31 == 0)\n        val hexKeyMap13 = hexKeyMap12.filter(_._2 % 37 == 0)\n        val hexKeyMap14 = hexKeyMap13.filter(_._2 % 41 == 0)\n        val hexKeyMap15 = hexKeyMap14.filter(_._2 % 43 == 0)\n        val hexKeyMap16 = hexKeyMap15.filter(_._2 % 47 == 0)\n        val hexKeyMap17 = hexKeyMap16.filter(_._2 % 51 == 0)\n        val hexKeyMap18 = hexKeyMap17.filter(_._2 % 55 == 0)\n        val hexKeyMap19 = hexKeyMap18.filter(_._2 % 59 == 0)\n        val hexKeyMap20 = hexKeyMap19.filter(_._2 % 63 == 0)\n        val hexKeyMap21 = hexKeyMap20.filter(_._2 % 67 == 0)\n        val hexKeyMap22 = hexKeyMap21.filter(_._2 % 71 == 0)\n        val hexKeyMap23 = hexKeyMap22.filter(_._2 % 75 == 0)\n        val hexKeyMap24 = hexKeyMap23.filter(_._2 % 79 == 0)\n        val hexKeyMap25 = hexKeyMap24.filter(_._2 % 83 == 0)\n        val hexKeyMap26 = hexKeyMap\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi9tqjwhe.scala:26:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value toHexString is not a member of Char.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          intWrapper(_$1)\n\u001b[31m\u001b[31m-- Error: /tmp/tmpi9tqjwhe.scala:26:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhex\u001b[0m = num.toCharArray.map(_.toHexString)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi9tqjwhe.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659799386
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLength = hexKey.length\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n        val hexKeyLength = hexKeyLength.toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpydndipww.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKeyLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpydndipww.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKeyLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpydndipww.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKeyLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpydndipww.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKeyLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpydndipww.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = hexKeyLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhex",
      "stdout": "",
      "timestamp": 1659799385
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = hexLength.toLong\n        val hexKeyArray = hexKey.toArray\n        val hexKeyArrayLength = hexKeyArray.length\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArrayLength - 1\n        val hexKeyArrayLength = hexKeyArray\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp25t1dltz.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp25t1dltz.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp25t1dltz.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp25t1dltz.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp25t1dltz.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        ",
      "stdout": "",
      "timestamp": 1659799389
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0l){ (sum, digit) => \n            val digit = digit - 48\n            val prime = digit % 2 == 0\n            val isPrime = prime && sum + digit <= 9\n            if (isPrime) sum + digit else sum\n        }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6831sft7.scala:28:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdigit\u001b[0m = digit - \u001b[31m48\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mdigit\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799385
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val numArray = num.toCharArray\n        val numArrayLength = numArray.length\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n        val num\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1uk9tpsf.scala:78:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1uk9tpsf.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumArrayLength\u001b[0m = numArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1uk9tpsf.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumArrayLength\u001b[0m = numArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1uk9tpsf.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumArrayLength\u001b[0m = numArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1uk9tpsf.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumArrayLength\u001b[0m = numArrayLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b",
      "stdout": "",
      "timestamp": 1659799392
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt_4qywzl.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyList = hexKey.toList\n        val hexKeyListLength = hexKeyList.length\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n        val hexKeyListLength = hexKeyListLength.toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hexKeyListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpivv0yfvx.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyListLength\u001b[0m = hex",
      "stdout": "",
      "timestamp": 1659799321
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.map(x => x % 10).filter(x => x != 0).count(x => x == 2)\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7fdyuz5u.scala:31)\n\tat Problem.main(tmp7fdyuz5u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799393
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLen = hex.length\n        val hexKey = hex.map(x => x.toInt)\n        val hexKeyLen = hexKey.length\n        val hexKeyLen2 = hexKeyLen / 2\n        val hexKeyLen3 = hexKeyLen / 3\n        val hexKeyLen4 = hexKeyLen / 4\n        val hexKeyLen5 = hexKeyLen / 5\n        val hexKeyLen6 = hexKeyLen / 6\n        val hexKeyLen7 = hexKeyLen / 7\n        val hexKeyLen8 = hexKeyLen / 8\n        val hexKeyLen9 = hexKeyLen / 9\n        val hexKeyLen10 = hexKeyLen / 10\n        val hexKeyLen11 = hexKeyLen / 11\n        val hexKeyLen12 = hexKeyLen / 12\n        val hexKeyLen13 = hexKeyLen / 13\n        val hexKeyLen14 = hexKeyLen / 14\n        val hexKeyLen15 = hexKeyLen / 15\n        val hexKeyLen16 = hexKeyLen / 16\n        val hexKeyLen17 = hexKeyLen / 17\n        val hexKeyLen18 = hexKeyLen / 18\n        val hexKeyLen19 = hexKeyLen / 19\n        val hexKeyLen20 = hexKeyLen / 20\n        val hexKeyLen21 = hexKeyLen / 21\n        val hexKeyLen22 = hexKeyLen / 22\n        val hexKeyLen23 = hexKeyLen / 23\n        val hexKeyLen24 = hexKeyLen / 24\n        val hexKeyLen25 = hexKeyLen / 25\n        val hexKeyLen26 = hexKeyLen / 26\n        val hexKeyLen27 = hexKeyLen / 27\n        val hexKeyLen28 = hexKeyLen / 28\n        val hexKeyLen29 = hexKeyLen / 29\n        val hexKeyLen30 = hexKeyLen / 30\n        val hexKeyLen31 = hexKeyLen / 31\n        val hexKeyLen32 = hexKeyLen / 32\n        val hexKeyLen33 = hexKeyLen / 33\n        val hexKeyLen34 = hexKeyLen / 34\n        val hexKeyLen35 = hexKeyLen / 35\n        val hexKeyLen36 = hexKeyLen / 36\n        val hexKeyLen37 = hexKeyLen / 37\n        val hexKeyLen38 = hexKeyLen / 38\n        \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsrmgyb0r.scala:68:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799355
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0l){ (sum, digit) => sum + digit * digit}\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpepn70mi5.scala:31)\n\tat Problem.main(tmpepn70mi5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.foldLeft(0)((sum, digit) => sum + digit * digit)\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"A\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$1(tmprte97a3g.scala:26)\n\tat Problem$.$anonfun$adapted$1(tmprte97a3g.scala:26)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:934)\n\tat Problem$.hexKey(tmprte97a3g.scala:26)\n\tat Problem$.main(tmprte97a3g.scala:31)\n\tat Problem.main(tmprte97a3g.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799393
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\")\n        val numsLength = nums.length\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n        val numsLength = numsLength + 1\n        val numsLength = numsLength.toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpici72b2_.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpici72b2_.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpici72b2_.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpici72b2_.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpici72b2_.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsLength\u001b[0m = numsLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b",
      "stdout": "",
      "timestamp": 1659799390
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\")\n        val numsLength = nums.length\n        val primes = mutable.Set[Long]()\n        val primesLength = primes.length\n        val primesSet = primes.toSet\n        val primesSetLength = primesSet.length\n        val primesSetSet = primesSet.toSet\n        val primesSetSetLength = primesSetSet.length\n        val primesSetSetSet = primesSetSet.toSet\n        val primesSetSetSetLength = primesSetSetSet.length\n        val primesSetSetSetSet = primesSetSetSet.toSet\n        val primesSetSetSetSetLength = primesSetSetSetSet.length\n        val primesSetSetSetSetSet = primesSetSetSetSet.toSet\n        val primesSetSetSetSetSetLength = primesSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetLength = primesSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSetSetSetSetSetSetSetSet.length\n        val primesSetSetSetSetSetSetSetSetSetSetSetLength = primesSetSetSetSetSet\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzctj4u_w.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetLength\u001b[0m = primesSetSetSetSetSetSetSetSetSet.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetSetSetSetSetSetSetSetLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetSetSetSetSetSetSetSetLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzctj4u_w.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetSetLength\u001b[0m = primesSetSetSetSetSetSetSetSetSet.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetSetSetSetSetSetSetSetSetLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetSetSetSetSetSetSetSetSetLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzctj4u_w.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetSetLength\u001b[0m = primesSetSetSetSetSetSetSetSetSetSet.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesSetSetSetSetSetSetSetSetSetLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesSetSetSetSetSetSetSetSetSetLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzctj4u_w.scala:47:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSetSetSetSetSetSetSetSetSetLength\u001b[0m = primesSetSetSetSetSetSetSetSetSetSetSet.length\n\u001b[31m\u001b[31m   |\u001b[0m        ",
      "stdout": "",
      "timestamp": 1659799392
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\").map(_.toInt)\n        val primes = nums.filter(n => isPrime(n))\n        val primesCount = primes.length\n        val primesSum = primes.sum\n        val primesSum2 = primesSum * primesSum\n        val primesSum3 = primesSum2 * primesSum\n        val primesSum4 = primesSum3 * primesSum\n        val primesSum5 = primesSum4 * primesSum\n        val primesSum6 = primesSum5 * primesSum\n        val primesSum7 = primesSum6 * primesSum\n        val primesSum8 = primesSum7 * primesSum\n        val primesSum9 = primesSum8 * primesSum\n        val primesSum10 = primesSum9 * primesSum\n        val primesSum11 = primesSum10 * primesSum\n        val primesSum12 = primesSum11 * primesSum\n        val primesSum13 = primesSum12 * primesSum\n        val primesSum14 = primesSum13 * primesSum\n        val primesSum15 = primesSum14 * primesSum\n        val primesSum16 = primesSum15 * primesSum\n        val primesSum17 = primesSum16 * primesSum\n        val primesSum18 = primesSum17 * primesSum\n        val primesSum19 = primesSum18 * primesSum\n        val primesSum20 = primesSum19 * primesSum\n        val primesSum21 = primesSum20 * primesSum\n        val primesSum22 = primesSum21 * primesSum\n        val primesSum23 = primesSum22 * primesSum\n        val primesSum24 = primesSum23 * primesSum\n        val primesSum25 = primesSum24 * primesSum\n        val primesSum26 = primesSum25 * primesSum\n        val primesSum27 = primesSum26 * primesSum\n        val primesSum28 = primesSum27 * primesSum\n        val primesSum29 = primesSum28 * primesSum\n        val primesSum30 = primesSum29 * primesSum\n        val primesSum31 = primesSum30 * primesSum\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxlqid9h7.scala:27:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = nums.filter(\u001b[36mn\u001b[0m => isPrime(n))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxlqid9h7.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799392
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = hexLength.toLong\n        val hexKeyArray = hexKey.toArray\n        val hexKeyArrayLength = hexKeyArray.length\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp6l9qtkw.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m",
      "stdout": "",
      "timestamp": 1659799359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLen = hex.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKeyLen = new mutable.HashMap[Int, Int]()\n        val hexKeyLen2 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen3 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen4 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen5 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen6 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen7 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen8 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen9 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen10 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen11 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen12 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen13 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen14 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen15 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen16 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen17 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen18 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen19 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen20 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen21 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen22 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen23 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen24 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen25 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen26 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen27 = new mutable.HashMap[Int, Int]()\n        val hexKeyLen28 = new mutable.HashMap[Int, Int]()\n        val hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzanaxa1f.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzanaxa1f.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzanaxa1f.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzanaxa1f.scala:30:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLen2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzanaxa1f.scala:31:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLen3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzanaxa1f.scala:32:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLen4\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[",
      "stdout": "",
      "timestamp": 1659799391
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\")\n        val numsCount = nums.length\n        val primes = mutable.Set[Long]()\n        val primesCount = mutable.Set[Long]()\n        val primesCount = nums.map(x => primesCount.add(x)).sum\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = primesCount.toLong\n        val primesCount = \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp9jgypze7.scala:68:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9jgypze7.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount\u001b[0m = nums.map(\u001b[36mx\u001b[0m => primesCount.add(x)).sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9jgypze7.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount\u001b[0m = primesCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9jgypze7.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount\u001b[0m = primesCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mprimesCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9jgypze7.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesCount\u001b[0m = primesCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mprimesCount is already defined as \u001b[33mval",
      "stdout": "",
      "timestamp": 1659799393
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(x => x.toInt)\n        val hexKey = hex.map(x => math.pow(16, x))\n        val hexKeySum = hexKey.sum\n        val hexKeySumInt = hexKeySum.toInt\n        val hexKeySumIntInt = hexKeySumInt.toInt\n        val hexKeySumIntIntInt = hexKeySumIntInt.toInt\n        val hexKeySumIntIntIntInt = hexKeySumIntIntInt.toInt\n        val hexKeySumIntIntIntIntInt = hexKeySumIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntInt = hexKeySumIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n        val hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n        val hex\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplf09xgqa.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplf09xgqa.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumIntIntIntIntIntIntIntIntIntIntIntInt\u001b[0m = hexKeySumIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeySumIntIntIntIntIntIntIntIntIntIntIntInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeySumIntIntIntIntIntIntIntIntIntIntIntInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplf09xgqa.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\u001b[0m = hexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeySumIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplf09xgqa.scala:37:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumIntIntIntIntIntIntIntIntInt\u001b[0m = hexKeySumIntIntIntIntIntIntIntIntInt.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m         Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKeySumIntIntIntIntIntIntIntIntInt\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cy",
      "stdout": "",
      "timestamp": 1659799393
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val primes = mutable.ArrayBuffer(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val hexPrimes = primes.filter(x => hex.contains(x))\n        val hexPrimesCount = hexPrimes.size\n        val hexPrime = hexPrimes.last\n        val hexPrimeCount = hexPrimes.size - hexPrime\n        val hexPrimeHex = hexPrime.toString.toCharArray\n        val hexPrimeHexCount = hexPrimeHex.length\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hexPrimeHexCount - 1\n        val hexPrimeHexCount = hex\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_2uagzmc.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPrimeHexCount\u001b[0m = hexPrimeHexCount - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexPrimeHexCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexPrimeHexCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_2uagzmc.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPrimeHexCount\u001b[0m = hexPrimeHexCount - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexPrimeHexCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexPrimeHexCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_2uagzmc.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPrimeHexCount\u001b[0m = hexPrimeHexCount - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexPrimeHexCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexPrimeHexCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_2uagzmc.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPrimeHexCount\u001b[0m = hexPrimeHexCount - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexPrimeHexCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexPrimeHexCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_2uagzmc.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexPri",
      "stdout": "",
      "timestamp": 1659799394
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexKey = hex.map(x => x % 10).sum\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"A\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$1(tmpq_kjeiry.scala:26)\n\tat Problem$.$anonfun$adapted$1(tmpq_kjeiry.scala:26)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:934)\n\tat Problem$.hexKey(tmpq_kjeiry.scala:26)\n\tat Problem$.main(tmpq_kjeiry.scala:31)\n\tat Problem.main(tmpq_kjeiry.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799395
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0)((acc, x) => acc * 16 + x)\n        hexKey / 16\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgtonoyb9.scala:31)\n\tat Problem.main(tmpgtonoyb9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799395
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toString.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexArray = hexString.toList\n        val hexCount = hexArray.length\n        val hexArray2 = hexArray.filter(x => x % 2 == 0)\n        val hexArray3 = hexArray.filter(x => x % 3 == 0)\n        val hexArray4 = hexArray.filter(x => x % 4 == 0)\n        val hexArray5 = hexArray.filter(x => x % 5 == 0)\n        val hexArray6 = hexArray.filter(x => x % 6 == 0)\n        val hexArray7 = hexArray.filter(x => x % 7 == 0)\n        val hexArray8 = hexArray.filter(x => x % 8 == 0)\n        val hexArray9 = hexArray.filter(x => x % 9 == 0)\n        val hexArray10 = hexArray.filter(x => x % 10 == 0)\n        val hexArray11 = hexArray.filter(x => x % 11 == 0)\n        val hexArray12 = hexArray.filter(x => x % 12 == 0)\n        val hexArray13 = hexArray.filter(x => x % 13 == 0)\n        val hexArray14 = hexArray.filter(x => x % 14 == 0)\n        val hexArray15 = hexArray.filter(x => x % 15 == 0)\n        val hexArray16 = hexArray.filter(x => x % 16 == 0)\n        val hexArray17 = hexArray.filter(x => x % 17 == 0)\n        val hexArray18 = hexArray.filter(x => x % 18 == 0)\n        val hexArray19 = hexArray.filter(x => x % 19 == 0)\n        val hexArray20 = hexArray.filter(x => x % 20 == 0)\n        val hexArray21 = hexArray.filter(x => x % 21 == 0)\n        val hexArray22 = hexArray.filter(x => x % 22 == 0)\n        val hexArray23 = hexArray.filter(x => x % 23 == 0)\n        val hexArray24 = hexArray.filter(x => x % 24 == 0)\n        val hexArray25 = hexArray.filter(x => x % 25 == 0)\n        val hexArray26 = hexArray.filter(x => x % 26 == 0)\n        val hexArray27 = hexArray.filter(x => x % 27 == 0)\n        val hexArray28 = hexArray.filter(x => x % 28 == 0)\n        val hexArray29 = hexArray.filter(x => x % 29 == 0)\n        val hexArray30\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpddbbu1jz.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpddbbu1jz.scala:59:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799395
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = new mutable.HashMap[Int, Int]()\n        val hexKeyLength = new mutable.HashMap[Int, Int]()\n        val hexKeyLength2 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength3 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength4 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength5 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength6 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength7 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength8 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength9 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength10 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength11 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength12 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength13 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength14 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength15 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength16 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength17 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength18 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength19 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength20 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength21 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength22 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength23 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength24 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength25 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength26 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength27 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength28 = new mutable.HashMap[Int, Int]()\n        val hexKeyLength\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9me1w98m.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9me1w98m.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9me1w98m.scala:29:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9me1w98m.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9me1w98m.scala:31:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9me1w98m.scala:32:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength4\u001b[0m =",
      "stdout": "",
      "timestamp": 1659799395
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexLength = hex.length\n        val hexKey = hexLength.toLong\n        val hexKeyArray = hexKey.toArray\n        val hexKeyArrayLength = hexKeyArray.length\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArrayLength = hexKeyArrayLength.toInt\n        val hexKeyArrayLength = hexKeyArrayLength.toLong\n        val hexKeyArray\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1nbr0lze.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1nbr0lze.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1nbr0lze.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1nbr0lze.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1nbr0lze.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyArrayLength\u001b[0m = hexKeyArrayLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeyArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeyArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must al",
      "stdout": "",
      "timestamp": 1659799395
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexLength = hex.length\n        val hexKey = new mutable.HashMap[Char, Long]()\n        val hexKeyLength = new mutable.HashMap[Char, Long]()\n        val hexKeyLength2 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength3 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength4 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength5 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength6 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength7 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength8 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength9 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength10 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength11 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength12 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength13 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength14 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength15 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength16 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength17 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength18 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength19 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength20 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength21 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength22 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength23 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength24 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength25 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength26 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength27 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength28 = new mutable.HashMap[Char, Long]()\n        val hexKeyLength\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm_fkxnhs.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm_fkxnhs.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mChar\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm_fkxnhs.scala:29:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mChar\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm_fkxnhs.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mChar\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm_fkxnhs.scala:31:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLength3\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mChar\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm_fkxnhs.scala:32:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeyLengt",
      "stdout": "",
      "timestamp": 1659799395
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val primesSet\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt_4qywzl.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_4qywzl.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexKey = hex.foldLeft(0L){ (sum, digit) => sum + digit * digit}\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprbv8u4fr.scala:31)\n\tat Problem.main(tmprbv8u4fr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799396
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexKey = hexCount - 1\n        val hexKeys = hexKey.toLong\n        val hexKeysArray = hexKeys.toArray\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray.length\n        val hexKeysArrayLength = hexKeysArray\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaisccc2h.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeysArrayLength\u001b[0m = hexKeysArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeysArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeysArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaisccc2h.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeysArrayLength\u001b[0m = hexKeysArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeysArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeysArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaisccc2h.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeysArrayLength\u001b[0m = hexKeysArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeysArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeysArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaisccc2h.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeysArrayLength\u001b[0m = hexKeysArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexKeysArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexKeysArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaisccc2h.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeysArrayLength",
      "stdout": "",
      "timestamp": 1659799395
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.filter(_ >= '0' && _ <='9').length\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpb27xzfvg.scala:27:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKey\u001b[0m = hex.filter(_ >= \u001b[31m'0'\u001b[0m && _ <=\u001b[31m'9'\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Wrong number of parameters, expected: 1\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799393
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexKey = hex.map(x => x.toInt)\n        val hexKey2 = hexKey.map(x => x % 10)\n        val hexKey3 = hexKey2.map(x => x % 10)\n        val hexKey4 = hexKey3.map(x => x % 10)\n        val hexKey5 = hexKey4.map(x => x % 10)\n        val hexKey6 = hexKey5.map(x => x % 10)\n        val hexKey7 = hexKey6.map(x => x % 10)\n        val hexKey8 = hexKey7.map(x => x % 10)\n        val hexKey9 = hexKey8.map(x => x % 10)\n        val hexKey10 = hexKey9.map(x => x % 10)\n        val hexKey11 = hexKey10.map(x => x % 10)\n        val hexKey12 = hexKey11.map(x => x % 10)\n        val hexKey13 = hexKey12.map(x => x % 10)\n        val hexKey14 = hexKey13.map(x => x % 10)\n        val hexKey15 = hexKey14.map(x => x % 10)\n        val hexKey16 = hexKey15.map(x => x % 10)\n        val hexKey17 = hexKey16.map(x => x % 10)\n        val hexKey18 = hexKey17.map(x => x % 10)\n        val hexKey19 = hexKey18.map(x => x % 10)\n        val hexKey20 = hexKey19.map(x => x % 10)\n        val hexKey21 = hexKey20.map(x => x % 10)\n        val hexKey22 = hexKey21.map(x => x % 10)\n        val hexKey23 = hexKey22.map(x => x % 10)\n        val hexKey24 = hexKey23.map(x => x % 10)\n        val hexKey25 = hexKey24.map(x => x % 10)\n        val hexKey26 = hexKey25.map(x => x % 10)\n        val hexKey27 = hexKey26.map(x => x % 10)\n        val hexKey28 = hexKey27.map(x => x % 10)\n        val hexKey29 = hexKey28.map(x => x % 10)\n        val hexKey30 = hexKey29.map(x => x % 10)\n        val hexKey31 = hexKey30.map(x => x % 10)\n        val hexKey32 = hexKey31.map(x => x % 10)\n        val hexKey33\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqi10ud8l.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqi10ud8l.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659799335
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(x => x.toInt)\n        val hexString = hex.mkString(\"\")\n        val hexArray = hexString.toCharArray\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n        val hexArrayLength = hexArray.length\n\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpefy2693t.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpefy2693t.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpefy2693t.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpefy2693t.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhexArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhexArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpefy2693t.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexArrayLength\u001b[0m = hexArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1659799396
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val hexKey = hex.foldLeft(0l){\n            (acc, x) => acc + (if (x % 2 == 0) x else x * 3 + 1)\n        }\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpvbh60qcp.scala:33)\n\tat Problem.main(tmpvbh60qcp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799396
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray\n        val hexCount = hex.length\n        val hexKey = hexCount.toLong\n        val hexKeys = hexKey.toLong * hexKey\n        val hexKeysPrime = hexKeys % hexKey\n        val hexKeysPrime2 = hexKeysPrime * hexKeysPrime\n        val hexKeysPrime3 = hexKeysPrime2 * hexKeysPrime\n        val hexKeysPrime4 = hexKeysPrime3 * hexKeysPrime\n        val hexKeysPrime5 = hexKeysPrime4 * hexKeysPrime\n        val hexKeysPrime6 = hexKeysPrime5 * hexKeysPrime\n        val hexKeysPrime7 = hexKeysPrime6 * hexKeysPrime\n        val hexKeysPrime8 = hexKeysPrime7 * hexKeysPrime\n        val hexKeysPrime9 = hexKeysPrime8 * hexKeysPrime\n        val hexKeysPrime10 = hexKeysPrime9 * hexKeysPrime\n        val hexKeysPrime11 = hexKeysPrime10 * hexKeysPrime\n        val hexKeysPrime12 = hexKeysPrime11 * hexKeysPrime\n        val hexKeysPrime13 = hexKeysPrime12 * hexKeysPrime\n        val hexKeysPrime14 = hexKeysPrime13 * hexKeysPrime\n        val hexKeysPrime15 = hexKeysPrime14 * hexKeysPrime\n        val hexKeysPrime16 = hexKeysPrime15 * hexKeysPrime\n        val hexKeysPrime17 = hexKeysPrime16 * hexKeysPrime\n        val hexKeysPrime18 = hexKeysPrime17 * hexKeysPrime\n        val hexKeysPrime19 = hexKeysPrime18 * hexKeysPrime\n        val hexKeysPrime20 = hexKeysPrime19 * hexKeysPrime\n        val hexKeysPrime21 = hexKeysPrime20 * hexKeysPrime\n        val hexKeysPrime22 = hexKeysPrime21 * hexKeysPrime\n        val hexKeysPrime23 = hexKeysPrime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2z16dayo.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659799396
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val primes = mutable.Set[Long]()\n        val primesSet = mutable.Set[Long]()\n        val primesSet2 = mutable.Set[Long]()\n        val primesSet3 = mutable.Set[Long]()\n        val primesSet4 = mutable.Set[Long]()\n        val primesSet5 = mutable.Set[Long]()\n        val primesSet6 = mutable.Set[Long]()\n        val primesSet7 = mutable.Set[Long]()\n        val primesSet8 = mutable.Set[Long]()\n        val primesSet9 = mutable.Set[Long]()\n        val primesSet10 = mutable.Set[Long]()\n        val primesSet11 = mutable.Set[Long]()\n        val primesSet12 = mutable.Set[Long]()\n        val primesSet13 = mutable.Set[Long]()\n        val primesSet14 = mutable.Set[Long]()\n        val primesSet15 = mutable.Set[Long]()\n        val primesSet16 = mutable.Set[Long]()\n        val primesSet17 = mutable.Set[Long]()\n        val primesSet18 = mutable.Set[Long]()\n        val primesSet19 = mutable.Set[Long]()\n        val primesSet20 = mutable.Set[Long]()\n        val primesSet21 = mutable.Set[Long]()\n        val primesSet22 = mutable.Set[Long]()\n        val primesSet23 = mutable.Set[Long]()\n        val primesSet24 = mutable.Set[Long]()\n        val primesSet25 = mutable.Set[Long]()\n        val primesSet26 = mutable.Set[Long]()\n        val primesSet27 = mutable.Set[Long]()\n        val primesSet28 = mutable.Set[Long]()\n        val primesSet29 = mutable.Set[Long]()\n        val primesSet30 = mutable.Set[Long]()\n        val primesSet31 = mutable.Set[Long]()\n        val primesSet32 = mutable.Set[Long]()\n        val primesSet33 = mutable.Set[Long]()\n        val prime\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpviixudjt.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet2\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet3\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpviixudjt.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimesSet4\u001b[0m = mutable.Set[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "stdout": "",
      "timestamp": 1659799343
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\D+\").map(_.toInt)\n        val primes = nums.filter(_ > 1).filter(_ % 2 != 0).filter(_ % 3 != 0).filter(_ % 5 != 0).filter(_ % 7 != 0).filter(_ % 11 != 0).filter(_ % 13 != 0)\n        primes.count(_ > 1)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppeuunbd3.scala:31)\n\tat Problem.main(tmppeuunbd3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799397
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\")\n        val hex = nums.map(_.toInt)\n        val hexStr = hex.mkString(\"\")\n        val hexKey = hexStr.map(x => x % 10).count(x => x == 0)\n        hexKey\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.regex.PatternSyntaxException: Unexpected internal error near index 1\n\\\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\tat java.base/java.util.regex.Pattern.compile(Pattern.java:1789)\n\tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1430)\n\tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\tat java.base/java.lang.String.split(String.java:3153)\n\tat java.base/java.lang.String.split(String.java:3199)\n\tat Problem$.hexKey(tmps93635uk.scala:26)\n\tat Problem$.main(tmps93635uk.scala:33)\n\tat Problem.main(tmps93635uk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659799398
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n        val hexLen = hex.length\n        val hexKey = hex.map(x => math.pow(16, hexLen - x - 1))\n        val hexKeyLen = hexKey.length\n        val hexKeySum = hexKey.sum\n        val hexKeySumLen = hexKeySum.length\n        val hexKeySumPrime = hexKeySum.filter(_ % 2 == 0).length\n        val hexKeySumPrimeLen = hexKeySumPrime.length\n        val hexKeySumPrimePrime = hexKeySumPrime.filter(_ % 3 == 0).length\n        val hexKeySumPrimePrimeLen = hexKeySumPrimePrime.length\n        val hexKeySumPrimePrimePrime = hexKeySumPrimePrime.filter(_ % 5 == 0).length\n        val hexKeySumPrimePrimePrimeLen = hexKeySumPrimePrimePrime.length\n        val hexKeySumPrimePrimePrimePrime = hexKeySumPrimePrimePrime.filter(_ % 7 == 0).length\n        val hexKeySumPrimePrimePrimePrimeLen = hexKeySumPrimePrimePrimePrime.length\n        val hexKeySumPrimePrimePrimePrimePrime = hexKeySumPrimePrimePrimePrime.filter(_ % 11 == 0).length\n        val hexKeySumPrimePrimePrimePrimePrimeLen = hexKeySumPrimePrimePrimePrimePrime.length\n        val hexKeySumPrimePrimePrimePrimePrimePrime = hexKeySumPrimePrimePrimePrimePrimePrime.filter(_ % 13 == 0).length\n        val hexKeySumPrimePrimePrimePrimePrimePrimeLen = hexKeySumPrimePrimePrimePrimePrimePrimePrime.length\n        val hexKeySumPrimePrimePrimePrimePrimePrimePrime = hexKeySumPrimePrimePrimePrimePrimePrimePrimePrime.filter(_ % 17 == 0).length\n        val hexKeySumPrimePrimePrimePrimePrimePrimePrimePrimeLen = hexKeySumPrimePrimePrimePrimePrimePrimePrimePrimePrime.length\n        val hexKeySumPrimePrimePrimePrimePri\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsno1zisz.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsno1zisz.scala:31:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumLen\u001b[0m = hexKeySum.length\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value length is not a member of Double\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsno1zisz.scala:32:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumPrime\u001b[0m = hexKeySum.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value filter is not a member of Double\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsno1zisz.scala:42:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumPrimePrimePrimePrimePrimePrime\u001b[0m = hexKeySumPrimePrimePrimePrimePrimePrime.filter(_ % \u001b[31m13\u001b[0m == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m      Recursive \u001b[33mvalue\u001b[0m \u001b[35mhexKeySumPrimePrimePrimePrimePrimePrime\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsno1zisz.scala:44:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhexKeySumPrimePrimePrimePrimePrimePrimePrime\u001b[0m = hexKeySumPrimePrimePrimePrimePrimePrimePrimePrime.filter(_ % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: hexKeySumPrimePrimePrimePrimePrimePrimePrimePrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsno",
      "stdout": "",
      "timestamp": 1659799398
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You have been tasked to write a function that receives \n    // a hexadecimal number as a string and counts the number of hexadecimal \n    // digits that are primes (prime number, or a prime, is a natural number \n    // greater than 1 that is not a product of two smaller natural numbers).\n    // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n        val primes = hex.filter(_ % 2 == 0).filter(_ % 3 == 0).filter(_ % 5 == 0).filter(_ % 7 == 0).filter(_ % 11 == 0).filter(_ % 13 == 0).filter(_ % 17 == 0).filter(_ % 19 == 0).filter(_ % 23 == 0).filter(_ % 29 == 0).filter(_ % 31 == 0).filter(_ % 37 == 0).filter(_ % 41 == 0).filter(_ % 43 == 0).filter(_ % 47 == 0).filter(_ % 53 == 0).filter(_ % 59 == 0).filter(_ % 61 == 0).filter(_ % 67 == 0).filter(_ % 71 == 0).filter(_ % 73 == 0).filter(_ % 79 == 0).filter(_ % 83 == 0).filter(_ % 89 == 0).filter(_ % 97 == 0).filter(_ % 101 == 0).filter(_ % 103 == 0).filter(_ % 107 == 0).filter(_ % 113 == 0).filter(_ % 127 == 0).filter(_ % 131 == 0).filter(_ % 137 == 0).filter(_ % 139 == 0).filter(_ % 143 == 0).filter(_ % 149 == 0).filter(_ % 151 == 0).filter(_ % 157 == 0).filter(_ % 163 == 0).filter(_ % 167 == 0).filter(_ % 173 == 0).filter(_ % 179 == 0).filter(_ % 181 == 0).filter(_ % 191 == 0).filter(_ % 193 == 0).filter(_ % 197 == 0).filter(_ % 199 == 0).filter(_ % 201 == 0).filter(_ % 207 == 0).filter(_ % 211 == 0).filter(_ % 213 == 0).filter(_ % 217 == 0).filter(_ % 223 == 0).filter(_ % 229 == 0).filter(_ % 233 == 0).filter(_ % 239 == 0).filter(_ % 241 == 0).filter(_ % 251 == 0).filter(_ % 257 == 0).filter(_ % 263 == 0).filter(_ % 269 == 0).filter(_ % 271 == 0).filter(_ % 277 == 0).filter(_ % 281 == 0).filter(_ % 283 == 0).filter(_ % 293 == 0).filter(_ % 307 == 0).filter(_ % 311 == 0).filter(_ % 313 == 0).filter(_ % 317 == 0).filter(_ % 323 == 0).filter(_ % 329 == 0).filter(_ % 331 == 0).filter(_ % 337 == 0).filter(_ % 341 == 0).filter(_ % 347 == 0).filter(_ % 351 == 0).filter(_ % 357 == 0).filter(_ % 363 == 0).filter(_ % 369 == 0).filter(_ % 371 == 0).filter(_ % 377 == 0).filter(_ % 381 == 0).filter(_ % 38\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj4e8qkd_.scala:28:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj4e8qkd_.scala:27:1725 ------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mprimes\u001b[0m = hex.filter(_ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m3\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m5\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m7\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m11\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m13\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m17\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m19\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m23\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m29\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m31\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m37\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m41\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m43\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m47\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m53\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m59\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m61\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m67\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m71\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m73\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m79\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m83\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m89\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m97\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m101\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m103\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m107\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m113\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m127\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m131\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m137\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m139\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m143\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m149\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m151\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m157\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m163\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m167\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m173\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m179\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m181\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m191\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31m193\u001b[0m == \u001b[31m0\u001b[0m).filter(_ % \u001b[31",
      "stdout": "",
      "timestamp": 1659799398
    }
  ]
}